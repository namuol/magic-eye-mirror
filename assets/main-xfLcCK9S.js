var f3=Object.defineProperty;var m3=(i,e,t)=>e in i?f3(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var Z=(i,e,t)=>m3(i,typeof e!="symbol"?e+"":e,t);const xf=new Map,Pl=[],g3=(i,e,t)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){const s=xf.get(i);if(s===void 0)xf.set(i,{backend:e,priority:t});else{if(s.priority>t)return;if(s.priority===t&&s.backend!==e)throw new Error(`cannot register backend "${i}" using priority ${t}`)}if(t>=0){const r=Pl.indexOf(i);r!==-1&&Pl.splice(r,1);for(let n=0;n<Pl.length;n++)if(xf.get(Pl[n]).priority<=t){Pl.splice(n,0,i);return}Pl.push(i)}return}throw new TypeError("not a valid backend")},_3=async i=>{const e=xf.get(i);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{const t=!!e.initPromise;try{return t||(e.initPromise=e.backend.init(i)),await e.initPromise,e.initialized=!0,e.backend}catch(s){return t||(e.error=`${s}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},y3=async i=>{const e=i.executionProviders||[],t=e.map(l=>typeof l=="string"?l:l.name),s=t.length===0?Pl:t;let r;const n=[],o=new Set;for(const l of s){const u=await _3(l);typeof u=="string"?n.push({name:l,err:u}):(r||(r=u),r===u&&o.add(l))}if(!r)throw new Error(`no available backend found. ERR: ${n.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(const{name:l,err:u}of n)t.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);const a=e.filter(l=>o.has(typeof l=="string"?l:l.name));return[r,new Proxy(i,{get:(l,u)=>u==="executionProviders"?a:Reflect.get(l,u)})]},x3="1.21.0";let QS="warning";const Wn={wasm:{},webgl:{},webgpu:{},versions:{common:x3},set logLevel(i){if(i!==void 0){if(typeof i!="string"||["verbose","info","warning","error","fatal"].indexOf(i)===-1)throw new Error(`Unsupported logging level: ${i}`);QS=i}},get logLevel(){return QS}};Object.defineProperty(Wn,"logLevel",{enumerable:!0});const b3=Wn,w3=(i,e)=>{const t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=i.dims[3],t.height=i.dims[2];const s=t.getContext("2d");if(s!=null){let r,n;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(r=i.dims[2],n=i.dims[3]):(r=i.dims[3],n=i.dims[2]);const o=(e==null?void 0:e.format)!==void 0?e.format:"RGB",a=e==null?void 0:e.norm;let l,u;a===void 0||a.mean===void 0?l=[255,255,255,255]:typeof a.mean=="number"?l=[a.mean,a.mean,a.mean,a.mean]:(l=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(l[3]=a.mean[3])),a===void 0||a.bias===void 0?u=[0,0,0,0]:typeof a.bias=="number"?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(u[3]=a.bias[3]));const c=n*r;let d=0,h=c,p=c*2,f=-1;o==="RGBA"?(d=0,h=c,p=c*2,f=c*3):o==="RGB"?(d=0,h=c,p=c*2):o==="RBG"&&(d=0,p=c,h=c*2);for(let m=0;m<n;m++)for(let x=0;x<r;x++){const g=(i.data[d++]-u[0])*l[0],_=(i.data[h++]-u[1])*l[1],S=(i.data[p++]-u[2])*l[2],M=f===-1?255:(i.data[f++]-u[3])*l[3];s.fillStyle="rgba("+g+","+_+","+S+","+M+")",s.fillRect(x,m,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},M3=(i,e)=>{const t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let s;if(t!=null){let r,n,o;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(r=i.dims[2],n=i.dims[1],o=i.dims[3]):(r=i.dims[3],n=i.dims[2],o=i.dims[1]);const a=e!==void 0&&e.format!==void 0?e.format:"RGB",l=e==null?void 0:e.norm;let u,c;l===void 0||l.mean===void 0?u=[255,255,255,255]:typeof l.mean=="number"?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(u[3]=l.mean[3])),l===void 0||l.bias===void 0?c=[0,0,0,0]:typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:(c=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(c[3]=l.bias[3]));const d=n*r;if(e!==void 0&&(e.format!==void 0&&o===4&&e.format!=="RGBA"||o===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const h=4;let p=0,f=1,m=2,x=3,g=0,_=d,S=d*2,M=-1;a==="RGBA"?(g=0,_=d,S=d*2,M=d*3):a==="RGB"?(g=0,_=d,S=d*2):a==="RBG"&&(g=0,S=d,_=d*2),s=t.createImageData(r,n);for(let w=0;w<n*r;p+=h,f+=h,m+=h,x+=h,w++)s.data[p]=(i.data[g++]-c[0])*u[0],s.data[f]=(i.data[_++]-c[1])*u[1],s.data[m]=(i.data[S++]-c[2])*u[2],s.data[x]=M===-1?255:(i.data[M++]-c[3])*u[3]}else throw new Error("Can not access image data");return s},l_=(i,e)=>{if(i===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:t,width:s}=e,r=e.norm??{mean:255,bias:0};let n,o;typeof r.mean=="number"?n=[r.mean,r.mean,r.mean,r.mean]:n=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?o=[r.bias,r.bias,r.bias,r.bias]:o=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];const a=e.format!==void 0?e.format:"RGBA",l=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",u=t*s,c=l==="RGBA"?new Float32Array(u*4):new Float32Array(u*3);let d=4,h=0,p=1,f=2,m=3,x=0,g=u,_=u*2,S=-1;a==="RGB"&&(d=3,h=0,p=1,f=2,m=-1),l==="RGBA"?S=u*3:l==="RBG"?(x=0,_=u,g=u*2):l==="BGR"&&(_=0,g=u,x=u*2);for(let w=0;w<u;w++,h+=d,f+=d,p+=d,m+=d)c[x++]=(i[h]+o[0])/n[0],c[g++]=(i[p]+o[1])/n[1],c[_++]=(i[f]+o[2])/n[2],S!==-1&&m!==-1&&(c[S++]=(i[m]+o[3])/n[3]);return l==="RGBA"?new hn("float32",c,[1,4,t,s]):new hn("float32",c,[1,3,t,s])},T3=async(i,e)=>{const t=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,s=typeof ImageData<"u"&&i instanceof ImageData,r=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,n=typeof i=="string";let o,a=e??{};const l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(t){const c=l();c.width=i.width,c.height=i.height;const d=u(c);if(d!=null){let h=i.height,p=i.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(h=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(a=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=h,a.width=p}else a.tensorFormat="RGBA",a.height=h,a.width=p;d.drawImage(i,0,0),o=d.getImageData(0,0,p,h).data}else throw new Error("Can not access image data")}else if(s){let c,d;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(c=e.resizedHeight,d=e.resizedWidth):(c=i.height,d=i.width),e!==void 0&&(a=e),a.format="RGBA",a.height=c,a.width=d,e!==void 0){const h=l();h.width=d,h.height=c;const p=u(h);if(p!=null)p.putImageData(i,0,0),o=p.getImageData(0,0,d,c).data;else throw new Error("Can not access image data")}else o=i.data}else if(r){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");const c=l();c.width=i.width,c.height=i.height;const d=u(c);if(d!=null){const h=i.height,p=i.width;return d.drawImage(i,0,0,p,h),o=d.getImageData(0,0,p,h).data,a.height=h,a.width=p,l_(o,a)}else throw new Error("Can not access image data")}else{if(n)return new Promise((c,d)=>{const h=l(),p=u(h);if(!i||!p)return d();const f=new Image;f.crossOrigin="Anonymous",f.src=i,f.onload=()=>{h.width=f.width,h.height=f.height,p.drawImage(f,0,0,h.width,h.height);const m=p.getImageData(0,0,h.width,h.height);a.height=h.height,a.width=h.width,c(l_(m.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return l_(o,a);throw new Error("Input data provided is not supported - aborted tensor creation")},v3=(i,e)=>{const{width:t,height:s,download:r,dispose:n}=e,o=[1,s,t,4];return new hn({location:"texture",type:"float32",texture:i,dims:o,download:r,dispose:n})},S3=(i,e)=>{const{dataType:t,dims:s,download:r,dispose:n}=e;return new hn({location:"gpu-buffer",type:t??"float32",gpuBuffer:i,dims:s,download:r,dispose:n})},E3=(i,e)=>{const{dataType:t,dims:s,download:r,dispose:n}=e;return new hn({location:"ml-tensor",type:t??"float32",mlTensor:i,dims:s,download:r,dispose:n})},A3=(i,e,t)=>new hn({location:"cpu-pinned",type:i,data:e,dims:t??[e.length]}),Xu=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),bf=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let ZS=!1;const C3=()=>{if(!ZS){ZS=!0;const i=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,s=typeof t<"u"&&t.from;i&&(Xu.set("int64",BigInt64Array),bf.set(BigInt64Array,"int64")),e&&(Xu.set("uint64",BigUint64Array),bf.set(BigUint64Array,"uint64")),s?(Xu.set("float16",t),bf.set(t,"float16")):Xu.set("float16",Uint16Array)}},P3=i=>{let e=1;for(let t=0;t<i.length;t++){const s=i[t];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${t}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${s}`);e*=s}return e},N3=(i,e)=>{switch(i.location){case"cpu":return new hn(i.type,i.data,e);case"cpu-pinned":return new hn({location:"cpu-pinned",data:i.data,type:i.type,dims:e});case"texture":return new hn({location:"texture",texture:i.texture,type:i.type,dims:e});case"gpu-buffer":return new hn({location:"gpu-buffer",gpuBuffer:i.gpuBuffer,type:i.type,dims:e});case"ml-tensor":return new hn({location:"ml-tensor",mlTensor:i.mlTensor,type:i.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${i.location} is not supported`)}};let hn=class{constructor(e,t,s){C3();let r,n;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,r=e.type,n=e.dims,e.location){case"cpu-pinned":{const a=Xu.get(r);if(!a)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,l;if(typeof e=="string")if(r=e,l=s,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{const u=Xu.get(e);if(u===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&u===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${u.name} as data.`);e==="uint64"||e==="int64"?a=u.from(t,BigInt):a=u.from(t)}else if(t instanceof u)a=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")a=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&t instanceof Uint16Array&&u!==Uint16Array)a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${r} tensor's data must be type of ${u}`)}else if(l=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const u=typeof e[0];if(u==="string")r="string",a=e;else if(u==="boolean")r="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${u}.`)}else if(e instanceof Uint8ClampedArray)r="uint8",a=Uint8Array.from(e);else{const u=bf.get(e.constructor);if(u===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=u,a=e}if(l===void 0)l=[a.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");n=l,this.cpuData=a,this.dataLocation="cpu"}const o=P3(n);if(this.cpuData&&o!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(o/2)===this.cpuData.length))throw new Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=n,this.size=o}static async fromImage(e,t){return T3(e,t)}static fromTexture(e,t){return v3(e,t)}static fromGpuBuffer(e,t){return S3(e,t)}static fromMLTensor(e,t){return E3(e,t)}static fromPinnedBuffer(e,t,s){return A3(e,t,s)}toDataURL(e){return w3(this,e)}toImageData(e){return M3(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return N3(this,e)}};const Wu=hn,RN=(i,e)=>{(typeof Wn.trace>"u"?!Wn.wasm.trace:!Wn.trace)||console.timeStamp(`${i}::ORT::${e}`)},IN=(i,e)=>{var r;const t=((r=new Error().stack)==null?void 0:r.split(/\r\n|\r|\n/g))||[];let s=!1;for(let n=0;n<t.length;n++){if(s&&!t[n].includes("TRACE_FUNC")){let o=`FUNC_${i}::${t[n].trim().split(" ")[1]}`;e&&(o+=`::${e}`),RN("CPU",o);return}t[n].includes("TRACE_FUNC")&&(s=!0)}},xx=i=>{(typeof Wn.trace>"u"?!Wn.wasm.trace:!Wn.trace)||IN("BEGIN",i)},bx=i=>{(typeof Wn.trace>"u"?!Wn.wasm.trace:!Wn.trace)||IN("END",i)};let F3=class DN{constructor(e){this.handler=e}async run(e,t,s){xx();const r={};let n={};if(typeof e!="object"||e===null||e instanceof Wu||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Wu)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(const u of t){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);r[u]=null}if(typeof s=="object"&&s!==null)n=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let u=!1;const c=Object.getOwnPropertyNames(t);for(const d of this.outputNames)if(c.indexOf(d)!==-1){const h=t[d];(h===null||h instanceof Wu)&&(u=!0,o=!1,r[d]=h)}if(u){if(typeof s=="object"&&s!==null)n=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else n=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const u of this.inputNames)if(typeof e[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(o)for(const u of this.outputNames)r[u]=null;const a=await this.handler.run(e,r,n),l={};for(const u in a)if(Object.hasOwnProperty.call(a,u)){const c=a[u];c instanceof Wu?l[u]=c:l[u]=new Wu(c.type,c.data,c.dims)}return bx(),l}async release(){return this.handler.dispose()}static async create(e,t,s,r){xx();let n,o={};if(typeof e=="string"){if(n=e,typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(n=e,typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){const c=e;let d=0,h=e.byteLength;if(typeof t=="object"&&t!==null)o=t;else if(typeof t=="number"){if(d=t,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(h=e.byteLength-d,typeof s=="number"){if(h=s,!Number.isSafeInteger(h))throw new RangeError("'byteLength' must be an integer.");if(h<=0||d+h>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-d}].`);if(typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");n=new Uint8Array(c,d,h)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[a,l]=await y3(o),u=await a.createInferenceSessionHandler(n,l);return bx(),new DN(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const R3=F3,I3=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:R3,TRACE:RN,TRACE_FUNC_BEGIN:xx,TRACE_FUNC_END:bx,Tensor:Wu,env:b3,registerBackend:g3},Symbol.toStringTag,{value:"Module"}));/*!
 * ONNX Runtime Web v1.22.0-dev.20250409-89f8206ba4
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Nb=Object.defineProperty,D3=Object.getOwnPropertyDescriptor,k3=Object.getOwnPropertyNames,L3=Object.prototype.hasOwnProperty,B3=(i=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(i,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):i)(function(i){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+i+'" is not supported')}),Ze=(i,e)=>()=>(i&&(e=i(i=0)),e),vc=(i,e)=>{for(var t in e)Nb(i,t,{get:e[t],enumerable:!0})},O3=(i,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of k3(e))!L3.call(i,r)&&r!==t&&Nb(i,r,{get:()=>e[r],enumerable:!(s=D3(e,r))||s.enumerable});return i},Qd=i=>O3(Nb({},"__esModule",{value:!0}),i),sd,ga,Bl,JS,kN,LN=Ze(()=>{sd=new Map,ga=[],Bl=(i,e,t)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let s=sd.get(i);if(s===void 0)sd.set(i,{backend:e,priority:t});else{if(s.priority>t)return;if(s.priority===t&&s.backend!==e)throw new Error(`cannot register backend "${i}" using priority ${t}`)}if(t>=0){let r=ga.indexOf(i);r!==-1&&ga.splice(r,1);for(let n=0;n<ga.length;n++)if(sd.get(ga[n]).priority<=t){ga.splice(n,0,i);return}ga.push(i)}return}throw new TypeError("not a valid backend")},JS=async i=>{let e=sd.get(i);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let t=!!e.initPromise;try{return t||(e.initPromise=e.backend.init(i)),await e.initPromise,e.initialized=!0,e.backend}catch(s){return t||(e.error=`${s}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},kN=async i=>{let e=i.executionProviders||[],t=e.map(l=>typeof l=="string"?l:l.name),s=t.length===0?ga:t,r,n=[],o=new Set;for(let l of s){let u=await JS(l);typeof u=="string"?n.push({name:l,err:u}):(r||(r=u),r===u&&o.add(l))}if(!r)throw new Error(`no available backend found. ERR: ${n.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(let{name:l,err:u}of n)t.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);let a=e.filter(l=>o.has(typeof l=="string"?l:l.name));return[r,new Proxy(i,{get:(l,u)=>u==="executionProviders"?a:Reflect.get(l,u)})]}}),$3=Ze(()=>{LN()}),BN,z3=Ze(()=>{BN="1.22.0-dev.20250409-89f8206ba4"}),u_,ln,ON=Ze(()=>{z3(),u_="warning",ln={wasm:{},webgl:{},webgpu:{},versions:{common:BN},set logLevel(i){if(i!==void 0){if(typeof i!="string"||["verbose","info","warning","error","fatal"].indexOf(i)===-1)throw new Error(`Unsupported logging level: ${i}`);u_=i}},get logLevel(){return u_}},Object.defineProperty(ln,"logLevel",{enumerable:!0})}),Vs,V3=Ze(()=>{ON(),Vs=ln}),$N,zN,U3=Ze(()=>{$N=(i,e)=>{let t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=i.dims[3],t.height=i.dims[2];let s=t.getContext("2d");if(s!=null){let r,n;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(r=i.dims[2],n=i.dims[3]):(r=i.dims[3],n=i.dims[2]);let o=(e==null?void 0:e.format)!==void 0?e.format:"RGB",a=e==null?void 0:e.norm,l,u;a===void 0||a.mean===void 0?l=[255,255,255,255]:typeof a.mean=="number"?l=[a.mean,a.mean,a.mean,a.mean]:(l=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(l[3]=a.mean[3])),a===void 0||a.bias===void 0?u=[0,0,0,0]:typeof a.bias=="number"?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(u[3]=a.bias[3]));let c=n*r,d=0,h=c,p=c*2,f=-1;o==="RGBA"?(d=0,h=c,p=c*2,f=c*3):o==="RGB"?(d=0,h=c,p=c*2):o==="RBG"&&(d=0,p=c,h=c*2);for(let m=0;m<n;m++)for(let x=0;x<r;x++){let g=(i.data[d++]-u[0])*l[0],_=(i.data[h++]-u[1])*l[1],S=(i.data[p++]-u[2])*l[2],M=f===-1?255:(i.data[f++]-u[3])*l[3];s.fillStyle="rgba("+g+","+_+","+S+","+M+")",s.fillRect(x,m,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},zN=(i,e)=>{let t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(t!=null){let r,n,o;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(r=i.dims[2],n=i.dims[1],o=i.dims[3]):(r=i.dims[3],n=i.dims[2],o=i.dims[1]);let a=e!==void 0&&e.format!==void 0?e.format:"RGB",l=e==null?void 0:e.norm,u,c;l===void 0||l.mean===void 0?u=[255,255,255,255]:typeof l.mean=="number"?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(u[3]=l.mean[3])),l===void 0||l.bias===void 0?c=[0,0,0,0]:typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:(c=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(c[3]=l.bias[3]));let d=n*r;if(e!==void 0&&(e.format!==void 0&&o===4&&e.format!=="RGBA"||o===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let h=4,p=0,f=1,m=2,x=3,g=0,_=d,S=d*2,M=-1;a==="RGBA"?(g=0,_=d,S=d*2,M=d*3):a==="RGB"?(g=0,_=d,S=d*2):a==="RBG"&&(g=0,S=d,_=d*2),s=t.createImageData(r,n);for(let w=0;w<n*r;p+=h,f+=h,m+=h,x+=h,w++)s.data[p]=(i.data[g++]-c[0])*u[0],s.data[f]=(i.data[_++]-c[1])*u[1],s.data[m]=(i.data[S++]-c[2])*u[2],s.data[x]=M===-1?255:(i.data[M++]-c[3])*u[3]}else throw new Error("Can not access image data");return s}}),xp,VN,UN,GN,jN,WN,G3=Ze(()=>{Fb(),xp=(i,e)=>{if(i===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:t,width:s}=e,r=e.norm??{mean:255,bias:0},n,o;typeof r.mean=="number"?n=[r.mean,r.mean,r.mean,r.mean]:n=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?o=[r.bias,r.bias,r.bias,r.bias]:o=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let a=e.format!==void 0?e.format:"RGBA",l=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",u=t*s,c=l==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),d=4,h=0,p=1,f=2,m=3,x=0,g=u,_=u*2,S=-1;a==="RGB"&&(d=3,h=0,p=1,f=2,m=-1),l==="RGBA"?S=u*3:l==="RBG"?(x=0,_=u,g=u*2):l==="BGR"&&(_=0,g=u,x=u*2);for(let M=0;M<u;M++,h+=d,f+=d,p+=d,m+=d)c[x++]=(i[h]+o[0])/n[0],c[g++]=(i[p]+o[1])/n[1],c[_++]=(i[f]+o[2])/n[2],S!==-1&&m!==-1&&(c[S++]=(i[m]+o[3])/n[3]);return l==="RGBA"?new Hr("float32",c,[1,4,t,s]):new Hr("float32",c,[1,3,t,s])},VN=async(i,e)=>{let t=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,s=typeof ImageData<"u"&&i instanceof ImageData,r=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,n=typeof i=="string",o,a=e??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(t){let c=l();c.width=i.width,c.height=i.height;let d=u(c);if(d!=null){let h=i.height,p=i.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(h=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(a=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=h,a.width=p}else a.tensorFormat="RGBA",a.height=h,a.width=p;d.drawImage(i,0,0),o=d.getImageData(0,0,p,h).data}else throw new Error("Can not access image data")}else if(s){let c,d;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(c=e.resizedHeight,d=e.resizedWidth):(c=i.height,d=i.width),e!==void 0&&(a=e),a.format="RGBA",a.height=c,a.width=d,e!==void 0){let h=l();h.width=d,h.height=c;let p=u(h);if(p!=null)p.putImageData(i,0,0),o=p.getImageData(0,0,d,c).data;else throw new Error("Can not access image data")}else o=i.data}else if(r){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let c=l();c.width=i.width,c.height=i.height;let d=u(c);if(d!=null){let h=i.height,p=i.width;return d.drawImage(i,0,0,p,h),o=d.getImageData(0,0,p,h).data,a.height=h,a.width=p,xp(o,a)}else throw new Error("Can not access image data")}else{if(n)return new Promise((c,d)=>{let h=l(),p=u(h);if(!i||!p)return d();let f=new Image;f.crossOrigin="Anonymous",f.src=i,f.onload=()=>{h.width=f.width,h.height=f.height,p.drawImage(f,0,0,h.width,h.height);let m=p.getImageData(0,0,h.width,h.height);a.height=h.height,a.width=h.width,c(xp(m.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return xp(o,a);throw new Error("Input data provided is not supported - aborted tensor creation")},UN=(i,e)=>{let{width:t,height:s,download:r,dispose:n}=e,o=[1,s,t,4];return new Hr({location:"texture",type:"float32",texture:i,dims:o,download:r,dispose:n})},GN=(i,e)=>{let{dataType:t,dims:s,download:r,dispose:n}=e;return new Hr({location:"gpu-buffer",type:t??"float32",gpuBuffer:i,dims:s,download:r,dispose:n})},jN=(i,e)=>{let{dataType:t,dims:s,download:r,dispose:n}=e;return new Hr({location:"ml-tensor",type:t??"float32",mlTensor:i,dims:s,download:r,dispose:n})},WN=(i,e,t)=>new Hr({location:"cpu-pinned",type:i,data:e,dims:t??[e.length]})}),Rl,Rd,c_,HN,j3=Ze(()=>{Rl=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Rd=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),c_=!1,HN=()=>{if(!c_){c_=!0;let i=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,s=typeof t<"u"&&t.from;i&&(Rl.set("int64",BigInt64Array),Rd.set(BigInt64Array,"int64")),e&&(Rl.set("uint64",BigUint64Array),Rd.set(BigUint64Array,"uint64")),s?(Rl.set("float16",t),Rd.set(t,"float16")):Rl.set("float16",Uint16Array)}}}),qN,KN,W3=Ze(()=>{Fb(),qN=i=>{let e=1;for(let t=0;t<i.length;t++){let s=i[t];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${t}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${s}`);e*=s}return e},KN=(i,e)=>{switch(i.location){case"cpu":return new Hr(i.type,i.data,e);case"cpu-pinned":return new Hr({location:"cpu-pinned",data:i.data,type:i.type,dims:e});case"texture":return new Hr({location:"texture",texture:i.texture,type:i.type,dims:e});case"gpu-buffer":return new Hr({location:"gpu-buffer",gpuBuffer:i.gpuBuffer,type:i.type,dims:e});case"ml-tensor":return new Hr({location:"ml-tensor",mlTensor:i.mlTensor,type:i.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${i.location} is not supported`)}}}),Hr,Fb=Ze(()=>{U3(),G3(),j3(),W3(),Hr=class{constructor(i,e,t){HN();let s,r;if(typeof i=="object"&&"location"in i)switch(this.dataLocation=i.location,s=i.type,r=i.dims,i.location){case"cpu-pinned":{let o=Rl.get(s);if(!o)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(i.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=i.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=i.texture,this.downloader=i.download,this.disposer=i.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=i.gpuBuffer,this.downloader=i.download,this.disposer=i.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=i.mlTensor,this.downloader=i.download,this.disposer=i.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,a;if(typeof i=="string")if(s=i,a=t,i==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");o=e}else{let l=Rl.get(i);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${i}.`);if(Array.isArray(e)){if(i==="float16"&&l===Uint16Array||i==="uint4"||i==="int4")throw new TypeError(`Creating a ${i} tensor from number array is not supported. Please use ${l.name} as data.`);i==="uint64"||i==="int64"?o=l.from(e,BigInt):o=l.from(e)}else if(e instanceof l)o=e;else if(e instanceof Uint8ClampedArray)if(i==="uint8")o=Uint8Array.from(e);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(i==="float16"&&e instanceof Uint16Array&&l!==Uint16Array)o=new globalThis.Float16Array(e.buffer,e.byteOffset,e.length);else throw new TypeError(`A ${s} tensor's data must be type of ${l}`)}else if(a=e,Array.isArray(i)){if(i.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof i[0];if(l==="string")s="string",o=i;else if(l==="boolean")s="bool",o=Uint8Array.from(i);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else if(i instanceof Uint8ClampedArray)s="uint8",o=Uint8Array.from(i);else{let l=Rd.get(i.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${i.constructor}.`);s=l,o=i}if(a===void 0)a=[o.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");r=a,this.cpuData=o,this.dataLocation="cpu"}let n=qN(r);if(this.cpuData&&n!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(n/2)===this.cpuData.length))throw new Error(`Tensor's size(${n}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=r,this.size=n}static async fromImage(i,e){return VN(i,e)}static fromTexture(i,e){return UN(i,e)}static fromGpuBuffer(i,e){return GN(i,e)}static fromMLTensor(i,e){return jN(i,e)}static fromPinnedBuffer(i,e,t){return WN(i,e,t)}toDataURL(i){return $N(this,i)}toImageData(i){return zN(this,i)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(i){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,i&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(i){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return KN(this,i)}}}),Vn,XN=Ze(()=>{Fb(),Vn=Hr}),Zd,d_,qn,_n,YN=Ze(()=>{ON(),Zd=(i,e)=>{(typeof ln.trace>"u"?!ln.wasm.trace:!ln.trace)||console.timeStamp(`${i}::ORT::${e}`)},d_=(i,e)=>{var r;let t=((r=new Error().stack)==null?void 0:r.split(/\r\n|\r|\n/g))||[],s=!1;for(let n=0;n<t.length;n++){if(s&&!t[n].includes("TRACE_FUNC")){let o=`FUNC_${i}::${t[n].trim().split(" ")[1]}`;e&&(o+=`::${e}`),Zd("CPU",o);return}t[n].includes("TRACE_FUNC")&&(s=!0)}},qn=i=>{(typeof ln.trace>"u"?!ln.wasm.trace:!ln.trace)||d_("BEGIN",i)},_n=i=>{(typeof ln.trace>"u"?!ln.wasm.trace:!ln.trace)||d_("END",i)}}),QN,H3=Ze(()=>{LN(),XN(),YN(),QN=class ZN{constructor(e){this.handler=e}async run(e,t,s){qn();let r={},n={};if(typeof e!="object"||e===null||e instanceof Vn||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Vn)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(let u of t){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);r[u]=null}if(typeof s=="object"&&s!==null)n=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,c=Object.getOwnPropertyNames(t);for(let d of this.outputNames)if(c.indexOf(d)!==-1){let h=t[d];(h===null||h instanceof Vn)&&(u=!0,o=!1,r[d]=h)}if(u){if(typeof s=="object"&&s!==null)n=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else n=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof e[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(o)for(let u of this.outputNames)r[u]=null;let a=await this.handler.run(e,r,n),l={};for(let u in a)if(Object.hasOwnProperty.call(a,u)){let c=a[u];c instanceof Vn?l[u]=c:l[u]=new Vn(c.type,c.data,c.dims)}return _n(),l}async release(){return this.handler.dispose()}static async create(e,t,s,r){qn();let n,o={};if(typeof e=="string"){if(n=e,typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(n=e,typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let c=e,d=0,h=e.byteLength;if(typeof t=="object"&&t!==null)o=t;else if(typeof t=="number"){if(d=t,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(h=e.byteLength-d,typeof s=="number"){if(h=s,!Number.isSafeInteger(h))throw new RangeError("'byteLength' must be an integer.");if(h<=0||d+h>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-d}].`);if(typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");n=new Uint8Array(c,d,h)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[a,l]=await kN(o),u=await a.createInferenceSessionHandler(n,l);return _n(),new ZN(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),Rb,q3=Ze(()=>{H3(),Rb=QN}),K3=Ze(()=>{}),X3=Ze(()=>{}),Y3=Ze(()=>{}),Q3=Ze(()=>{}),JN={};vc(JN,{InferenceSession:()=>Rb,TRACE:()=>Zd,TRACE_FUNC_BEGIN:()=>qn,TRACE_FUNC_END:()=>_n,Tensor:()=>Vn,env:()=>Vs,registerBackend:()=>Bl});var Xn=Ze(()=>{$3(),V3(),q3(),XN(),K3(),X3(),YN(),Y3(),Q3()}),Ib=Ze(()=>{}),eF={};vc(eF,{default:()=>tF});var h_,p_,tF,Z3=Ze(()=>{var i;oD(),Zl(),Db(),h_="ort-wasm-proxy-worker",p_=((i=globalThis.self)==null?void 0:i.name)===h_,p_&&(self.onmessage=e=>{let{type:t,in:s}=e.data;try{switch(t){case"init-wasm":kb(s.wasm).then(()=>{Jb(s).then(()=>{postMessage({type:t})},r=>{postMessage({type:t,err:r})})},r=>{postMessage({type:t,err:r})});break;case"init-ep":{let{epName:r,env:n}=s;e0(n,r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})});break}case"copy-from":{let{buffer:r}=s,n=Vf(r);postMessage({type:t,out:n});break}case"create":{let{model:r,options:n}=s;t0(r,n).then(o=>{postMessage({type:t,out:o})},o=>{postMessage({type:t,err:o})});break}case"release":s0(s),postMessage({type:t});break;case"run":{let{sessionId:r,inputIndices:n,inputs:o,outputIndices:a,options:l}=s;i0(r,n,o,a,new Array(a.length).fill(null),l).then(u=>{u.some(c=>c[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:u},n0([...o,...u]))},u=>{postMessage({type:t,err:u})});break}case"end-profiling":r0(s),postMessage({type:t});break;default:}}catch(r){postMessage({type:t,err:r})}}),tF=p_?null:e=>new Worker(e??Gr,{type:"module",name:h_})}),sF={};vc(sF,{default:()=>iF});var f_,m_,iF,eE,J3=Ze(()=>{var i,e;m_=(f_=import.meta.url,async function(t={}){var wu;var s,r,n=t,o=new Promise((y,C)=>{s=y,r=C}),a=typeof window=="object",l=typeof WorkerGlobalScope<"u",u=l&&((wu=self.name)==null?void 0:wu.startsWith("em-pthread"));n.mountExternalData=(y,C)=>{y.startsWith("./")&&(y=y.substring(2)),(n.Eb||(n.Eb=new Map)).set(y,C)},n.unmountExternalData=()=>{delete n.Eb};var c=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,pc:!0}).buffer.constructor;let d=y=>async(...C)=>{var D;try{if(n.Fb)throw Error("Session already started");let $=n.Fb={dc:C[0],errors:[]},H=await y(...C);if(n.Fb!==$)throw Error("Session mismatch");(D=n.Jb)==null||D.flush();let me=$.errors;if(0<me.length){let Re=await Promise.all(me);if(Re=Re.filter(qe=>qe),0<Re.length)throw Error(Re.join(`
`))}return H}finally{n.Fb=null}};n.jsepInit=(y,C)=>{if(y==="webgpu"){[n.Jb,n.Ub,n.Yb,n.Kb,n.Xb,n.jb,n.Zb,n.ac,n.Vb,n.Wb,n.$b]=C;let D=n.Jb;n.jsepRegisterBuffer=($,H,me,Re)=>D.registerBuffer($,H,me,Re),n.jsepGetBuffer=$=>D.getBuffer($),n.jsepCreateDownloader=($,H,me)=>D.createDownloader($,H,me),n.jsepOnCreateSession=$=>{D.onCreateSession($)},n.jsepOnReleaseSession=$=>{D.onReleaseSession($)},n.jsepOnRunStart=$=>D.onRunStart($),n.bc=($,H)=>{D.upload($,H)}}else if(y==="webnn"){let D=C[0];[n.nc,n.Nb,n.webnnEnsureTensor,n.Ob,n.webnnDownloadTensor]=C.slice(1),n.webnnReleaseTensorId=n.Nb,n.webnnUploadTensor=n.Ob,n.webnnOnRunStart=$=>D.onRunStart($),n.webnnOnRunEnd=D.onRunEnd.bind(D),n.webnnRegisterMLContext=($,H)=>{D.registerMLContext($,H)},n.webnnOnReleaseSession=$=>{D.onReleaseSession($)},n.webnnCreateMLTensorDownloader=($,H)=>D.createMLTensorDownloader($,H),n.webnnRegisterMLTensor=($,H,me,Re)=>D.registerMLTensor($,H,me,Re),n.webnnCreateMLContext=$=>D.createMLContext($),n.webnnRegisterMLConstant=($,H,me,Re,qe,at)=>D.registerMLConstant($,H,me,Re,qe,n.Eb,at),n.webnnRegisterGraphInput=D.registerGraphInput.bind(D),n.webnnIsGraphInput=D.isGraphInput.bind(D),n.webnnCreateTemporaryTensor=D.createTemporaryTensor.bind(D),n.webnnIsInt64Supported=D.isInt64Supported.bind(D)}};let h=()=>{let y=(C,D,$)=>(...H)=>{let me=Gs,Re=D==null?void 0:D();H=C(...H);let qe=D==null?void 0:D();return Re!==qe&&(C=qe,$(Re),D=$=null),Gs!=me?new Promise((at,mt)=>{Br={resolve:at,reject:mt}}):H};(()=>{for(let C of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])n[C]=y(n[C],()=>n[C],D=>n[C]=D)})(),d!==void 0&&(n._OrtRun=d(n._OrtRun),n._OrtRunWithBinding=d(n._OrtRunWithBinding)),h=void 0};n.asyncInit=()=>{h==null||h()};var p,f,m=Object.assign({},n),x=(y,C)=>{throw C},g="";(a||l)&&(l?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),f_&&(g=f_),g=g.startsWith("blob:")?"":g.slice(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1),l&&(f=y=>{var C=new XMLHttpRequest;return C.open("GET",y,!1),C.responseType="arraybuffer",C.send(null),new Uint8Array(C.response)}),p=async y=>{if(U(y))return new Promise((D,$)=>{var H=new XMLHttpRequest;H.open("GET",y,!0),H.responseType="arraybuffer",H.onload=()=>{H.status==200||H.status==0&&H.response?D(H.response):$(H.status)},H.onerror=$,H.send(null)});var C=await fetch(y,{credentials:"same-origin"});if(C.ok)return C.arrayBuffer();throw Error(C.status+" : "+C.url)});var _=console.log.bind(console),S=console.error.bind(console),M=_,w=S;Object.assign(n,m),m=null;var v,T,E,F,I,z,G,L,Q,q,J,ee,se,fe=n.wasmBinary,ue=!1,U=y=>y.startsWith("file://");function k(){return v.buffer!=F.buffer&&oe(),F}function j(){return v.buffer!=F.buffer&&oe(),I}function re(){return v.buffer!=F.buffer&&oe(),z}function we(){return v.buffer!=F.buffer&&oe(),G}function de(){return v.buffer!=F.buffer&&oe(),L}function Pe(){return v.buffer!=F.buffer&&oe(),Q}function Xe(){return v.buffer!=F.buffer&&oe(),q}function et(){return v.buffer!=F.buffer&&oe(),se}if(u){let y=function(C){try{var D=C.data,$=D.Bb;if($==="load"){let H=[];self.onmessage=me=>H.push(me),self.startWorker=()=>{postMessage({Bb:"loaded"});for(let me of H)y(me);self.onmessage=y};for(let me of D.Rb)n[me]&&!n[me].proxy||(n[me]=(...Re)=>{postMessage({Bb:"callHandler",Qb:me,args:Re})},me=="print"&&(M=n[me]),me=="printErr"&&(w=n[me]));v=D.kc,oe(),Me(D.lc)}else if($==="run"){V(D.Ab),gu(D.Ab,0,0,1,0,0),Qr(),Fe(D.Ab),X||(Wc(),X=!0);try{ie(D.fc,D.Hb)}catch(H){if(H!="unwind")throw H}}else D.target!=="setimmediate"&&($==="checkMailbox"?X&&Qe():$&&(w(`worker: received unknown command ${$}`),w(D)))}catch(H){throw _u(),H}};var Me,X=!1;w=function(...C){C=C.join(" "),console.error(C)},self.alert=function(...C){postMessage({Bb:"alert",text:C.join(" "),ic:rl()})},self.onunhandledrejection=C=>{throw C.reason||C},self.onmessage=y}function oe(){var y=v.buffer;n.HEAP8=F=new Int8Array(y),n.HEAP16=z=new Int16Array(y),n.HEAPU8=I=new Uint8Array(y),n.HEAPU16=G=new Uint16Array(y),n.HEAP32=L=new Int32Array(y),n.HEAPU32=Q=new Uint32Array(y),n.HEAPF32=q=new Float32Array(y),n.HEAPF64=se=new Float64Array(y),n.HEAP64=J=new BigInt64Array(y),n.HEAPU64=ee=new BigUint64Array(y)}function K(){u?startWorker(n):At.Ca()}u||(v=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),oe());var Ce,Ee=0,$e=null;function Be(){if(--Ee==0&&$e){var y=$e;$e=null,y()}}function Ve(y){throw w(y="Aborted("+y+")"),ue=!0,y=new WebAssembly.RuntimeError(y+". Build with -sASSERTIONS for more info."),r(y),y}function We(){return{a:{L:lt,Aa:it,b:He,$:Ut,A:_t,pa:ys,X:$s,Z:Qi,qa:Zr,na:vn,ga:Jr,ma:Qn,J:dr,Y:Zn,V:Lr,oa:Sn,W:Jn,va:to,E:wt,Q:en,O:so,D:Ka,u:Xa,r:Ya,P:An,z:W,R:te,ja:he,T:ut,aa:ft,M:Lt,F:hs,ia:Fe,sa:ps,t:li,Ba:Zi,w:Mi,o:ii,l:nn,c:hr,n:Eh,j:ca,v:Ph,p:Nh,f:Fh,s:Rh,m:Ih,e:da,k:Dh,i:kh,g:Lh,d:Bh,da:Oh,ea:Rc,fa:$h,ba:lu,ca:Ic,N:Dc,xa:kc,ua:uu,h:zh,C:Vh,G:Uh,ta:Lc,x:Gh,ra:jh,U:Wh,q:qm,y:Oc,K:Hh,S:du,za:No,ya:qh,ka:zc,la:fu,_:ss,B:Vc,I:Uc,ha:Gc,H:jc,a:v,wa:tt}}}var Je={829644:(y,C,D,$,H)=>{if(n===void 0||!n.Eb)return 1;if((y=Mt(Number(y>>>0))).startsWith("./")&&(y=y.substring(2)),!(y=n.Eb.get(y)))return 2;if(C=Number(C>>>0),D=Number(D>>>0),$=Number($>>>0),C+D>y.byteLength)return 3;try{let me=y.subarray(C,C+D);switch(H){case 0:j().set(me,$>>>0);break;case 1:n.mc?n.mc($,me):n.bc($,me);break;default:return 4}return 0}catch{return 4}},830468:(y,C,D)=>{n.Ob(y,j().subarray(C>>>0,C+D>>>0))},830532:()=>n.nc(),830574:y=>{n.Nb(y)},830611:()=>{n.Vb()},830642:()=>{n.Wb()},830671:()=>{n.$b()},830696:y=>n.Ub(y),830729:y=>n.Yb(y),830761:(y,C,D)=>{n.Kb(Number(y),Number(C),Number(D),!0)},830824:(y,C,D)=>{n.Kb(Number(y),Number(C),Number(D))},830881:()=>typeof wasmOffsetConverter<"u",830938:y=>{n.jb("Abs",y,void 0)},830989:y=>{n.jb("Neg",y,void 0)},831040:y=>{n.jb("Floor",y,void 0)},831093:y=>{n.jb("Ceil",y,void 0)},831145:y=>{n.jb("Reciprocal",y,void 0)},831203:y=>{n.jb("Sqrt",y,void 0)},831255:y=>{n.jb("Exp",y,void 0)},831306:y=>{n.jb("Erf",y,void 0)},831357:y=>{n.jb("Sigmoid",y,void 0)},831412:(y,C,D)=>{n.jb("HardSigmoid",y,{alpha:C,beta:D})},831491:y=>{n.jb("Log",y,void 0)},831542:y=>{n.jb("Sin",y,void 0)},831593:y=>{n.jb("Cos",y,void 0)},831644:y=>{n.jb("Tan",y,void 0)},831695:y=>{n.jb("Asin",y,void 0)},831747:y=>{n.jb("Acos",y,void 0)},831799:y=>{n.jb("Atan",y,void 0)},831851:y=>{n.jb("Sinh",y,void 0)},831903:y=>{n.jb("Cosh",y,void 0)},831955:y=>{n.jb("Asinh",y,void 0)},832008:y=>{n.jb("Acosh",y,void 0)},832061:y=>{n.jb("Atanh",y,void 0)},832114:y=>{n.jb("Tanh",y,void 0)},832166:y=>{n.jb("Not",y,void 0)},832217:(y,C,D)=>{n.jb("Clip",y,{min:C,max:D})},832286:y=>{n.jb("Clip",y,void 0)},832338:(y,C)=>{n.jb("Elu",y,{alpha:C})},832396:y=>{n.jb("Gelu",y,void 0)},832448:y=>{n.jb("Relu",y,void 0)},832500:(y,C)=>{n.jb("LeakyRelu",y,{alpha:C})},832564:(y,C)=>{n.jb("ThresholdedRelu",y,{alpha:C})},832634:(y,C)=>{n.jb("Cast",y,{to:C})},832692:y=>{n.jb("Add",y,void 0)},832743:y=>{n.jb("Sub",y,void 0)},832794:y=>{n.jb("Mul",y,void 0)},832845:y=>{n.jb("Div",y,void 0)},832896:y=>{n.jb("Pow",y,void 0)},832947:y=>{n.jb("Equal",y,void 0)},833e3:y=>{n.jb("Greater",y,void 0)},833055:y=>{n.jb("GreaterOrEqual",y,void 0)},833117:y=>{n.jb("Less",y,void 0)},833169:y=>{n.jb("LessOrEqual",y,void 0)},833228:(y,C,D,$,H)=>{n.jb("ReduceMean",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},833403:(y,C,D,$,H)=>{n.jb("ReduceMax",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},833577:(y,C,D,$,H)=>{n.jb("ReduceMin",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},833751:(y,C,D,$,H)=>{n.jb("ReduceProd",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},833926:(y,C,D,$,H)=>{n.jb("ReduceSum",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},834100:(y,C,D,$,H)=>{n.jb("ReduceL1",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},834273:(y,C,D,$,H)=>{n.jb("ReduceL2",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},834446:(y,C,D,$,H)=>{n.jb("ReduceLogSum",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},834623:(y,C,D,$,H)=>{n.jb("ReduceSumSquare",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},834803:(y,C,D,$,H)=>{n.jb("ReduceLogSumExp",y,{keepDims:!!C,noopWithEmptyAxes:!!D,axes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},834983:y=>{n.jb("Where",y,void 0)},835036:(y,C,D)=>{n.jb("Transpose",y,{perm:C?Array.from(de().subarray(Number(C)>>>0,Number(D)>>>0)):[]})},835160:(y,C,D,$)=>{n.jb("DepthToSpace",y,{blocksize:C,mode:Mt(D),format:$?"NHWC":"NCHW"})},835293:(y,C,D,$)=>{n.jb("DepthToSpace",y,{blocksize:C,mode:Mt(D),format:$?"NHWC":"NCHW"})},835426:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti,io)=>{n.jb("ConvTranspose",y,{format:at?"NHWC":"NCHW",autoPad:C,dilations:[D],group:$,kernelShape:[H],pads:[me,Re],strides:[qe],wIsConst:()=>!!k()[mt>>>0],outputPadding:zt?Array.from(de().subarray(Number(zt)>>>0,Number(is)>>>0)):[],outputShape:vs?Array.from(de().subarray(Number(vs)>>>0,Number(Ti)>>>0)):[],activation:Mt(io)})},835859:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti)=>{n.jb("ConvTranspose",y,{format:qe?"NHWC":"NCHW",autoPad:C,dilations:Array.from(de().subarray(Number(D)>>>0,2+(Number(D)>>>0)>>>0)),group:$,kernelShape:Array.from(de().subarray(Number(H)>>>0,2+(Number(H)>>>0)>>>0)),pads:Array.from(de().subarray(Number(me)>>>0,4+(Number(me)>>>0)>>>0)),strides:Array.from(de().subarray(Number(Re)>>>0,2+(Number(Re)>>>0)>>>0)),wIsConst:()=>!!k()[at>>>0],outputPadding:mt?Array.from(de().subarray(Number(mt)>>>0,Number(zt)>>>0)):[],outputShape:is?Array.from(de().subarray(Number(is)>>>0,Number(vs)>>>0)):[],activation:Mt(Ti)})},836520:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti,io)=>{n.jb("ConvTranspose",y,{format:at?"NHWC":"NCHW",autoPad:C,dilations:[D],group:$,kernelShape:[H],pads:[me,Re],strides:[qe],wIsConst:()=>!!k()[mt>>>0],outputPadding:zt?Array.from(de().subarray(Number(zt)>>>0,Number(is)>>>0)):[],outputShape:vs?Array.from(de().subarray(Number(vs)>>>0,Number(Ti)>>>0)):[],activation:Mt(io)})},836953:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti)=>{n.jb("ConvTranspose",y,{format:qe?"NHWC":"NCHW",autoPad:C,dilations:Array.from(de().subarray(Number(D)>>>0,2+(Number(D)>>>0)>>>0)),group:$,kernelShape:Array.from(de().subarray(Number(H)>>>0,2+(Number(H)>>>0)>>>0)),pads:Array.from(de().subarray(Number(me)>>>0,4+(Number(me)>>>0)>>>0)),strides:Array.from(de().subarray(Number(Re)>>>0,2+(Number(Re)>>>0)>>>0)),wIsConst:()=>!!k()[at>>>0],outputPadding:mt?Array.from(de().subarray(Number(mt)>>>0,Number(zt)>>>0)):[],outputShape:is?Array.from(de().subarray(Number(is)>>>0,Number(vs)>>>0)):[],activation:Mt(Ti)})},837614:(y,C)=>{n.jb("GlobalAveragePool",y,{format:C?"NHWC":"NCHW"})},837705:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti)=>{n.jb("AveragePool",y,{format:Ti?"NHWC":"NCHW",auto_pad:C,ceil_mode:D,count_include_pad:$,storage_order:H,dilations:me?Array.from(de().subarray(Number(me)>>>0,Number(Re)>>>0)):[],kernel_shape:qe?Array.from(de().subarray(Number(qe)>>>0,Number(at)>>>0)):[],pads:mt?Array.from(de().subarray(Number(mt)>>>0,Number(zt)>>>0)):[],strides:is?Array.from(de().subarray(Number(is)>>>0,Number(vs)>>>0)):[]})},838184:(y,C)=>{n.jb("GlobalAveragePool",y,{format:C?"NHWC":"NCHW"})},838275:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti)=>{n.jb("AveragePool",y,{format:Ti?"NHWC":"NCHW",auto_pad:C,ceil_mode:D,count_include_pad:$,storage_order:H,dilations:me?Array.from(de().subarray(Number(me)>>>0,Number(Re)>>>0)):[],kernel_shape:qe?Array.from(de().subarray(Number(qe)>>>0,Number(at)>>>0)):[],pads:mt?Array.from(de().subarray(Number(mt)>>>0,Number(zt)>>>0)):[],strides:is?Array.from(de().subarray(Number(is)>>>0,Number(vs)>>>0)):[]})},838754:(y,C)=>{n.jb("GlobalMaxPool",y,{format:C?"NHWC":"NCHW"})},838841:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti)=>{n.jb("MaxPool",y,{format:Ti?"NHWC":"NCHW",auto_pad:C,ceil_mode:D,count_include_pad:$,storage_order:H,dilations:me?Array.from(de().subarray(Number(me)>>>0,Number(Re)>>>0)):[],kernel_shape:qe?Array.from(de().subarray(Number(qe)>>>0,Number(at)>>>0)):[],pads:mt?Array.from(de().subarray(Number(mt)>>>0,Number(zt)>>>0)):[],strides:is?Array.from(de().subarray(Number(is)>>>0,Number(vs)>>>0)):[]})},839316:(y,C)=>{n.jb("GlobalMaxPool",y,{format:C?"NHWC":"NCHW"})},839403:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti)=>{n.jb("MaxPool",y,{format:Ti?"NHWC":"NCHW",auto_pad:C,ceil_mode:D,count_include_pad:$,storage_order:H,dilations:me?Array.from(de().subarray(Number(me)>>>0,Number(Re)>>>0)):[],kernel_shape:qe?Array.from(de().subarray(Number(qe)>>>0,Number(at)>>>0)):[],pads:mt?Array.from(de().subarray(Number(mt)>>>0,Number(zt)>>>0)):[],strides:is?Array.from(de().subarray(Number(is)>>>0,Number(vs)>>>0)):[]})},839878:(y,C,D,$,H)=>{n.jb("Gemm",y,{alpha:C,beta:D,transA:$,transB:H})},839982:y=>{n.jb("MatMul",y,void 0)},840036:(y,C,D,$)=>{n.jb("ArgMax",y,{keepDims:!!C,selectLastIndex:!!D,axis:$})},840144:(y,C,D,$)=>{n.jb("ArgMin",y,{keepDims:!!C,selectLastIndex:!!D,axis:$})},840252:(y,C)=>{n.jb("Softmax",y,{axis:C})},840315:(y,C)=>{n.jb("Concat",y,{axis:C})},840375:(y,C,D,$,H)=>{n.jb("Split",y,{axis:C,numOutputs:D,splitSizes:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},840531:y=>{n.jb("Expand",y,void 0)},840585:(y,C)=>{n.jb("Gather",y,{axis:Number(C)})},840656:(y,C)=>{n.jb("GatherElements",y,{axis:Number(C)})},840735:(y,C)=>{n.jb("GatherND",y,{batch_dims:Number(C)})},840814:(y,C,D,$,H,me,Re,qe,at,mt,zt)=>{n.jb("Resize",y,{antialias:C,axes:D?Array.from(de().subarray(Number(D)>>>0,Number($)>>>0)):[],coordinateTransformMode:Mt(H),cubicCoeffA:me,excludeOutside:Re,extrapolationValue:qe,keepAspectRatioPolicy:Mt(at),mode:Mt(mt),nearestMode:Mt(zt)})},841176:(y,C,D,$,H,me,Re)=>{n.jb("Slice",y,{starts:C?Array.from(de().subarray(Number(C)>>>0,Number(D)>>>0)):[],ends:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[],axes:me?Array.from(de().subarray(Number(me)>>>0,Number(Re)>>>0)):[]})},841440:y=>{n.jb("Tile",y,void 0)},841492:(y,C,D)=>{n.jb("InstanceNormalization",y,{epsilon:C,format:D?"NHWC":"NCHW"})},841606:(y,C,D)=>{n.jb("InstanceNormalization",y,{epsilon:C,format:D?"NHWC":"NCHW"})},841720:y=>{n.jb("Range",y,void 0)},841773:(y,C)=>{n.jb("Einsum",y,{equation:Mt(C)})},841854:(y,C,D,$,H)=>{n.jb("Pad",y,{mode:C,value:D,pads:$?Array.from(de().subarray(Number($)>>>0,Number(H)>>>0)):[]})},841997:(y,C,D,$,H,me)=>{n.jb("BatchNormalization",y,{epsilon:C,momentum:D,spatial:!!H,trainingMode:!!$,format:me?"NHWC":"NCHW"})},842166:(y,C,D,$,H,me)=>{n.jb("BatchNormalization",y,{epsilon:C,momentum:D,spatial:!!H,trainingMode:!!$,format:me?"NHWC":"NCHW"})},842335:(y,C,D)=>{n.jb("CumSum",y,{exclusive:Number(C),reverse:Number(D)})},842432:(y,C,D)=>{n.jb("DequantizeLinear",y,{axis:C,blockSize:D})},842522:(y,C,D,$,H)=>{n.jb("GridSample",y,{align_corners:C,mode:Mt(D),padding_mode:Mt($),format:H?"NHWC":"NCHW"})},842692:(y,C,D,$,H)=>{n.jb("GridSample",y,{align_corners:C,mode:Mt(D),padding_mode:Mt($),format:H?"NHWC":"NCHW"})},842862:(y,C)=>{n.jb("ScatterND",y,{reduction:Mt(C)})},842947:(y,C,D,$,H,me,Re,qe,at)=>{n.jb("Attention",y,{numHeads:C,isUnidirectional:D,maskFilterValue:$,scale:H,doRotary:me,qkvHiddenSizes:Re?Array.from(de().subarray(Number(qe)>>>0,Number(qe)+Re>>>0)):[],pastPresentShareBuffer:!!at})},843219:y=>{n.jb("BiasAdd",y,void 0)},843274:y=>{n.jb("BiasSplitGelu",y,void 0)},843335:y=>{n.jb("FastGelu",y,void 0)},843391:(y,C,D,$,H,me,Re,qe,at,mt,zt,is,vs,Ti,io,Qh)=>{n.jb("Conv",y,{format:is?"NHWC":"NCHW",auto_pad:C,dilations:D?Array.from(de().subarray(Number(D)>>>0,Number($)>>>0)):[],group:H,kernel_shape:me?Array.from(de().subarray(Number(me)>>>0,Number(Re)>>>0)):[],pads:qe?Array.from(de().subarray(Number(qe)>>>0,Number(at)>>>0)):[],strides:mt?Array.from(de().subarray(Number(mt)>>>0,Number(zt)>>>0)):[],w_is_const:()=>!!k()[Number(vs)>>>0],activation:Mt(Ti),activation_params:io?Array.from(Xe().subarray(Number(io)>>>0,Number(Qh)>>>0)):[]})},843975:y=>{n.jb("Gelu",y,void 0)},844027:(y,C,D,$,H,me,Re,qe,at)=>{n.jb("GroupQueryAttention",y,{numHeads:C,kvNumHeads:D,scale:$,softcap:H,doRotary:me,rotaryInterleaved:Re,smoothSoftmax:qe,localWindowSize:at})},844244:(y,C,D,$)=>{n.jb("LayerNormalization",y,{axis:C,epsilon:D,simplified:!!$})},844355:(y,C,D,$)=>{n.jb("LayerNormalization",y,{axis:C,epsilon:D,simplified:!!$})},844466:(y,C,D,$,H,me)=>{n.jb("MatMulNBits",y,{k:C,n:D,accuracyLevel:$,bits:H,blockSize:me})},844593:(y,C,D,$,H,me)=>{n.jb("MultiHeadAttention",y,{numHeads:C,isUnidirectional:D,maskFilterValue:$,scale:H,doRotary:me})},844752:(y,C)=>{n.jb("QuickGelu",y,{alpha:C})},844816:(y,C,D,$,H)=>{n.jb("RotaryEmbedding",y,{interleaved:!!C,numHeads:D,rotaryEmbeddingDim:$,scale:H})},844955:(y,C,D)=>{n.jb("SkipLayerNormalization",y,{epsilon:C,simplified:!!D})},845057:(y,C,D)=>{n.jb("SkipLayerNormalization",y,{epsilon:C,simplified:!!D})},845159:(y,C,D,$)=>{n.jb("GatherBlockQuantized",y,{gatherAxis:C,quantizeAxis:D,blockSize:$})},845280:y=>{n.Zb(y)},845314:(y,C)=>n.ac(Number(y),Number(C),n.Fb.dc,n.Fb.errors)};function it(y,C,D){return Mr(async()=>{await n.Xb(Number(y),Number(C),Number(D))})}function lt(){return typeof wasmOffsetConverter<"u"}class Ue{constructor(C){Z(this,"name","ExitStatus");this.message=`Program terminated with exit(${C})`,this.status=C}}var rt=y=>{y.terminate(),y.onmessage=()=>{}},yt=[],Nt=y=>{Zt.length==0&&(le(),O(Zt[0]));var C=Zt.pop();if(!C)return 6;_s.push(C),ti[y.Ab]=C,C.Ab=y.Ab;var D={Bb:"run",fc:y.ec,Hb:y.Hb,Ab:y.Ab};return C.postMessage(D,y.Mb),0},bt=0,Ye=(y,C,...D)=>{for(var $=2*D.length,H=ll(),me=xu(8*$),Re=me>>>3,qe=0;qe<D.length;qe++){var at=D[qe];typeof at=="bigint"?(J[Re+2*qe]=1n,J[Re+2*qe+1]=at):(J[Re+2*qe]=0n,et()[Re+2*qe+1>>>0]=at)}return y=Hc(y,0,$,me,C),al(H),y};function tt(y){if(u)return Ye(0,1,y);if(E=y,!(0<bt)){for(var C of _s)rt(C);for(C of Zt)rt(C);Zt=[],_s=[],ti={},ue=!0}x(0,new Ue(y))}function pt(y){if(u)return Ye(1,0,y);ss(y)}var ss=y=>{if(E=y,u)throw pt(y),"unwind";tt(y)},Zt=[],_s=[],bi=[],ti={},$t=y=>{var C=y.Ab;delete ti[C],Zt.push(y),_s.splice(_s.indexOf(y),1),y.Ab=0,qc(C)};function Qr(){bi.forEach(y=>y())}var O=y=>new Promise(C=>{y.onmessage=H=>{var me=(H=H.data).Bb;if(H.Gb&&H.Gb!=rl()){var Re=ti[H.Gb];Re?Re.postMessage(H,H.Mb):w(`Internal error! Worker sent a message "${me}" to target pthread ${H.Gb}, but that thread no longer exists!`)}else me==="checkMailbox"?Qe():me==="spawnThread"?Nt(H):me==="cleanupThread"?$t(ti[H.hc]):me==="loaded"?(y.loaded=!0,C(y)):me==="alert"?alert(`Thread ${H.ic}: ${H.text}`):H.target==="setimmediate"?y.postMessage(H):me==="callHandler"?n[H.Qb](...H.args):me&&w(`worker sent an unknown command ${me}`)},y.onerror=H=>{throw w(`worker sent an error! ${H.filename}:${H.lineno}: ${H.message}`),H};var D,$=[];for(D of[])n.propertyIsEnumerable(D)&&$.push(D);y.postMessage({Bb:"load",Rb:$,kc:v,lc:T})});function le(){var y=new Worker((()=>{let C=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new C("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});Zt.push(y)}var V=y=>{oe();var C=Pe()[y+52>>>2>>>0];y=Pe()[y+56>>>2>>>0],yu(C,C-y),al(C)},ie=(y,C)=>{bt=0,y=Yc(y,C),0<bt?E=y:ol(y)};class ve{constructor(C){this.Ib=C-24}}function He(y,C,D){var $=new ve(y>>>=0);throw C>>>=0,D>>>=0,Pe()[$.Ib+16>>>2>>>0]=0,Pe()[$.Ib+4>>>2>>>0]=C,Pe()[$.Ib+8>>>2>>>0]=D,y}function Ne(y,C,D,$){return u?Ye(2,1,y,C,D,$):Ut(y,C,D,$)}function Ut(y,C,D,$){if(y>>>=0,D>>>=0,$>>>=0,c===void 0)return 6;var H=[];return u&&H.length===0?Ne(y,C>>>=0,D,$):(y={ec:D,Ab:y,Hb:$,Mb:H},u?(y.Bb="spawnThread",postMessage(y,H),0):Nt(y))}var ds=typeof TextDecoder<"u"?new TextDecoder:void 0,Ct=(y,C=0,D=NaN)=>{var $=(C>>>=0)+D;for(D=C;y[D]&&!(D>=$);)++D;if(16<D-C&&y.buffer&&ds)return ds.decode(y.buffer instanceof ArrayBuffer?y.subarray(C,D):y.slice(C,D));for($="";C<D;){var H=y[C++];if(128&H){var me=63&y[C++];if((224&H)==192)$+=String.fromCharCode((31&H)<<6|me);else{var Re=63&y[C++];65536>(H=(240&H)==224?(15&H)<<12|me<<6|Re:(7&H)<<18|me<<12|Re<<6|63&y[C++])?$+=String.fromCharCode(H):(H-=65536,$+=String.fromCharCode(55296|H>>10,56320|1023&H))}}else $+=String.fromCharCode(H)}return $},Mt=(y,C)=>(y>>>=0)?Ct(j(),y,C):"";function _t(y,C,D){return u?Ye(3,1,y,C,D):0}function ys(y,C){if(u)return Ye(4,1,y,C)}var Is=y=>{for(var C=0,D=0;D<y.length;++D){var $=y.charCodeAt(D);127>=$?C++:2047>=$?C+=2:55296<=$&&57343>=$?(C+=4,++D):C+=3}return C},wi=(y,C,D)=>{var $=j();if(C>>>=0,0<D){var H=C;D=C+D-1;for(var me=0;me<y.length;++me){var Re=y.charCodeAt(me);if(55296<=Re&&57343>=Re&&(Re=65536+((1023&Re)<<10)|1023&y.charCodeAt(++me)),127>=Re){if(C>=D)break;$[C++>>>0]=Re}else{if(2047>=Re){if(C+1>=D)break;$[C++>>>0]=192|Re>>6}else{if(65535>=Re){if(C+2>=D)break;$[C++>>>0]=224|Re>>12}else{if(C+3>=D)break;$[C++>>>0]=240|Re>>18,$[C++>>>0]=128|Re>>12&63}$[C++>>>0]=128|Re>>6&63}$[C++>>>0]=128|63&Re}}$[C>>>0]=0,y=C-H}else y=0;return y};function $s(y,C){if(u)return Ye(5,1,y,C)}function Qi(y,C,D){if(u)return Ye(6,1,y,C,D)}function Zr(y,C,D){return u?Ye(7,1,y,C,D):0}function vn(y,C){if(u)return Ye(8,1,y,C)}function Jr(y,C,D){if(u)return Ye(9,1,y,C,D)}function Qn(y,C,D,$){if(u)return Ye(10,1,y,C,D,$)}function dr(y,C,D,$){if(u)return Ye(11,1,y,C,D,$)}function Zn(y,C,D,$){if(u)return Ye(12,1,y,C,D,$)}function Lr(y){if(u)return Ye(13,1,y)}function Sn(y,C){if(u)return Ye(14,1,y,C)}function Jn(y,C,D){if(u)return Ye(15,1,y,C,D)}var eo,si,to=()=>Ve(""),ki=y=>{for(var C="";j()[y>>>0];)C+=eo[j()[y++>>>0]];return C},En={},ir={};function je(y,C,D={}){return function($,H,me={}){var Re=H.name;if(!$)throw new si(`type "${Re}" must have a positive integer typeid pointer`);if(ir.hasOwnProperty($)){if(me.Sb)return;throw new si(`Cannot register type '${Re}' twice`)}ir[$]=H,En.hasOwnProperty($)&&(H=En[$],delete En[$],H.forEach(qe=>qe()))}(y,C,D)}var dt=(y,C,D)=>{switch(C){case 1:return D?$=>k()[$>>>0]:$=>j()[$>>>0];case 2:return D?$=>re()[$>>>1>>>0]:$=>we()[$>>>1>>>0];case 4:return D?$=>de()[$>>>2>>>0]:$=>Pe()[$>>>2>>>0];case 8:return D?$=>J[$>>>3]:$=>ee[$>>>3];default:throw new TypeError(`invalid integer width (${C}): ${y}`)}};function wt(y,C,D){D>>>=0,je(y>>>=0,{name:C=ki(C>>>0),fromWireType:$=>$,toWireType:function($,H){if(typeof H!="bigint"&&typeof H!="number")throw H=H===null?"null":($=typeof H)=="object"||$==="array"||$==="function"?H.toString():""+H,new TypeError(`Cannot convert "${H}" to ${this.name}`);return typeof H=="number"&&(H=BigInt(H)),H},Cb:xs,readValueFromPointer:dt(C,D,C.indexOf("u")==-1),Db:null})}var xs=8;function en(y,C,D,$){je(y>>>=0,{name:C=ki(C>>>0),fromWireType:function(H){return!!H},toWireType:function(H,me){return me?D:$},Cb:xs,readValueFromPointer:function(H){return this.fromWireType(j()[H>>>0])},Db:null})}var tn=[],Li=[];function hr(y){9<(y>>>=0)&&--Li[y+1]==0&&(Li[y]=void 0,tn.push(y))}var ai=y=>{if(!y)throw new si("Cannot use deleted val. handle = "+y);return Li[y]},fi=y=>{switch(y){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let C=tn.pop()||Li.length;return Li[C]=y,Li[C+1]=1,C}};function sn(y){return this.fromWireType(Pe()[y>>>2>>>0])}var Ha={name:"emscripten::val",fromWireType:y=>{var C=ai(y);return hr(y),C},toWireType:(y,C)=>fi(C),Cb:xs,readValueFromPointer:sn,Db:null};function so(y){return je(y>>>0,Ha)}var qa=(y,C)=>{switch(C){case 4:return function(D){return this.fromWireType(Xe()[D>>>2>>>0])};case 8:return function(D){return this.fromWireType(et()[D>>>3>>>0])};default:throw new TypeError(`invalid float width (${C}): ${y}`)}};function Ka(y,C,D){D>>>=0,je(y>>>=0,{name:C=ki(C>>>0),fromWireType:$=>$,toWireType:($,H)=>H,Cb:xs,readValueFromPointer:qa(C,D),Db:null})}function Xa(y,C,D,$,H){if(y>>>=0,D>>>=0,C=ki(C>>>0),H===-1&&(H=4294967295),H=qe=>qe,$===0){var me=32-8*D;H=qe=>qe<<me>>>me}var Re=C.includes("unsigned")?function(qe,at){return at>>>0}:function(qe,at){return at};je(y,{name:C,fromWireType:H,toWireType:Re,Cb:xs,readValueFromPointer:dt(C,D,$!==0),Db:null})}function Ya(y,C,D){function $(me){var Re=Pe()[me>>>2>>>0];return me=Pe()[me+4>>>2>>>0],new H(k().buffer,me,Re)}var H=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][C];je(y>>>=0,{name:D=ki(D>>>0),fromWireType:$,Cb:xs,readValueFromPointer:$},{Sb:!0})}function An(y,C){je(y>>>=0,{name:C=ki(C>>>0),fromWireType:function(D){for(var $,H=Pe()[D>>>2>>>0],me=D+4,Re=me,qe=0;qe<=H;++qe){var at=me+qe;qe!=H&&j()[at>>>0]!=0||(Re=Mt(Re,at-Re),$===void 0?$=Re:($+="\0",$+=Re),Re=at+1)}return Tr(D),$},toWireType:function(D,$){$ instanceof ArrayBuffer&&($=new Uint8Array($));var H=typeof $=="string";if(!(H||$ instanceof Uint8Array||$ instanceof Uint8ClampedArray||$ instanceof Int8Array))throw new si("Cannot pass non-string to std::string");var me=H?Is($):$.length,Re=nl(4+me+1),qe=Re+4;if(Pe()[Re>>>2>>>0]=me,H)wi($,qe,me+1);else if(H)for(H=0;H<me;++H){var at=$.charCodeAt(H);if(255<at)throw Tr(Re),new si("String has UTF-16 code units that do not fit in 8 bits");j()[qe+H>>>0]=at}else for(H=0;H<me;++H)j()[qe+H>>>0]=$[H];return D!==null&&D.push(Tr,Re),Re},Cb:xs,readValueFromPointer:sn,Db(D){Tr(D)}})}var ua=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Qa=(y,C)=>{for(var D=y>>1,$=D+C/2;!(D>=$)&&we()[D>>>0];)++D;if(32<(D<<=1)-y&&ua)return ua.decode(j().slice(y,D));for(D="",$=0;!($>=C/2);++$){var H=re()[y+2*$>>>1>>>0];if(H==0)break;D+=String.fromCharCode(H)}return D},Za=(y,C,D)=>{if(D??(D=2147483647),2>D)return 0;var $=C;D=(D-=2)<2*y.length?D/2:y.length;for(var H=0;H<D;++H){var me=y.charCodeAt(H);re()[C>>>1>>>0]=me,C+=2}return re()[C>>>1>>>0]=0,C-$},Ja=y=>2*y.length,el=(y,C)=>{for(var D=0,$="";!(D>=C/4);){var H=de()[y+4*D>>>2>>>0];if(H==0)break;++D,65536<=H?(H-=65536,$+=String.fromCharCode(55296|H>>10,56320|1023&H)):$+=String.fromCharCode(H)}return $},ye=(y,C,D)=>{if(C>>>=0,D??(D=2147483647),4>D)return 0;var $=C;D=$+D-4;for(var H=0;H<y.length;++H){var me=y.charCodeAt(H);if(55296<=me&&57343>=me&&(me=65536+((1023&me)<<10)|1023&y.charCodeAt(++H)),de()[C>>>2>>>0]=me,(C+=4)+4>D)break}return de()[C>>>2>>>0]=0,C-$},R=y=>{for(var C=0,D=0;D<y.length;++D){var $=y.charCodeAt(D);55296<=$&&57343>=$&&++D,C+=4}return C};function W(y,C,D){if(y>>>=0,C>>>=0,D=ki(D>>>=0),C===2)var $=Qa,H=Za,me=Ja,Re=qe=>we()[qe>>>1>>>0];else C===4&&($=el,H=ye,me=R,Re=qe=>Pe()[qe>>>2>>>0]);je(y,{name:D,fromWireType:qe=>{for(var at,mt=Pe()[qe>>>2>>>0],zt=qe+4,is=0;is<=mt;++is){var vs=qe+4+is*C;is!=mt&&Re(vs)!=0||(zt=$(zt,vs-zt),at===void 0?at=zt:(at+="\0",at+=zt),zt=vs+C)}return Tr(qe),at},toWireType:(qe,at)=>{if(typeof at!="string")throw new si(`Cannot pass non-string to C++ string type ${D}`);var mt=me(at),zt=nl(4+mt+C);return Pe()[zt>>>2>>>0]=mt/C,H(at,zt+4,mt+C),qe!==null&&qe.push(Tr,zt),zt},Cb:xs,readValueFromPointer:sn,Db(qe){Tr(qe)}})}function te(y,C){je(y>>>=0,{Tb:!0,name:C=ki(C>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function he(y){gu(y>>>0,!l,1,!a,131072,!1),Qr()}var _e=y=>{if(!ue)try{if(y(),!(0<bt))try{u?ol(E):ss(E)}catch(C){C instanceof Ue||C=="unwind"||x(0,C)}}catch(C){C instanceof Ue||C=="unwind"||x(0,C)}};function Fe(y){y>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(de(),y>>>2,y).value.then(Qe),y+=128,Atomics.store(de(),y>>>2,1))}var Qe=()=>{var y=rl();y&&(Fe(y),_e(Xc))};function ut(y,C){(y>>>=0)==C>>>0?setTimeout(Qe):u?postMessage({Gb:y,Bb:"checkMailbox"}):(y=ti[y])&&y.postMessage({Bb:"checkMailbox"})}var nt=[];function ft(y,C,D,$,H){for(C>>>=0,$/=2,nt.length=$,D=H>>>0>>>3,H=0;H<$;H++)nt[H]=J[D+2*H]?J[D+2*H+1]:et()[D+2*H+1>>>0];return(C?Je[C]:Yh[y])(...nt)}var Lt=()=>{bt=0};function hs(y){y>>>=0,u?postMessage({Bb:"cleanupThread",hc:y}):$t(ti[y])}function ps(y){}var zs=(y,C)=>{var D=ir[y];if(D===void 0)throw y=mu(y),D=ki(y),Tr(y),new si(`${C} has unknown type ${D}`);return D},Ts=(y,C,D)=>{var $=[];return y=y.toWireType($,D),$.length&&(Pe()[C>>>2>>>0]=fi($)),y};function li(y,C,D){return C>>>=0,D>>>=0,y=ai(y>>>0),C=zs(C,"emval::as"),Ts(C,D,y)}function Zi(y,C){return C>>>=0,y=ai(y>>>0),(C=zs(C,"emval::as")).toWireType(null,y)}var Bi=y=>{try{y()}catch(C){Ve(C)}},mi=0,Gs=null,Cn=0,Ds=[],Qs={},Ji={},rn=0,Br=null,ji=[];function Mr(y){return function(C){if(!ue){if(mi===0){var D=!1,$=!1;C((H=0)=>{if(!ue&&(Cn=H,D=!0,$)){mi=2,Bi(()=>Zc(Gs)),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.resume(),H=!1;try{var me=function(){var at=de()[Gs+8>>>2>>>0];return at=At[Ji[at]],--bt,at()}()}catch(at){me=at,H=!0}var Re=!1;if(!Gs){var qe=Br;qe&&(Br=null,(H?qe.reject:qe.resolve)(me),Re=!0)}if(H&&!Re)throw me}}),$=!0,D||(mi=1,Gs=function(){var H=nl(65548),me=H+12;Pe()[H>>>2>>>0]=me,Pe()[H+4>>>2>>>0]=me+65536,me=Ds[0];var Re=Qs[me];return Re===void 0&&(Re=rn++,Qs[me]=Re,Ji[Re]=me),me=Re,de()[H+8>>>2>>>0]=me,H}(),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.pause(),Bi(()=>Qc(Gs)))}else mi===2?(mi=0,Bi(Jc),Tr(Gs),Gs=null,ji.forEach(_e)):Ve(`invalid state: ${mi}`);return Cn}}(C=>{y().then(C)})}function Mi(y){return y>>>=0,Mr(async()=>{var C=await ai(y);return fi(C)})}var js=[];function ii(y,C,D,$){return D>>>=0,$>>>=0,(y=js[y>>>0])(null,C=ai(C>>>0),D,$)}var ui={},Wi=y=>{var C=ui[y];return C===void 0?ki(y):C};function nn(y,C,D,$,H){return D>>>=0,$>>>=0,H>>>=0,(y=js[y>>>0])(C=ai(C>>>0),C[D=Wi(D)],$,H)}var tl=()=>typeof globalThis=="object"?globalThis:Function("return this")();function Eh(y){return(y>>>=0)==0?fi(tl()):(y=Wi(y),fi(tl()[y]))}var Ah=y=>{var C=js.length;return js.push(y),C},Ch=(y,C)=>{for(var D=Array(y),$=0;$<y;++$)D[$]=zs(Pe()[C+4*$>>>2>>>0],"parameter "+$);return D},Pc=(y,C)=>Object.defineProperty(C,"name",{value:y});function ca(y,C,D){var $=(C=Ch(y,C>>>0)).shift();y--;var H=`return function (obj, func, destructorsRef, args) {
`,me=0,Re=[];D===0&&Re.push("obj");for(var qe=["retType"],at=[$],mt=0;mt<y;++mt)Re.push("arg"+mt),qe.push("argType"+mt),at.push(C[mt]),H+=`  var arg${mt} = argType${mt}.readValueFromPointer(args${me?"+"+me:""});
`,me+=C[mt].Cb;return H+=`  var rv = ${D===1?"new func":"func.call"}(${Re.join(", ")});
`,$.Tb||(qe.push("emval_returnValue"),at.push(Ts),H+=`  return emval_returnValue(retType, destructorsRef, rv);
`),qe.push(H+`};
`),y=function(zt){var is=Function;if(!(is instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof is} which is not a function`);var vs=Pc(is.name||"unknownFunctionName",function(){});return vs.prototype=is.prototype,vs=new vs,(zt=is.apply(vs,zt))instanceof Object?zt:vs}(qe)(...at),D=`methodCaller<(${C.map(zt=>zt.name).join(", ")}) => ${$.name}>`,Ah(Pc(D,y))}function Ph(y){return y=Wi(y>>>0),fi(n[y])}function Nh(y,C){return C>>>=0,y=ai(y>>>0),C=ai(C),fi(y[C])}function Fh(y){9<(y>>>=0)&&(Li[y+1]+=1)}function Rh(){return fi([])}function Ih(y){y=ai(y>>>0);for(var C=Array(y.length),D=0;D<y.length;D++)C[D]=y[D];return fi(C)}function da(y){return fi(Wi(y>>>0))}function Dh(){return fi({})}function kh(y){for(var C=ai(y>>>=0);C.length;){var D=C.pop();C.pop()(D)}hr(y)}function Lh(y,C,D){C>>>=0,D>>>=0,y=ai(y>>>0),C=ai(C),D=ai(D),y[C]=D}function Bh(y,C){return C>>>=0,y=(y=zs(y>>>0,"_emval_take_value")).readValueFromPointer(C),fi(y)}function Oh(y,C){y=-9007199254740992>y||9007199254740992<y?NaN:Number(y),C>>>=0,y=new Date(1e3*y),de()[C>>>2>>>0]=y.getUTCSeconds(),de()[C+4>>>2>>>0]=y.getUTCMinutes(),de()[C+8>>>2>>>0]=y.getUTCHours(),de()[C+12>>>2>>>0]=y.getUTCDate(),de()[C+16>>>2>>>0]=y.getUTCMonth(),de()[C+20>>>2>>>0]=y.getUTCFullYear()-1900,de()[C+24>>>2>>>0]=y.getUTCDay(),y=(y.getTime()-Date.UTC(y.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,de()[C+28>>>2>>>0]=y}var au=y=>y%4==0&&(y%100!=0||y%400==0),Nc=[0,31,60,91,121,152,182,213,244,274,305,335],Fc=[0,31,59,90,120,151,181,212,243,273,304,334];function Rc(y,C){y=-9007199254740992>y||9007199254740992<y?NaN:Number(y),C>>>=0,y=new Date(1e3*y),de()[C>>>2>>>0]=y.getSeconds(),de()[C+4>>>2>>>0]=y.getMinutes(),de()[C+8>>>2>>>0]=y.getHours(),de()[C+12>>>2>>>0]=y.getDate(),de()[C+16>>>2>>>0]=y.getMonth(),de()[C+20>>>2>>>0]=y.getFullYear()-1900,de()[C+24>>>2>>>0]=y.getDay();var D=(au(y.getFullYear())?Nc:Fc)[y.getMonth()]+y.getDate()-1|0;de()[C+28>>>2>>>0]=D,de()[C+36>>>2>>>0]=-60*y.getTimezoneOffset(),D=new Date(y.getFullYear(),6,1).getTimezoneOffset();var $=new Date(y.getFullYear(),0,1).getTimezoneOffset();y=0|(D!=$&&y.getTimezoneOffset()==Math.min($,D)),de()[C+32>>>2>>>0]=y}function $h(y){y>>>=0;var C=new Date(de()[y+20>>>2>>>0]+1900,de()[y+16>>>2>>>0],de()[y+12>>>2>>>0],de()[y+8>>>2>>>0],de()[y+4>>>2>>>0],de()[y>>>2>>>0],0),D=de()[y+32>>>2>>>0],$=C.getTimezoneOffset(),H=new Date(C.getFullYear(),6,1).getTimezoneOffset(),me=new Date(C.getFullYear(),0,1).getTimezoneOffset(),Re=Math.min(me,H);return 0>D?de()[y+32>>>2>>>0]=+(H!=me&&Re==$):0<D!=(Re==$)&&(H=Math.max(me,H),C.setTime(C.getTime()+6e4*((0<D?Re:H)-$))),de()[y+24>>>2>>>0]=C.getDay(),D=(au(C.getFullYear())?Nc:Fc)[C.getMonth()]+C.getDate()-1|0,de()[y+28>>>2>>>0]=D,de()[y>>>2>>>0]=C.getSeconds(),de()[y+4>>>2>>>0]=C.getMinutes(),de()[y+8>>>2>>>0]=C.getHours(),de()[y+12>>>2>>>0]=C.getDate(),de()[y+16>>>2>>>0]=C.getMonth(),de()[y+20>>>2>>>0]=C.getYear(),y=C.getTime(),BigInt(isNaN(y)?-1:y/1e3)}function lu(y,C,D,$,H,me,Re){return u?Ye(16,1,y,C,D,$,H,me,Re):-52}function Ic(y,C,D,$,H,me){if(u)return Ye(17,1,y,C,D,$,H,me)}var Po={},qm=()=>performance.timeOrigin+performance.now();function Dc(y,C){if(u)return Ye(18,1,y,C);if(Po[y]&&(clearTimeout(Po[y].id),delete Po[y]),!C)return 0;var D=setTimeout(()=>{delete Po[y],_e(()=>Kc(y,performance.timeOrigin+performance.now()))},C);return Po[y]={id:D,qc:C},0}function kc(y,C,D,$){y>>>=0,C>>>=0,D>>>=0,$>>>=0;var H=new Date().getFullYear(),me=new Date(H,0,1).getTimezoneOffset();H=new Date(H,6,1).getTimezoneOffset();var Re=Math.max(me,H);Pe()[y>>>2>>>0]=60*Re,de()[C>>>2>>>0]=+(me!=H),y=(C=qe=>{var at=Math.abs(qe);return`UTC${0<=qe?"-":"+"}${String(Math.floor(at/60)).padStart(2,"0")}${String(at%60).padStart(2,"0")}`})(me),C=C(H),H<me?(wi(y,D,17),wi(C,$,17)):(wi(y,$,17),wi(C,D,17))}var Lc=()=>Date.now();function uu(y,C,D){return 0<=y&&3>=y?(y===0?y=Date.now():y=performance.timeOrigin+performance.now(),J[D>>>0>>>3]=BigInt(Math.round(1e6*y)),0):28}var cu=[],Bc=(y,C)=>{cu.length=0;for(var D;D=j()[y++>>>0];){var $=D!=105;C+=($&=D!=112)&&C%8?4:0,cu.push(D==112?Pe()[C>>>2>>>0]:D==106?J[C>>>3]:D==105?de()[C>>>2>>>0]:et()[C>>>3>>>0]),C+=$?8:4}return cu};function zh(y,C,D){return y>>>=0,C=Bc(C>>>0,D>>>0),Je[y](...C)}function Vh(y,C,D){return y>>>=0,C=Bc(C>>>0,D>>>0),Je[y](...C)}var Uh=()=>{};function Gh(y,C){return w(Mt(y>>>0,C>>>0))}var jh=()=>{throw bt+=1,"unwind"};function Wh(){return 4294901760}var Oc=()=>navigator.hardwareConcurrency;function Hh(){return Ve("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function du(y){y>>>=0;var C=j().length;if(y<=C||4294901760<y)return!1;for(var D=1;4>=D;D*=2){var $=C*(1+.2/D);$=Math.min($,y+100663296);e:{$=(Math.min(4294901760,65536*Math.ceil(Math.max(y,$)/65536))-v.buffer.byteLength+65535)/65536|0;try{v.grow($),oe();var H=1;break e}catch{}H=void 0}if(H)return!0}return!1}var ha=()=>(Ve("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),pa={},hu=y=>{y.forEach(C=>{ha()})};function No(){var y=Error().stack.toString().split(`
`);return y[0]=="Error"&&y.shift(),hu(y),pa.Lb=ha(),pa.cc=y,pa.Lb}function qh(y,C,D){if(y>>>=0,C>>>=0,pa.Lb==y)var $=pa.cc;else($=Error().stack.toString().split(`
`))[0]=="Error"&&$.shift(),hu($);for(var H=3;$[H]&&ha()!=y;)++H;for(y=0;y<D&&$[y+H];++y)de()[C+4*y>>>2>>>0]=ha();return y}var $c,pu={},Kh=()=>{if(!$c){var y,C={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(y in pu)pu[y]===void 0?delete C[y]:C[y]=pu[y];var D=[];for(y in C)D.push(`${y}=${C[y]}`);$c=D}return $c};function zc(y,C){if(u)return Ye(19,1,y,C);y>>>=0,C>>>=0;var D=0;return Kh().forEach(($,H)=>{var me=C+D;for(H=Pe()[y+4*H>>>2>>>0]=me,me=0;me<$.length;++me)k()[H++>>>0]=$.charCodeAt(me);k()[H>>>0]=0,D+=$.length+1}),0}function fu(y,C){if(u)return Ye(20,1,y,C);y>>>=0,C>>>=0;var D=Kh();Pe()[y>>>2>>>0]=D.length;var $=0;return D.forEach(H=>$+=H.length+1),Pe()[C>>>2>>>0]=$,0}function Vc(y){return u?Ye(21,1,y):52}function Uc(y,C,D,$){return u?Ye(22,1,y,C,D,$):52}function Gc(y,C,D,$){return u?Ye(23,1,y,C,D,$):70}var Xh=[null,[],[]];function jc(y,C,D,$){if(u)return Ye(24,1,y,C,D,$);C>>>=0,D>>>=0,$>>>=0;for(var H=0,me=0;me<D;me++){var Re=Pe()[C>>>2>>>0],qe=Pe()[C+4>>>2>>>0];C+=8;for(var at=0;at<qe;at++){var mt=j()[Re+at>>>0],zt=Xh[y];mt===0||mt===10?((y===1?M:w)(Ct(zt)),zt.length=0):zt.push(mt)}H+=qe}return Pe()[$>>>2>>>0]=H,0}u||function(){for(var y=n.numThreads-1;y--;)le();yt.unshift(()=>{Ee++,function(C){u?C():Promise.all(Zt.map(O)).then(C)}(()=>Be())})}();for(var sl=Array(256),il=0;256>il;++il)sl[il]=String.fromCharCode(il);eo=sl,si=n.BindingError=class extends Error{constructor(y){super(y),this.name="BindingError"}},n.InternalError=class extends Error{constructor(y){super(y),this.name="InternalError"}},Li.push(0,1,void 0,1,null,1,!0,1,!1,1),n.count_emval_handles=()=>Li.length/2-5-tn.length;var At,Yh=[tt,pt,Ne,_t,ys,$s,Qi,Zr,vn,Jr,Qn,dr,Zn,Lr,Sn,Jn,lu,Ic,Dc,zc,fu,Vc,Uc,Gc,jc];(async function(){function y($,H){return At=$.exports,At=function(){var me=At,Re={};for(let[qe,at]of Object.entries(me))Re[qe]=typeof at=="function"?(...mt)=>{Ds.push(qe);try{return at(...mt)}finally{ue||(Ds.pop(),Gs&&mi===1&&Ds.length===0&&(mi=0,bt+=1,Bi(bu),typeof Fibers<"u"&&Fibers.rc()))}}:at;return Re}(),At=function(){var me=At,Re=at=>mt=>at(mt)>>>0,qe=at=>()=>at()>>>0;return(me=Object.assign({},me)).Da=Re(me.Da),me.fb=qe(me.fb),me.hb=Re(me.hb),me.tb=Re(me.tb),me.ub=qe(me.ub),me.__cxa_get_exception_ptr=Re(me.__cxa_get_exception_ptr),me}(),bi.push(At.ib),T=H,Be(),At}Ee++;var C=We();if(n.instantiateWasm)return new Promise($=>{n.instantiateWasm(C,(H,me)=>{y(H,me),$(H.exports)})});if(u)return new Promise($=>{Me=H=>{var me=new WebAssembly.Instance(H,We());$(y(me,H))}});Ce??(Ce=n.locateFile?n.locateFile?n.locateFile("ort-wasm-simd-threaded.jsep.wasm",g):g+"ort-wasm-simd-threaded.jsep.wasm":new URL("/magic-eye-yourself/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href);try{var D=await async function($){var H=Ce;if(!fe&&typeof WebAssembly.instantiateStreaming=="function"&&!U(H))try{var me=fetch(H,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(me,$)}catch(Re){w(`wasm streaming compile failed: ${Re}`),w("falling back to ArrayBuffer instantiation")}return async function(Re,qe){try{var at=await async function(mt){if(!fe)try{var zt=await p(mt);return new Uint8Array(zt)}catch{}if(mt==Ce&&fe)mt=new Uint8Array(fe);else{if(!f)throw"both async and sync fetching of the wasm failed";mt=f(mt)}return mt}(Re);return await WebAssembly.instantiate(at,qe)}catch(mt){w(`failed to asynchronously prepare wasm: ${mt}`),Ve(mt)}}(H,$)}(C);return y(D.instance,D.module)}catch($){return r($),Promise.reject($)}})();var mu=y=>(mu=At.Da)(y),Wc=()=>(Wc=At.Ea)();n._OrtInit=(y,C)=>(n._OrtInit=At.Fa)(y,C),n._OrtGetLastError=(y,C)=>(n._OrtGetLastError=At.Ga)(y,C),n._OrtCreateSessionOptions=(y,C,D,$,H,me,Re,qe,at,mt)=>(n._OrtCreateSessionOptions=At.Ha)(y,C,D,$,H,me,Re,qe,at,mt),n._OrtAppendExecutionProvider=(y,C,D,$,H)=>(n._OrtAppendExecutionProvider=At.Ia)(y,C,D,$,H),n._OrtAddFreeDimensionOverride=(y,C,D)=>(n._OrtAddFreeDimensionOverride=At.Ja)(y,C,D),n._OrtAddSessionConfigEntry=(y,C,D)=>(n._OrtAddSessionConfigEntry=At.Ka)(y,C,D),n._OrtReleaseSessionOptions=y=>(n._OrtReleaseSessionOptions=At.La)(y),n._OrtCreateSession=(y,C,D)=>(n._OrtCreateSession=At.Ma)(y,C,D),n._OrtReleaseSession=y=>(n._OrtReleaseSession=At.Na)(y),n._OrtGetInputOutputCount=(y,C,D)=>(n._OrtGetInputOutputCount=At.Oa)(y,C,D),n._OrtGetInputOutputMetadata=(y,C,D,$)=>(n._OrtGetInputOutputMetadata=At.Pa)(y,C,D,$),n._OrtFree=y=>(n._OrtFree=At.Qa)(y),n._OrtCreateTensor=(y,C,D,$,H,me)=>(n._OrtCreateTensor=At.Ra)(y,C,D,$,H,me),n._OrtGetTensorData=(y,C,D,$,H)=>(n._OrtGetTensorData=At.Sa)(y,C,D,$,H),n._OrtReleaseTensor=y=>(n._OrtReleaseTensor=At.Ta)(y),n._OrtCreateRunOptions=(y,C,D,$)=>(n._OrtCreateRunOptions=At.Ua)(y,C,D,$),n._OrtAddRunConfigEntry=(y,C,D)=>(n._OrtAddRunConfigEntry=At.Va)(y,C,D),n._OrtReleaseRunOptions=y=>(n._OrtReleaseRunOptions=At.Wa)(y),n._OrtCreateBinding=y=>(n._OrtCreateBinding=At.Xa)(y),n._OrtBindInput=(y,C,D)=>(n._OrtBindInput=At.Ya)(y,C,D),n._OrtBindOutput=(y,C,D,$)=>(n._OrtBindOutput=At.Za)(y,C,D,$),n._OrtClearBoundOutputs=y=>(n._OrtClearBoundOutputs=At._a)(y),n._OrtReleaseBinding=y=>(n._OrtReleaseBinding=At.$a)(y),n._OrtRunWithBinding=(y,C,D,$,H)=>(n._OrtRunWithBinding=At.ab)(y,C,D,$,H),n._OrtRun=(y,C,D,$,H,me,Re,qe)=>(n._OrtRun=At.bb)(y,C,D,$,H,me,Re,qe),n._OrtEndProfiling=y=>(n._OrtEndProfiling=At.cb)(y),n._JsepOutput=(y,C,D)=>(n._JsepOutput=At.db)(y,C,D),n._JsepGetNodeName=y=>(n._JsepGetNodeName=At.eb)(y);var rl=()=>(rl=At.fb)(),Tr=n._free=y=>(Tr=n._free=At.gb)(y),nl=n._malloc=y=>(nl=n._malloc=At.hb)(y),gu=(y,C,D,$,H,me)=>(gu=At.kb)(y,C,D,$,H,me),_u=()=>(_u=At.lb)(),Hc=(y,C,D,$,H)=>(Hc=At.mb)(y,C,D,$,H),qc=y=>(qc=At.nb)(y),ol=y=>(ol=At.ob)(y),Kc=(y,C)=>(Kc=At.pb)(y,C),Xc=()=>(Xc=At.qb)(),yu=(y,C)=>(yu=At.rb)(y,C),al=y=>(al=At.sb)(y),xu=y=>(xu=At.tb)(y),ll=()=>(ll=At.ub)(),Yc=n.dynCall_ii=(y,C)=>(Yc=n.dynCall_ii=At.vb)(y,C),Qc=y=>(Qc=At.wb)(y),bu=()=>(bu=At.xb)(),Zc=y=>(Zc=At.yb)(y),Jc=()=>(Jc=At.zb)();return n.stackSave=()=>ll(),n.stackRestore=y=>al(y),n.stackAlloc=y=>xu(y),n.setValue=function(y,C,D="i8"){switch(D.endsWith("*")&&(D="*"),D){case"i1":case"i8":k()[y>>>0]=C;break;case"i16":re()[y>>>1>>>0]=C;break;case"i32":de()[y>>>2>>>0]=C;break;case"i64":J[y>>>3]=BigInt(C);break;case"float":Xe()[y>>>2>>>0]=C;break;case"double":et()[y>>>3>>>0]=C;break;case"*":Pe()[y>>>2>>>0]=C;break;default:Ve(`invalid type for setValue: ${D}`)}},n.getValue=function(y,C="i8"){switch(C.endsWith("*")&&(C="*"),C){case"i1":case"i8":return k()[y>>>0];case"i16":return re()[y>>>1>>>0];case"i32":return de()[y>>>2>>>0];case"i64":return J[y>>>3];case"float":return Xe()[y>>>2>>>0];case"double":return et()[y>>>3>>>0];case"*":return Pe()[y>>>2>>>0];default:Ve(`invalid type for getValue: ${C}`)}},n.UTF8ToString=Mt,n.stringToUTF8=wi,n.lengthBytesUTF8=Is,function y(){if(0<Ee)$e=y;else if(u)s(n),K();else{for(;0<yt.length;)yt.shift()(n);0<Ee?$e=y:(n.calledRun=!0,ue||(K(),s(n)))}}(),n.PTR_SIZE=4,o}),iF=m_,eE=(e=(i=globalThis.self)==null?void 0:i.name)==null?void 0:e.startsWith("em-pthread"),eE&&m_()}),g_,wx,tE,Gr,rF,bp,sE,iE,__,rE,y_,nF,x_,oF,Db=Ze(()=>{Ib(),g_=typeof location>"u"?void 0:location.origin,wx=import.meta.url>"file:"&&import.meta.url<"file;",tE=()=>{{if(wx){let i=URL;return new URL(new i("ort.bundle.min.mjs",import.meta.url).href,g_).href}return import.meta.url}},Gr=tE(),rF=()=>{if(Gr&&!Gr.startsWith("blob:"))return Gr.substring(0,Gr.lastIndexOf("/")+1)},bp=(i,e)=>{try{let t=e??Gr;return(t?new URL(i,t):new URL(i)).origin===g_}catch{return!1}},sE=(i,e)=>{let t=e??Gr;try{return(t?new URL(i,t):new URL(i)).href}catch{return}},iE=(i,e)=>`${e??"./"}${i}`,__=async i=>{let e=await(await fetch(i,{credentials:"same-origin"})).blob();return URL.createObjectURL(e)},rE=async i=>(await import(i)).default,y_=(Z3(),Qd(eF)).default,nF=async()=>{if(!Gr)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(bp(Gr))return[void 0,y_()];let i=await __(Gr);return[i,y_(i)]},x_=(J3(),Qd(sF)).default,oF=async(i,e,t)=>{if(!i&&!e&&x_&&Gr&&bp(Gr))return[void 0,x_];{let s="ort-wasm-simd-threaded.jsep.mjs",r=i??sE(s,e),n=t&&r&&!bp(r,e),o=n?await __(r):r??iE(s,e);return[n?o:void 0,await rE(o)]}}}),b_,wp,id,w_,nE,oE,aE,kb,ks,Zl=Ze(()=>{Db(),wp=!1,id=!1,w_=!1,nE=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},oE=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},aE=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},kb=async i=>{if(wp)return Promise.resolve();if(id)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(w_)throw new Error("previous call to 'initializeWebAssembly()' failed.");id=!0;let e=i.initTimeout,t=i.numThreads;if(i.simd!==!1){if(i.simd==="relaxed"){if(!aE())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!oE())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let s=nE();t>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+t+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),i.numThreads=t=1);let r=i.wasmPaths,n=typeof r=="string"?r:void 0,o=r==null?void 0:r.mjs,a=(o==null?void 0:o.href)??o,l=r==null?void 0:r.wasm,u=(l==null?void 0:l.href)??l,c=i.wasmBinary,[d,h]=await oF(a,n,t>1),p=!1,f=[];if(e>0&&f.push(new Promise(m=>{setTimeout(()=>{p=!0,m()},e)})),f.push(new Promise((m,x)=>{let g={numThreads:t};if(c)g.wasmBinary=c;else if(u||n)g.locateFile=_=>u??n+_;else if(a&&a.indexOf("blob:")!==0)g.locateFile=_=>new URL(_,a).href;else if(d){let _=rF();_&&(g.locateFile=S=>_+S)}h(g).then(_=>{id=!1,wp=!0,b_=_,m(),d&&URL.revokeObjectURL(d)},_=>{id=!1,w_=!0,x(_)})})),await Promise.race(f),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},ks=()=>{if(wp&&b_)return b_;throw new Error("WebAssembly is not initialized yet.")}}),zn,kf,As,Lb=Ze(()=>{Zl(),zn=(i,e)=>{let t=ks(),s=t.lengthBytesUTF8(i)+1,r=t._malloc(s);return t.stringToUTF8(i,r,s),e.push(r),r},kf=(i,e,t,s)=>{if(typeof i=="object"&&i!==null){if(t.has(i))throw new Error("Circular reference in options");t.add(i)}Object.entries(i).forEach(([r,n])=>{let o=e?e+r:r;if(typeof n=="object")kf(n,o+".",t,s);else if(typeof n=="string"||typeof n=="number")s(o,n.toString());else if(typeof n=="boolean")s(o,n?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof n}`)})},As=i=>{let e=ks(),t=e.stackSave();try{let s=e.PTR_SIZE,r=e.stackAlloc(2*s);e._OrtGetLastError(r,r+s);let n=Number(e.getValue(r,s===4?"i32":"i64")),o=e.getValue(r+s,"*"),a=o?e.UTF8ToString(o):"";throw new Error(`${i} ERROR_CODE: ${n}, ERROR_MESSAGE: ${a}`)}finally{e.stackRestore(t)}}}),aF,ez=Ze(()=>{Zl(),Lb(),aF=i=>{let e=ks(),t=0,s=[],r=i||{};try{if((i==null?void 0:i.logSeverityLevel)===void 0)r.logSeverityLevel=2;else if(typeof i.logSeverityLevel!="number"||!Number.isInteger(i.logSeverityLevel)||i.logSeverityLevel<0||i.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${i.logSeverityLevel}`);if((i==null?void 0:i.logVerbosityLevel)===void 0)r.logVerbosityLevel=0;else if(typeof i.logVerbosityLevel!="number"||!Number.isInteger(i.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${i.logVerbosityLevel}`);(i==null?void 0:i.terminate)===void 0&&(r.terminate=!1);let n=0;return(i==null?void 0:i.tag)!==void 0&&(n=zn(i.tag,s)),t=e._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,n),t===0&&As("Can't create run options."),(i==null?void 0:i.extra)!==void 0&&kf(i.extra,"",new WeakSet,(o,a)=>{let l=zn(o,s),u=zn(a,s);e._OrtAddRunConfigEntry(t,l,u)!==0&&As(`Can't set a run config entry: ${o} - ${a}.`)}),[t,s]}catch(n){throw t!==0&&e._OrtReleaseRunOptions(t),s.forEach(o=>e._free(o)),n}}}),lE,uE,cE,rd,dE,lF,tz=Ze(()=>{Zl(),Lb(),lE=i=>{switch(i){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${i}`)}},uE=i=>{switch(i){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${i}`)}},cE=i=>{i.extra||(i.extra={}),i.extra.session||(i.extra.session={});let e=i.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),i.executionProviders&&i.executionProviders.some(t=>(typeof t=="string"?t:t.name)==="webgpu")&&(i.enableMemPattern=!1)},rd=(i,e,t,s)=>{let r=zn(e,s),n=zn(t,s);ks()._OrtAddSessionConfigEntry(i,r,n)!==0&&As(`Can't set a session config entry: ${e} - ${t}.`)},dE=async(i,e,t)=>{for(let s of e){let r=typeof s=="string"?s:s.name,n=[];switch(r){case"webnn":if(r="WEBNN",typeof s!="string"){let c=s==null?void 0:s.deviceType;c&&rd(i,"deviceType",c,t)}break;case"webgpu":if(r="JS",typeof s!="string"){let c=s;if(c!=null&&c.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);rd(i,"preferredLayout",c.preferredLayout,t)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let o=zn(r,t),a=n.length,l=0,u=0;if(a>0){l=ks()._malloc(a*ks().PTR_SIZE),t.push(l),u=ks()._malloc(a*ks().PTR_SIZE),t.push(u);for(let c=0;c<a;c++)ks().setValue(l+c*ks().PTR_SIZE,n[c][0],"*"),ks().setValue(u+c*ks().PTR_SIZE,n[c][1],"*")}await ks()._OrtAppendExecutionProvider(i,o,l,u,a)!==0&&As(`Can't append execution provider: ${r}.`)}},lF=async i=>{let e=ks(),t=0,s=[],r=i||{};cE(r);try{let n=lE(r.graphOptimizationLevel??"all"),o=uE(r.executionMode??"sequential"),a=typeof r.logId=="string"?zn(r.logId,s):0,l=r.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let u=r.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let c=typeof r.optimizedModelFilePath=="string"?zn(r.optimizedModelFilePath,s):0;if(t=e._OrtCreateSessionOptions(n,!!r.enableCpuMemArena,!!r.enableMemPattern,o,!!r.enableProfiling,0,a,l,u,c),t===0&&As("Can't create session options."),r.executionProviders&&await dE(t,r.executionProviders,s),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);rd(t,"enableGraphCapture",r.enableGraphCapture.toString(),s)}if(r.freeDimensionOverrides)for(let[d,h]of Object.entries(r.freeDimensionOverrides)){if(typeof d!="string")throw new Error(`free dimension override name must be a string: ${d}`);if(typeof h!="number"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let p=zn(d,s);e._OrtAddFreeDimensionOverride(t,p,h)!==0&&As(`Can't set a free dimension override: ${d} - ${h}.`)}return r.extra!==void 0&&kf(r.extra,"",new WeakSet,(d,h)=>{rd(t,d,h,s)}),[t,s]}catch(n){throw t!==0&&e._OrtReleaseSessionOptions(t)!==0&&As("Can't release session options."),s.forEach(o=>e._free(o)),n}}}),Hu,Uo,Il,Bb,Lf,Ob,$b,Mx,kt=Ze(()=>{Hu=i=>{switch(i){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${i}`)}},Uo=i=>{switch(i){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${i}`)}},Il=(i,e)=>{let t=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][i],s=typeof e=="number"?e:e.reduce((r,n)=>r*n,1);return t>0?Math.ceil(s*t):void 0},Bb=i=>{switch(i){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${i}`)}},Lf=i=>{switch(i){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${i}`)}},Ob=i=>i==="float32"||i==="float16"||i==="int32"||i==="int64"||i==="uint32"||i==="uint8"||i==="bool"||i==="uint4"||i==="int4",$b=i=>i==="float32"||i==="float16"||i==="int32"||i==="int64"||i==="uint32"||i==="uint64"||i==="int8"||i==="uint8"||i==="bool"||i==="uint4"||i==="int4",Mx=i=>{switch(i){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${i}`)}}}),zb,uF=Ze(()=>{Ib(),zb=async i=>{if(typeof i=="string"){let e=await fetch(i);if(!e.ok)throw new Error(`failed to load external data file: ${i}`);let t=e.headers.get("Content-Length"),s=t?parseInt(t,10):0;if(s<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${i}, no response body.`);let r=e.body.getReader(),n;try{n=new ArrayBuffer(s)}catch(a){if(a instanceof RangeError){let l=Math.ceil(s/65536);n=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw a}let o=0;for(;;){let{done:a,value:l}=await r.read();if(a)break;let u=l.byteLength;new Uint8Array(n,o,u).set(l),o+=u}return new Uint8Array(n,0,s)}}else return i instanceof Blob?new Uint8Array(await i.arrayBuffer()):i instanceof Uint8Array?i:new Uint8Array(i)}}),hE,pE,fE,mE,Vb,gE,ls,na=Ze(()=>{kt(),hE=["V","I","W","E","F"],pE=(i,e)=>{console.log(`[${hE[i]},${new Date().toISOString()}]${e}`)},Vb=(i,e)=>{fE=i,mE=e},gE=(i,e)=>{let t=Lf(i),s=Lf(fE);t>=s&&pE(t,typeof e=="function"?e():e)},ls=(...i)=>{mE&&gE(...i)}}),_E,hc,Ae,Bf,cF,dF,hF,Gt=Ze(()=>{_E=class{static calcMatMulShape(i,e){return i[1]!==e[0]?void 0:[i[0],e[1]]}},hc=class{static calcShape(i,e,t=!1){let s=i.length,r=e.length;if(s===0)return e;if(r===0)return i;let n=Math.max(i.length,e.length),o=new Array(n);if(t){if(s<2||r<2)return;let a=_E.calcMatMulShape([i[s-2],i[s-1]],[e[r-2],e[r-1]]);if(a===void 0)return;[o[n-2],o[n-1]]=a}for(let a=t?3:1;a<=n;a++){let l=s-a<0?1:i[s-a],u=r-a<0?1:e[r-a];if(l!==u&&l>1&&u>1)return;let c=Math.max(l,u);if(l&&u)o[n-a]=Math.max(l,u);else{if(c>1)return;o[n-a]=0}}return o}static isValidBroadcast(i,e){let t=i.length,s=e.length;if(t>s)return!1;for(let r=1;r<=t;r++)if(i[t-r]!==1&&i[t-r]!==e[s-r])return!1;return!0}},Ae=class wf{static size(e){return wf.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,t=4){let s=e.length;if(s===0)return[];let r=new Array(s),n=s-1;for(;n>=0;){if(e[n]%t===0){r[n]=e[n]/t;break}if(t%e[n]!==0)throw new Error("cannot convert shape");r[n]=1,t/=e[n],n--}for(n--;n>=0;n--)r[n]=e[n];return r}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return wf.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return wf.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,s){let r=1;for(let n=t;n<s;n++){if(e[n]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(e[n])}return r}static computeStrides(e){let t=e.length;if(t===0)return[];if(t===1)return[1];let s=new Array(t);s[t-1]=1,s[t-2]=e[t-1];for(let r=t-3;r>=0;--r)s[r]=s[r+1]*e[r+1];return s}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map(s=>this.normalizeAxis(s,t??e.length))}static sortBasedOnPerm(e,t){return t?t.map(s=>e[s]):e.slice().reverse()}static padShape(e,t){let s=e.length;return e.map((r,n)=>r+t[n]+t[n+s])}static areEqual(e,t){return e.length!==t.length?!1:e.every((s,r)=>s===t[r])}},Bf=class Id{static adjustPoolAttributes(e,t,s,r,n,o){if(!e&&s.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<t.length-2;a++)a>=s.length?s.push(t[a+2]):s[a]=t[a+2];for(let a=0;a<s.length;a++)if(a<r.length){if(r[a]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let a=0;a<s.length;a++)if(a<n.length){if(n[a]<0)throw new Error("dilations should be greater than or equal to 1")}else n.push(1);for(let a=0;a<s.length*2;a++)if(a<o.length){if(o[a]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let a=0;a<s.length;a++){if(s[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[a]>=s[a]||o[a+s.length]>=s[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,s,r,n,o,a){if(a){if(n.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<e.length-2;l++)Id.adjustPadAndReturnShape(e[l+(o?1:2)],t[l],s[l],r[l],n,l,l+e.length-2,a)}}static computePoolOutputShape(e,t,s,r,n,o,a){if(t.length<=0)throw new Error("input shape must be of size greater than 0");let l=[t[0],t[1]];return Id.computeShapeHelper(e,t,l,s,r,n,o,a),l}static computeConvOutputShape(e,t,s,r,n,o,a){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[e[0],t[0]];return Id.computeShapeHelper(!1,e,l,s,r,n,o,a),l}static computeShapeHelper(e,t,s,r,n,o,a,l){if(e)for(let u=0;u<t.length-2;u++)s.push(1);else for(let u=0;u<t.length-2;u++)s.push(Id.adjustPadAndReturnShape(t[u+2],r[u],n[u],o[u],a,u,u+t.length-2,l))}static adjustPadAndReturnShape(e,t,s,r,n,o,a,l){let u=s*(r-1)+1;if(l&&l!=="NOTSET")switch(l){case"VALID":return n[o]=0,n[a]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let c=((e+t-1)/t-1)*t+r-e;return n[o]=Math.floor(l==="SAME_LOWER"?(c+1)/2:c/2),n[a]=c-n[o],Math.floor((e+c-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+n[o]+n[a]-u)/t+1)}},cF=class{static getShapeOfGemmResult(i,e,t,s,r){if(i.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let n,o,a;e?(n=i[1],o=i[0]):(n=i[0],o=i[1]);let l=-1;if(s?(a=t[0],l=1):(a=t[1],l=0),t[l]!==o)throw new Error("dimension mismatch");if(n<=0||a<=0||o<=0)throw new Error("invalid shape specified");if(r&&!hc.isValidBroadcast(r,[n,a]))throw new Error("gemm: invalid bias shape for broadcast");return[n,a,o]}},dF=-34028234663852886e22,hF=34028234663852886e22}),Ub,pF=Ze(()=>{kt(),Ub=(i,e)=>new(Bb(e))(i)}),Tx,M_,yE,T_,xE,v_,S_,E_,bE,fF,sz=Ze(()=>{na(),Tx=(i,e=!0)=>{if(i.byteLength%8!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let t=i.byteLength/8,s=new BigInt64Array(i.buffer,i.byteOffset,t),r=new Int32Array(t);for(let n=0;n<t;n++){let o=s[n];if(o>2147483647n||o<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${n}: ${o}`);r[n]=Number(o)}return e?new Uint8Array(r.buffer):r},M_=(i,e=!0)=>{if(i.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let t=i.byteLength/4,s=new Int32Array(i.buffer,i.byteOffset,t),r=BigInt64Array.from(s,BigInt);return e?new Uint8Array(r.buffer):r},yE=1,T_=()=>yE++,xE=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),v_=(i,e)=>{let t=xE.get(i);if(!t)throw new Error("Unsupported data type.");return e.length>0?Math.ceil(e.reduce((s,r)=>s*r)*t/8):0},S_=class{constructor(i){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:e,context:t,tensor:s,dataType:r,shape:n,shouldConvertInt64toInt32:o=!1}=i;this.sessionId=e,this.mlContext=t,this.mlTensor=s,this.dataType=r,this.tensorShape=n,this.shouldConvertInt64toInt32=o}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return v_(this.dataType,this.tensorShape)}destroy(){ls("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(i){this.mlContext.writeTensor(this.mlTensor,i)}async read(i,e){if(i){let t=await this.mlContext.readTensor(this.mlTensor),s=M_(new Uint8Array(t));if(e){(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(s);return}else return s.buffer}else return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(i,e,t){return this.mlContext===i&&this.dataType===e&&this.tensorShape.length===t.length&&this.tensorShape.every((s,r)=>s===t[r])}setIsInt64ToInt32Converted(i){this.isInt64ToInt32Converted=i}},E_=class{constructor(i,e){this.tensorManager=i,this.wrapper=e}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(i,e,t,s){let r=e,n=this.tensorManager.getMLContext(i),o=r==="int64"&&!n.opSupportLimits().input.dataTypes.includes("int64");if(o&&(r="int32",ls("verbose",()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32")),this.wrapper){if(this.wrapper.canReuseTensor(n,r,t))return this.wrapper.tensor;if(s){if(this.wrapper.byteLength!==v_(r,t))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let a=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(i,r,t,a,!0,!0,o),s&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(i){let e=i;if(this.wrapper)if(this.wrapper.shouldConvertInt64toInt32&&(e=Tx(i,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),e.byteLength===this.wrapper.byteLength){this.wrapper.write(e);return}else ls("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(i){var e,t,s;if(this.activeUpload){let r=(e=this.wrapper)!=null&&e.isInt64ToInt32Converted?M_(this.activeUpload):this.activeUpload;if(i){i instanceof ArrayBuffer?new Uint8Array(i).set(r):new Uint8Array(i.buffer,i.byteOffset,i.byteLength).set(r);return}else return r.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return i?this.wrapper.read((t=this.wrapper)==null?void 0:t.shouldConvertInt64toInt32,i):this.wrapper.read((s=this.wrapper)==null?void 0:s.shouldConvertInt64toInt32)}},bE=class{constructor(i){this.backend=i,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(i){let e=this.backend.getMLContext(i);if(!e)throw new Error("MLContext not found for session.");return e}reserveTensorId(){let i=T_();return this.tensorTrackersById.set(i,new E_(this)),i}releaseTensorId(i){let e=this.tensorTrackersById.get(i);e&&(this.tensorTrackersById.delete(i),e.tensorWrapper&&this.releaseTensor(e.tensorWrapper))}async ensureTensor(i,e,t,s,r){ls("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${t}, shape: ${s}, copyOld: ${r}}`);let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.ensureTensor(i,t,s,r)}upload(i,e){let t=this.tensorTrackersById.get(i);if(!t)throw new Error("Tensor not found.");t.upload(e)}async download(i,e){ls("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${i}, dstBuffer: ${e==null?void 0:e.byteLength}}`);let t=this.tensorTrackersById.get(i);if(!t)throw new Error("Tensor not found.");return t.download(e)}releaseTensorsForSession(i){for(let e of this.freeTensors)e.sessionId===i&&e.destroy();this.freeTensors=this.freeTensors.filter(e=>e.sessionId!==i)}registerTensor(i,e,t,s){let r=this.getMLContext(i),n=T_(),o=new S_({sessionId:i,context:r,tensor:e,dataType:t,shape:s});return this.tensorTrackersById.set(n,new E_(this,o)),this.externalTensors.add(o),n}async getCachedTensor(i,e,t,s,r,n,o=!1){let a=this.getMLContext(i);for(let[u,c]of this.freeTensors.entries())if(c.canReuseTensor(a,e,t)){ls("verbose",()=>`[WebNN] Reusing tensor {dataType: ${e}, shape: ${t}}`);let d=this.freeTensors.splice(u,1)[0];return d.sessionId=i,d}ls("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${t}}`);let l=await a.createTensor({dataType:e,shape:t,dimensions:t,usage:s,writable:r,readable:n});return new S_({sessionId:i,context:a,tensor:l,dataType:e,shape:t,shouldConvertInt64toInt32:o})}releaseTensor(i){this.externalTensors.has(i)&&this.externalTensors.delete(i),this.freeTensors.push(i)}},fF=(...i)=>new bE(...i)}),Mp,wE,mF,iz=Ze(()=>{kt(),Zl(),pF(),sz(),na(),Mp=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),wE=(i,e)=>{if(i===e)return!0;if(i===void 0||e===void 0)return!1;let t=Object.keys(i).sort(),s=Object.keys(e).sort();return t.length===s.length&&t.every((r,n)=>r===s[n]&&i[r]===e[r])},mF=class{constructor(i){this.tensorManager=fF(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Vb(i.logLevel,!!i.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(i){ls("verbose",()=>`[WebNN] onRunStart {sessionId: ${i}}`),this.activeSessionId=i}onRunEnd(i){ls("verbose",()=>`[WebNN] onRunEnd {sessionId: ${i}}`);let e=this.temporarySessionTensorIds.get(i);if(e){for(let t of e)ls("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t);this.temporarySessionTensorIds.delete(i),this.activeSessionId=void 0}}async createMLContext(i){if(i instanceof GPUDevice){let t=this.mlContextCache.findIndex(s=>s.gpuDevice===i);if(t!==-1)return this.mlContextCache[t].mlContext;{let s=await navigator.ml.createContext(i);return this.mlContextCache.push({gpuDevice:i,mlContext:s}),s}}else if(i===void 0){let t=this.mlContextCache.findIndex(s=>s.options===void 0&&s.gpuDevice===void 0);if(t!==-1)return this.mlContextCache[t].mlContext;{let s=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:s}),s}}let e=this.mlContextCache.findIndex(t=>wE(t.options,i));if(e!==-1)return this.mlContextCache[e].mlContext;{let t=await navigator.ml.createContext(i);return this.mlContextCache.push({options:i,mlContext:t}),t}}registerMLContext(i,e){this.mlContextBySessionId.set(i,e);let t=this.sessionIdsByMLContext.get(e);t||(t=new Set,this.sessionIdsByMLContext.set(e,t)),t.add(i),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(i,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(i){this.sessionGraphInputs.delete(i);let e=this.mlContextBySessionId.get(i);if(!e)return;this.tensorManager.releaseTensorsForSession(i),this.mlContextBySessionId.delete(i);let t=this.sessionIdsByMLContext.get(e);if(t.delete(i),t.size===0){this.sessionIdsByMLContext.delete(e);let s=this.mlContextCache.findIndex(r=>r.mlContext===e);s!==-1&&this.mlContextCache.splice(s,1)}}getMLContext(i){return this.mlContextBySessionId.get(i)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(i){ls("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${i}}`),this.tensorManager.releaseTensorId(i)}async ensureTensor(i,e,t,s,r){let n=Mp.get(t);if(!n)throw new Error(`Unsupported ONNX data type: ${t}`);return this.tensorManager.ensureTensor(i??this.currentSessionId,e,n,s,r)}async createTemporaryTensor(i,e,t){ls("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${e}, shape: ${t}}`);let s=Mp.get(e);if(!s)throw new Error(`Unsupported ONNX data type: ${e}`);let r=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(i,r,s,t,!1);let n=this.temporarySessionTensorIds.get(i);return n?n.push(r):this.temporarySessionTensorIds.set(i,[r]),r}uploadTensor(i,e){if(!ks().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");ls("verbose",()=>`[WebNN] uploadTensor {tensorId: ${i}, data: ${e.byteLength}}`),this.tensorManager.upload(i,e)}async downloadTensor(i,e){return this.tensorManager.download(i,e)}createMLTensorDownloader(i,e){return async()=>{let t=await this.tensorManager.download(i);return Ub(t,e)}}registerMLTensor(i,e,t,s){let r=Mp.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);let n=this.tensorManager.registerTensor(i,e,r,s);return ls("verbose",()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${r}, dimensions: ${s}} -> {tensorId: ${n}}`),n}registerMLConstant(i,e,t,s,r,n,o=!1){if(!n)throw new Error("External mounted files are not available.");let a=i;i.startsWith("./")&&(a=i.substring(2));let l=n.get(a);if(!l)throw new Error(`File with name ${a} not found in preloaded files.`);if(e+t>l.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let u=l.slice(e,e+t).buffer,c;switch(r.dataType){case"float32":c=new Float32Array(u);break;case"float16":c=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(u):new Uint16Array(u);break;case"int32":c=new Int32Array(u);break;case"uint32":c=new Uint32Array(u);break;case"int64":o?(c=Tx(new Uint8Array(u),!1),r.dataType="int32"):c=new BigInt64Array(u);break;case"uint64":c=new BigUint64Array(u);break;case"int8":c=new Int8Array(u);break;case"int4":case"uint4":case"uint8":c=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${r.dataType} in creating WebNN Constant from external data.`)}return ls("verbose",()=>`[WebNN] registerMLConstant {dataType: ${r.dataType}, shape: ${r.shape}}} ${o?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),s.constant(r,c)}registerGraphInput(i){this.temporaryGraphInputs.push(i)}isGraphInput(i,e){let t=this.sessionGraphInputs.get(i);return t?t.includes(e):!1}isInt64Supported(i){var e;return!!((e=this.mlContextBySessionId.get(i))!=null&&e.opSupportLimits().input.dataTypes.includes("int64"))}flush(){}}}),Gb=Ze(()=>{}),A_,Tp,vp,ME,TE,C_,vx,vE,gF,rz=Ze(()=>{na(),Gb(),A_=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Tp=[],vp=i=>Math.ceil(Number(i)/16)*16,ME=i=>{for(let e=0;e<Tp.length;e++){let t=Tp[e];if(i<=t)return t}return Math.ceil(i/16)*16},TE=1,C_=()=>TE++,vx=async(i,e,t,s)=>{let r=vp(t),n=i.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=i.getCommandEncoder();i.endComputePass(),o.copyBufferToBuffer(e,0,n,0,r),i.flush(),await n.mapAsync(GPUMapMode.READ);let a=n.getMappedRange();if(s){let l=s();return l.set(new Uint8Array(a,0,t)),l}else return new Uint8Array(a.slice(0,t))}finally{n.destroy()}},vE=class{constructor(i){this.backend=i,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of A_)Tp.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(i,e){let t=e.buffer,s=e.byteOffset,r=e.byteLength,n=vp(r),o=this.storageCache.get(i);if(!o)throw new Error("gpu data for uploading does not exist");if(Number(o.originalSize)!==r)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${r}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=a.getMappedRange();new Uint8Array(l).set(new Uint8Array(t,s,r)),a.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(a,0,o.gpuData.buffer,0,n),this.backend.device.queue.submit([u.finish()]),a.destroy(),ls("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${i})`)}memcpy(i,e){let t=this.storageCache.get(i);if(!t)throw new Error("source gpu data for memcpy does not exist");let s=this.storageCache.get(e);if(!s)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==s.originalSize)throw new Error("inconsistent source and destination gpu data size");let r=vp(t.originalSize),n=this.backend.getCommandEncoder();this.backend.endComputePass(),n.copyBufferToBuffer(t.gpuData.buffer,0,s.gpuData.buffer,0,r)}registerExternalBuffer(i,e,t){let s;if(t){if(s=t[0],i===t[1])return ls("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, buffer is the same, skip.`),s;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else s=C_();return this.storageCache.set(s,{gpuData:{id:s,type:0,buffer:i},originalSize:e}),ls("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, registered.`),s}unregisterExternalBuffer(i){i!==void 0&&(this.storageCache.delete(i),ls("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${i}`))}create(i,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let t=ME(i),s,r=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,n=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(r||n){let a=(r?this.freeBuffers:this.freeUniformBuffers).get(t);a?a.length>0?s=a.pop():s=this.backend.device.createBuffer({size:t,usage:e}):s=this.backend.device.createBuffer({size:t,usage:e})}else s=this.backend.device.createBuffer({size:t,usage:e});let o={id:C_(),type:0,buffer:s};return this.storageCache.set(o.id,{gpuData:o,originalSize:Number(i)}),ls("verbose",()=>`[WebGPU] GpuDataManager.create(size=${i}) => id=${o.id}`),o}get(i){var e;return(e=this.storageCache.get(i))==null?void 0:e.gpuData}release(i){let e=typeof i=="bigint"?Number(i):i,t=this.storageCache.get(e);if(!t){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return ls("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(i,e){let t=this.storageCache.get(Number(i));if(!t)throw new Error("data does not exist");await vx(this.backend,t.gpuData.buffer,t.originalSize,e)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let i of this.buffersPending){let e=A_.get(i.size);if((i.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let t=this.freeBuffers.get(i.size)||[];e===void 0||t.length>=e?i.destroy():t.push(i)}else if((i.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let t=this.freeUniformBuffers.get(i.size)||[];e===void 0||t.length>=e?i.destroy():t.push(i)}else i.destroy()}this.buffersPending=[]}else{let i=this.capturedPendingBuffers.get(this.backend.currentSessionId);i||(i=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,i));for(let e of this.buffersPending)i.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(i=>{i.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(i=>{i.forEach(e=>{e.destroy()})}),this.storageCache.forEach(i=>{i.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(i=>{i.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(i){let e=this.capturedPendingBuffers.get(i);e&&(e.forEach(t=>{t.destroy()}),this.capturedPendingBuffers.delete(i)),this.sessionCount-=1,this.sessionCount===0&&(ls("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map)}},gF=(...i)=>new vE(...i)}),SE,Ms,oi=Ze(()=>{SE=class{constructor(i){Object.assign(this,i)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(i=>`${this[i]}`).join(";")),this.key}},Ms=i=>new SE(i)}),pc,Sp,Ui,or,Tt,Js,Sx,Yu,Oa,xt,nd,Oe,gt,_F,jb,EE,yF,qt=Ze(()=>{kt(),Gt(),pc=64,Sp=(i,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(i)){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${i}`)}},Ui=(i,e=1)=>{let t=Sp(i,e);return typeof t=="string"?t:t[0]},or=(i,e=1)=>{let t=Sp(i,e);return typeof t=="string"?t:t[1]},Tt=(...i)=>{let e=[];return i.forEach(t=>{t.length!==0&&e.push({type:12,data:t},{type:12,data:Ae.computeStrides(t)})}),e},Js=i=>i%4===0?4:i%2===0?2:1,Sx=(i="f32",e,t="0")=>!e||e===1?`${i}(${t})`:`vec${e}<${i}>(${t})`,Yu=(i,e,t)=>i==="f32"?t:e===1?`f32(${t})`:`vec${e}<f32>(${t})`,Oa=(i,e)=>e===4?`(${i}.x + ${i}.y + ${i}.z + ${i}.w)`:e===2?`(${i}.x + ${i}.y)`:e===3?`(${i}.x + ${i}.y + ${i}.z)`:i,xt=(i,e,t,s)=>i.startsWith("uniforms.")&&t>4?typeof e=="string"?s==="f16"?`${i}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${i}[(${e}) / 4][(${e}) % 4]`:s==="f16"?`${i}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${i}[${Math.floor(e/4)}][${e%4}]`:t>1?`${i}[${e}]`:i,nd=(i,e,t,s,r)=>{let n=typeof t=="number",o=n?t:t.length,a=[...new Array(o).keys()],l=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,u=Sp(e,r),c=typeof u=="string"?u:u[1],d=typeof u=="string"?u:u[0],h={indices:l,value:c,storage:d,tensor:e},p=U=>typeof U=="string"?U:`${U}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=n?"uniforms.":"",x=`${m}${i}_shape`,g=`${m}${i}_strides`,_="";for(let U=0;U<o-1;U++)_+=`
    let dim${U} = current / ${xt(g,U,o)};
    let rest${U} = current % ${xt(g,U,o)};
    indices[${U}] = dim${U};
    current = rest${U};
    `;_+=`indices[${o-1}] = current;`;let S=o<2?"":`
  fn o2i_${i}(offset: u32) -> ${h.indices} {
    var indices: ${h.indices};
    var current = offset;
    ${_}
    return indices;
  }`,M=U=>(f.offsetToIndices=!0,o<2?U:`o2i_${i}(${U})`),w=[];if(o>=2)for(let U=o-1;U>=0;U--)w.push(`${xt(g,U,o)} * (indices[${U}])`);let v=o<2?"":`
  fn i2o_${i}(indices: ${h.indices}) -> u32 {
    return ${w.join("+")};
  }`,T=U=>(f.indicesToOffset=!0,o<2?U:`i2o_${i}(${U})`),E=(...U)=>o===0?"0u":`${h.indices}(${U.map(p).join(",")})`,F=(U,k)=>o<2?`${U}`:`${xt(U,k,o)}`,I=(U,k,j)=>o<2?`${U}=${j};`:`${xt(U,k,o)}=${j};`,z={},G=(U,k)=>{f.broadcastedIndicesToOffset=!0;let j=`${k.name}broadcastedIndicesTo${i}Offset`;if(j in z)return`${j}(${U})`;let re=[];for(let we=o-1;we>=0;we--){let de=k.indicesGet("outputIndices",we+k.rank-o);re.push(`${F(g,we)} * (${de} % ${F(x,we)})`)}return z[j]=`fn ${j}(outputIndices: ${k.type.indices}) -> u32 {
             return ${re.length>0?re.join("+"):"0u"};
           }`,`${j}(${U})`},L=(U,k)=>(()=>{if(h.storage===h.value)return`${i}[${U}]=${k};`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`${i}[${U}]=vec2<u32>(u32(${k}), select(0u, 0xFFFFFFFFu, ${k} < 0));`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`${i}[${U}]=vec2<u32>(u32(${k}), 0u);`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`${i}[${U}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${k}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),Q=U=>(()=>{if(h.storage===h.value)return`${i}[${U}]`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`i32(${i}[${U}].x)`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`u32(${i}[${U}].x)`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`vec4<bool>(bool(${i}[${U}] & 0xFFu), bool(${i}[${U}] & 0xFF00u), bool(${i}[${U}] & 0xFF0000u), bool(${i}[${U}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),q=o<2?"":`
  fn get_${i}ByIndices(indices: ${h.indices}) -> ${c} {
    return ${Q(`i2o_${i}(indices)`)};
  }`,J=o<2?"":(()=>{let U=a.map(j=>`d${j}: u32`).join(", "),k=a.map(j=>`d${j}`).join(", ");return`
  fn get_${i}(${U}) -> ${c} {
    return get_${i}ByIndices(${E(k)});
  }`})(),ee=(...U)=>{if(U.length!==o)throw new Error(`indices length must be ${o}`);let k=U.map(p).join(",");return o===0?Q("0u"):o===1?Q(k[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${i}(${k})`)},se=U=>o<2?Q(U):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${i}ByIndices(${U})`),fe=o<2?"":`
  fn set_${i}ByIndices(indices: ${h.indices}, value: ${c}) {
    ${L(`i2o_${i}(indices)`,"value")}
  }`,ue=o<2?"":(()=>{let U=a.map(j=>`d${j}: u32`).join(", "),k=a.map(j=>`d${j}`).join(", ");return`
  fn set_${i}(${U}, value: ${c}) {
    set_${i}ByIndices(${E(k)}, value);
  }`})();return{impl:()=>{let U=[],k=!1;return f.offsetToIndices&&(U.push(S),k=!0),f.indicesToOffset&&(U.push(v),k=!0),f.broadcastedIndicesToOffset&&(Object.values(z).forEach(j=>U.push(j)),k=!0),f.set&&(U.push(ue),k=!0),f.setByIndices&&(U.push(fe),k=!0),f.get&&(U.push(J),k=!0),f.getByIndices&&(U.push(q),k=!0),!n&&k&&U.unshift(`const ${x} = ${h.indices}(${t.join(",")});`,`const ${g} = ${h.indices}(${Ae.computeStrides(t).join(",")});`),U.join(`
`)},type:h,offsetToIndices:M,indicesToOffset:T,broadcastedIndicesToOffset:G,indices:E,indicesGet:F,indicesSet:I,set:(...U)=>{if(U.length!==o+1)throw new Error(`indices length must be ${o}`);let k=U[o];if(typeof k!="string")throw new Error("value must be string");let j=U.slice(0,o).map(p).join(",");return o===0?L("0u",k):o===1?L(j[0],k):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${i}(${j}, ${k})`)},setByOffset:L,setByIndices:(U,k)=>o<2?L(U,k):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${i}ByIndices(${U}, ${k});`),get:ee,getByOffset:Q,getByIndices:se,usage:s,name:i,strides:g,shape:x,rank:o}},Oe=(i,e,t,s=1)=>nd(i,e,t,"input",s),gt=(i,e,t,s=1)=>nd(i,e,t,"output",s),_F=(i,e,t)=>nd(i,e,t,"atomicOutput",1),jb=(i,e,t,s=1)=>nd(i,e,t,"internal",s),EE=class{constructor(i,e){this.normalizedDispatchGroup=i,this.limits=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(i){return`if (global_idx >= ${typeof i=="number"?`${i}u`:i}) { return; }`}mainStart(i=pc){let e=typeof i=="number"?i:i[0],t=typeof i=="number"?1:i[1],s=typeof i=="number"?1:i[2];if(e>this.limits.maxComputeWorkgroupSizeX||t>this.limits.maxComputeWorkgroupSizeY||s>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${e}, ${t}, ${s}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(e*t*s>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${e}, ${t}, ${s}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let r=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,n=r?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,o=r?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${e*t*s}u + local_idx;`;return`@compute @workgroup_size(${e}, ${t}, ${s})
  fn main(${n}) {
    ${o}
  `}appendVariableUniforms(i){i.rank!==0&&(i.shape.startsWith("uniforms.")&&this.uniforms.push({name:i.shape.replace("uniforms.",""),type:"u32",length:i.rank}),i.strides.startsWith("uniforms.")&&this.uniforms.push({name:i.strides.replace("uniforms.",""),type:"u32",length:i.rank}))}declareVariable(i,e){if(i.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(i),this.appendVariableUniforms(i);let t=i.usage==="input"?"read":"read_write",s=i.usage==="atomicOutput"?"atomic<i32>":i.type.storage;return`@group(0) @binding(${e}) var<storage, ${t}> ${i.name}: array<${s}>;`}declareVariables(...i){return i.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(i){if(i.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(i),this.appendVariableUniforms(i)}registerInternalVariables(...i){return i.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(i,e,t=1){return this.uniforms.push({name:i,type:e,length:t}),this}registerUniforms(i){return this.uniforms=this.uniforms.concat(i),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let i=[];for(let{name:e,type:t,length:s}of this.uniforms)if(s&&s>4)t==="f16"?i.push(`@align(16) ${e}:array<mat2x4<${t}>, ${Math.ceil(s/8)}>`):i.push(`${e}:array<vec4<${t}>, ${Math.ceil(s/4)}>`);else{let r=s==null||s===1?t:`vec${s}<${t}>`;i.push(`${e}:${r}`)}return`
      struct Uniforms { ${i.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(i=>i.impl()).join(`
`)+this.internalVariables.map(i=>i.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let i=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(e=>[i(e.type),e.length??1])}},yF=(i,e)=>new EE(i,e)}),AE,P_,CE,PE,NE,FE,Xr,xF,bF,Va=Ze(()=>{kt(),Gt(),oi(),qt(),AE=(i,e)=>{if(!i||i.length!==1)throw new Error("Transpose requires 1 input.");if(e.length!==0&&e.length!==i[0].dims.length)throw new Error(`perm size ${e.length} does not match input rank ${i[0].dims.length}`)},P_=(i,e)=>e.length!==0?e:[...new Array(i).keys()].reverse(),CE=(i,e)=>Ae.sortBasedOnPerm(i,P_(i.length,e)),PE=(i,e,t,s)=>{let r=`fn perm(i: ${s.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`;for(let n=0;n<e;++n)r+=`a[${i[n]}]=i[${n}];`;return r+="return a;}"},NE=(i,e)=>{let t=[],s=[];for(let r=0;r<i.length;++r)i[r]!==1&&t.push(i[r]),i[e[r]]!==1&&s.push(e[r]);return{newShape:t,newPerm:s}},FE=(i,e)=>{let t=0;for(let s=0;s<i.length;++s)if(e[i[s]]!==1){if(i[s]<t)return!1;t=i[s]}return!0},Xr=(i,e)=>{let t=i.dataType,s=i.dims.length,r=P_(s,e),n=CE(i.dims,r),o=i.dims,a=n,l=s<2||FE(r,i.dims),u;if(l)return u=f=>{let m=Oe("input",t,o,4),x=gt("output",t,a,4);return`
  ${f.registerUniform("output_size","u32").declareVariables(m,x)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let f=Ae.size(n);return{outputs:[{dims:n,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(f/64/4)},programUniforms:[{type:12,data:Math.ceil(f/4)}]}},getShaderSource:u};let{newShape:c,newPerm:d}=NE(i.dims,r),h=Ae.areEqual(d,[2,3,1]),p=Ae.areEqual(d,[3,1,2]);if(c.length===2||h||p){o=h?[c[0],c[1]*c[2]]:p?[c[0]*c[1],c[2]]:c,a=[o[1],o[0]];let f=16;return u=m=>{let x=Oe("a",t,o.length),g=gt("output",t,a.length);return`
  ${m.registerUniform("output_size","u32").declareVariables(x,g)}
  var<workgroup> tile : array<array<${g.type.value}, ${f+1}>, ${f}>;
  ${m.mainStart([f,f,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${f} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${f}u + local_id.x;
    let input_row = workgroup_id_x * ${f}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${x.getByIndices(`${x.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${f}u + local_id.x;
    let output_row = workgroup_id_y * ${f}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${g.setByIndices(`${g.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let m=Ae.size(n);return{outputs:[{dims:n,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(a[1]/f),y:Math.ceil(a[0]/f)},programUniforms:[{type:12,data:m},...Tt(o,a)]}},getShaderSource:u}}return u=f=>{let m=Oe("a",t,o.length),x=gt("output",t,a.length);return`
  ${f.registerUniform("output_size","u32").declareVariables(m,x)}

  ${PE(r,s,m,x)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${x.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${x.setByOffset("global_idx",m.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:()=>{let f=Ae.size(n);return{outputs:[{dims:n,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Tt(o,a)]}},getShaderSource:u}},xF=(i,e)=>{AE(i.inputs,e.perm),i.compute(Xr(i.inputs[0],e.perm))},bF=i=>Ms({perm:i.perm})}),RE,IE,DE,kE,LE,BE,OE,$E,zE,VE,Nn,wF,MF,TF,vF,SF,EF,AF,CF,PF,NF,nz=Ze(()=>{kt(),Gt(),qt(),Wb(),Va(),RE={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},IE={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},DE={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},kE={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},LE=(i,e)=>{let t=[];for(let s=e-i;s<e;++s)t.push(s);return t},BE=(i,e)=>{let t=[],s=i.length;for(let n=0;n<s;n++)e.indexOf(n)===-1&&t.push(i[n]);let r=e.map(n=>i[n]);return[t,r]},OE=(i,e)=>{let t=i.length+e.length,s=[],r=0;for(let n=0;n<t;n++)e.indexOf(n)===-1?s.push(i[r++]):s.push(1);return s},$E=(i,e)=>{for(let t=0;t<i.length;++t)if(i[i.length-t-1]!==e-1-t)return!1;return!0},zE=(i,e)=>{let t=[];if(!$E(i,e)){for(let s=0;s<e;++s)i.indexOf(s)===-1&&t.push(s);i.forEach(s=>t.push(s))}return t},VE=(i,e,t,s,r,n,o)=>{let a=t[0].dims,l=Ae.size(n),u=Ae.size(o),c=Oe("_A",t[0].dataType,a),d=gt("output",r,n),h=64;l===1&&(h=256);let p=`
          var<workgroup> aBestValues : array<f32, ${h}>;
       `,f=m=>`
        ${m.registerUniform("reduceSize","u32").declareVariables(c,d)}
        ${p}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${m.mainStart(h)}

          let outputIndex = global_idx / ${h};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${DE[s]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${h}) {
           let candidate = f32(${c.getByOffset("offset + k")});
           bestValue = ${RE[s]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${h}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${IE[s]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${d.setByOffset("outputIndex",`${s==="mean"?`${d.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${d.type.storage}(${kE[s]})`}`)};
         }
        }`;return{name:i,shaderCache:{hint:`${e};${h}`,inputDependencies:["type"]},getShaderSource:f,getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},Nn=(i,e,t,s)=>{let r=i.inputs.length===1?t:Ex(i.inputs,t),n=r.axes;n.length===0&&!r.noopWithEmptyAxes&&(n=i.inputs[0].dims.map((p,f)=>f));let o=Ae.normalizeAxes(n,i.inputs[0].dims.length),a=o,l=i.inputs[0],u=zE(a,i.inputs[0].dims.length);u.length>0&&(l=i.compute(Xr(i.inputs[0],u),{inputs:[0],outputs:[-1]})[0],a=LE(a.length,l.dims.length));let[c,d]=BE(l.dims,a),h=c;r.keepDims&&(h=OE(c,o)),i.compute(VE(e,r.cacheKey,[l],s,i.inputs[0].dataType,h,d),{inputs:[l]})},wF=(i,e)=>{Nn(i,"ReduceMeanShared",e,"mean")},MF=(i,e)=>{Nn(i,"ReduceL1Shared",e,"l1")},TF=(i,e)=>{Nn(i,"ReduceL2Shared",e,"l2")},vF=(i,e)=>{Nn(i,"ReduceLogSumExpShared",e,"logSumExp")},SF=(i,e)=>{Nn(i,"ReduceMaxShared",e,"max")},EF=(i,e)=>{Nn(i,"ReduceMinShared",e,"min")},AF=(i,e)=>{Nn(i,"ReduceProdShared",e,"prod")},CF=(i,e)=>{Nn(i,"ReduceSumShared",e,"sum")},PF=(i,e)=>{Nn(i,"ReduceSumSquareShared",e,"sumSquare")},NF=(i,e)=>{Nn(i,"ReduceLogSumShared",e,"logSum")}}),Fn,UE,Of,Ex,Rn,GE,jE,WE,HE,qE,KE,XE,YE,QE,ZE,In,FF,RF,IF,DF,kF,LF,BF,OF,$F,zF,Wb=Ze(()=>{kt(),Gt(),oi(),qt(),nz(),Fn=i=>{if(!i||i.length===0||i.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(i.length===2&&i[1].dims.length!==1)throw new Error("Invalid axes input dims.")},UE=i=>["","",`var value = ${i.getByIndices("input_indices")};`,""],Of=(i,e,t,s,r,n,o=!1,a=!1)=>{let l=[],u=t[0].dims,c=u.length,d=Ae.normalizeAxes(r,c),h=!a&&d.length===0;u.forEach((m,x)=>{h||d.indexOf(x)>=0?o&&l.push(1):l.push(m)});let p=l.length,f=Ae.size(l);return{name:i,shaderCache:e,getShaderSource:m=>{let x=[],g=Oe("_A",t[0].dataType,c),_=gt("output",n,p),S=s(g,_,d),M=S[2];for(let w=0,v=0;w<c;w++)h||d.indexOf(w)>=0?(o&&v++,M=`for(var j${w}: u32 = 0; j${w} < ${u[w]}; j${w}++) {
                  ${S[2].includes("last_index")?`let last_index = j${w};`:""}
                  ${g.indicesSet("input_indices",w,`j${w}`)}
                  ${M}
                }`):(x.push(`${g.indicesSet("input_indices",w,_.indicesGet("output_indices",v))};`),v++);return`

        ${m.registerUniform("output_size","u32").declareVariables(g,_)}

        ${m.mainStart()}
          ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${g.type.indices};
          let output_indices = ${_.offsetToIndices("global_idx")};

          ${x.join(`
`)}
          ${S[0]}       // init ops for reduce max/min
          ${S[1]}
          ${M}
          ${S[3]}
          ${S.length===4?_.setByOffset("global_idx","value"):S.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:l,dataType:n}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Tt(u,l)]})}},Ex=(i,e)=>{let t=[];return i[1].dims[0]>0&&i[1].getBigInt64Array().forEach(s=>t.push(Number(s))),Ms({axes:t,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},Rn=(i,e,t,s)=>{let r=i.inputs,n=r.length===1?t:Ex(r,t);i.compute(Of(e,{hint:n.cacheKey,inputDependencies:["rank"]},[r[0]],n.noopWithEmptyAxes&&n.axes.length===0?UE:s,n.axes,r[0].dataType,n.keepDims,n.noopWithEmptyAxes),{inputs:[0]})},GE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceLogSum",e,(t,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,"value = log(value);"])},jE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceL1",e,(t,s)=>[`var value = ${s.type.storage}(0);`,"",`value += abs(${t.getByIndices("input_indices")});`,""])},WE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceL2",e,(t,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},HE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceLogSumExp",e,(t,s)=>[`var value = ${s.type.storage}(0);`,"",`value += exp(${t.getByIndices("input_indices")});`,"value = log(value);"])},qE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceMax",e,(t,s,r)=>{let n=[];for(let o=0;o<t.rank;o++)(r.indexOf(o)>=0||r.length===0)&&n.push(t.indicesSet("input_indices",o,0));return[`${n.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = max(value, ${t.getByIndices("input_indices")});`,""]})},KE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceMean",e,(t,s,r)=>{let n=1;for(let o=0;o<t.rank;o++)(r.indexOf(o)>=0||r.length===0)&&(n*=i.inputs[0].dims[o]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${s.type.value}(sum / ${n});`]})},XE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceMin",e,(t,s,r)=>{let n=[];for(let o=0;o<t.rank;o++)(r.indexOf(o)>=0||r.length===0)&&n.push(`input_indices[${o}] = 0;`);return[`${n.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = min(value, ${t.getByIndices("input_indices")});`,""]})},YE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceProd",e,(t,s)=>[`var value = ${s.type.storage}(1);`,"",`value *= ${t.getByIndices("input_indices")};`,""])},QE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceSum",e,(t,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,""])},ZE=(i,e)=>{Fn(i.inputs),Rn(i,"ReduceSumSquare",e,(t,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += t * t;`,""])},In=(i,e,t)=>{if(e.length===0)return t;let s=1,r=1;for(let n=0;n<e.length;n++)e.indexOf(n)===-1?s*=i[n]:r*=i[n];return r<32&&s>1024},FF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?KE(i,e):wF(i,e)},RF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?jE(i,e):MF(i,e)},IF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?WE(i,e):TF(i,e)},DF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?HE(i,e):vF(i,e)},kF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?qE(i,e):SF(i,e)},LF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?XE(i,e):EF(i,e)},BF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?YE(i,e):AF(i,e)},OF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?QE(i,e):CF(i,e)},$F=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?ZE(i,e):PF(i,e)},zF=(i,e)=>{In(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?GE(i,e):NF(i,e)}}),N_,VF,UF,Ax,oz=Ze(()=>{kt(),oi(),Wb(),N_=i=>{if(!i||i.length===0||i.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(i[0].dataType!==1)throw new Error("Invalid input type.")},VF=(i,e)=>{N_(i.inputs);let t=(s,r,n)=>{let o=[];for(let a=0;a<s.rank;a++)(n.indexOf(a)>=0||n.length===0)&&o.push(`input_indices[${a}] = 0;`);return[`${o.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};i.compute(Of("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[i.inputs[0]],t,[e.axis],7,e.keepDims),{inputs:[0]})},UF=(i,e)=>{N_(i.inputs);let t=(s,r,n)=>{let o=[];for(let a=0;a<s.rank;a++)(n.indexOf(a)>=0||n.length===0)&&o.push(`input_indices[${a}] = 0;`);return[`${o.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};i.compute(Of("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[i.inputs[0]],t,[e.axis],7,e.keepDims),{inputs:[0]})},Ax=i=>Ms(i)}),JE,Ep,eA,tA,sA,Jd,iA,GF,Hb=Ze(()=>{kt(),Gt(),Gb(),qt(),JE=(i,e)=>{let t=i[0],s=i[1],r=i[2],n=i[3],o=i[4],a=i[5];if(o&&a)throw new Error("Attention cannot have both past and attention_bias");if(t.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let l=t.dims[0],u=t.dims[1],c=t.dims[2];if(r.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(s.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(s.dims[0]!==c)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(r.dims[0]!==s.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let d=r.dims[0]/3,h=d,p=h;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let S of e.qkvHiddenSizes)if(S%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");d=e.qkvHiddenSizes[0],h=e.qkvHiddenSizes[1],p=e.qkvHiddenSizes[2]}let f=u;if(d!==h)throw new Error("qkv_hidden_sizes first element should be same as the second");if(r.dims[0]!==d+h+p)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let m=0;if(o){if(h!==p)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(o.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(o.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(o.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(o.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(o.dims[4]!==h/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(m=o.dims[3])}let x=f+m,g=-1,_=0;if(n)throw new Error("Mask not supported");if(o)throw new Error("past is not supported");if(a){if(a.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(a.dims[0]!==l||a.dims[1]!==e.numHeads||a.dims[2]!==u||a.dims[3]!==x)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:u,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:x,maxSequenceLength:g,inputHiddenSize:c,hiddenSize:d,vHiddenSize:p,headSize:Math.floor(d/e.numHeads),vHeadSize:Math.floor(p/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:_,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Ep=(i,e,t)=>e&&i?`
      let total_sequence_length_input = u32(${e.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${i==null?void 0:i.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${t?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,eA=(i,e,t,s,r,n,o,a)=>{let l=Js(o?1:n),u=64,c=n/l;c<u&&(u=32);let d=Math.ceil(n/l/u),h=[{type:12,data:e},{type:12,data:t},{type:12,data:s},{type:12,data:r},{type:12,data:c},{type:12,data:d}],p=Ui(i.dataType,l),f=or(1,l),m=["type"];o&&m.push("type"),a&&m.push("type");let x=g=>{let _=gt("x",i.dataType,i.dims,l),S=[_],M=o?Oe("seq_lens",o.dataType,o.dims):void 0;M&&S.push(M);let w=a?Oe("total_sequence_length_input",a.dataType,a.dims):void 0;w&&S.push(w);let v=or(i.dataType),T=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${u}>;
  var<workgroup> thread_sum: array<f32, ${u}>;
  ${g.registerUniforms(T).declareVariables(...S)}
  ${g.mainStart([u,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${Ep(M,w,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${o?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${f}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${u}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${f}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${u}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${_.type.value}(${v}(1.0) / ${v}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${f}(x[offset + i]);
        x[offset + i] = ${_.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${o?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${_.type.value}(${v}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${p};${l}`,inputDependencies:m},getShaderSource:x,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:r,z:e*t},programUniforms:h})}},tA=(i,e,t,s,r,n,o,a,l)=>{let u=o+n.kvSequenceLength,c=[n.batchSize,n.numHeads,n.sequenceLength,u],d=i>1&&s,h=n.kvNumHeads?n.kvNumHeads:n.numHeads,p=d?[n.batchSize,h,u,n.headSize]:void 0,f=n.nReps?n.nReps:1,m=n.scale===0?1/Math.sqrt(n.headSize):n.scale,x=Js(n.headSize),g=n.headSize/x,_=12,S={x:Math.ceil(u/_),y:Math.ceil(n.sequenceLength/_),z:n.batchSize*n.numHeads},M=[{type:12,data:n.sequenceLength},{type:12,data:g},{type:12,data:u},{type:12,data:n.numHeads},{type:12,data:n.headSize},{type:1,data:m},{type:12,data:o},{type:12,data:n.kvSequenceLength},{type:12,data:f}],w=d&&s&&Ae.size(s.dims)>0,v=["type","type"];w&&v.push("type"),r&&v.push("type"),a&&v.push("type"),l&&v.push("type");let T=[{dims:c,dataType:e.dataType,gpuDataType:0}];d&&T.push({dims:p,dataType:e.dataType,gpuDataType:0});let E=F=>{let I=Oe("q",e.dataType,e.dims,x),z=Oe("key",t.dataType,t.dims,x),G=[I,z];if(w){let fe=Oe("past_key",s.dataType,s.dims,x);G.push(fe)}r&&G.push(Oe("attention_bias",r.dataType,r.dims));let L=a?Oe("seq_lens",a.dataType,a.dims):void 0;L&&G.push(L);let Q=l?Oe("total_sequence_length_input",l.dataType,l.dims):void 0;Q&&G.push(Q);let q=gt("output",e.dataType,c),J=[q];d&&J.push(gt("present_key",e.dataType,p,x));let ee=or(1,x),se=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${_}u;

  var<workgroup> tileQ: array<${I.type.storage}, ${_*_}>;
  var<workgroup> tileK: array<${I.type.storage}, ${_*_}>;
  ${F.registerUniforms(se).declareVariables(...G,...J)}
  ${F.mainStart([_,_,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${f===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${f===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${Ep(L,Q,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${w&&d?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${d?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${ee}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${w&&d?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${d?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${ee}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(x){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${x}`)}})()};
        output[outputIdx] = ${q.type.value} (sum * uniforms.alpha) + ${r?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${x};${r!==void 0};${s!==void 0};${i}`,inputDependencies:v},getRunData:()=>({outputs:T,dispatchGroup:S,programUniforms:M}),getShaderSource:E}},sA=(i,e,t,s,r,n,o=void 0,a=void 0)=>{let l=n+r.kvSequenceLength,u=r.nReps?r.nReps:1,c=r.vHiddenSize*u,d=i>1&&s,h=r.kvNumHeads?r.kvNumHeads:r.numHeads,p=d?[r.batchSize,h,l,r.headSize]:void 0,f=[r.batchSize,r.sequenceLength,c],m=12,x={x:Math.ceil(r.vHeadSize/m),y:Math.ceil(r.sequenceLength/m),z:r.batchSize*r.numHeads},g=[{type:12,data:r.sequenceLength},{type:12,data:l},{type:12,data:r.vHeadSize},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:12,data:c},{type:12,data:n},{type:12,data:r.kvSequenceLength},{type:12,data:u}],_=d&&s&&Ae.size(s.dims)>0,S=["type","type"];_&&S.push("type"),o&&S.push("type"),a&&S.push("type");let M=[{dims:f,dataType:e.dataType,gpuDataType:0}];d&&M.push({dims:p,dataType:e.dataType,gpuDataType:0});let w=v=>{let T=Oe("probs",e.dataType,e.dims),E=Oe("v",t.dataType,t.dims),F=[T,E];_&&F.push(Oe("past_value",s.dataType,s.dims));let I=o?Oe("seq_lens",o.dataType,o.dims):void 0;o&&F.push(I);let z=a?Oe("total_sequence_length_input",a.dataType,a.dims):void 0;a&&F.push(z);let G=[gt("output",e.dataType,f)];d&&G.push(gt("present_value",e.dataType,p));let L=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${m}u;
  var<workgroup> tileQ: array<${T.type.value}, ${m*m}>;
  var<workgroup> tileV: array<${T.type.value}, ${m*m}>;
  ${v.registerUniforms(L).declareVariables(...F,...G)}
  ${v.mainStart([m,m,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${u===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${u===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${Ep(I,z,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${_&&d?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${d?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${T.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${_&&d?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${d?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${s!==void 0};${i}`,inputDependencies:S},getRunData:()=>({outputs:M,dispatchGroup:x,programUniforms:g}),getShaderSource:w}},Jd=(i,e,t,s,r,n,o,a,l,u,c=void 0,d=void 0)=>{let h=Math.min(i.outputCount,1+(o?1:0)+(a?1:0)),p=h>1?u.pastSequenceLength:0,f=p+u.kvSequenceLength,m=l&&Ae.size(l.dims)>0?l:void 0,x=[e,t];h>1&&o&&Ae.size(o.dims)>0&&x.push(o),m&&x.push(m),c&&x.push(c),d&&x.push(d);let g=i.compute(tA(h,e,t,o,m,u,p,c,d),{inputs:x,outputs:h>1?[-1,1]:[-1]})[0];i.compute(eA(g,u.batchSize,u.numHeads,p,u.sequenceLength,f,c,d),{inputs:c&&d?[g,c,d]:[g],outputs:[]});let _=[g,s];h>1&&a&&Ae.size(a.dims)>0&&_.push(a),c&&_.push(c),d&&_.push(d),i.compute(sA(h,g,s,a,u,p,c,d),{inputs:_,outputs:h>1?[0,2]:[0]})},iA=(i,e)=>{let t=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],s=e.sequenceLength,r=e.inputHiddenSize,n=e.headSize,o=12,a={x:Math.ceil(e.headSize/o),y:Math.ceil(e.sequenceLength/o),z:e.batchSize*e.numHeads},l=[i.inputs[0],i.inputs[1],i.inputs[2]],u=[{type:12,data:s},{type:12,data:r},{type:12,data:n},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],c=d=>{let h=gt("output_q",l[0].dataType,t),p=gt("output_k",l[0].dataType,t),f=gt("output_v",l[0].dataType,t),m=Oe("input",l[0].dataType,l[0].dims),x=Oe("weight",l[1].dataType,l[1].dims),g=Oe("bias",l[2].dataType,l[2].dims),_=m.type.storage,S=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${o}u;
  var<workgroup> tileInput: array<${_}, ${o*o}>;
  var<workgroup> tileWeightQ: array<${_}, ${o*o}>;
  var<workgroup> tileWeightK: array<${_}, ${o*o}>;
  var<workgroup> tileWeightV: array<${_}, ${o*o}>;
  ${d.registerUniforms(S).declareVariables(m,x,g,h,p,f)}
  ${d.mainStart([o,o,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${_}(0);
    var valueK = ${_}(0);
    var valueV = ${_}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return i.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:t,dataType:i.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:i.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:i.inputs[0].dataType,gpuDataType:0}],dispatchGroup:a,programUniforms:u}),getShaderSource:c},{inputs:l,outputs:[-1,-1,-1]})},GF=(i,e)=>{let t=JE(i.inputs,e),[s,r,n]=iA(i,t);return Jd(i,s,r,n,i.inputs[4],void 0,void 0,void 0,i.inputs[5],t)}}),rA,nA,oA,jF,az=Ze(()=>{Xn(),kt(),Gt(),oi(),qt(),rA=(i,e)=>{if(!i||i.length!==5)throw new Error("BatchNormalization requires 5 inputs");let t=(s,r,n)=>{let o=r.length;if(o!==s.length)throw new Error(`${n}: num dimensions != ${o}`);r.forEach((a,l)=>{if(a!==s[l])throw new Error(`${n}: dim[${l}] do not match`)})};if(i[0].dims.length>1){let s=e.format==="NHWC"?e.spatial?i[0].dims.slice(-1):i[0].dims.slice(-1).concat(i[0].dims.slice(1,i[0].dims.length-1)):i[0].dims.slice(1,e.spatial?2:void 0);t(i[1].dims,s,"Invalid input scale"),t(i[2].dims,s,"Invalid input B"),t(i[3].dims,s,"Invalid input mean"),t(i[4].dims,s,"Invalid input var")}else t(i[1].dims,[1],"Invalid input scale"),t(i[2].dims,[1],"Invalid input B"),t(i[3].dims,[1],"Invalid input mean"),t(i[4].dims,[1],"Invalid input var")},nA=(i,e)=>{let{epsilon:t,spatial:s,format:r}=e,n=i[0].dims,o=s?Js(n[n.length-1]):1,a=r==="NHWC"&&n.length>1?o:1,l=Ae.size(n)/o,u=s,c=u?n.length:n,d=Oe("x",i[0].dataType,i[0].dims,o),h=Oe("scale",i[1].dataType,i[1].dims,a),p=Oe("bias",i[2].dataType,i[2].dims,a),f=Oe("inputMean",i[3].dataType,i[3].dims,a),m=Oe("inputVar",i[4].dataType,i[4].dims,a),x=gt("y",i[0].dataType,c,o),g=()=>{let S="";if(s)S=`let cOffset = ${n.length===1?"0u":r==="NHWC"?`outputIndices[${n.length-1}] / ${o}`:"outputIndices[1]"};`;else if(r==="NCHW")S=`
            ${x.indicesSet("outputIndices","0","0")}
            let cOffset = ${x.indicesToOffset("outputIndices")};`;else{S=`var cIndices = ${h.type.indices}(0);
                       cIndices[0] = outputIndices[${n.length-1}];`;for(let M=1;M<h.rank;M++)S+=`cIndices[${M}] = outputIndices[${M}];`;S+=`let cOffset = ${h.indicesToOffset("cIndices")};`}return S},_=S=>`
  const epsilon = ${t};
  ${S.registerUniform("outputSize","u32").declareVariables(d,h,p,f,m,x)}
  ${S.mainStart()}
  ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${x.offsetToIndices(`global_idx * ${o}`)};
    ${g()}
    let scale = ${h.getByOffset("cOffset")};
    let bias = ${p.getByOffset("cOffset")};
    let inputMean = ${f.getByOffset("cOffset")};
    let inputVar = ${m.getByOffset("cOffset")};
    let x = ${d.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${x.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${s}_${o}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:_,getRunData:()=>({outputs:[{dims:i[0].dims,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...Tt(n)]:[{type:12,data:l}]})}},oA=i=>Ms(i),jF=(i,e)=>{let{inputs:t,outputCount:s}=i,r=oA({...e,outputCount:s});if(Vs.webgpu.validateInputContent&&rA(t,r),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");i.compute(nA(t,r))}}),aA,lA,WF,lz=Ze(()=>{Gt(),qt(),aA=i=>{if(i[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(i[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(i[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(i[0].dims[2]!==i[1].dims[0])throw new Error("last dimension of input and bias are not the same")},lA=i=>{let e=i[0].dims,t=i[0].dims[2],s=Ae.size(e)/4,r=i[0].dataType,n=Oe("input",r,e,4),o=Oe("bias",r,[t],4),a=Oe("residual",r,e,4),l=gt("output",r,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:u=>`
  const channels = ${t}u / 4;
  ${u.declareVariables(n,o,a,l)}

  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let value = ${n.getByOffset("global_idx")}
      + ${o.getByOffset("global_idx % channels")} + ${a.getByOffset("global_idx")};
    ${l.setByOffset("global_idx","value")}
  }`}},WF=i=>{aA(i.inputs),i.compute(lA(i.inputs))}}),uA,ms,HF,qF,KF,XF,YF,QF,ZF,JF,eR,cA,tR,sR,iR,rR,Dd,nR,Mf,oR,aR,lR,uR,cR,dR,hR,pR,fR,mR,gR,_R,yR,xR,bR,wR,F_,MR,Cx,Px,TR,vR,SR,dA,hA,ER,qb=Ze(()=>{kt(),Gt(),oi(),qt(),uA=(i,e,t,s,r,n,o)=>{let a=Math.ceil(e/4),l="";typeof r=="string"?l=`${r}(a)`:l=r("a");let u=Oe("inputData",t,[a],4),c=gt("outputData",s,[a],4),d=[{name:"vec_size",type:"u32"}];return o&&d.push(...o),`
      ${i.registerUniforms(d).declareVariables(u,c)}

  ${n??""}

  ${i.mainStart()}
    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${u.getByOffset("global_idx")};
    ${c.setByOffset("global_idx",l)}
  }`},ms=(i,e,t,s,r,n=i.dataType,o,a)=>{let l=[{type:12,data:Math.ceil(Ae.size(i.dims)/4)}];return o&&l.push(...o),{name:e,shaderCache:{hint:r,inputDependencies:["type"]},getShaderSource:u=>uA(u,Ae.size(i.dims),i.dataType,n,t,s,a),getRunData:u=>({outputs:[{dims:i.dims,dataType:n}],dispatchGroup:{x:Math.ceil(Ae.size(u[0].dims)/64/4)},programUniforms:l})}},HF=i=>{i.compute(ms(i.inputs[0],"Abs","abs"))},qF=i=>{i.compute(ms(i.inputs[0],"Acos","acos"))},KF=i=>{i.compute(ms(i.inputs[0],"Acosh","acosh"))},XF=i=>{i.compute(ms(i.inputs[0],"Asin","asin"))},YF=i=>{i.compute(ms(i.inputs[0],"Asinh","asinh"))},QF=i=>{i.compute(ms(i.inputs[0],"Atan","atan"))},ZF=i=>{i.compute(ms(i.inputs[0],"Atanh","atanh"))},JF=i=>Ms(i),eR=(i,e)=>{let t;switch(e.to){case 10:t="vec4<f16>";break;case 1:t="vec4<f32>";break;case 12:t="vec4<u32>";break;case 6:t="vec4<i32>";break;case 9:t="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}i.compute(ms(i.inputs[0],"Cast",t,void 0,e.cacheKey,e.to))},cA=i=>{let e,t,s=i.length>=2&&i[1].data!==0,r=i.length>=3&&i[2].data!==0;switch(i[0].dataType){case 1:e=s?i[1].getFloat32Array()[0]:-34028234663852886e22,t=r?i[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:e=s?i[1].getUint16Array()[0]:64511,t=r?i[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Ms({min:e,max:t})},tR=(i,e)=>{let t=e||cA(i.inputs),s=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"Clip",r=>`clamp(${r}, vec4<${s}>(uniforms.min), vec4<${s}>(uniforms.max))`,void 0,t.cacheKey,void 0,[{type:i.inputs[0].dataType,data:t.min},{type:i.inputs[0].dataType,data:t.max}],[{name:"min",type:s},{name:"max",type:s}]),{inputs:[0]})},sR=i=>{i.compute(ms(i.inputs[0],"Ceil","ceil"))},iR=i=>{i.compute(ms(i.inputs[0],"Cos","cos"))},rR=i=>{i.compute(ms(i.inputs[0],"Cosh","cosh"))},Dd=i=>Ms(i),nR=(i,e)=>{let t=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"Elu",s=>`elu_vf32(${s})`,`
  const elu_alpha_ = ${t}(${e.alpha});

  fn elu_f32(a: ${t}) -> ${t} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${t}>) -> vec4<${t}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},Mf=(i="f32")=>`
const r0: ${i} = 0.3275911;
const r1: ${i} = 0.254829592;
const r2: ${i} = -0.284496736;
const r3: ${i} = 1.421413741;
const r4: ${i} = -1.453152027;
const r5: ${i} = 1.061405429;

fn erf_vf32(v: vec4<${i}>) -> vec4<${i}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,oR=i=>{let e=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"Erf",t=>`erf_vf32(${t})`,Mf(e)))},aR=i=>{i.compute(ms(i.inputs[0],"Exp","exp"))},lR=i=>{i.compute(ms(i.inputs[0],"Floor","floor"))},uR=i=>{let e=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"Gelu",t=>`0.5 * ${t} * (1.0 + erf_vf32(${t} * 0.7071067811865475))`,Mf(e)))},cR=(i,e)=>{let t=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"LeakyRelu",s=>`select(leaky_relu_alpha_ * ${s}, ${s}, ${s} >= vec4<${t}>(0.0))`,`const leaky_relu_alpha_ = ${t}(${e.alpha});`,e.cacheKey))},dR=i=>{i.compute(ms(i.inputs[0],"Not",e=>`!${e}`))},hR=i=>{i.compute(ms(i.inputs[0],"Neg",e=>`-${e}`))},pR=i=>{i.compute(ms(i.inputs[0],"Reciprocal",e=>`1.0/${e}`))},fR=i=>{let e=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"Relu",t=>`select(vec4<${e}>(0.0), ${t}, ${t} > vec4<${e}>(0.0))`))},mR=i=>{i.compute(ms(i.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},gR=i=>Ms(i),_R=(i,e)=>{let t=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"HardSigmoid",s=>`max(vec4<${t}>(0.0), min(vec4<${t}>(1.0), ${e.alpha} * ${s} + vec4<${t}>(${e.beta})))`,void 0,e.cacheKey))},yR=i=>{i.compute(ms(i.inputs[0],"Sin","sin"))},xR=i=>{i.compute(ms(i.inputs[0],"Sinh","sinh"))},bR=i=>{i.compute(ms(i.inputs[0],"Sqrt","sqrt"))},wR=i=>{i.compute(ms(i.inputs[0],"Tan","tan"))},F_=i=>`sign(${i}) * (1 - exp(-2 * abs(${i}))) / (1 + exp(-2 * abs(${i})))`,MR=i=>{i.compute(ms(i.inputs[0],"Tanh",F_))},Cx=(i="f32")=>`
const fast_gelu_a: ${i} = 0.5;
const fast_gelu_b: ${i} = 0.7978845608028654;
const fast_gelu_c: ${i} = 0.035677408136300125;

fn tanh_v(v: vec4<${i}>) -> vec4<${i}> {
  return ${F_("v")};
}
`,Px=i=>`(fast_gelu_a + fast_gelu_a * tanh_v(${i} * (fast_gelu_c * ${i} * ${i} + fast_gelu_b))) * ${i}`,TR=i=>{let e=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"FastGelu",Px,Cx(e),void 0,i.inputs[0].dataType))},vR=(i,e)=>{let t=or(i.inputs[0].dataType);return i.compute(ms(i.inputs[0],"ThresholdedRelu",s=>`select(vec4<${t}>(0.0), ${s}, ${s} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${t}>(${e.alpha});`,e.cacheKey)),0},SR=i=>{i.compute(ms(i.inputs[0],"Log","log"))},dA=(i,e)=>`
const alpha = vec4<${i}>(${e});
const one = ${i}(1.0);
const zero = ${i}(0.0);

fn quick_gelu_impl(x: vec4<${i}>) -> vec4<${i}> {
  let v = x *alpha;
  var x1 : vec4<${i}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,hA=i=>`quick_gelu_impl(${i})`,ER=(i,e)=>{let t=or(i.inputs[0].dataType);i.compute(ms(i.inputs[0],"QuickGelu",hA,dA(t,e.alpha),e.cacheKey,i.inputs[0].dataType))}}),pA,fA,AR,uz=Ze(()=>{Gt(),qt(),qb(),pA=i=>{if(i[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(i[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(i[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(i[0].dims[2]!==i[1].dims[0])throw new Error("last dimension of input and bias are not the same")},fA=i=>{let e=i[0].dims.slice();e[2]=e[2]/2;let t=Oe("input",i[0].dataType,i[0].dims,4),s=Oe("bias",i[0].dataType,[i[0].dims[2]],4),r=gt("output",i[0].dataType,e,4),n=Ae.size(e)/4,o=Ui(i[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:a=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${i[0].dims[2]/4/2}u;

  ${a.declareVariables(t,s,r)}

  ${Mf(o)}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes(n)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${r.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},AR=i=>{pA(i.inputs),i.compute(fA(i.inputs))}}),mA,gA,Dn,CR,PR,NR,FR,RR,IR,DR,kR,LR,BR,cz=Ze(()=>{kt(),Gt(),qt(),mA=(i,e,t,s,r,n,o,a,l,u,c,d)=>{let h,p;typeof a=="string"?h=p=(_,S)=>`${a}((${_}),(${S}))`:typeof a=="function"?h=p=a:(h=a.scalar,p=a.vector);let f=gt("outputData",c,s.length,4),m=Oe("aData",l,e.length,4),x=Oe("bData",u,t.length,4),g;if(r)if(n){let _=Ae.size(e)===1,S=Ae.size(t)===1,M=e.length>0&&e[e.length-1]%4===0,w=t.length>0&&t[t.length-1]%4===0;_||S?g=f.setByOffset("global_idx",p(_?`${m.type.value}(${m.getByOffset("0")}.x)`:m.getByOffset("global_idx"),S?`${x.type.value}(${x.getByOffset("0")}.x)`:x.getByOffset("global_idx"))):g=`
            let outputIndices = ${f.offsetToIndices("global_idx * 4u")};
            let offsetA = ${m.broadcastedIndicesToOffset("outputIndices",f)};
            let offsetB = ${x.broadcastedIndicesToOffset("outputIndices",f)};
            ${f.setByOffset("global_idx",p(o||M?m.getByOffset("offsetA / 4u"):`${m.type.value}(${m.getByOffset("offsetA / 4u")}[offsetA % 4u])`,o||w?x.getByOffset("offsetB / 4u"):`${x.type.value}(${x.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else g=f.setByOffset("global_idx",p(m.getByOffset("global_idx"),x.getByOffset("global_idx")));else{if(!n)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let _=(S,M,w="")=>{let v=`aData[indexA${M}][componentA${M}]`,T=`bData[indexB${M}][componentB${M}]`;return`
            let outputIndices${M} = ${f.offsetToIndices(`global_idx * 4u + ${M}u`)};
            let offsetA${M} = ${m.broadcastedIndicesToOffset(`outputIndices${M}`,f)};
            let offsetB${M} = ${x.broadcastedIndicesToOffset(`outputIndices${M}`,f)};
            let indexA${M} = offsetA${M} / 4u;
            let indexB${M} = offsetB${M} / 4u;
            let componentA${M} = offsetA${M} % 4u;
            let componentB${M} = offsetB${M} % 4u;
            ${S}[${M}] = ${w}(${h(v,T)});
          `};c===9?g=`
            var data = vec4<u32>(0);
            ${_("data",0,"u32")}
            ${_("data",1,"u32")}
            ${_("data",2,"u32")}
            ${_("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:g=`
            ${_("outputData[global_idx]",0)}
            ${_("outputData[global_idx]",1)}
            ${_("outputData[global_idx]",2)}
            ${_("outputData[global_idx]",3)}
          `}return`
        ${i.registerUniform("vec_size","u32").declareVariables(m,x,f)}

        ${d??""}

        ${i.mainStart()}
        ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${g}
      }`},gA=(i,e,t,s,r,n,o=t.dataType)=>{let a=t.dims.map(m=>Number(m)??1),l=s.dims.map(m=>Number(m)??1),u=!Ae.areEqual(a,l),c=a,d=Ae.size(a),h=!1,p=!1,f=[u];if(u){let m=hc.calcShape(a,l,!1);if(!m)throw new Error("Can't perform binary op on the given tensors");c=m.slice(),d=Ae.size(c);let x=Ae.size(a)===1,g=Ae.size(l)===1,_=a.length>0&&a[a.length-1]%4===0,S=l.length>0&&l[l.length-1]%4===0;f.push(x),f.push(g),f.push(_),f.push(S);let M=1;for(let w=1;w<c.length;w++){let v=a[a.length-w],T=l[l.length-w];if(v===T)M*=v;else break}M%4===0?(p=!0,h=!0):(x||g||_||S)&&(h=!0)}else h=!0;return f.push(h),{name:i,shaderCache:{hint:e+f.map(m=>m.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:m=>mA(m,a,l,c,h,u,p,r,t.dataType,s.dataType,o,n),getRunData:()=>({outputs:[{dims:c,dataType:o}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:Math.ceil(Ae.size(c)/4)},...Tt(a,l,c)]})}},Dn=(i,e,t,s,r,n)=>{i.compute(gA(e,r??"",i.inputs[0],i.inputs[1],t,s,n))},CR=i=>{Dn(i,"Add",(e,t)=>`${e}+${t}`)},PR=i=>{Dn(i,"Div",(e,t)=>`${e}/${t}`)},NR=i=>{Dn(i,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},FR=i=>{Dn(i,"Mul",(e,t)=>`${e}*${t}`)},RR=i=>{let e=Oe("input",i.inputs[0].dataType,i.inputs[0].dims).type.value;Dn(i,"Pow",{scalar:(t,s)=>`pow_custom(${t},${s})`,vector:(t,s)=>`pow_vector_custom(${t},${s})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},IR=i=>{Dn(i,"Sub",(e,t)=>`${e}-${t}`)},DR=i=>{Dn(i,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},kR=i=>{Dn(i,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},LR=i=>{Dn(i,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},BR=i=>{Dn(i,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}}),_A,yA,xA,bA,OR,$R,dz=Ze(()=>{kt(),Gt(),oi(),qt(),_A=(i,e)=>{if(!i||i.length<1)throw new Error("too few inputs");let t=0,s=i[t],r=s.dataType,n=s.dims.length;i.forEach((o,a)=>{if(a!==t){if(o.dataType!==r)throw new Error("input tensors should be one type");if(o.dims.length!==n)throw new Error("input tensors should have the same shape");o.dims.forEach((l,u)=>{if(u!==e&&l!==s.dims[u])throw new Error("non concat dimensions must match")})}})},yA=(i,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${i}u>(${e});
    for (var i: u32 = 0u; i < ${i}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${i}u;
  }`,xA=(i,e)=>{let t=i.length,s=[];for(let r=0;r<t;++r){let n=e.setByOffset("global_idx",i[r].getByIndices("indices"));t===1?s.push(n):r===0?s.push(`if (inputIndex == ${r}u) { ${n} }`):r===t-1?s.push(`else { ${n} }`):s.push(`else if (inputIndex == ${r}) { ${n} }`)}return s.join(`
`)},bA=(i,e,t,s)=>{let r=Ae.size(t),n=new Array(i.length),o=new Array(i.length),a=0,l=[],u=[],c=[{type:12,data:r}];for(let m=0;m<i.length;++m)a+=i[m].dims[e],n[m]=a,u.push(i[m].dims.length),o[m]=Oe(`input${m}`,s,u[m]),l.push("rank"),c.push({type:12,data:n[m]});for(let m=0;m<i.length;++m)c.push(...Tt(i[m].dims));c.push(...Tt(t));let d=gt("output",s,t.length),h=d.indicesGet("indices",e),p=Array.from(Array(n.length).keys()).map(m=>`uniforms.sizeInConcatAxis${m}`).join(","),f=m=>`

  ${(()=>{m.registerUniform("outputSize","u32");for(let x=0;x<i.length;x++)m.registerUniform(`sizeInConcatAxis${x}`,"u32");return m.declareVariables(...o,d)})()}

  ${yA(n.length,p)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${d.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${h});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${n.length}u>(${p});
      ${h} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${xA(o,d)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:t,dataType:s}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:c}),getShaderSource:f}},OR=(i,e)=>{let t=i.inputs,s=t[0].dims,r=Ae.normalizeAxis(e.axis,s.length);_A(t,r);let n=s.slice();n[r]=t.reduce((a,l)=>a+(l.dims.length>r?l.dims[r]:0),0);let o=t.filter(a=>Ae.size(a.dims)>0);i.compute(bA(o,r,n,t[0].dataType),{inputs:o})},$R=i=>Ms({axis:i.axis})}),ql,Kl,Xl,Kb,Jl=Ze(()=>{kt(),Gt(),ql=(i,e,t="f32")=>{switch(i.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${t}(uniforms.clip_min)), ${e}(${t}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${t}(uniforms.alpha) * value + ${t}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${t}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${i.activation}`)}},Kl=(i,e)=>{i.activation==="Clip"?e.push({type:1,data:i.clipMax},{type:1,data:i.clipMin}):i.activation==="HardSigmoid"?e.push({type:1,data:i.alpha},{type:1,data:i.beta}):i.activation==="LeakyRelu"&&e.push({type:1,data:i.alpha})},Xl=(i,e)=>{i.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):i.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):i.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},Kb=i=>{let e=(i==null?void 0:i.activation)||"";if(e==="HardSigmoid"){let[t,s]=(i==null?void 0:i.activation_params)||[.2,.5];return{activation:e,alpha:t,beta:s}}else if(e==="Clip"){let[t,s]=(i==null?void 0:i.activation_params)||[dF,hF];return{activation:e,clipMax:s,clipMin:t}}else if(e==="LeakyRelu"){let[t]=(i==null?void 0:i.activation_params)||[.01];return{activation:e,alpha:t}}return{activation:e}}}),qi,zR,Xb=Ze(()=>{qi=(i,e)=>{switch(i){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${i}-component is not supported.`)}},zR=i=>`
      ${i?"value = value + getBiasByOutputCoords(coords);":""}
      `}),VR,hz=Ze(()=>{VR=i=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${i}.x), i32(${i}.y), i32(${i}.z), 1));
}
`}),$d,Yb,Qb=Ze(()=>{kt(),Gt(),qt(),Jl(),$d=(i,e,t,s,r)=>{let n=s-t;return`
      ${Array.from({length:t}).map((o,a)=>`
      if (${xt(e.shape,a,e.rank)} != 1) {
        ${e.indicesSet(i,a,xt(r,a+n,s))}
      } else {
        ${e.indicesSet(i,a,0)}
      }`).join("")}
`},Yb=(i,e,t,s,r=!1,n)=>{let o=i[0].dims,a=i[1].dims,l=o[o.length-2],u=a[a.length-1],c=o[o.length-1],d=Js(u),h=Js(c),p=Js(l),f=Ae.size(t)/d/p,m=i.length>2,x=s?s.slice(0,-2):t.slice(0,-2),g=[Ae.size(x),l,u],_=[{type:12,data:f},{type:12,data:l},{type:12,data:u},{type:12,data:c}];Kl(e,_),_.push(...Tt(x,o,a)),m&&_.push(...Tt(i[2].dims)),_.push(...Tt(g));let S=M=>{let w=jb("batch_dims",i[0].dataType,x.length),v=Oe("a",i[0].dataType,o.length,h),T=Oe("b",i[1].dataType,a.length,d),E=gt("output",i[0].dataType,g.length,d),F=Ui(E.type.tensor),I=ql(e,E.type.value,F),z=[v,T],G="";if(m){let q=r?d:1;z.push(Oe("bias",i[2].dataType,i[2].dims.length,q)),G=`${r?`value += bias[col / ${q}];`:`value += ${E.type.value}(bias[row + i]);`}`}let L=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Xl(e,L);let Q=()=>{let q=`var a_data: ${v.type.value};`;for(let J=0;J<h;J++)q+=`
              let b_data${J} = b[(b_offset + (k + ${J}) * uniforms.N + col) / ${d}];`;for(let J=0;J<p;J++){q+=`a_data = a[(a_offset + (row + ${J}) * uniforms.K + k) / ${h}];`;for(let ee=0;ee<h;ee++)q+=`
            values[${J}] = fma(${T.type.value}(a_data${h===1?"":`[${ee}]`}), b_data${ee}, values[${J}]);
`}return q};return`
  ${M.registerUniforms(L).registerInternalVariables(w).declareVariables(...z,E)}
  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${d})) * ${d};
    var index1 = global_idx / (uniforms.N / ${d});
    let stride1 = uniforms.M / ${p};
    let row = (index1 % stride1) * ${p};
    let batch = index1 / stride1;

    ${t.length===2?"":`let batch_indices = ${w.offsetToIndices("batch")};`}

    var a_indices: ${v.type.indices};
    ${$d("a_indices",v,v.rank-2,w.rank,"batch_indices")}
    ${v.indicesSet("a_indices",v.rank-2,0)}
    ${v.indicesSet("a_indices",v.rank-1,0)}
    let a_offset = ${v.indicesToOffset("a_indices")};

    var b_indices: ${T.type.indices};
    ${$d("b_indices",T,T.rank-2,w.rank,"batch_indices")}
    ${T.indicesSet("b_indices",T.rank-2,0)}
    ${T.indicesSet("b_indices",T.rank-1,0)}
    let b_offset = ${T.indicesToOffset("b_indices")};
    var values: array<${E.type.value}, ${p}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {
      ${Q()}
    }
    for (var i = 0u; i < ${p}u; i++) {
      var value = values[i];
      ${G}
      ${I}
      let cur_indices = ${E.type.indices}(batch, row + i, col);
      let offset = ${E.indicesToOffset("cur_indices")};
      ${E.setByOffset(`offset / ${d}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${d};${h};${p};${r}`,inputDependencies:m?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:n?n(t):t,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:_}),getShaderSource:S}}}),wA,MA,Nx,R_,TA,Fx,vA,$f,Zb=Ze(()=>{kt(),Gt(),qt(),Jl(),Qb(),Xb(),wA=(i,e)=>i?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,MA=(i,e)=>i?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Nx=(i,e,t="f32",s,r=!1,n=32,o=!1,a=32)=>{let l=e[1]*i[1],u=e[0]*i[0],c=r?l:n,d=r?n:l,h=c/e[0],p=n/e[1];if(!((r&&h===4&&i[1]===4||!r&&(h===3||h===4))&&c%e[0]===0&&n%e[1]===0&&i[0]===4))throw new Error(`If transposeA ${r} is true, innerElementSize ${h} and workPerThread[1] ${i[1]} must be 4.
      Otherwise, innerElementSize ${h} must be 3 or 4.
  tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${n} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${i[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${h}<${t}>, ${c/h}>, ${d}>;
var<workgroup> mm_Bsub: array<array<vec4<${t}>, ${u/i[0]}>, ${n}>;

const rowPerThread = ${i[1]};
const colPerThread = ${i[0]};
const innerElementSize = ${h};
const tileInner = ${n};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${o?"0":"i32(globalId.z)"};
  ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${l};

  let num_tiles = ${o?`${Math.ceil(a/n)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${o?`i32(globalId.z) * ${a}`:"0"};

  var acc: array<vec4<${t}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${p};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${wA(r,s)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${s?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${h===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${MA(r,h)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},R_=(i,e)=>i?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,TA=i=>i?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Fx=(i,e,t="f32",s,r=!1,n=32,o=!1,a=32,l=!1)=>{let u=i[1]*e[1],c=i[0]*e[0],d=r?u:n,h=r?n:u;if(!(h%e[1]===0&&d%e[0]===0&&n%e[1]===0))throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}, tileInner ${n} must be divisible by workgroupSize[1]${e[1]}`);let p=h/e[1],f=d/e[0],m=n/e[1],x=l?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${u};
    let globalColStart = i32(workgroupId.x) * ${c};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
          ${R_(r,s)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${s?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${t}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${u};

let tileRowA = i32(localId.y) * ${p};
let tileColA = i32(localId.x) * ${f};
let tileRowB = i32(localId.y) * ${m};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${R_(r,s)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${s?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${t}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${TA(r)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${t}, ${d}>, ${h}>;
  var<workgroup> mm_Bsub : array<array<${t}, ${c}>, ${n}>;
  const rowPerThread = ${i[1]};
  const colPerThread = ${i[0]};
  const tileInner = ${n};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${o?"0":"i32(globalId.z)"};
    ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${o?`${Math.ceil(a/n)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${a}`:"0"};

    var acc : array<array<${t}, colPerThread>, rowPerThread>;
    ${x}
  }
`},vA=(i,e,t,s,r=!1)=>{let[n,o,a,l]=s,u=Ui(s[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${n.type.indices}) -> ${qi(i,u)} {
      var value = ${qi(i,u)}(0.0);
      let col = colIn * ${i};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${o.type.indices};
        ${$d("aIndices",o,o.rank-2,n.rank,"batchIndices")}
        ${o.indicesSet("aIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("aIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${n.type.indices}) -> ${qi(i,u)} {
      var value = ${qi(i,u)}(0.0);
      let col = colIn * ${i};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${a.type.indices};
        ${$d("bIndices",a,a.rank-2,n.rank,"batchIndices")}
        ${a.indicesSet("bIndices",a.rank-2,"u32(row)")}
        ${a.indicesSet("bIndices",a.rank-1,"u32(colIn)")}
        value = ${a.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${qi(i,u)}) {
      let col = colIn * ${i};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${r?"bias[colIn]":`${qi(i,u)}(bias[row])`};`:""}
        ${t}
        ${l.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},$f=(i,e,t,s,r=!1,n)=>{let o=i[0].dims,a=i[1].dims,l=o.slice(0,-2),u=a.slice(0,-2),c=s?s.slice(0,-2):t.slice(0,-2),d=Ae.size(c),h=o[o.length-2],p=o[o.length-1],f=a[a.length-1],m=p%4===0&&f%4===0,x=h<=8?[4,1,1]:[4,4,1],g=[8,8,1],_=[Math.ceil(f/g[0]/x[0]),Math.ceil(h/g[1]/x[1]),Math.ceil(d/g[2]/x[2])],S=m?4:1,M=[...l,h,p/S],w=M.length,v=[...u,p,f/S],T=v.length,E=[d,h,f/S],F=[{type:6,data:h},{type:6,data:f},{type:6,data:p}];Kl(e,F),F.push(...Tt(c,M,v));let I=["rank","rank"],z=i.length>2;z&&(F.push(...Tt(i[2].dims)),I.push("rank")),F.push(...Tt(E));let G=L=>{let Q=c.length,q=jb("batchDims",i[0].dataType,Q,1),J=Ui(i[0].dataType),ee=Oe("a",i[0].dataType,w,S),se=Oe("b",i[1].dataType,T,S),fe=gt("result",i[0].dataType,E.length,S),ue=[ee,se];if(z){let we=r?S:1;ue.push(Oe("bias",i[2].dataType,i[2].dims.length,we))}let U=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Xl(e,U);let k=Ui(fe.type.tensor),j=ql(e,fe.type.value,k),re=vA(S,z,j,[q,ee,se,fe],r);return`
  ${L.registerUniforms(U).registerInternalVariables(q).declareVariables(...ue,fe)}
  ${re}
  ${m?Nx(x,g,J,q):Fx(x,g,J,q)}
                   `};return{name:"MatMul",shaderCache:{hint:`${x};${e.activation};${m};${r}`,inputDependencies:I},getRunData:()=>({outputs:[{dims:n?n(t):t,dataType:i[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]},programUniforms:F}),getShaderSource:G}}}),SA,UR,pz=Ze(()=>{kt(),na(),qt(),Jl(),Xb(),hz(),Zb(),SA=(i,e,t,s,r=!1,n,o=4,a=4,l=4,u="f32")=>{let c=F=>{switch(F){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${F} is not supported.`)}},d=F=>{switch(F){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${F} is not supported.`)}},h=i?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,p=i?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,f=i?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",m=i?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",x=i?"row":"col",g=i?"col":"row",_=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${i?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${x} / outWidth;
    let outCol = ${x} % outWidth;

    let WRow = ${g} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${g} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${g} % inChannels;
    var resData = ${qi(o,u)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${m}) {
      ${h}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${c(o)}
    }
    return resData;`,S=i?e&&s?`
    let col = colIn * ${o};
    ${_}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${_}
    }
    return ${qi(o,u)}(0.0);`:s&&t?`
    let col = colIn * ${o};
    ${_}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${_}
    }
    return ${qi(o,u)}(0.0);`,M=i?s&&t?d(a):`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${d(a)}
    }
    return ${qi(a,u)}(0.0);`:`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${d(a)}
    }
    return ${qi(a,u)}(0.0);`,w=qi(l,u),v=qi(i?o:a,u),T=qi(i?a:o,u),E=ql(n,w,u);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${v} {
      ${i?S:M}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${T} {
      ${i?M:S}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {
      let col = colIn * ${l};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${i?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${p}
      ${zR(r)}
      ${E}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},UR=(i,e,t,s,r,n,o,a,l)=>{let u=e.format==="NHWC",c=u?i[0].dims[3]:i[0].dims[1],d=t[0],h=u?t[2]:t[3],p=u?t[1]:t[2],f=u?t[3]:t[1],m=u&&(c%4===0||c%3===0)&&f%4===0,x=u?f:h*p,g=u?h*p:f,_=[8,8,1],S=s<=8?[4,1,1]:[4,4,1],M=[Math.ceil(x/_[0]/S[0]),Math.ceil(g/_[1]/S[1]),Math.ceil(d/_[2]/S[2])];ls("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${M}`);let w=m?u&&c%4!==0?3:4:1,v=_[1]*S[1],T=_[0]*S[0],E=Math.max(_[0]*w,_[1]),F=s%v===0,I=r%T===0,z=n%E===0,G=m?[w,4,4]:[1,1,1],L=[{type:6,data:s},{type:6,data:r},{type:6,data:n},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];Kl(e,L),L.push(...Tt(i[0].dims,i[1].dims));let Q=["rank","rank"];o&&(L.push(...Tt(i[2].dims)),Q.push("rank")),L.push(...Tt(t));let q=J=>{let ee=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Xl(e,ee);let se=m?4:1,fe=Ui(i[0].dataType),ue=`
      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${fe}>`:fe}) {
        result[flatIndex] = ${m?`vec4<${fe}>`:fe}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${fe}>`:fe}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${m?"/ 4":""}, value);
      }`,U=Oe("x",i[0].dataType,i[0].dims.length,w===3?1:w),k=Oe("w",i[1].dataType,i[1].dims.length,se),j=[U,k],re=gt("result",i[0].dataType,t.length,se);if(o){let we=Oe("bias",i[2].dataType,i[2].dims.length,se);j.push(we),ue+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${fe}>`:fe} {
          return bias[coords.${u?"w":"y"}${m?"/ 4":""}];
        }`}return`
        ${VR("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${J.registerUniforms(ee).declareVariables(...j,re)}
        ${ue}
        ${SA(u,F,I,z,o,e,G[0],G[1],G[2],fe)}
        ${m?Nx(S,_,fe,void 0,!u,E):Fx(S,_,fe,void 0,!u,E,!1,void 0,a)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${w};${m};${F};${I};${z};${v};${T};${E}`,inputDependencies:Q},getRunData:()=>({outputs:[{dims:l?l(t):t,dataType:i[0].dataType}],dispatchGroup:{x:M[0],y:M[1],z:M[2]},programUniforms:L}),getShaderSource:q}}}),EA,I_,od,AA,D_,CA,GR,jR,fz=Ze(()=>{kt(),na(),Gt(),qt(),Jl(),Xb(),EA=i=>{let e=1;for(let t=0;t<i.length;t++)e*=i[t];return e},I_=i=>typeof i=="number"?[i,i,i]:i,od=(i,e)=>e<=1?i:i+(i-1)*(e-1),AA=(i,e,t,s=1)=>{let r=od(e,s);return Math.floor((i[0]*(t-1)-t+r)/2)},D_=(i,e,t,s,r)=>{r==null&&(r=AA(i,e[0],s[0]));let n=[0,0,0,t];for(let o=0;o<3;o++)i[o]+2*r>=e[o]&&(n[o]=Math.trunc((i[o]-e[o]+2*r)/s[o]+1));return n},CA=(i,e,t,s,r,n,o,a,l,u)=>{let c,d,h,p;if(i==="VALID"&&(i=0),typeof i=="number"){c={top:i,bottom:i,left:i,right:i,front:i,back:i};let f=D_([e,t,s,1],[a,l,u],1,[r,n,o],i);d=f[0],h=f[1],p=f[2]}else if(Array.isArray(i)){if(!i.every((m,x,g)=>m===g[0]))throw Error(`Unsupported padding parameter: ${i}`);c={top:i[0],bottom:i[1],left:i[2],right:i[3],front:i[4],back:i[5]};let f=D_([e,t,s,1],[a,l,u],1,[r,n,o],i[0]);d=f[0],h=f[1],p=f[2]}else if(i==="SAME_UPPER"){d=Math.ceil(e/r),h=Math.ceil(t/n),p=Math.ceil(s/o);let f=(d-1)*r+a-e,m=(h-1)*n+l-t,x=(p-1)*o+u-s,g=Math.floor(f/2),_=f-g,S=Math.floor(m/2),M=m-S,w=Math.floor(x/2),v=x-w;c={top:S,bottom:M,left:w,right:v,front:g,back:_}}else throw Error(`Unknown padding parameter: ${i}`);return{padInfo:c,outDepth:d,outHeight:h,outWidth:p}},GR=(i,e,t,s,r,n=!1,o="channelsLast")=>{let a,l,u,c,d;if(o==="channelsLast")[a,l,u,c,d]=i;else if(o==="channelsFirst")[a,d,l,u,c]=i;else throw new Error(`Unknown dataFormat ${o}`);let[h,,p,f,m]=e,[x,g,_]=I_(t),[S,M,w]=I_(s),v=od(p,S),T=od(f,M),E=od(m,w),{padInfo:F,outDepth:I,outHeight:z,outWidth:G}=CA(r,l,u,c,x,g,_,v,T,E),L=n?h*d:h,Q=[0,0,0,0,0];return o==="channelsFirst"?Q=[a,L,I,z,G]:o==="channelsLast"&&(Q=[a,I,z,G,L]),{batchSize:a,dataFormat:o,inDepth:l,inHeight:u,inWidth:c,inChannels:d,outDepth:I,outHeight:z,outWidth:G,outChannels:L,padInfo:F,strideDepth:x,strideHeight:g,strideWidth:_,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:v,effectiveFilterHeight:T,effectiveFilterWidth:E,dilationDepth:S,dilationHeight:M,dilationWidth:w,inShape:i,outShape:Q,filterShape:e}},jR=(i,e,t,s,r,n)=>{let o=n==="channelsLast";o?i[0].dims[3]:i[0].dims[1];let a=[64,1,1],l={x:t.map((x,g)=>g)},u=[Math.ceil(EA(l.x.map(x=>t[x]))/a[0]),1,1];ls("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let c=1,d=Ae.size(t),h=[{type:12,data:d},{type:12,data:s},{type:12,data:r},{type:12,data:e.strides},{type:12,data:e.dilations}];Kl(e,h),h.push(...Tt(i[0].dims,i[1].dims));let p=["rank","rank"],f=i.length===3;f&&(h.push(...Tt(i[2].dims)),p.push("rank")),h.push(...Tt(t));let m=x=>{let g=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:s.length},{name:"pads",type:"u32",length:r.length},{name:"strides",type:"u32",length:e.strides.length},{name:"dilations",type:"u32",length:e.dilations.length}];Xl(e,g);let _=1,S=Ui(i[0].dataType),M=Oe("x",i[0].dataType,i[0].dims.length,c),w=Oe("W",i[1].dataType,i[1].dims.length,_),v=[M,w],T=gt("result",i[0].dataType,t.length,_),E="";if(f){let z=Oe("bias",i[2].dataType,i[2].dims.length,_);v.push(z),E+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${S} {
          return bias[${o?xt("coords",4,5):xt("coords",1,5)}];
        }`}let F=qi(c,S),I=ql(e,F,S);return`
            ${E}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${M.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${x.registerUniforms(g).declareVariables(...v,T)}
          ${x.mainStart()}
          ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${T.offsetToIndices("global_idx")};
              let batch = ${xt("coords",0,M.rank)};
              let d2 = ${o?xt("coords",M.rank-1,M.rank):xt("coords",1,M.rank)};
              let xFRCCorner = vec3<u32>(${o?xt("coords",1,M.rank):xt("coords",2,M.rank)},
              ${o?xt("coords",2,M.rank):xt("coords",3,M.rank)},
              ${o?xt("coords",3,M.rank):xt("coords",4,M.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${o?xt("uniforms.x_shape",1,M.rank):xt("uniforms.x_shape",2,M.rank)};
              let xShapeZ = ${o?xt("uniforms.x_shape",2,M.rank):xt("uniforms.x_shape",3,M.rank)};
              let xShapeW = ${o?xt("uniforms.x_shape",3,M.rank):xt("uniforms.x_shape",4,M.rank)};
              let xShapeU = ${o?xt("uniforms.x_shape",4,M.rank):xt("uniforms.x_shape",1,M.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${o?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${o?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${o?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${o?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${f?"value = value + getBiasByOutputCoords(coords)":""};
              ${I}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${e.cacheKey};${o};${c};${f}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:t,dataType:i[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:h}),getShaderSource:m}}}),WR,HR,mz=Ze(()=>{kt(),Gt(),qt(),Jl(),WR=(i,e,t,s)=>{let r=i.length>2,n=r?"value += b[output_channel];":"",o=i[0].dims,a=i[1].dims,l=e.format==="NHWC",u=l?t[3]:t[1],c=u/e.group,d=l&&c>=4?Js(u):1,h=Ae.size(t)/d,p=[{type:12,data:h},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:c}];Kl(e,p),p.push(...Tt(o,[a[0],a[1],a[2],a[3]/d]));let f=r?["rank","rank","rank"]:["rank","rank"];p.push(...Tt([t[0],t[1],t[2],t[3]/d]));let m=x=>{let g=gt("output",i[0].dataType,t.length,d),_=Ui(g.type.tensor),S=ql(e,g.type.value,_),M=Oe("x",i[0].dataType,o.length),w=Oe("w",i[1].dataType,a.length,d),v=[M,w];r&&v.push(Oe("b",i[2].dataType,i[2].dims,d));let T=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Xl(e,T);let E=l?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${M.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${w.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${M.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${w.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${x.registerUniforms(T).declareVariables(...v,g)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${g.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${l?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${d} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];

    var value: ${g.type.value} = ${g.type.value}(0);
    ${E}
    ${n}
    ${S}
    ${g.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${e.cacheKey}_${d}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:s?s(t):t,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:p}),getShaderSource:m}},HR=(i,e,t,s)=>{let r=i.length>2,n=Js(t[3]),o=Js(t[2]),a=Ae.size(t)/n/o,l=[i[0].dims[0],i[0].dims[1],i[0].dims[2],i[0].dims[3]/n],u=[i[1].dims[0],i[1].dims[1],i[1].dims[2],i[1].dims[3]/n],c=[t[0],t[1],t[2],t[3]/n],d=[{type:12,data:a},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];Kl(e,d),d.push(...Tt(l,u,c));let h=(o-1)*e.strides[1]+u[1],p=f=>{let m=gt("output",i[0].dataType,c.length,n),x=Ui(m.type.tensor),g=ql(e,m.type.value,x),_=Oe("x",i[0].dataType,l.length,n),S=Oe("w",i[1].dataType,u.length,n),M=[_,S];r&&M.push(Oe("b",i[2].dataType,i[2].dims,n));let w=r?"value += b[output_channel];":"",v=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Xl(e,v),`
  ${f.registerUniforms(v).declareVariables(...M,m)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${o}u;
    let col = (index1 % width1) * ${o}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${_.type.value}, ${h}>;
    var values: array<${m.type.value}, ${o}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${h}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${_.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${_.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {
          let w_val = ${S.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${o}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${o}u; i++) {
      var value = values[i];
      ${w}
      ${g}
      ${m.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${n};${o};${h};${u[0]};${u[1]}`,inputDependencies:r?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s?s(t):t,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:d}),getShaderSource:p}}}),PA,Ap,NA,Cp,Rx,k_,FA,RA,Ix,gz=Ze(()=>{Gt(),pz(),fz(),Zb(),mz(),Jl(),Qb(),Va(),PA=(i,e,t,s,r,n)=>{let o=i[0],a=i.slice(n?1:2,n?3:4),l=a.length,u=e[0],c=e.slice(2).map((h,p)=>h+(h-1)*(t[p]-1)),d=a.map((h,p)=>h+s[p]+s[p+l]).map((h,p)=>Math.floor((h-c[p]+r[p])/r[p]));return d.splice(0,0,o),d.splice(n?3:1,0,u),d},Ap=[2,3,1,0],NA=(i,e)=>{if(!i||i.length!==2&&i.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(i[0].dims.length>5)throw new Error("greater than 5D is not supported");if(i[0].dims.length!==i[1].dims.length)throw new Error("filter does not have same dimension as input");let t=i[0].dims[e.format==="NHWC"?i[0].dims.length-1:1],s=i[1].dims[1]*e.group;if(t!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(i.length===3&&(i[2].dims.length!==1||i[1].dims[0]!==i[2].dims[0]))throw new Error("invalid bias");let r=i[0].dims.length-2;if(e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.length!==r*2)throw new Error(`pads should be ${r*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==i[1].dims.length-2)throw new Error("invalid kernel shape")},Cp=(i,e)=>{let t=i.kernelShape.slice();t.length<e[1].dims.length-2&&t.push(...Array(e[1].dims.length-2-t.length).fill(0));for(let n=2;n<e[1].dims.length;++n)t[n-2]===0&&(t[n-2]=e[1].dims[n]);let s=i.pads.slice();Bf.adjustPadsBasedOnAutoPad(e[0].dims,i.strides,i.dilations,t,s,i.format==="NHWC",i.autoPad);let r=Object.assign({},i);return Object.assign(r,{kernelShape:t,pads:s}),r},Rx=i=>{let e=Kb(i),t=i.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][i.auto_pad],r=i.dilations,n=i.group,o=i.kernel_shape,a=i.pads,l=i.strides,u=i.w_is_const();return{autoPad:s,format:t,dilations:r,group:n,kernelShape:o,pads:a,strides:l,wIsConst:u,...e,cacheKey:`${i.format};${e.activation};`}},k_=(i,e,t,s)=>{let r=t.format==="NHWC",n=PA(e[0].dims,e[1].dims,t.dilations,t.pads,t.strides,r);if(t.group!==1){let v=[e[0]];if(r){let T=i.kernelCustomData.wT??i.compute(Xr(e[1],Ap),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!i.kernelCustomData.wT&&(i.kernelCustomData.wT=T),v.push(T)}else v.push(e[1]);e.length===3&&v.push(e[2]),!i.adapterInfo.isArchitecture("ampere")&&r&&e[1].dims[0]===t.group&&e[1].dims[1]===1&&t.dilations[0]===1&&t.dilations[1]===1?i.compute(HR(v,t,n,s),{inputs:v}):i.compute(WR(v,t,n,s),{inputs:v});return}let o=e.length===3,a=e[0].dims[r?1:2],l=e[0].dims[r?2:3],u=e[0].dims[r?3:1],c=e[1].dims[2],d=e[1].dims[3],h=n[r?1:2],p=n[r?2:3],f=n[r?3:1],m=r&&c===a&&d===l&&t.pads[0]===0&&t.pads[1]===0;if(m||c===1&&d===1&&t.dilations[0]===1&&t.dilations[1]===1&&t.strides[0]===1&&t.strides[1]===1&&t.pads[0]===0&&t.pads[1]===0){let v=n[0],T,E,F,I=[];if(r){let L=i.kernelCustomData.wT??i.compute(Xr(e[1],Ap),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];if(t.wIsConst&&!i.kernelCustomData.wT&&(i.kernelCustomData.wT=L),m){let Q=a*l*u;T=e[0].reshape([1,v,Q]),E=L.reshape([1,Q,f]),F=[1,v,f]}else T=e[0].reshape([v,a*l,u]),E=L.reshape([1,u,f]),F=[v,h*p,f];I.push(T),I.push(E)}else T=e[0].reshape([v,u,a*l]),E=e[1].reshape([1,f,u]),F=[v,f,h*p],I.push(E),I.push(T);o&&I.push(e[2]);let z=F[2],G=I[0].dims[I[0].dims.length-1];z<8&&G<8?i.compute(Yb(I,t,n,F,r,s),{inputs:I}):i.compute($f(I,t,n,F,r,s),{inputs:I});return}let x=!0,g=i.kernelCustomData.wT??i.compute(Xr(e[1],Ap),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!i.kernelCustomData.wT&&(i.kernelCustomData.wT=g);let _=[e[0],g];o&&_.push(e[2]);let S=r?h*p:f,M=r?f:h*p,w=c*d*u;i.compute(UR(_,t,n,S,M,w,o,x,s),{inputs:_})},FA=(i,e)=>{let t=e.format==="NHWC",s=[i.inputs[0].reshape(t?[i.inputs[0].dims[0],1,i.inputs[0].dims[1],i.inputs[0].dims[2]]:[i.inputs[0].dims[0],i.inputs[0].dims[1],1,i.inputs[0].dims[2]]),i.inputs[1].reshape([i.inputs[1].dims[0],i.inputs[1].dims[1],1,i.inputs[1].dims[2]])];i.inputs.length===3&&s.push(i.inputs[2]);let r=[0,e.pads[0],0,e.pads[1]],n=[1].concat(e.strides),o=[1].concat(e.dilations),a=[1].concat(e.kernelShape),l=Cp({...e,pads:r,strides:n,dilations:o,kernelShape:a},s);k_(i,s,l,u=>t?[u[0],u[2],u[3]]:[u[0],u[1],u[3]])},RA=(i,e,t)=>{let s=t.format==="NHWC"?"channelsLast":"channelsFirst",r=Cp(t,e),n=t.autoPad==="NOTSET"?t.pads:t.autoPad,o=GR(e[0].dims,e[1].dims,t.strides,t.dilations,n,!1,s);i.compute(jR(e,r,o.outShape,[o.filterDepth,o.filterHeight,o.filterWidth],[o.padInfo.front,o.padInfo.top,o.padInfo.left],s))},Ix=(i,e)=>{if(NA(i.inputs,e),i.inputs[0].dims.length===3)FA(i,e);else if(i.inputs[0].dims.length===5)RA(i,i.inputs,e);else{let t=Cp(e,i.inputs);k_(i,i.inputs,t)}}}),qR,_z=Ze(()=>{kt(),na(),Gt(),qt(),qR=(i,e,t)=>{let s=i.length>2,r=e.outputShape,n=e.format==="NHWC",o=e.group,a=i[1].dims,l=a[2]/o,u=a[3],c=n?Js(l):1,d=n&&u===1&&l>=4,h=d?Math.floor(l/4)*4:Math.floor(l/c)*c,p=l-h,f=n?Js(u):1,m=n?u===1?c:f:1,x=Ae.size(r)/f,g=[Math.ceil(x/64),1,1];ls("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${g}`);let _=["rank","rank"],S=[e.strides[0],e.strides[1]],M=[e.kernelShape[n?1:2],e.kernelShape[n?2:3]],w=[e.dilations[0],e.dilations[1]],v=[M[0]+(e.dilations[0]<=1?0:(e.kernelShape[n?1:2]-1)*(e.dilations[0]-1)),M[1]+(e.dilations[1]<=1?0:(e.kernelShape[n?2:3]-1)*(e.dilations[1]-1))],T=[v[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),v[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],E=[{type:12,data:x},{type:12,data:S},{type:12,data:M},{type:12,data:w},{type:12,data:v},{type:6,data:T},{type:12,data:h},{type:12,data:l},{type:12,data:u},...Tt(i[0].dims,i[1].dims)];s&&(E.push(...Tt(i[2].dims)),_.push("rank")),E.push(...Tt(r));let F=I=>{let z=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:S.length},{name:"filter_dims",type:"u32",length:M.length},{name:"dilations",type:"u32",length:M.length},{name:"effective_filter_dims",type:"u32",length:v.length},{name:"pads",type:"i32",length:T.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],G=Ui(i[0].dataType),L=n?1:2,Q=n?2:3,q=n?3:1,J=Oe("W",i[1].dataType,i[1].dims.length,m),ee=Oe("Dy",i[0].dataType,i[0].dims.length,c),se=[ee,J];s&&se.push(Oe("bias",i[2].dataType,[r[q]].length,f));let fe=gt("result",i[0].dataType,r.length,f),ue=()=>{let j="";if(d)c===4?j+=`
        let xValue = ${ee.getByOffset("x_offset")};
        let wValue = ${J.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:c===2?j+=`
          dotProd = dotProd + dot(vec4<${G}>(${ee.getByOffset("x_offset")}, ${ee.getByOffset("x_offset + 1u")}), vec4<${G}>(${J.getByOffset("w_offset")}, ${J.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:c===1&&(j+=`
          dotProd = dotProd + dot(vec4<${G}>(${ee.getByOffset("x_offset")}, ${ee.getByOffset("x_offset + 1u")}, ${ee.getByOffset("x_offset + 2u")}, ${ee.getByOffset("x_offset + 3u")}), vec4<${G}>(${J.getByOffset("w_offset")}, ${J.getByOffset("w_offset + 1u")}, ${J.getByOffset("w_offset + 2u")}, ${J.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(j+=`
                  let xValue = ${n?ee.getByOffset(`${ee.indicesToOffset(`${ee.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c}`):ee.get("batch","inputChannel","idyR","idyC")};
        `,c===1)j+=`
          let w_offset = ${J.indicesToOffset(`${J.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${J.getByOffset(`w_offset / ${m}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let re=0;re<c;re++)j+=`
            let wValue${re} = ${J.getByOffset(`${J.indicesToOffset(`${J.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${re}, wOutChannel)`)} / ${m}`)};
            dotProd = dotProd + xValue[${re}] * wValue${re};`;return j},U=()=>{if(p===0)return"";if(!d)throw new Error(`packInputAs4 ${d} is not true.`);let j="";if(c===1){j+="dotProd = dotProd";for(let re=0;re<p;re++)j+=`
            + ${ee.getByOffset(`x_offset + ${re}`)} * ${J.getByOffset(`w_offset + ${re}`)}`;j+=";"}else if(c===2){if(p!==2)throw new Error(`Invalid inputChannelsRemainder ${p}.`);j+=`
          let xValue = ${ee.getByOffset("x_offset")};
          let wValue = ${J.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return j},k=`
            let outputIndices = ${fe.offsetToIndices(`global_idx * ${f}`)};
            let batch = ${fe.indicesGet("outputIndices",0)};
            let d1 = ${fe.indicesGet("outputIndices",q)};
            let r = ${fe.indicesGet("outputIndices",L)};
            let c = ${fe.indicesGet("outputIndices",Q)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${fe.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${G}(dyRCorner) + ${G}(wR)) / ${G}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${G}(uniforms.Dy_shape[${L}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${G}(dyCCorner) + ${G}(wC)) / ${G}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${G}(uniforms.Dy_shape[${Q}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${d?`
                var x_offset = ${ee.indicesToOffset(`${ee.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c};
                var w_offset = ${J.indicesToOffset(`${J.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${m};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${d?4:c}) {
                  ${ue()}
                  inputChannel = inputChannel + ${d?4:c};
                }
                ${U()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${s?` + bias[d1 / ${f}]`:""};
            ${fe.setByOffset("global_idx","value")};
          `;return`
    ${I.registerUniforms(z).declareVariables(...se,fe)}
      ${I.mainStart()}
      ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${k}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};${c}${m}${f}${d}${p}`,inputDependencies:_},getRunData:()=>({dispatchGroup:{x:g[0],y:g[1],z:g[2]},outputs:[{dims:t?t(r):r,dataType:i[0].dataType}],programUniforms:E}),getShaderSource:F}}}),IA,DA,kA,L_,KR,LA,B_,BA,XR,yz=Ze(()=>{_z(),Jl(),Va(),IA=(i,e,t,s,r,n)=>(i-1)*e+t+(s-1)*r+1-n,DA=(i,e,t,s,r)=>{let n=Math.floor(i/2);e==="SAME_UPPER"?(t[s]=n,t[r]=i-n):e==="SAME_LOWER"&&(t[s]=i-n,t[r]=n)},kA=(i,e,t,s,r,n,o,a,l,u)=>{let c=i.length-2,d=u.length===0;l.length<c&&l.push(...Array(c-l.length).fill(0));let h=i[0],p=e[a?3:1]*r;for(let f=0,m=i.length-c-(a?1:0);f<c;++f,++m){let x=i[m],g=d?x*o[f]:u[f],_=IA(x,o[f],n[f],e[m],t[f],g);DA(_,s,n,f,f+c),d&&u.push(o[f]*(x-1)+l[f]+(e[m]-1)*t[f]+1-n[f]-n[f+c])}u.splice(0,0,h),u.splice(a?3:1,0,p)},L_=(i,e)=>{let t=i.kernelShape.slice();if(i.kernelShape.length===0||i.kernelShape.reduce((d,h)=>d*h,1)===0){t.length=0;for(let d=2;d<e[1].dims.length;++d)t.push(e[1].dims[d])}let s=i.format==="NHWC";t.splice(0,0,e[1].dims[0]),t.splice(s?3:1,0,e[1].dims[1]);let r=i.pads.slice(),n=i.outputShape.slice(),o=i.outputPadding.slice(),a=e[0].dims,l=i.dilations.slice();if(l.reduce((d,h)=>d+h,0)===0){let d=e[0].dims.length-2;l=new Array(d).fill(1)}let u=i.strides.slice();if(u.reduce((d,h)=>d+h,0)===0){let d=e[0].dims.length-2;u=new Array(d).fill(1)}kA(a,t,l,i.autoPad,i.group,r,u,s,o,n);let c=Object.assign({},i);return Object.assign(c,{kernelShape:t,pads:r,outputPadding:o,outputShape:n,dilations:l,strides:u}),c},KR=i=>{let e=Kb(i),t=i.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof i.autoPad>"u"?0:i.autoPad],r=i.dilations,n=i.group,o=i.kernelShape,a=i.pads,l=i.strides,u=i.wIsConst(),c=i.outputPadding,d=i.outputShape;return{autoPad:s,format:t,dilations:r,group:n,kernelShape:o,outputPadding:c,outputShape:d,pads:a,strides:l,wIsConst:u,...e,cacheKey:`${i.format};${e.activation};`}},LA=(i,e)=>{if(!i||i.length!==2&&i.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(i[0].dims.length!==4&&i[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(i[0].dims.length!==i[1].dims.length)throw new Error("filter does not have same dimension as input");let t=i[0].dims[e.format==="NHWC"?i[0].dims.length-1:1],s=i[1].dims[0];if(t!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let r=i[1].dims[1]*e.group;if(i.length===3&&(i[2].dims.length!==1||i[2].dims[0]!==r))throw new Error("invalid bias");let n=i[0].dims.length-2;if(e.dilations.reduce((o,a)=>o+a,0)>0&&e.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(e.strides.reduce((o,a)=>o+a,0)>0&&e.strides.length!==n)throw new Error(`strides should be ${n}D`);if(e.pads.reduce((o,a)=>o+a,0)>0&&e.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(e.outputPadding.length!==n&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${n}D`);if(e.kernelShape.reduce((o,a)=>o+a,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==i[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==i[0].dims.length-2)throw new Error("invalid output shape")},B_=(i,e,t,s)=>{let r=i.kernelCustomData.wT??i.compute(Xr(e[1],[2,3,0,1]),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!i.kernelCustomData.wT&&(i.kernelCustomData.wT=r);let n=[e[0],r];e.length===3&&n.push(e[2]),i.compute(qR(n,t,s),{inputs:n})},BA=(i,e)=>{let t=e.format==="NHWC",s=[i.inputs[0].reshape(t?[i.inputs[0].dims[0],1,i.inputs[0].dims[1],i.inputs[0].dims[2]]:[i.inputs[0].dims[0],i.inputs[0].dims[1],1,i.inputs[0].dims[2]]),i.inputs[1].reshape([i.inputs[1].dims[0],i.inputs[1].dims[1],1,i.inputs[1].dims[2]])];i.inputs.length===3&&s.push(i.inputs[2]);let r=e.kernelShape;(r.length===0||r[0]===0)&&(r=[i.inputs[1].dims[2]]);let n=e.dilations;(n.length===0||n[0]===0)&&(n=[1]);let o=e.strides;(o.length===0||o[0]===0)&&(o=[1]);let a=e.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],o=[1].concat(o),n=[1].concat(n),r=[1].concat(r);let l=e.outputPadding;l=[0].concat(l);let u=L_({...e,pads:a,strides:o,dilations:n,kernelShape:r,outputPadding:l},s);B_(i,s,u,c=>t?[c[0],c[2],c[3]]:[c[0],c[1],c[3]])},XR=(i,e)=>{if(LA(i.inputs,e),i.inputs[0].dims.length===3)BA(i,e);else{let t=L_(e,i.inputs);B_(i,i.inputs,t)}}}),OA,YR,QR,xz=Ze(()=>{kt(),Gt(),oi(),qt(),OA=(i,e,t,s)=>{let r=Ae.size(e),n=e.length,o=Oe("input",i,n),a=gt("output",i,n),l=t.dataType===6?t.getInt32Array()[0]:Number(t.getBigInt64Array()[0]),u=Ae.normalizeAxis(l,n),c=d=>{let h=` i32(${o.indicesGet("inputIndices","uniforms.axis")}) `,p=xt("uniforms.input_shape","uniforms.axis",n),f=s.reverse?h+(s.exclusive?" + 1":""):"0",m=s.reverse?p:h+(s.exclusive?"":" + 1");return`
                ${d.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(o,a)}
                ${d.mainStart()}
                  ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${a.offsetToIndices("global_idx")};
                  var sum = ${a.type.value}(0);
                  let first : i32 = ${f};
                  let last : i32 = ${m};
                  for (var i : i32 = first; i < last; i++) {
                    ${o.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${o.getByIndices("inputIndices")};
                  }
                  ${a.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:s.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:i}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},{type:12,data:u},...Tt(e,e)]}),getShaderSource:c}},YR=(i,e)=>{let t=i.inputs[0].dims,s=i.inputs[0].dataType,r=i.inputs[1];i.compute(OA(s,t,r,e),{inputs:[0]})},QR=i=>{let e=i.exclusive===1,t=i.reverse===1;return Ms({exclusive:e,reverse:t})}}),$A,zA,VA,ZR,JR,bz=Ze(()=>{kt(),Gt(),oi(),qt(),$A=i=>{if(!i||i.length!==1)throw new Error("DepthToSpace requires 1 input.");if(i[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},zA=(i,e,t,s)=>{let r=[];r.push(`fn perm(i: ${s.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`);for(let n=0;n<e;++n)r.push(t.indicesSet("a",i[n],`i[${n}]`));return r.push("return a;}"),r.join(`
`)},VA=(i,e)=>{let t,s,r,n,o,a,l=e.format==="NHWC",u=e.blocksize,c=e.mode==="DCR";l?([t,s,r,n]=i.dims,o=c?[t,s,r,u,u,n/u**2]:[t,s,r,n/u**2,u,u],a=c?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([t,s,r,n]=[i.dims[0],i.dims[2],i.dims[3],i.dims[1]],o=c?[t,u,u,n/u**2,s,r]:[t,n/u**2,u,u,s,r],a=c?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let d=i.reshape(o),h=d.dims.length,p=i.dataType,f=Oe("a",p,h),m=gt("output",p,h),x=g=>`
  ${g.registerUniform("output_size","u32").declareVariables(f,m)}

  ${zA(a,h,f,m)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${m.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${m.setByOffset("global_idx",f.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${i.dims};${e.blocksize};${e.mode}`,inputDependencies:["rank"]},getRunData:g=>{let _=l?[t,s*u,r*u,n/u**2]:[t,n/u**2,s*u,r*u],S=Ae.size(_),M=d.dims,w=Ae.sortBasedOnPerm(M,a);return{outputs:[{dims:_,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:[{type:12,data:S},...Tt(M,w)]}},getShaderSource:x}},ZR=(i,e)=>{$A(i.inputs),i.compute(VA(i.inputs[0],e))},JR=i=>Ms({blocksize:i.blocksize,mode:i.mode,format:i.format})}),Pp,ad,O_,UA,GA,jA,WA,$_,HA,eI,tI,wz=Ze(()=>{kt(),Gt(),oi(),qt(),Pp="[a-zA-Z]|\\.\\.\\.",ad="("+Pp+")+",O_="^"+ad+"$",UA="("+ad+",)*"+ad,GA="^"+UA+"$",jA=class{constructor(i=-1){this.symbolToIndices=new Map,this.inputIndex=i}addSymbol(i,e){let t=this.symbolToIndices.get(i);t===void 0?t=[e]:t.push(e),this.symbolToIndices.set(i,t)}},WA=class{constructor(i,e){var r;this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[t,s]=e.includes("->")?e.split("->",2):[e,""];if(!t.match(RegExp(GA)))throw new Error("Invalid LHS term");if(t.split(",").forEach((n,o)=>{let a=i[o].dims.slice();if(!n.match(RegExp(O_)))throw new Error("Invalid LHS term");let l=this.processTerm(n,!0,a,o);this.lhs.push(l)}),s==="")s+=[...this.symbolToInfo.entries()].filter(([n,o])=>o.count===1||n==="...").map(([n])=>n).join("");else if(!s.match(RegExp(ad)))throw new Error("Invalid RHS");(r=s.match(RegExp(Pp,"g")))==null||r.forEach(n=>{if(n==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let o=this.symbolToInfo.get(n);if(o===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(o.dimValue)}}),this.rhs=this.processTerm(s,!1,this.outputDims)}addSymbol(i,e,t){let s=this.symbolToInfo.get(i);if(s!==void 0){if(s.dimValue!==e&&s.count!==1)throw new Error("Dimension mismatch");s.count++,s.inputIndices.push(t)}else s={count:1,dimValue:e,inputIndices:[t]};this.symbolToInfo.set(i,s)}processTerm(i,e,t,s=-1){let r=t.length,n=!1,o=[],a=0;if(!i.match(RegExp(O_))&&!e&&i!=="")throw new Error("Invalid LHS term");let l=i.match(RegExp(Pp,"g")),u=new jA(s);return l==null||l.forEach((c,d)=>{if(c==="..."){if(n)throw new Error("Only one ellipsis is allowed per input term");n=!0;let h=r-l.length+1;if(h<0)throw new Error("Ellipsis out of bounds");if(o=t.slice(a,a+h),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=o;else throw new Error("Ellipsis must be specified in the LHS");for(let p=0;p<o.length;p++){let f=String.fromCharCode(48+p);u.addSymbol(f,d+p),this.addSymbol(f,t[a++],s)}}else u.addSymbol(c,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(c,t[a++],s)}),u}},$_=i=>i+"_max",HA=(i,e,t,s)=>{let r=i.map(u=>u.length).map((u,c)=>Oe(`input${c}`,e,u)),n=Ae.size(s),o=gt("output",e,s.length),a=[...t.symbolToInfo.keys()].filter(u=>!t.rhs.symbolToIndices.has(u)),l=u=>{let c=[],d="var prod = 1.0;",h="var sum = 0.0;",p="sum += prod;",f=[],m=[],x=[],g=[],_=t.symbolToInfo.size===t.rhs.symbolToIndices.size;t.symbolToInfo.forEach((M,w)=>{var v;if(t.rhs.symbolToIndices.has(w)){let T=(v=t.rhs.symbolToIndices.get(w))==null?void 0:v[0];T!==void 0&&t.lhs.forEach((E,F)=>{if(M.inputIndices.includes(F)){let I=E.symbolToIndices.get(w);if(I===void 0)throw new Error("Invalid symbol error");I.forEach(z=>{c.push(`${r[F].indicesSet(`input${F}Indices`,z,o.indicesGet("outputIndices",T))}`)})}})}else t.lhs.forEach((T,E)=>{if(M.inputIndices.includes(E)){let F=T.symbolToIndices.get(w);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(I=>{f.push(`${r[E].indicesSet(`input${E}Indices`,I,`${w}`)}`)}),g.push(`prod *= ${r[E].getByIndices(`input${E}Indices`)};`)}}),m.push(`for(var ${w}: u32 = 0; ${w} < uniforms.${$_(w)}; ${w}++) {`),x.push("}")});let S=_?[...c,`let sum = ${r.map((M,w)=>M.getByIndices(`input${w}Indices`)).join(" * ")};`]:[...c,h,...m,...f,d,...g,p,...x];return`
            ${u.registerUniforms(a.map(M=>({name:`${$_(M)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...r,o)}

            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${o.offsetToIndices("global_idx")};
            ${r.map((M,w)=>`var input${w}Indices: ${r[w].type.indices};`).join(`
`)}
            ${S.join(`
`)};
            ${o.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:t.equation,inputDependencies:i.map(()=>"rank")},getRunData:()=>{let u=a.filter(d=>t.symbolToInfo.has(d)).map(d=>{var h;return{type:12,data:((h=t.symbolToInfo.get(d))==null?void 0:h.dimValue)||0}});u.push({type:12,data:n});let c=i.map((d,h)=>[...Tt(d)]).reduce((d,h)=>d.concat(h),u);return c.push(...Tt(s)),{outputs:[{dims:s,dataType:e}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:c}},getShaderSource:l}},eI=(i,e)=>{let t=new WA(i.inputs,e.equation),s=t.outputDims,r=i.inputs.map((n,o)=>n.dims);i.compute(HA(r,i.inputs[0].dataType,t,s))},tI=i=>{let e=i.equation.replace(/\s+/g,"");return Ms({equation:e})}}),qA,z_,KA,XA,sI,Mz=Ze(()=>{kt(),Gt(),qt(),qA=i=>{if(!i||i.length!==2)throw new Error("Expand requires 2 input.");let e=i[0].dims,t=Array.from(i[1].getBigInt64Array(),Number),s=t.length<e.length?0:t.length-e.length,r=e.length<t.length?0:e.length-t.length;for(;s<t.length&&r<e.length;++s,++r)if(t[s]!==e[r]&&t[s]!==1&&e[r]!==1)throw new Error("Expand requires shape to be broadcastable to input")},z_=(i,e)=>{let t=i.length-e.length,s=[];for(let r=0;r<t;++r)s.push(i[r]);for(let r=0;r<e.length;++r)s.push(e[r]===1?i[r+t]:e[r]);return s},KA=(i,e)=>i.length>e.length?z_(i,e):z_(e,i),XA=i=>{let e=i[0].dims,t=Array.from(i[1].getBigInt64Array(),Number),s=KA(e,t),r=i[0].dataType,n=r===9||Ae.size(e)===1,o=r===9||e.length>0&&e[e.length-1]%4===0?4:1,a=n||s.length>0&&s[s.length-1]%4===0?4:1,l=Math.ceil(Ae.size(s)/a),u=d=>{let h=Oe("input",r,e.length,o),p=gt("output",r,s.length,a),f;if(r===9){let m=(x,g,_="")=>`
          let outputIndices${g} = ${p.offsetToIndices(`outputOffset + ${g}u`)};
          let offset${g} = ${h.broadcastedIndicesToOffset(`outputIndices${g}`,p)};
          let index${g} = offset${g} / 4u;
          let component${g} = offset${g} % 4u;
          ${x}[${g}] = ${_}(${h.getByOffset(`index${g}`)}[component${g}]);
        `;f=`
        let outputOffset = global_idx * ${a};
        var data = vec4<u32>(0);
        ${m("data",0,"u32")}
        ${m("data",1,"u32")}
        ${m("data",2,"u32")}
        ${m("data",3,"u32")}
        ${p.setByOffset("global_idx","data")}
      }`}else f=`
        let outputIndices = ${p.offsetToIndices(`global_idx * ${a}`)};
        let inputOffset = ${h.broadcastedIndicesToOffset("outputIndices",p)};
        let data = ${p.type.value}(${h.getByOffset(`inputOffset / ${o}`)});
        ${p.setByOffset("global_idx","data")}
      }`;return`
    ${d.registerUniform("vec_size","u32").declareVariables(h,p)}
    ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${f}`},c=[{type:12,data:l},...Tt(e,s)];return{name:"Expand",shaderCache:{hint:`${s.length};${o}${a}`,inputDependencies:["rank"]},getShaderSource:u,getRunData:()=>({outputs:[{dims:s,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c})}},sI=i=>{qA(i.inputs),i.compute(XA(i.inputs),{inputs:[0]})}}),YA,iI,Tz=Ze(()=>{kt(),Gt(),qt(),qb(),YA=i=>{let e=i[0].dataType,t=Ae.size(i[0].dims),s=Ae.size(i[1].dims),r=s%4===0,n=o=>{let a=Oe("x",e,[1],4),l=Oe("bias",e,[1],4),u=gt("y",e,[1],4),c=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],d=p=>`
      let bias${p}_offset: u32 = (global_idx * 4 + ${p}) % uniforms.bias_size;
      let bias${p} = ${l.getByOffset(`bias${p}_offset / 4`)}[bias${p}_offset % 4];`,h=r?`
      let bias = ${l.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${d(0)}${d(1)}${d(2)}${d(3)}
      let bias = ${a.type.value}(bias0, bias1, bias2, bias3);`;return`${o.registerUniforms(c).declareVariables(a,l,u)}

    ${Cx(or(e))}

    ${o.mainStart(pc)}
      ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${a.getByOffset("global_idx")};
      ${h}
      let x_in = x + bias;
      ${u.setByOffset("global_idx",Px("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${r}`,inputDependencies:["type","type"]},getShaderSource:n,getRunData:o=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],programUniforms:[{type:12,data:Math.ceil(t/4)},{type:12,data:s}],dispatchGroup:{x:Math.ceil(t/pc/4)}})}},iI=i=>{i.inputs.length<2||Ae.size(i.inputs[1].dims)===0?TR(i):i.compute(YA(i.inputs))}}),QA,ZA,rI,nI,vz=Ze(()=>{kt(),Gt(),oi(),qt(),QA=i=>{if(!i||i.length!==2)throw new Error("Gather requires 2 inputs.")},ZA=(i,e)=>{let t=i[0].dims,s=i[1].dims,r=t.length,n=Ae.normalizeAxis(e.axis,r),o=t.slice(0);o.splice(n,1,...s);let a=t[n],l=i[0].dataType===9?4:1,u=Math.ceil(Ae.size(o)/l),c=[{type:12,data:u},{type:6,data:a},{type:12,data:n},...Tt(i[0].dims,i[1].dims,o)],d=h=>{let p=Oe("data",i[0].dataType,i[0].dims.length,l),f=Oe("inputIndices",i[1].dataType,i[1].dims.length),m=gt("output",i[0].dataType,o.length,l),x=_=>{let S=s.length,M=`var indicesIndices${_}  = ${f.type.indices}(0);`;for(let w=0;w<S;w++)M+=`${S>1?`indicesIndices${_}[${w}]`:`indicesIndices${_}`} = ${o.length>1?`outputIndices${_}[uniforms.axis + ${w}]`:`outputIndices${_}`};`;M+=`
          var idx${_} = ${f.getByIndices(`indicesIndices${_}`)};
          if (idx${_} < 0) {
            idx${_} = idx${_} + uniforms.axisDimLimit;
          }
          var dataIndices${_} : ${p.type.indices};
        `;for(let w=0,v=0;w<r;w++)w===n?(M+=`${r>1?`dataIndices${_}[${w}]`:`dataIndices${_}`} = u32(idx${_});`,v+=S):(M+=`${r>1?`dataIndices${_}[${w}]`:`dataIndices${_}`} = ${o.length>1?`outputIndices${_}[${v}]`:`outputIndices${_}`};`,v++);return M},g;if(i[0].dataType===9){let _=(S,M,w="")=>`
          let outputIndices${M} = ${m.offsetToIndices(`outputOffset + ${M}u`)};
          ${x(M)};
          let offset${M} = ${p.indicesToOffset(`dataIndices${M}`)};
          let index${M} = offset${M} / 4u;
          let component${M} = offset${M} % 4u;
          ${S}[${M}] = ${w}(${p.getByOffset(`index${M}`)}[component${M}]);
        `;g=`
        let outputOffset = global_idx * ${l};
        var value = vec4<u32>(0);
        ${_("value",0,"u32")}
        ${_("value",1,"u32")}
        ${_("value",2,"u32")}
        ${_("value",3,"u32")}
        ${m.setByOffset("global_idx","value")}
      `}else g=`
      let outputIndices = ${m.offsetToIndices("global_idx")};
      ${x("")};
      let value = ${p.getByIndices("dataIndices")};
      ${m.setByOffset("global_idx","value")};
      `;return`
      ${h.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(p,f,m)}
      ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${g}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:d}},rI=i=>Ms({axis:i.axis}),nI=(i,e)=>{let t=i.inputs;QA(t),i.compute(ZA(i.inputs,e))}}),JA,oI,aI,Sz=Ze(()=>{kt(),Gt(),qt(),JA=(i,e,t,s,r,n,o,a,l)=>{let u=[{type:12,data:n},{type:12,data:s},{type:12,data:r},{type:12,data:t},{type:12,data:o},{type:12,data:a},{type:12,data:l}],c=[n];u.push(...Tt(e.dims,c));let d=h=>{let p=Oe("indices_data",e.dataType,e.dims.length),f=gt("input_slice_offsets_data",12,1,1),m=[p,f],x=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:r.length},{name:"sizes_from_slice_dims_data",type:"u32",length:t.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${h.registerUniforms(x).declareVariables(...m)}
  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${r.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${t.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return i.compute({name:"computeSliceOffsets",shaderCache:{hint:`${r.length}_${t.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:c,dataType:i.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:u}),getShaderSource:d},{inputs:[e],outputs:[-1]})[0]},oI=(i,e)=>{let t=i.inputs,s=t[0].dims,r=t[0].dataType,n=t[1].dims,o=n[n.length-1],a=Ae.sizeToDimension(n,n.length-1),l=Ae.sizeFromDimension(s,e.batchDims+o),u=Ae.sizeToDimension(s,e.batchDims),c=Ae.sizeFromDimension(s,e.batchDims),d=a/u,h=new Array(o),p=l;for(let M=0;M<o;++M)h[o-1-M]=p,p*=s[e.batchDims+o-1-M];let f=JA(i,t[1],h,e.batchDims,s,a,d,c,o),m=e.batchDims+o;if(m>s.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let x=n.slice(0,-1).concat(s.slice(m)),g=Ae.size(x),_=[{type:12,data:g},{type:12,data:l},...Tt(t[0].dims,f.dims,x)],S=M=>{let w=Oe("data",t[0].dataType,t[0].dims.length),v=Oe("slice_offsets",12,f.dims.length),T=gt("output",t[0].dataType,x.length);return`
          ${M.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(w,v,T)}
            ${M.mainStart()}
            ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};i.compute({name:"GatherND",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:x,dataType:r}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:_}),getShaderSource:S},{inputs:[t[0],f]})},aI=i=>({batchDims:i.batch_dims,cacheKey:""})}),eC,tC,lI,uI,Ez=Ze(()=>{kt(),Gt(),oi(),qt(),eC=(i,e)=>{if(i.length<3||i.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let t=Ae.normalizeAxis(e.quantizeAxis,i[0].dims.length),s=e.blockSize,r=i[0],n=i[2],o=i.length===4?i[3]:void 0;if(n.dims.length!==r.dims.length||!r.dims.map((a,l)=>l===t?Math.ceil(a/s)===n.dims[l]:a===n.dims[l]).reduce((a,l)=>a&&l,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(o){if(o.dataType!==r.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(o.dims.length!==n.dims.length||!o.dims.map((a,l)=>a===n.dims[l]).reduce((a,l)=>a&&l,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},tC=(i,e)=>{let t=i[0].dims,s=i[1].dims,r=t.length,n=Ae.normalizeAxis(e.gatherAxis,r),o=Ae.normalizeAxis(e.quantizeAxis,r),a=t.slice(0);a.splice(n,1,...s);let l=Ae.size(a),u=i[2].dataType,c=i[0].dataType===22,d=[{type:12,data:l},{type:12,data:o},{type:12,data:n},{type:12,data:e.blockSize},...Tt(...i.map((p,f)=>p.dims),a)],h=p=>{let f=Oe("data",i[0].dataType,i[0].dims.length),m=Oe("inputIndices",i[1].dataType,i[1].dims.length),x=Oe("scales",i[2].dataType,i[2].dims.length),g=i.length>3?Oe("zeroPoint",i[3].dataType,i[3].dims.length):void 0,_=gt("output",u,a.length),S=[f,m,x];g&&S.push(g);let M=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${p.registerUniforms(M).declareVariables(...S,_)}
        ${p.mainStart()}
        let output_indices = ${_.offsetToIndices("global_idx")};
        var indices_indices = ${m.type.indices}(0);
        ${s.length>1?`
          for (var i: u32 = 0; i < ${s.length}; i++) {
            let index = ${_.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${m.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${_.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${f.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${_.indicesGet("output_indices","i")};
          ${f.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${m.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${t[n]};
        }
        ${f.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${a.length}; i++) {
          let index = ${_.indicesGet("output_indices",`i + ${s.length} - 1`)};
          ${f.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${f.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${f.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${x.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${x.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${x.getByIndices("scale_indices")};
        ${g?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${g.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${g.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${or(u)}(quantized_data - zero_point) * scale;
        ${_.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${e.cacheKey};${i.filter((p,f)=>f!==1).map(p=>p.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:i.length},(p,f)=>"rank")},getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:h}},lI=(i,e)=>{let t=i.inputs;eC(t,e),i.compute(tC(i.inputs,e))},uI=i=>Ms({blockSize:i.blockSize,gatherAxis:i.gatherAxis,quantizeAxis:i.quantizeAxis})}),sC,iC,cI,dI,Az=Ze(()=>{kt(),Gt(),oi(),qt(),sC=i=>{if(!i||i.length!==2)throw new Error("GatherElements requires 2 inputs.");if(i[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(i[0].dims.length!==i[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},iC=(i,e)=>{let t=i[0].dims,s=i[0].dataType,r=t.length,n=i[1].dims,o=i[1].dataType,a=Ae.normalizeAxis(e.axis,r),l=t[a],u=n.slice(0),c=Ae.size(u),d=Oe("input",s,r),h=Oe("indicesInput",o,n.length),p=gt("output",s,u.length),f=[{type:12,data:c},{type:6,data:l},{type:12,data:a}];return f.push(...Tt(t,n,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:f}),getShaderSource:m=>`
      ${m.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(d,h,p)}
      ${m.mainStart()}
      ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${p.offsetToIndices("global_idx")};

      var idx = ${h.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${d.type.indices}(outputIndices);
      ${d.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${d.getByIndices("inputIndices")};

      ${p.setByOffset("global_idx","value")};
  }`}},cI=i=>Ms({axis:i.axis}),dI=(i,e)=>{let t=i.inputs;sC(t),i.compute(iC(i.inputs,e))}}),rC,nC,hI,pI,Cz=Ze(()=>{kt(),Gt(),qt(),rC=i=>{if(!i)throw new Error("Input is missing");if(i.length<2||i.length>3)throw new Error("Invaid input number.");if(i.length===3&&i[2].dims.length>2)throw new Error("Invalid input shape of C");if(i[0].dataType!==i[1].dataType||i.length===3&&i[0].dataType!==i[2].dataType)throw new Error("Input types are mismatched")},nC=(i,e)=>{let t=i[0].dims.slice(),s=i[1].dims.slice(),[r,n,o]=cF.getShapeOfGemmResult(t,e.transA,s,e.transB,i.length===3?i[2].dims:void 0),a=[r,n];if(!a)throw new Error("Can't use gemm on the given tensors");let l=16,u=Math.ceil(n/l),c=Math.ceil(r/l),d=!0,h=Ae.size(a),p=[{type:12,data:d?u:h},{type:12,data:r},{type:12,data:n},{type:12,data:o},{type:1,data:e.alpha},{type:1,data:e.beta}],f=["type","type"];i.length===3&&(p.push(...Tt(i[2].dims)),f.push("rank")),p.push(...Tt(a));let m=g=>{let _="";e.transA&&e.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let S=e.alpha===1?"":"value *= uniforms.alpha;",M=Oe("a",i[0].dataType,i[0].dims),w=Oe("b",i[1].dataType,i[1].dims),v=M.type.value,T=null,E=[M,w];i.length===3&&(T=Oe("c",i[2].dataType,i[2].dims.length),E.push(T));let F=gt("output",i[0].dataType,a.length);E.push(F);let I=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${g.registerUniforms(I).declareVariables(...E)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${v}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${_}
    }

    ${S}
    ${T!=null?`let cOffset = ${T.broadcastedIndicesToOffset("vec2(m, n)",F)}; value += ${v}(uniforms.beta) * ${T.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},x=g=>{let _=Oe("a",i[0].dataType,i[0].dims),S=Oe("b",i[1].dataType,i[1].dims),M=null,w=[_,S];i.length===3&&(M=Oe("c",i[2].dataType,i[2].dims.length),w.push(M));let v=gt("output",i[0].dataType,a.length);w.push(v);let T=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],E="",F="";e.transA&&e.transB?(F=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);
      }
      `,E="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):e.transA&&!e.transB?(F=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);
      }
      `,E="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!e.transA&&e.transB?(F=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);
      }
      `,E="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!e.transA&&!e.transB&&(F=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${_.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);
      }
      `,E="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let I=e.alpha===1?"":"value *= uniforms.alpha;";return`
  ${g.registerUniforms(T).declareVariables(...w)}
  var<workgroup> tile_a: array<array<${_.type.storage}, ${l}>, ${l}>;
  var<workgroup> tile_b: array<array<${S.type.storage}, ${l}>, ${l}>;
  ${g.mainStart([l,l,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};
    let num_tiles = (uniforms.K - 1) / ${l} + 1;
    var k_start = 0u;
    var value = ${v.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${F}
      k_start = k_start + ${l};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${l}; k++) {
        ${E}
      }
      workgroupBarrier();
    }

    ${I}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${M!=null?`let cOffset = ${M.broadcastedIndicesToOffset("vec2(m, n)",v)}; value += ${v.type.value}(uniforms.beta) * ${M.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return d?{name:"GemmShared",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:a,dataType:i[0].dataType}],dispatchGroup:{x:u*c},programUniforms:p}),getShaderSource:x}:{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:a,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:p}),getShaderSource:m}},hI=i=>{let e=i.transA,t=i.transB,s=i.alpha,r=i.beta;return{transA:e,transB:t,alpha:s,beta:r,cacheKey:`${i.transA};${i.transB};${i.alpha===1}`}},pI=(i,e)=>{rC(i.inputs),i.compute(nC(i.inputs,e))}}),ro,Fo,fl,ml,oC,aC,lC,uC,cC,dC,hC,pC,fI,mI,Pz=Ze(()=>{kt(),Gt(),oi(),qt(),[ro,Fo,fl,ml]=[0,1,2,3],oC=i=>{if(i[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(i[0].dims.length!==i[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(i[0].dims.length-2!==i[1].dims[i[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${i[0].dims.length-2}`);if(i[0].dims[0]!==i[1].dims[0])throw new Error("grid batch size must match input batch size")},aC=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,lC=i=>`
  fn gs_bicubic_interpolate(p: mat4x4<${i}>, x: f32, y: f32) -> ${i} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${i}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,uC=i=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${i.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,cC=i=>`
  ${i.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,dC=(i,e,t)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${e} {
     var pixel = ${e}(0);
     var indices = vec4<u32>(0);
     indices[${ro}] = batch;
     indices[${Fo}] = channel;`+(()=>{switch(t.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${fl}] = u32(r);
            indices[${ml}] = u32(c);
          } else {
            return ${e}(0);
          }
        `;case"border":return`
          indices[${fl}] = u32(clamp(r, 0, H - 1));
          indices[${ml}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${fl}] = gs_reflect(r, border[1], border[3]);
          indices[${ml}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${t.paddingMode} is not supported`)}})()+`
    return ${i.getByIndices("indices")};
  }
`,hC=(i,e,t)=>(()=>{switch(t.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${ro}], indices[${Fo}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${ro}], indices[${Fo}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${ro}], indices[${Fo}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${ro}], indices[${Fo}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${ro}], indices[${Fo}], border);

          let dx2 = ${e}(f32(x2) - x);
          let dx1 = ${e}(x - f32(x1));
          let dy2 = ${e}(f32(y2) - y);
          let dy1 = ${e}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${e}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${ro}], indices[${Fo}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${t.mode} is not supported`)}})()+`${i.setByOffset("global_idx","result")}`,pC=(i,e)=>{let t=Oe("x",i[0].dataType,i[0].dims.length),s=[i[1].dims[0],i[1].dims[1],i[1].dims[2]],r=Oe("grid",i[1].dataType,s.length,2),n=[i[0].dims[0],i[0].dims[1],i[1].dims[1],i[1].dims[2]];e.format==="NHWC"&&(n=[i[0].dims[0],i[1].dims[1],i[1].dims[2],i[0].dims[3]],[ro,Fo,fl,ml]=[0,3,1,2]);let o=gt("output",i[0].dataType,n.length),a=t.type.value,l=Ae.size(n),u=[{type:12,data:l},...Tt(i[0].dims,s,n)],c=d=>`
  ${d.registerUniform("output_size","u32").declareVariables(t,r,o)}
  ${aC}
  ${lC(a)}
  ${uC(e)}
  ${cC(e)}
  ${dC(t,a,e)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${fl}]);
      let W_in = i32(uniforms.x_shape[${ml}]);

      ${e.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${o.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${ro}], indices[${fl}], indices[${ml}]);
      let nxy = ${r.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${hC(o,a,e)}
  }`;return{name:"GridSample",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:["type","type"]},getRunData:d=>{let h=Ae.size(n);return{outputs:[{dims:n,dataType:d[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:u}},getShaderSource:c}},fI=(i,e)=>{oC(i.inputs),i.compute(pC(i.inputs,e))},mI=i=>Ms({alignCorners:i.align_corners,mode:i.mode,paddingMode:i.padding_mode,format:i.format})}),fr,fC,gI,V_,mC,kd,_I,yI=Ze(()=>{kt(),Gt(),oi(),Gb(),Hb(),qt(),Va(),fr=(i,e)=>i.length>e&&i[e].dims.length>0?i[e]:void 0,fC=(i,e)=>{let t=i[0],s=fr(i,1),r=fr(i,2),n=fr(i,3),o=fr(i,4),a=fr(i,5),l=fr(i,6),u=fr(i,7);if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let c=t.dims[0],d=t.dims[1],h=t.dims.length===3?t.dims[2]:e.numHeads*t.dims[4],p=d,f=0,m=0,x=Math.floor(h/e.numHeads);if(l&&u&&Ae.size(l.dims)&&Ae.size(u.dims)){if(l.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims[0]!==c||l.dims[1]!==e.numHeads||l.dims[3]!==x)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[0]!==c||u.dims[1]!==e.numHeads||u.dims[3]!==x)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==u.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(u.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');f=l.dims[2],m=l.dims[2]}else if(l&&Ae.size(l.dims)||u&&Ae.size(u.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g;if(s&&Ae.size(s.dims)>0){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(s.dims[2]!==t.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');g=2,p=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==x)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');g=5,p=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==x)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');g=0,p=s.dims[2]}}else{if(t.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(t.dims[2]!==e.numHeads||t.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}if(n&&Ae.size(n.dims)>0){if(n.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(s&&s.dims.length===5&&s.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let _=f+p,S=0;if(o&&Ae.size(o.dims)>0){S=8;let T=o.dims;throw T.length===1?T[0]===c?S=1:T[0]===3*c+2&&(S=3):T.length===2&&T[0]===c&&T[1]===_&&(S=5),S===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let M=!1,w=h;if(r&&Ae.size(r.dims)>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(p!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');w=r.dims[2]}else{if(p!==r.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');w=r.dims[1]*r.dims[3],M=!0}}let v=!1;if(o&&Ae.size(o.dims)>0)throw new Error("Key padding mask is not supported");if(a&&Ae.size(a.dims)>0){if(a.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(a.dims[0]!==c||a.dims[1]!==e.numHeads||a.dims[2]!==d||a.dims[3]!==_)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:d,pastSequenceLength:f,kvSequenceLength:p,totalSequenceLength:_,maxSequenceLength:m,inputHiddenSize:0,hiddenSize:h,vHiddenSize:w,headSize:x,vHeadSize:Math.floor(w/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:S,scale:e.scale,broadcastResPosBias:v,passPastInKv:M,qkvFormat:g}},gI=i=>Ms({...i}),V_=Ms({perm:[0,2,1,3]}),mC=(i,e,t,s,r,n,o)=>{let a=[s,r,n],l=Ae.size(a),u=[{type:12,data:l},{type:12,data:o},{type:12,data:n}],c=d=>{let h=gt("qkv_with_bias",e.dataType,a),p=Oe("qkv",e.dataType,a),f=Oe("bias",t.dataType,a),m=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${d.registerUniforms(m).declareVariables(p,f,h)}
  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return i.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:c},{inputs:[e,t],outputs:[-1]})[0]},kd=(i,e,t,s,r,n,o,a)=>{let l=n;if(o&&Ae.size(o.dims)>0){if(s===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=mC(i,n,o,e,s,t*r,a),l=l.reshape([e,s,t,r]),t===1||s===1?l:i.compute(Xr(l,V_.perm),{inputs:[l],outputs:[-1]})[0]}else return n.dims.length===3&&(l=n.reshape([e,s,t,r])),t===1||s===1?l:i.compute(Xr(l,V_.perm),{inputs:[l],outputs:[-1]})[0]},_I=(i,e)=>{let t=fC(i.inputs,e),s=i.inputs[0],r=fr(i.inputs,1),n=fr(i.inputs,2),o=fr(i.inputs,3),a=fr(i.inputs,4),l=fr(i.inputs,5),u=fr(i.inputs,6),c=fr(i.inputs,7);if(s.dims.length===5)throw new Error("Packed QKV is not implemented");if((r==null?void 0:r.dims.length)===5)throw new Error("Packed KV is not implemented");let d=r&&n&&r.dims.length===4&&n.dims.length===4,h=kd(i,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,s,o,0);if(d)return Jd(i,h,r,n,a,void 0,u,c,l,t);if(!r||!n)throw new Error("key and value must be provided");let p=kd(i,t.batchSize,t.numHeads,t.kvSequenceLength,t.headSize,r,o,t.hiddenSize),f=kd(i,t.batchSize,t.numHeads,t.kvSequenceLength,t.vHeadSize,n,o,2*t.hiddenSize);Jd(i,h,p,f,a,void 0,u,c,l,t)}}),gC,_C,yC,xC,Dx,xI,bI,wI=Ze(()=>{kt(),Gt(),oi(),qt(),gC=i=>{if(!i||i.length<1)throw new Error("too few inputs")},_C=(i,e)=>{let t=[],s=e.numOutputs;return i[1].dims[0]>0&&(i[1].getBigInt64Array().forEach(r=>t.push(Number(r))),s=t.length),Ms({numOutputs:s,axis:e.axis,splitSizes:t})},yC=i=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${i}u; i += 1u ) {
    if (index < ${xt("uniforms.size_in_split_axis","i",i)}) {
        return i;
    }
    }
    return ${i}u;
}`,xC=i=>{let e=i.length,t=[];for(let s=0;s<e;++s){let r=i[s].setByIndices("indices","input[global_idx]");e===1?t.push(r):s===0?t.push(`if (output_number == ${s}u) { ${r} }`):s===e-1?t.push(`else { ${r} }`):t.push(`else if (output_number == ${s}) { ${r} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${i[0].type.indices}, global_idx: u32) {
        ${t.join(`
`)}
      }`},Dx=(i,e)=>{let t=i[0].dims,s=Ae.size(t),r=i[0].dataType,n=Ae.normalizeAxis(e.axis,t.length),o=new Array(e.numOutputs),a=Oe("input",r,t.length),l=new Array(e.numOutputs),u=[],c=[],d=0,h=[{type:12,data:s}];for(let f=0;f<e.numOutputs;f++){d+=e.splitSizes[f],l[f]=d;let m=t.slice();m[n]=e.splitSizes[f],c.push(m),o[f]=gt(`output${f}`,r,m.length),u.push({dims:c[f],dataType:i[0].dataType})}h.push({type:12,data:l},...Tt(t,...c));let p=f=>`
  ${f.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(a,...o)}
  ${yC(l.length)}
  ${xC(o)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${a.offsetToIndices("global_idx")};
    var index = ${a.indicesGet("indices",n)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${xt("uniforms.size_in_split_axis","output_number - 1u",l.length)};
      ${a.indicesSet("indices",n,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:p,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(s/64)},programUniforms:h})}},xI=(i,e)=>{gC(i.inputs);let t=i.inputs.length===1?e:_C(i.inputs,e);i.compute(Dx(i.inputs,t),{inputs:[0]})},bI=i=>{let e=i.axis,t=i.splitSizes,s=i.numOutputs<0?t.length:i.numOutputs;if(s!==t.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Ms({axis:e,numOutputs:s,splitSizes:t})}}),bC,zf,MI,TI=Ze(()=>{kt(),Gt(),oi(),qt(),bC=(i,e)=>{let[t,s,r,n]=i,{numHeads:o,rotaryEmbeddingDim:a}=e;if(t.dims.length!==3&&t.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${t.dims.length}`);if(!Ae.areEqual(s.dims,[])&&!Ae.areEqual(s.dims,[1])&&s.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${s.dims.length}`);if(r.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${r.dims.length}`);if(n.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${n.dims.length}`);if(!Ae.areEqual(r.dims,n.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(a>0&&o===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=t.dims[0],u=t.dims[t.dims.length-2],c=r.dims[0],d=Ae.sizeFromDimension(t.dims,1)/u,h=a===0?r.dims[1]*2:d/o;if(a>h)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(s.dims.length===2){if(l!==s.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${s.dims[0]}`);if(u!==s.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${s.dims[1]}`)}if(h/2!==r.dims[1]&&a/2!==r.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${r.dims[1]}`);if(u>c)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},zf=(i,e)=>{let{interleaved:t,numHeads:s,rotaryEmbeddingDim:r,scale:n}=e,o=i[0].dims[0],a=Ae.sizeFromDimension(i[0].dims,1),l=i[0].dims[i[0].dims.length-2],u=a/l,c=i[2].dims[1],d=r===0?c*2:u/s,h=new Array(o,l,u/d,d-c),p=Ae.computeStrides(h),f=[{type:1,data:n},{type:12,data:h},{type:12,data:p},...i[0].dims.length===3?new Array({type:12,data:[a,u,d,1]}):[],...i[0].dims.length===4?new Array({type:12,data:[a,d,l*d,1]}):[],...Tt(i[0].dims,i[1].dims,i[2].dims,i[3].dims,i[0].dims)],m=x=>{let g=Oe("input",i[0].dataType,i[0].dims.length),_=Oe("position_ids",i[1].dataType,i[1].dims.length),S=Oe("cos_cache",i[2].dataType,i[2].dims.length),M=Oe("sin_cache",i[3].dataType,i[3].dims.length),w=gt("output",i[0].dataType,i[0].dims.length);return x.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:h.length},{name:"global_strides",type:"u32",length:p.length},{name:"input_output_strides",type:"u32",length:p.length}]),`
        ${x.declareVariables(g,_,S,M,w)}

        ${x.mainStart(pc)}
          let half_rotary_emb_dim = uniforms.${S.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${x.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${_.broadcastedIndicesToOffset("bsnh.xy",gt("",_.type.tensor,2))};
            let position_id =
                u32(${_.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${t});
            let j = i + select(half_rotary_emb_dim, 1, ${t});
            let re = ${g.getByOffset("i")} * ${S.get("position_id","bsnh[3]")} -
                ${g.getByOffset("j")} * ${M.get("position_id","bsnh[3]")};
            ${w.setByOffset("i","re")}
            let im = ${g.getByOffset("i")} * ${M.get("position_id","bsnh[3]")} +
                ${g.getByOffset("j")} * ${S.get("position_id","bsnh[3]")};
            ${w.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${w.setByOffset("k",g.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:Ms({interleaved:t}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:m,getRunData:()=>({outputs:[{dims:i[0].dims,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(Ae.size(h)/pc)},programUniforms:f})}},MI=(i,e)=>{bC(i.inputs,e),i.compute(zf(i.inputs,e))}}),wC,MC,U_,TC,vI,Nz=Ze(()=>{oi(),kt(),Hb(),yI(),wI(),Va(),TI(),qt(),wC=(i,e)=>{if(e.doRotary&&i.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let t=i[0],s=i[1],r=i[2],n=i[3],o=i[4];if(e.doRotary!==0&&i.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(e.localWindowSize!==-1)throw new Error("Local attention is not supported");if(e.softcap!==0)throw new Error("Softcap is not supported");if(e.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(e.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let a=!1,l=t.dims[0],u=t.dims[1],c=t.dims.length===3?a?t.dims[2]/3:t.dims[2]:e.numHeads*t.dims[4],d=u,h=0,p=!s||s.dims.length===0,f=Math.floor(p?c/(e.numHeads+2*e.kvNumHeads):c/e.numHeads);p&&(c=f*e.numHeads);let m=n&&n.dims.length!==0,x=o&&o.dims.length!==0;if(m&&n.dims.length===4&&n.dims[0]===l&&n.dims[1]!==e.kvNumHeads&&n.dims[2]===e.kvNumHeads&&n.dims[3]===f)throw new Error("BSNH pastKey/pastValue is not supported");if(m&&x){if(n.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(o.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');h=n.dims[2]}else if(m||x)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g=1;if(s&&s.dims.length>0){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(t.dims[2]%s.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');d=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==f)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');d=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==f)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');d=s.dims[2]}}else{if(t.dims.length!==3&&t.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(t.dims.length===5&&(t.dims[2]!==e.numHeads||t.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}let _=0,S=!1,M=e.kvNumHeads?f*e.kvNumHeads:c;if(r&&r.dims.length>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(d!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');M=r.dims[2]}else{if(d!==r.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');M=r.dims[1]*r.dims[3],S=!0}}let w=i.length>4?i[5]:void 0;if(w&&w.dims.length!==1&&w.dims[0]!==l)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:u,pastSequenceLength:h,kvSequenceLength:d,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:c,vHiddenSize:M,headSize:f,vHeadSize:Math.floor(M/e.kvNumHeads),numHeads:e.numHeads,kvNumHeads:e.kvNumHeads,nReps:e.numHeads/e.kvNumHeads,pastPresentShareBuffer:!1,maskType:_,scale:e.scale,broadcastResPosBias:!1,passPastInKv:S,qkvFormat:g}},MC=Ms({perm:[0,2,1,3]}),U_=(i,e,t)=>{let s=e,r=t.kvNumHeads;return e.dims.length===3&&t.kvSequenceLength!==0&&(s=e.reshape([t.batchSize,t.kvSequenceLength,r,t.headSize]),s=i.compute(Xr(s,MC.perm),{inputs:[s],outputs:[-1]})[0]),s},TC=(i,e,t,s)=>{let r=7,n=["type","type"],o=[i*e],a=i*e,l=[{type:12,data:a},{type:12,data:e},{type:12,data:i}],u=c=>{let d=Oe("seq_lens",t.dataType,t.dims),h=Oe("total_seq_lens",s.dataType,s.dims),p=gt("pos_ids",r,o),f=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${c.registerUniforms(f).declareVariables(d,h,p)}
  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${h.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${d.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${p.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${p.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${p.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${i};${e}`,inputDependencies:n},getRunData:()=>({outputs:[{dims:o,dataType:r}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:u}},vI=(i,e)=>{var M;let t=wC(i.inputs,e);if(i.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((M=i.inputs[1])==null?void 0:M.dims.length)===5)throw new Error("Packed KV is not implemented");let s=i.inputs[0],r=i.inputs[1]&&i.inputs[1].dims.length>0?i.inputs[1]:void 0,n=i.inputs[2]&&i.inputs[2].dims.length>0?i.inputs[2]:void 0,o=i.inputs[3]&&i.inputs[3].dims.length!==0?i.inputs[3]:void 0,a=i.inputs[4]&&i.inputs[4].dims.length!==0?i.inputs[4]:void 0,l=i.inputs.length>4?i.inputs[5]:void 0,u=i.inputs.length>5?i.inputs[6]:void 0,c=t.kvNumHeads?t.kvNumHeads:t.numHeads,d=Ms({axis:2,numOutputs:3,splitSizes:[t.numHeads*t.headSize,c*t.headSize,c*t.headSize]}),[h,p,f]=!r&&!n?i.compute(Dx([s],d),{inputs:[s],outputs:[-1,-1,-1]}):[s,r,n],m,x;if(e.doRotary){let w=i.compute(TC(t.batchSize,t.sequenceLength,l,u),{inputs:[l,u],outputs:[-1]})[0],v=i.inputs[7],T=i.inputs[8],E=Ms({interleaved:e.rotaryInterleaved!==0,numHeads:t.numHeads,rotaryEmbeddingDim:0,scale:e.scale}),F=[h,w,v,T],I=[-1];m=i.compute(zf(F,E),{inputs:F,outputs:I})[0],F.splice(0,1,p);let z=Ms({interleaved:e.rotaryInterleaved!==0,numHeads:t.kvNumHeads,rotaryEmbeddingDim:0,scale:e.scale});x=i.compute(zf(F,z),{inputs:F,outputs:I})[0]}let g=kd(i,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,e.doRotary?m:h,void 0,0),_=U_(i,e.doRotary?x:p,t),S=U_(i,f,t);Jd(i,g,_,S,void 0,void 0,o,a,void 0,t,l,u)}}),G_,vC,SC,SI,Fz=Ze(()=>{kt(),Gt(),Va(),qt(),G_=(i,e,t,s,r,n,o,a)=>{let l=Js(n),u=l===1?"f32":`vec${l}f`,c=l===1?"vec2f":`mat2x${l}f`,d=r*o,h=64;d===1&&(h=256);let p=[r,o,n/l],f=[r,o,2],m=["rank","type","type"],x=[];x.push(...Tt(p,f));let g=_=>{let S=Oe("x",e.dataType,3,l),M=Oe("scale",t.dataType,t.dims),w=Oe("bias",s.dataType,s.dims),v=gt("output",1,3,2),T=[S,M,w,v];return`
  var<workgroup> workgroup_shared : array<${c}, ${h}>;
  const workgroup_size = ${h}u;
  ${_.declareVariables(...T)}
  ${_.mainStart(h)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${u}(0);
    var squared_sum = ${u}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${u}(${S.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${c}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Oa("workgroup_shared[0][0]",l)} / f32(hight * ${l});
      let squared_sum_final = ${Oa("workgroup_shared[0][1]",l)} / f32(hight * ${l});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${a}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return i.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${a};${h}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:d},programUniforms:x}),getShaderSource:g},{inputs:[e,t,s],outputs:[-1]})[0]},vC=(i,e,t)=>{let s=e[0].dims,r=s,n=2,o=s[0],a=s[1],l=Ae.sizeFromDimension(s,n),u=Js(l),c=Ae.size(r)/u,d=G_(i,e[0],e[1],e[2],o,l,a,t.epsilon),h=[o,a,l/u],p=[o,a],f=["type","none"],m=x=>{let g=Oe("x",e[0].dataType,h.length,u),_=Oe("scale_shift",1,p.length,2),S=gt("output",e[0].dataType,h.length,u),M=[g,_,S];return`
  ${x.registerUniform("output_size","u32").declareVariables(...M)}
  ${x.mainStart()}
  ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${S.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${_.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${g.getByOffset("global_idx")} * ${S.type.value}(scale_shift.x) + ${S.type.value}(scale_shift.y);
      ${S.setByOffset("global_idx","value")};
  }`};i.compute({name:"InstanceNormalization",shaderCache:{hint:`${u}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},...Tt(h,p,h)]}),getShaderSource:m},{inputs:[e[0],d]})},SC=(i,e,t)=>{let s=e[0].dims,r=s,n=s[0],o=s[s.length-1],a=Ae.sizeFromDimension(s,1)/o,l=Js(o),u=Ae.size(r)/l,c=[{type:12,data:a},{type:12,data:Math.floor(o/l)}],d=["type","type"],h=!1,p=[0,s.length-1];for(let g=0;g<s.length-2;g++)h=h||s[g+1]!==1,p.push(g+1);h=h&&s[s.length-1]!==1;let f=h?i.compute(Xr(i.inputs[0],p),{inputs:[i.inputs[0]],outputs:[-1]})[0]:i.inputs[0].reshape(Array.from({length:s.length},(g,_)=>s[p[_]])),m=G_(i,f,e[1],e[2],n,a,o,t.epsilon),x=g=>{let _=Ui(e[0].dataType),S=l===1?"vec2f":`mat${l}x2f`,M=T=>{let E=T===0?"x":"y",F=l===1?"f32":`vec${l}f`;switch(l){case 1:return`${_}(${F}(scale.${E}))`;case 2:return`vec2<${_}>(${F}(scale[0].${E}, scale[1].${E}))`;case 4:return`vec4<${_}>(${F}(scale[0].${E}, scale[1].${E}, scale[2].${E}, scale[3].${E}))`;default:throw new Error(`Not supported compoents ${l}`)}},w=Oe("input",e[0].dataType,e[0].dims,l),v=gt("output",e[0].dataType,r,l);return`
  @group(0) @binding(0) var<storage, read> input : array<${w.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${S}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${v.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${g.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${M(0)}, ${M(1)});
  }`};i.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:x},{inputs:[e[0],m]})},SI=(i,e)=>{e.format==="NHWC"?SC(i,i.inputs,e):vC(i,i.inputs,e)}}),EC,AC,EI,Rz=Ze(()=>{kt(),Gt(),qt(),EC=i=>{if(!i||i.length<2)throw new Error("layerNorm requires at least 2 inputs.")},AC=(i,e,t)=>{let s=e.simplified,r=i[0].dims,n=i[1],o=!s&&i[2],a=r,l=Ae.normalizeAxis(e.axis,r.length),u=Ae.sizeToDimension(r,l),c=Ae.sizeFromDimension(r,l),d=Ae.size(n.dims),h=o?Ae.size(o.dims):0;if(d!==c||o&&h!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${d} and bias size of ${h}`);let p=[];for(let w=0;w<r.length;++w)w<l?p.push(r[w]):p.push(1);let f=Js(c),m=["type","type"],x=[{type:12,data:u},{type:1,data:c},{type:12,data:Math.floor(c/f)},{type:1,data:e.epsilon}];o&&m.push("type");let g=t>1,_=t>2,S=w=>{let v=Ui(i[0].dataType),T=[Oe("x",i[0].dataType,i[0].dims,f),Oe("scale",n.dataType,n.dims,f)];o&&T.push(Oe("bias",o.dataType,o.dims,f)),T.push(gt("output",i[0].dataType,a,f)),g&&T.push(gt("mean_data_output",1,p)),_&&T.push(gt("inv_std_output",1,p));let E=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${w.registerUniforms(E).declareVariables(...T)}
  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Sx("f32",f)};
    var mean_square_vector = ${Sx("f32",f)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Yu(v,f,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Oa("mean_vector",f)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Oa("mean_square_vector",f)} / uniforms.norm_size ${s?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Yu(v,f,"x[j + offset]")};
      let f32scale = ${Yu(v,f,"scale[j]")};
      output[j + offset] = ${T[0].type.value}((f32input ${s?"":"- mean"}) * inv_std_dev * f32scale
        ${o?`+ ${Yu(v,f,"bias[j]")}`:""}
      );
    }

    ${g?"mean_data_output[global_idx] = mean":""};
    ${_?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},M=[{dims:a,dataType:i[0].dataType}];return g&&M.push({dims:p,dataType:1}),_&&M.push({dims:p,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${t};${s}`,inputDependencies:m},getRunData:()=>({outputs:M,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:x}),getShaderSource:S}},EI=(i,e)=>{EC(i.inputs),i.compute(AC(i.inputs,e,i.outputCount))}}),CC,AI,Iz=Ze(()=>{Gt(),Qb(),Zb(),CC=i=>{if(!i||i.length!==2)throw new Error("MatMul requires 2 inputs.");if(i[0].dims[i[0].dims.length-1]!==i[1].dims[i[1].dims.length-2])throw new Error("shared dimension does not match.")},AI=i=>{CC(i.inputs);let e=hc.calcShape(i.inputs[0].dims,i.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let t=e[e.length-1],s=i.inputs[0].dims[i.inputs[0].dims.length-1];if(t<8&&s<8)i.compute(Yb(i.inputs,{activation:""},e));else{let r=e[e.length-2],n=Ae.size(i.inputs[0].dims.slice(0,-2)),o=Ae.size(i.inputs[1].dims.slice(0,-2));if(n!==1&&r===1&&o===1){let a=i.inputs[0].reshape([1,n,s]),l=i.inputs[1].reshape([1,s,t]),u=[1,n,t],c=[a,l];i.compute($f(c,{activation:""},e,u),{inputs:c})}else i.compute($f(i.inputs,{activation:""},e))}}}),PC,NC,FC,CI,PI,Dz=Ze(()=>{kt(),Gt(),oi(),qt(),PC=(i,e)=>{if(i.length<3||i.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let t=i[0],s=t.dims.length;if(t.dims[s-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let r=Math.floor((e.k+e.blockSize-1)/e.blockSize),n=e.blockSize/8*e.bits,o=i[1];if(!Ae.areEqual(o.dims,[e.n,r,n]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let a=i[2].dims;if(Ae.size(a)!==e.n*r)throw new Error("scales input size error.");if(i.length===4){let l=i[3].dims,u=e.bits>4?e.n*r:e.n*Math.floor((r+1)/2);if(Ae.size(l)!==u)throw new Error("zeroPoints input size error.")}},NC=(i,e)=>{let t=i[0].dims,s=t.length,r=t[s-2],n=e.k,o=e.n,a=t.slice(0,s-2),l=Ae.size(a),u=i[1].dims[2]/4,c=i[0].dataType,d=Js(e.k),h=Js(u),p=Js(o),f=a.concat([r,o]),m=r>1&&o/p%2===0?2:1,x=Ae.size(f)/p/m,g=64,_=[],S=[l,r,n/d],M=Ae.convertShape(i[1].dims).slice();M.splice(-1,1,u/h),_.push(...Tt(S)),_.push(...Tt(M)),_.push(...Tt(i[2].dims)),i.length===4&&_.push(...Tt(Ae.convertShape(i[3].dims)));let w=[l,r,o/p];_.push(...Tt(w));let v=T=>{let E=S.length,F=Oe("a",i[0].dataType,E,d),I=Oe("b",12,M.length,h),z=Oe("scales",i[2].dataType,i[2].dims.length),G=[F,I,z],L=i.length===4?Oe("zero_points",12,i[3].dims.length):void 0;L&&G.push(L);let Q=w.length,q=gt("output",i[0].dataType,Q,p),J=Ui(i[0].dataType),ee=(()=>{switch(d){case 1:return`array<${J}, 8>`;case 2:return`mat4x2<${J}>`;case 4:return`mat2x4<${J}>`;default:throw new Error(`${d}-component is not supported.`)}})(),se=()=>{let U=`
          // reuse a data
            var input_offset = ${F.indicesToOffset(`${F.type.indices}(batch, row, word_offset)`)};
            var a_data: ${ee};
            for (var j: u32 = 0; j < ${8/d}; j++) {
              a_data[j] = ${F.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let k=0;k<p*m;k++)U+=`
            b_value = ${h===1?`b${k}_data`:`b${k}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${ee}(${Array.from({length:4},(j,re)=>`${J}(b_value_lower[${re}]), ${J}(b_value_upper[${re}])`).join(", ")});
            b_dequantized_values = ${d===1?`${ee}(${Array.from({length:8},(j,re)=>`(b_quantized_values[${re}] - ${L?`zero_point${k}`:"zero_point"}) * scale${k}`).join(", ")});`:`(b_quantized_values - ${ee}(${Array(8).fill(`${L?`zero_point${k}`:"zero_point"}`).join(",")})) * scale${k};`};
            workgroup_shared[local_id.x * ${m} + ${Math.floor(k/p)}]${p>1?`[${k%p}]`:""} += ${Array.from({length:8/d},(j,re)=>`${d===1?`a_data[${re}] * b_dequantized_values[${re}]`:`dot(a_data[${re}], b_dequantized_values[${re}])`}`).join(" + ")};
          `;return U},fe=()=>{let U=`
            var col_index = col * ${p};
            ${L?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${J}(8);`}
            `;for(let k=0;k<p*m;k++)U+=`
            let scale${k} = ${z.getByOffset("col_index * nBlocksPerCol + block")};
            ${L?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${L.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${k} = ${J}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return U},ue=()=>{let U=`col_index = col * ${p};`;for(let k=0;k<p*m;k++)U+=`
            let b${k}_data = ${I.getByIndices(`${I.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return U+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${ee};
            var b_dequantized_values: ${ee};`,U};return`
        var<workgroup> workgroup_shared: array<${q.type.value}, ${m*g}>;
        ${T.declareVariables(...G,q)}
        ${T.mainStart([g,1,1])}
          let output_indices = ${q.offsetToIndices(`(global_idx / ${g}) * ${m}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${g}) {
            //process one block
            var word_offset: u32 = block * ${e.blockSize/d};
            ${fe()}
            for (var word: u32 = 0; word < ${u}; word += ${h}) {
              ${ue()}
              for (var i: u32 = 0; i < ${h}; i++) {
                ${se()}
                word_offset += ${8/d};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${m}) {
            var output_value: ${q.type.value} = ${q.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${g}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${m};
            }
            ${q.setByIndices(`${q.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${e.blockSize};${e.bits};${d};${h};${p};${m};${g}`,inputDependencies:Array(i.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:c}],dispatchGroup:{x},programUniforms:_}),getShaderSource:v}},FC=(i,e)=>{let t=i[0].dims,s=t.length,r=t[s-2],n=e.k,o=e.n,a=t.slice(0,s-2),l=Ae.size(a),u=i[1].dims[2]/4,c=i[0].dataType,d=Js(e.k),h=Js(u),p=a.concat([r,o]),f=128,m=o%8===0?8:o%4===0?4:1,x=f/m,g=x*h*8,_=g/d,S=g/e.blockSize,M=Ae.size(p)/m,w=[],v=[l,r,n/d],T=Ae.convertShape(i[1].dims).slice();T.splice(-1,1,u/h),w.push(...Tt(v)),w.push(...Tt(T)),w.push(...Tt(i[2].dims)),i.length===4&&w.push(...Tt(Ae.convertShape(i[3].dims)));let E=[l,r,o];w.push(...Tt(E));let F=I=>{let z=v.length,G=Oe("a",i[0].dataType,z,d),L=Oe("b",12,T.length,h),Q=Oe("scales",i[2].dataType,i[2].dims.length),q=[G,L,Q],J=i.length===4?Oe("zero_points",12,i[3].dims.length):void 0;J&&q.push(J);let ee=E.length,se=gt("output",i[0].dataType,ee),fe=Ui(i[0].dataType),ue=()=>{switch(d){case 1:return`
          let a_data0 = vec4<${fe}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${fe}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${fe}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${fe}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${d}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${G.type.value}, ${_}>;
        var<workgroup> inter_results: array<array<${se.type.value}, ${x}>, ${m}>;
        ${I.declareVariables(...q,se)}
        ${I.mainStart([x,m,1])}
          let output_indices = ${se.offsetToIndices(`workgroup_index * ${m}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${S} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${_};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${_}; a_offset += ${f})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${G.getByIndices(`${G.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${G.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${S} + local_id.x;
            ${J?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${J.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${fe}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${fe}(8);`}
            let scale = ${Q.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${L.getByIndices(`${L.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${e.blockSize/d};
            for (var i: u32 = 0; i < ${h}; i++) {
              ${ue()}
              let b_value = ${h===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${fe}>(${Array.from({length:4},(U,k)=>`${fe}(b_value_lower[${k}]), ${fe}(b_value_upper[${k}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${fe}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(U,k)=>`${`dot(a_data${k}, b_dequantized_values[${k}])`}`).join(" + ")};
              word_offset += ${8/d};
            }
            workgroupBarrier();
          }

          if (local_idx < ${m}) {
            var output_value: ${se.type.value} = ${se.type.value}(0);
            for (var b = 0u; b < ${x}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${se.setByIndices(`${se.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${e.blockSize};${d};${h};${x};${m}`,inputDependencies:Array(i.length).fill("rank")},getRunData:()=>({outputs:[{dims:p,dataType:c}],dispatchGroup:{x:M},programUniforms:w}),getShaderSource:F}},CI=(i,e)=>{PC(i.inputs,e),e.blockSize===32&&i.adapterInfo.isVendor("intel")&&i.adapterInfo.isArchitecture("gen-12lp")?i.compute(FC(i.inputs,e)):i.compute(NC(i.inputs,e))},PI=i=>Ms(i)}),RC,IC,DC,kC,LC,BC,OC,$C,NI,kz=Ze(()=>{kt(),Gt(),qt(),RC=i=>{if(!i||i.length<1)throw new Error("Too few inputs");if(i[0].dataType!==1&&i[0].dataType!==10)throw new Error("Input type must be float or float16.");if(i.length>=2){let e=i[0].dims.length*2===i[1].dims[0];if(i.length===4&&(e=i[3].dims[0]*2===i[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},IC=(i,e,t)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
            k = i32(${i.indicesGet("indices",r)}) - ${xt("uniforms.pads",r,t)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${xt("uniforms.x_shape",r,e)})) {
              break;
            }
            offset += k * i32(${xt("uniforms.x_strides",r,e)});
        `;return`
          value = ${i.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${s}
            value = x[offset];
          }
      `},DC=(i,e,t)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${i.indicesGet("indices",r)}) - ${xt("uniforms.pads",r,t)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${xt("uniforms.x_shape",r,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${xt("uniforms.x_shape",r,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${xt("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},kC=(i,e,t)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${i.indicesGet("indices",r)}) - ${xt("uniforms.pads",r,t)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${xt("uniforms.x_shape",r,e)})) {
                  k = i32(${xt("uniforms.x_shape",r,e)}) - 1;
                }
                offset += k * i32(${xt("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},LC=(i,e,t)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${i.indicesGet("indices",r)}) - ${xt("uniforms.pads",r,t)};
                if (k < 0)  {
                  k += i32(${xt("uniforms.x_shape",r,e)}]);
                }
                if (k >= i32(${xt("uniforms.x_shape",r,e)})) {
                  k -= i32(${xt("uniforms.x_shape",r,e)});
                }
                offset += k * i32(${xt("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},BC=(i,e,t)=>{switch(t.mode){case 0:return IC(i,e,t.pads.length);case 1:return DC(i,e,t.pads.length);case 2:return kC(i,e,t.pads.length);case 3:return LC(i,e,t.pads.length);default:throw new Error("Invalid mode")}},OC=(i,e)=>{let t=Ae.padShape(i[0].dims.slice(),e.pads),s=i[0].dims,r=Ae.size(t),n=[{type:12,data:r},{type:6,data:e.pads}],o=i.length>=3&&i[2].data;e.mode===0&&n.push({type:o?i[2].dataType:1,data:e.value}),n.push(...Tt(i[0].dims,t));let a=["rank"],l=u=>{let c=gt("output",i[0].dataType,t.length),d=Oe("x",i[0].dataType,s.length),h=d.type.value,p=BC(c,s.length,e),f=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&f.push({name:"constant_value",type:o?h:"f32"}),`
            ${u.registerUniforms(f).declareVariables(d,c)}
            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${c.offsetToIndices("global_idx")};

            var value = ${h}(0);
            ${p}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}${o}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:t,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(Ae.size(t)/64)},programUniforms:n}),getShaderSource:l}},$C=(i,e)=>{if(i.length>1){let t=i[1].getBigInt64Array(),s=i.length>=3&&i[2].data?i[2].dataType===10?i[2].getUint16Array()[0]:i[2].getFloat32Array()[0]:0,r=i[0].dims.length,n=new Int32Array(2*r).fill(0);if(i.length>=4){let a=i[3].getBigInt64Array();for(let l=0;l<a.length;l++)n[Number(a[l])]=Number(t[l]),n[Number(a[l])+r]=Number(t[l+a.length])}else t.forEach((a,l)=>n[Number(l)]=Number(a));let o=[];return n.forEach(a=>o.push(a)),{mode:e.mode,value:s,pads:o}}else return e},NI=(i,e)=>{RC(i.inputs);let t=$C(i.inputs,e);i.compute(OC(i.inputs,t),{inputs:[0]})}}),ld,j_,W_,H_,q_,zC,VC,K_,X_,FI,RI,Y_,II,DI,Q_,kI,LI,BI,OI,Lz=Ze(()=>{Xn(),kt(),Gt(),qt(),ld=i=>{if(Vs.webgpu.validateInputContent&&(!i||i.length!==1))throw new Error("Pool ops requires 1 input.")},j_=(i,e,t)=>{let s=e.format==="NHWC",r=i.dims.slice();s&&r.splice(1,0,r.pop());let n=Object.hasOwnProperty.call(e,"dilations"),o=e.kernelShape.slice(),a=e.strides.slice(),l=n?e.dilations.slice():[],u=e.pads.slice();Bf.adjustPoolAttributes(t,r,o,a,l,u);let c=Bf.computePoolOutputShape(t,r,a,l,o,u,e.autoPad),d=Object.assign({},e);n?Object.assign(d,{kernelShape:o,strides:a,pads:u,dilations:l,cacheKey:e.cacheKey}):Object.assign(d,{kernelShape:o,strides:a,pads:u,cacheKey:e.cacheKey});let h=c.slice();return h.push(h.splice(1,1)[0]),[d,s?h:c]},W_=(i,e)=>{let t=e.format==="NHWC",s=Ae.size(i),r=Ae.size(e.kernelShape),n=[{type:12,data:s},{type:12,data:r}],o=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let a=e.kernelShape[e.kernelShape.length-1],l=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],c=e.pads[e.pads.length-1],d=!!(u+c);n.push({type:12,data:a},{type:12,data:l},{type:12,data:u},{type:12,data:c}),o.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let h=!1;if(e.kernelShape.length===2){let p=e.kernelShape[e.kernelShape.length-2],f=e.strides[e.strides.length-2],m=e.pads[e.pads.length/2-2],x=e.pads[e.pads.length-2];h=!!(m+x),n.push({type:12,data:p},{type:12,data:f},{type:12,data:m},{type:12,data:x}),o.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[n,o,!0,d,h]}else{if(t)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let a=Ae.computeStrides(e.kernelShape);n.push({type:12,data:a},{type:12,data:e.pads},{type:12,data:e.strides}),o.push({name:"kernelStrides",type:"u32",length:a.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let l=e.pads.reduce((u,c)=>u+c);return[n,o,!!l,!1,!1]}},H_=(i,e,t,s,r,n,o,a,l,u,c,d)=>{let h=r.format==="NHWC",p=e.type.value,f=gt("output",e.type.tensor,s);if(r.kernelShape.length<=2){let m="",x="",g="",_=t-(h?2:1);if(c?m=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${_}] < 0 || xIndices[${_}]
                      >= uniforms.x_shape[${_}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${n}
                }`:m=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${n}
                }`,r.kernelShape.length===2){let S=t-(h?3:2);d?x=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${S}] < 0 || xIndices[${S}] >= uniforms.x_shape[${S}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:x=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sh - uniforms.phStart + j;
                `,g=`
              }
            `}return`
            ${i.registerUniforms(l).declareVariables(e,f)}

            ${i.mainStart()}
              ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${f.offsetToIndices("global_idx")};
              var xIndices = ${f.offsetToIndices("global_idx")};

              var value = ${p}(${a});
              var pad = 0;
              ${x}
              ${m}
              ${g}
              ${o}

              output[global_idx] = value;
            }`}else{if(h)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let m=r.kernelShape.length,x=r.pads.length,g="";return u?g=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${n}
              }`:g=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${n}
            `,`
            ${i.registerUniforms(l).declareVariables(e,f)}

            ${i.mainStart()}
              ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${f.offsetToIndices("global_idx")};
              var xIndices = ${f.offsetToIndices("global_idx")};

              var offsets: array<u32, ${m}>;

              var value = ${p}(${a});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${m-1}u; j++) {
                  offsets[j] = offset / ${xt("uniforms.kernelStrides","j",m)};
                  offset -= offsets[j] * ${xt("uniforms.kernelStrides","j",m)};
                }
                offsets[${m-1}] = offset;

                isPad = false;
                for (var j = ${t-m}u; j < ${t}u; j++) {
                  xIndices[j] = indices[j] * ${xt("uniforms.strides",`j - ${t-m}u`,m)}
                    + offsets[j - ${t-m}u] - ${xt("uniforms.pads","j - 2u",x)};
                  ${g}
              }
              ${o}

              output[global_idx] = value;
            }`}},q_=i=>`${i.format};${i.ceilMode};${i.autoPad};${i.kernelShape.length}`,zC=i=>`${q_(i)};${i.countIncludePad}`,VC=i=>`${q_(i)};${i.storageOrder};${i.dilations}`,K_=i=>({format:i.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][i.auto_pad],ceilMode:i.ceil_mode,kernelShape:i.kernel_shape,strides:i.strides,pads:i.pads}),X_=(i,e,t,s)=>{let[r,n]=j_(e,s,t),o=Oe("x",e.dataType,e.dims.length),a=o.type.value,l="value += x_val;",u="";r.countIncludePad?u+=`value /= ${a}(uniforms.kernelSize);`:u+=`value /= ${a}(i32(uniforms.kernelSize) - pad);`;let[c,d,h,p,f]=W_(n,r);c.push(...Tt(e.dims,n));let m=["rank"];return{name:i,shaderCache:{hint:`${s.cacheKey};${h};${p};${f}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:n,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(Ae.size(n)/64)},programUniforms:c}),getShaderSource:x=>H_(x,o,e.dims.length,n.length,r,l,u,0,d,h,p,f)}},FI=i=>{let e=i.count_include_pad!==0,t=K_(i);if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let s={countIncludePad:e,...t,cacheKey:""};return{...s,cacheKey:zC(s)}},RI=(i,e)=>{ld(i.inputs),i.compute(X_("AveragePool",i.inputs[0],!1,e))},Y_={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},II=i=>{let e=i.format;return{format:e,...Y_,cacheKey:e}},DI=(i,e)=>{ld(i.inputs),i.compute(X_("GlobalAveragePool",i.inputs[0],!0,e))},Q_=(i,e,t,s)=>{let[r,n]=j_(e,s,t),o=`
      value = max(x_val, value);
    `,a="",l=Oe("x",e.dataType,e.dims.length),u=["rank"],[c,d,h,p,f]=W_(n,r);return c.push(...Tt(e.dims,n)),{name:i,shaderCache:{hint:`${s.cacheKey};${h};${p};${f}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:n,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(Ae.size(n)/64)},programUniforms:c}),getShaderSource:m=>H_(m,l,e.dims.length,n.length,r,o,a,e.dataType===10?-65504:-1e5,d,h,p,f)}},kI=(i,e)=>{ld(i.inputs),i.compute(Q_("MaxPool",i.inputs[0],!1,e))},LI=i=>{let e=i.storage_order,t=i.dilations,s=K_(i);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let r={storageOrder:e,dilations:t,...s,cacheKey:""};return{...r,cacheKey:VC(r)}},BI=i=>{let e=i.format;return{format:e,...Y_,cacheKey:e}},OI=(i,e)=>{ld(i.inputs),i.compute(Q_("GlobalMaxPool",i.inputs[0],!0,e))}}),UC,GC,$I,zI,Bz=Ze(()=>{kt(),Gt(),oi(),qt(),UC=(i,e)=>{if(i.length<2||i.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(i.length===3&&i[1].dims===i[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(i.length===3&&i[0].dataType!==i[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(i[0].dataType===6&&i.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(i[1].dims.length!==0&&i[1].dims.length!==1&&i[1].dims.length!==i[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(i.length>2){if(i[0].dataType!==i[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(i[1].dims.length!==i[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!i[1].dims.map((t,s)=>t===i[2].dims[s]).reduce((t,s)=>t&&s,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(e.blockSize>0){if(i[1].dims.length===0||i[1].dims.length===1&&i[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!i[1].dims.map((r,n)=>n===e.axis||r===i[0].dims[n]).reduce((r,n)=>r&&n,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(i[1].dims.length!==i[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let t=i[0].dims[e.axis],s=i[1].dims[e.axis];if(e.blockSize<Math.ceil(t/s)||e.blockSize>Math.ceil(t/(s-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},GC=(i,e)=>{let t=Ae.normalizeAxis(e.axis,i[0].dims.length),s=i[0].dataType,r=s===3,n=i[0].dims,o=i[1].dataType,a=Ae.size(n),l=s===3||s===2,u=l?[Math.ceil(Ae.size(i[0].dims)/4)]:i[0].dims,c=i[1].dims,d=i.length>2?i[2]:void 0,h=d?l?[Math.ceil(Ae.size(d.dims)/4)]:d.dims:void 0,p=c.length===0||c.length===1&&c[0]===1,f=p===!1&&c.length===1,m=Js(a),x=p&&(!l||m===4),g=x?m:1,_=x&&!l?m:1,S=Oe("input",l?12:s,u.length,_),M=Oe("scale",o,c.length),w=d?Oe("zero_point",l?12:s,h.length):void 0,v=gt("output",o,n.length,g),T=[S,M];w&&T.push(w);let E=[u,c];d&&E.push(h);let F=[{type:12,data:a/g},{type:12,data:t},{type:12,data:e.blockSize},...Tt(...E,n)],I=z=>{let G=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${z.registerUniforms(G).declareVariables(...T,v)}
      ${z.mainStart()}
          ${z.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${v.offsetToIndices("global_idx")};

          // Set input x
          ${l?`
            let input = ${S.getByOffset("global_idx / 4")};
            let x_vec = ${r?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${g===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${S.getByOffset("global_idx")};`};

          // Set scale input
          ${p?`let scale_value= ${M.getByOffset("0")}`:f?`
            let scale_index = ${v.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${M.getByOffset("scale_index")};`:`
            var scale_indices: ${M.type.indices} = output_indices;
            let index = ${M.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${M.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${M.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${w?p?l?`
                let zero_point_input = ${w.getByOffset("0")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${w.getByOffset("0")}`:f?l?`
                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${w.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${w.getByOffset("zero_point_index")};`:l?`
                let zero_point_offset = ${M.indicesToOffset("scale_indices")};
                let zero_point_input = ${w.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${w.getByIndices("scale_indices")};`:`let zero_point_value = ${l?r?"i32":"u32":S.type.value}(0);`};
      // Compute and write output
      ${v.setByOffset("global_idx",`${v.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:e.cacheKey,inputDependencies:w?["rank","rank","rank"]:["rank","rank"]},getShaderSource:I,getRunData:()=>({outputs:[{dims:n,dataType:o}],dispatchGroup:{x:Math.ceil(a/g/64),y:1,z:1},programUniforms:F})}},$I=(i,e)=>{UC(i.inputs,e),i.compute(GC(i.inputs,e))},zI=i=>Ms({axis:i.axis,blockSize:i.blockSize})}),jC,WC,VI,Oz=Ze(()=>{Xn(),kt(),qt(),jC=(i,e,t)=>{let s=i===e,r=i<e&&t<0,n=i>e&&t>0;if(s||r||n)throw new Error("Range these inputs' contents are invalid.")},WC=(i,e,t,s)=>{let r=Math.abs(Math.ceil((e-i)/t)),n=[r],o=r,a=[{type:12,data:o},{type:s,data:i},{type:s,data:t},...Tt(n)],l=u=>{let c=gt("output",s,n.length),d=c.type.value,h=[{name:"outputSize",type:"u32"},{name:"start",type:d},{name:"delta",type:d}];return`
        ${u.registerUniforms(h).declareVariables(c)}
        ${u.mainStart()}
        ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${d}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${s}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:n,dataType:s}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:a})}},VI=i=>{let e=0,t=0,s=0;i.inputs[0].dataType===6?(e=i.inputs[0].getInt32Array()[0],t=i.inputs[1].getInt32Array()[0],s=i.inputs[2].getInt32Array()[0]):i.inputs[0].dataType===1&&(e=i.inputs[0].getFloat32Array()[0],t=i.inputs[1].getFloat32Array()[0],s=i.inputs[2].getFloat32Array()[0]),Vs.webgpu.validateInputContent&&jC(e,t,s),i.compute(WC(e,t,s,i.inputs[0].dataType),{inputs:[]})}}),HC,Z_,J_,qC,UI,GI,$z=Ze(()=>{kt(),Gt(),oi(),qt(),HC=(i,e,t,s)=>{if(i!=="none"&&s!=="i32"&&s!=="u32"&&s!=="f32")throw new Error(`Input ${s} is not supported with reduction ${i}.`);let r=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,n=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${e}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(i){case"none":return`${e}=${t};`;case"add":return s==="i32"||s==="u32"?`atomicAdd(&${e}, bitcast<${s}>(${t}));`:`
              ${r}bitcast<${s}>(oldValue) + (${t})${n}`;case"max":return s==="i32"||s==="u32"?`atomicMax(&${e}, bitcast<${s}>(${t}));`:`
                ${r}max(bitcast<f32>(oldValue), (${t}))${n}`;case"min":return s==="i32"||s==="u32"?`atomicMin(&${e}, bitcast<${s}>(${t}));`:`${r}min(bitcast<${s}>(oldValue), (${t}))${n}`;case"mul":return`${r}(bitcast<${s}>(oldValue) * (${t}))${n}`;default:throw new Error(`Reduction ${i} is not supported.`)}},Z_=(i,e)=>`${i===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[${e?"i - indices_start":"i"}];
    let dim_value = uniforms.output_shape[${e?"i - indices_start":"i"} + uniforms.last_index_dimension];`}
    
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));`,J_=(i,e,t)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {
        let value = updates[uniforms.num_updates_elements * ${t?"global_idx":"idx"} + i];
        ${HC(i.reduction,"output[data_offset + i]","value",e)}
      }`,qC=(i,e)=>{let t=i[0].dims,s=i[1].dims,r=t,n=1,o=Math.ceil(Ae.size(s)/n),a=s[s.length-1],l=Ae.sizeFromDimension(t,a),u=Ae.sizeFromDimension(s,0)/a,c=[{type:12,data:o},{type:12,data:a},{type:12,data:l},...Tt(i[1].dims,i[2].dims,r)],d=h=>{let p=Oe("indices",i[1].dataType,i[1].dims.length),f=Oe("updates",i[2].dataType,i[2].dims.length,n),m=e.reduction!=="none"&&e.reduction!==""?_F("output",i[0].dataType,r.length):gt("output",i[0].dataType,r.length,n);return`
      ${h.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(p,f,m)}
      ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${e.reduction==="none"}) {
    for (var i = 0; i < ${u}; i = i + 1) {
      for (var j = i + 1; j < ${u}; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  if (${e.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    // Process each index-update pair individually when duplicates exist
    for (var idx = 0u; idx < ${u}u; idx++) {
      var data_offset = 0u;
      for (var i = 0u; i < uniforms.last_index_dimension; i++) {
        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);
        ${Z_(t.length,!1)}
      }
      ${J_(e,m.type.value,!1)}
    }
    return;
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  var indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${Z_(t.length,!0)}
  }
  ${J_(e,m.type.value,!0)}
  }`};return{name:"ScatterND",shaderCache:{hint:`${e.cacheKey}_${e.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:c}),getShaderSource:d}},UI=i=>Ms({reduction:i.reduction}),GI=(i,e)=>{i.compute(qC(i.inputs,e),{inputs:[i.inputs[1],i.inputs[2]],outputs:[]})}}),KC,XC,YC,ey,QC,ZC,JC,eP,tP,sP,iP,rP,ty,nP,oP,aP,lP,uP,jI,WI,zz=Ze(()=>{kt(),Gt(),oi(),qt(),KC=(i,e)=>{if(i.every(t=>t>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),i.length>0){if(e.mode==="linear"){if(!(i.length===2||i.length===3||i.length===4&&i[0]===1&&i[1]===1||i.length===4&&i[0]===1&&i[3]===1||i.length===5&&i[0]===1&&i[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(i.length===2||i.length===4&&i[0]===1&&i[1]===1||i.length===4&&i[0]===1&&i[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},XC=(i,e,t)=>{e.every(r=>r>=0&&r<t||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let s=new Array(t).fill(1);return e.forEach((r,n)=>s[r]=i[n]),s},YC=(i,e,t,s,r,n)=>{let[o,a,l]=t>10?[1,2,3]:[-1,i.length>1?1:-1,-1],u=i[0].dims.length;if(o>0&&i.length>o&&i[o].dims.length>0)i[o].getFloat32Array().forEach(c=>n.push(c));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(a>0&&i.length>a&&i[a].dims.length===1&&i[a].dims[0]>0){if(i[a].getFloat32Array().forEach(c=>s.push(c)),s.length!==0&&s.length!==u&&t>=18&&s.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");KC(s,e),e.axes.length>0&&XC(s,e.axes,u).forEach((c,d)=>s[d]=c)}if(l>0&&i.length>l&&i[l].dims.length===1&&i[l].dims[0]>0&&(i[l].getBigInt64Array().forEach(c=>r.push(Number(c))),r.length!==0&&r.length!==u&&t>=18&&r.length!==e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(s.length!==0&&s.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(r.length!==0&&r.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof s<"u"&&typeof r<"u"&&s.length>0&&r.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},ey=(i,e,t,s)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${i}) * (${e});
  let whole = ${s}(big / (${t}));
  let fract = ${s}(big % (${t})) / ${s}(${t});
  return whole + fract;
`,QC=(i,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(i){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${e}(xResized) / ${e}(xScale);
          } else {
            ${ey("xResized","lengthOriginal","lengthResized",e)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${ey("xResized","lengthOriginal - 1","lengthResized - 1",e)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${i} is not supported`)}})()+"}",ZC=(i,e,t)=>`fn getNearestPixelFromOriginal(xOriginal: ${t}, isDownSample: bool) -> ${t} {`+(()=>{switch(i){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${i} is not supported`)}})()+"}",JC=(i,e,t)=>{let s=new Array(t).fill(0).concat(new Array(t).fill(1)),r=i.length===0?s:i.slice();return e.length>0?(e.forEach((n,o)=>{s[n]=r[o],s[o+t]=r[e.length+o]}),s):r},eP=(i,e,t,s)=>{let r=[];if(t.length>0)if(s.length>0){if(i.forEach(n=>r.push(n)),Math.max(...s)>i.length)throw new Error("axes is out of bound");s.forEach((n,o)=>r[n]=t[o])}else t.forEach(n=>r.push(n));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");r=i.map((n,o)=>Math.round(n*e[o]))}return r},tP=(i,e,t)=>{let s=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(n=>e[n]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(n=>e[n]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let r=i.slice();return t.axes.length>0?(t.axes.forEach(n=>e[n]=s),t.axes.forEach(n=>r[n]=Math.round(i[n]*e[n]))):(e.fill(s,0,e.length),r.forEach((n,o)=>r[o]=Math.round(n*e[o]))),r},sP=(i,e,t,s,r)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${i.type.indices}) -> array<${i.type.value}, ${t.length}> {
      var original_indices: array<${i.type.value}, ${t.length}>;
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var output_index = ${i.indicesGet("output_indices","i")};
        var scale = ${xt("uniforms.scales","i",s)};
        var roi_low = ${xt("uniforms.roi","i",r)};
        var roi_hi = ${xt("uniforms.roi",`i + ${e.length}`,r)};
        if (scale == 1.0) {
          original_indices[i] = ${i.type.value}(output_index);
        } else {
          var input_shape_i = ${xt("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${xt("uniforms.output_shape","i",t.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,iP=(i,e,t,s,r,n,o)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${i.type.indices} {
      var input_indices: ${i.type.indices};
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${xt("uniforms.scales","i",r)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${xt("uniforms.roi","i",n)};
          var roi_hi = ${xt("uniforms.roi",`i + ${t.length}`,n)};
          var input_shape_i = ${xt("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${xt("uniforms.output_shape","i",s.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${o} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${i.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,rP=(i,e)=>`
    fn checkInputIndices(input_indices: ${i.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${i.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${xt("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,ty=(i,e,t,s)=>i.rank>s?`
    ${i.indicesSet("input_indices",e,"channel")};
    ${i.indicesSet("input_indices",t,"batch")};
`:"",nP=(i,e,t,s,r)=>{let[n,o,a,l]=t.length===2?[-1,0,1,-1]:[0,2,3,1],u=i.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {
      var input_indices: ${i.type.indices};
      ${i.indicesSet("input_indices",o,`max(0, min(row, ${t[o]} - 1))`)};
      ${i.indicesSet("input_indices",a,`max(0, min(col, ${t[a]} - 1))`)};
      ${ty(i,l,n,2)}
      return ${i.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${u} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${u} = originalIndices[${o}];
      var col:${u} = originalIndices[${a}];
      ${s?`if (row < 0 || row > (${t[o]} - 1) || col < 0 || col > (${t[a]} - 1)) {
        return ${r};
      }`:""};
      row = max(0, min(row, ${t[o]} - 1));
      col = max(0, min(col, ${t[a]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${t.length>2?`u32(originalIndices[${l}])`:"0"};
      var batch: u32 =  ${t.length>2?`u32(originalIndices[${n}])`:"0"};
      var x11: ${u} = getInputValue(batch, channel, row1, col1);
      var x12: ${u} = getInputValue(batch, channel, row1, col2);
      var x21: ${u} = getInputValue(batch, channel, row2, col1);
      var x22: ${u} = getInputValue(batch, channel, row2, col2);
      var dx1: ${u} = abs(row - ${u}(row1));
      var dx2: ${u} = abs(${u}(row2) - row);
      var dy1: ${u} = abs(col - ${u}(col1));
      var dy2: ${u} = abs(${u}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},oP=(i,e,t,s,r,n,o,a,l,u)=>{let c=t.length===2,[d,h]=c?[0,1]:[2,3],p=i.type.value,f=m=>{let x=m===d?"row":"col";return`
      fn ${x}CubicInterpolation(input_indices: ${i.type.indices}, output_indices: ${e.type.indices}) -> ${p} {
        var output_index = ${e.indicesGet("output_indices",m)};
        var originalIdx: ${p} = getOriginalCoordinateFromResizedCoordinate(output_index, ${r[m]},
        ${s[m]}, ${t[m]}, ${n[m]}, ${n[m]} + ${t.length});
        var fractOriginalIdx: ${p} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${a} && (originalIdx < 0 || originalIdx > (${t[m]} - 1))) {
          return ${l};
        }
        var data: array<${p}, 4> = array<${p}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${x}: ${p} = originalIdx + ${p}(i);
          if (${x} < 0 || ${x} >= ${t[m]}) {
            ${u?`coefs[i + 1] = 0.0;
                        continue;`:a?`return ${l};`:`${x} = max(0, min(${x}, ${t[m]} - 1));`};
          }
        var input_indices_copy: ${i.type.indices} = input_indices;
          ${i.indicesSet("input_indices_copy",m,`u32(${x})`)};
          data[i + 1] = ${m===d?i.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${f(d)};
    ${f(h)};
  fn getCubicInterpolationCoefs(s: ${p}) -> array<${p}, 4> {
    var absS = abs(s);
    var coeffs: array<${p}, 4> = array<${p}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${p} = 1.0 - absS;
    var twoMinusAbsS: ${p} = 2.0 - absS;
    var onePlusAbsS: ${p} = 1.0 + absS;
    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};
    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;
    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${p}, 4>, coefs: array<${p}, 4>) -> ${p} {
    var coefsSum: ${p} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${p} {
    var input_indices: ${i.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},aP=(i,e,t,s,r)=>{let[n,o,a,l,u]=t.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],c=i.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${c} {
      var input_indices: ${i.type.indices};
      ${i.indicesSet("input_indices",o,`max(0, min(depth, ${t[o]} - 1))`)};
      ${i.indicesSet("input_indices",a,`max(0, min(height, ${t[a]} - 1))`)};
      ${i.indicesSet("input_indices",l,`max(0, min(width, ${t[l]} - 1))`)};
      ${ty(i,u,n,3)}
      return ${i.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${c} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${c} = originalIndices[${o}];
      var height:${c} = originalIndices[${a}];
      var width:${c} = originalIndices[${l}];
      ${s?`if (depth < 0 || depth > (${t[o]} - 1) || height < 0 || height > (${t[a]} - 1) || width < 0 || (width > ${t[l]} - 1)) {
      return ${r};
        }`:""};

    depth = max(0, min(depth, ${t[o]} - 1));
      height = max(0, min(height, ${t[a]} - 1));
      width = max(0, min(width, ${t[l]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${t.length>3?`u32(originalIndices[${u}])`:"0"};
      var batch: u32 =  ${t.length>3?`u32(originalIndices[${n}])`:"0"};

      var x111: ${c} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${c} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${c} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${c} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${c} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${c} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${c} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${c} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${c} = abs(depth - ${c}(depth1));
      var dx2: ${c} = abs(${c}(depth2) - depth);
      var dy1: ${c} = abs(height - ${c}(height1));
      var dy2: ${c} = abs(${c}(height2) - height);
      var dz1: ${c} = abs(width - ${c}(width1));
      var dz2: ${c} = abs(${c}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},lP=(i,e,t,s,r,n)=>{let o=i.dims,a=JC(n,e.axes,o.length),l=eP(o,s,r,e.axes),u=s.slice();s.length===0&&(u=o.map((_,S)=>_===0?1:l[S]/_),e.keepAspectRatioPolicy!=="stretch"&&(l=tP(o,u,e)));let c=gt("output",i.dataType,l.length),d=Oe("input",i.dataType,o.length),h=Ae.size(l),p=o.length===l.length&&o.every((_,S)=>_===l[S]),f=e.coordinateTransformMode==="tf_crop_and_resize",m=e.extrapolationValue,x=d.type.value,g=_=>`
      ${p?"":`
      ${QC(e.coordinateTransformMode,x)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${rP(d,o)};
              ${ZC(e.nearestMode,t,x)};
              ${iP(d,c,o,l,u.length,a.length,f)};
              `;case"linear":return`
              ${sP(c,o,l,u.length,a.length)};
              ${(()=>{if(o.length===2||o.length===4)return`${nP(d,c,o,f,m)}`;if(o.length===3||o.length===5)return`${aP(d,c,o,f,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(o.length===2||o.length===4)return`${oP(d,c,o,l,u,a,e.cubicCoeffA,f,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${_.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",a.length).declareVariables(d,c)}
      ${_.mainStart()}
        ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${p?"output[global_idx] = input[global_idx];":`
        let output_indices = ${c.offsetToIndices("global_idx")};
        var input_indices: ${d.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${d.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${o.length===2||o.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${t}|${u.length>0?e.mode==="cubic"?u:u.length:""}|${r.length>0?r:""}|${a.length>0?a:""}|${p}|${e.mode==="nearest"?o.length:o}`,inputDependencies:["rank"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:l,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:u},{type:1,data:a},...Tt(o,l)]})}},uP=i=>{let e=i.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},jI=(i,e)=>{let t=[],s=[],r=[],n=uP(i);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");YC(i.inputs,e,n,t,s,r),i.compute(lP(i.inputs[0],e,n,t,s,r),{inputs:[0]})},WI=i=>{let e=i.antialias,t=i.axes,s=i.coordinateTransformMode,r=i.cubicCoeffA,n=i.excludeOutside!==0,o=i.extrapolationValue,a=i.keepAspectRatioPolicy,l=i.mode,u=i.nearestMode===""?"simple":i.nearestMode;return Ms({antialias:e,axes:t,coordinateTransformMode:s,cubicCoeffA:r,excludeOutside:n,extrapolationValue:o,keepAspectRatioPolicy:a,mode:l,nearestMode:u})}}),cP,dP,HI,Vz=Ze(()=>{kt(),Gt(),qt(),cP=i=>{if(!i||i.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=i[0],t=i[1],s=i[2];if(e.dataType!==t.dataType||e.dataType!==s.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Skip must be 2D or 3D");let r=e.dims[e.dims.length-1],n=e.dims[e.dims.length-2];if(t.dims[t.dims.length-1]!==r)throw new Error("Skip must have the same hidden size as input");if(t.dims[t.dims.length-2]!==n)throw new Error("Skip must have the same sequence length as input");if(s.dims.length!==1)throw new Error("Gamma must be 1D");if(s.dims[s.dims.length-1]!==r)throw new Error("Gamma must have the same hidden size as input");if(i.length>3){let o=i[3];if(o.dims.length!==1)throw new Error("Beta must be 1D");if(o.dims[o.dims.length-1]!==r)throw new Error("Beta must have the same hidden size as input")}if(i.length>4){let o=i[4];if(o.dims.length!==1)throw new Error("Bias must be 1D");if(o.dims[o.dims.length-1]!==r)throw new Error("Bias must have the same hidden size as input")}},dP=(i,e,t,s)=>{let r=e.simplified,n=i[0].dims,o=Ae.size(n),a=n,l=o,u=n.slice(-1)[0],c=s?n.slice(0,-1).concat(1):[],d=!r&&i.length>3,h=i.length>4,p=s&&t>1,f=s&&t>2,m=t>3,x=64,g=Js(u),_=[{type:12,data:l},{type:12,data:g},{type:12,data:u},{type:1,data:e.epsilon}],S=w=>{let v=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],T=[Oe("x",i[0].dataType,i[0].dims,g),Oe("skip",i[1].dataType,i[1].dims,g),Oe("gamma",i[2].dataType,i[2].dims,g)];d&&T.push(Oe("beta",i[3].dataType,i[3].dims,g)),h&&T.push(Oe("bias",i[4].dataType,i[4].dims,g)),T.push(gt("output",i[0].dataType,a,g)),p&&T.push(gt("mean_output",1,c)),f&&T.push(gt("inv_std_output",1,c)),m&&T.push(gt("input_skip_bias_sum",i[0].dataType,a,g));let E=Ui(i[0].dataType),F=Ui(1,g);return`

      ${w.registerUniforms(v).declareVariables(...T)}
      var<workgroup> sum_shared : array<${F}, ${x}>;
      var<workgroup> sum_squared_shared : array<${F}, ${x}>;

      ${w.mainStart([x,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${x};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${x};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${x-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${h?"bias[offset1d + i]":E+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${m?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Yu(E,g,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${x};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Oa("sum",g)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Oa("square_sum",g)} / f32(uniforms.hidden_size) ${r?"":"- mean * mean"} + uniforms.epsilon);
        ${p?"mean_output[global_idx] = mean;":""}
        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${r?"":`- ${E}(mean)`}) *
            ${E}(inv_std_dev) * gamma[offset1d + i]
            ${d?"+ beta[offset1d + i]":""};
        }
      }`},M=[{dims:a,dataType:i[0].dataType}];return t>1&&M.push({dims:c,dataType:1}),t>2&&M.push({dims:c,dataType:1}),t>3&&M.push({dims:n,dataType:i[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${p};${f};${m}`,inputDependencies:i.map((w,v)=>"type")},getShaderSource:S,getRunData:()=>({outputs:M,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:_})}},HI=(i,e)=>{cP(i.inputs);let t=[0];i.outputCount>1&&t.push(-3),i.outputCount>2&&t.push(-3),i.outputCount>3&&t.push(3),i.compute(dP(i.inputs,e,i.outputCount,!1),{outputs:t})}}),hP,ud,pP,sy,fP,mP,qI,KI,Uz=Ze(()=>{kt(),Gt(),oi(),qt(),hP=(i,e)=>{if(!i||i.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");i.slice(1).forEach((t,s)=>{if(i[s+1].dataType!==6&&i[s+1].dataType!==7)throw new Error(`Input ${s} must be an array of int32 or int64`)})},ud=(i,e)=>{let t=[];if(i.length>e)if(i[e].dataType===7)i[e].getBigInt64Array().forEach(s=>t.push(Number(s)));else if(i[e].dataType===6)i[e].getInt32Array().forEach(s=>t.push(Number(s)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return t},pP=(i,e)=>{if(i.length>1){let t=ud(i,1),s=ud(i,2),r=ud(i,3);return r.length===0&&(r=[...Array(i[0].dims.length).keys()]),Ms({starts:t,ends:s,axes:r})}else return e},sy=(i,e,t,s,r)=>{let n=i;return i<0&&(n+=t[s[e]]),r[e]<0?Math.max(0,Math.min(n,t[s[e]]-1)):Math.max(0,Math.min(n,t[s[e]]))},fP=(i,e,t)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${i.type.indices} {
          var input_indices: ${i.type.indices};
          var carry = 0u;
          for (var i = ${t.length}; i >= 0; i--) {
            let input_shape_i = ${xt("uniforms.input_shape","i",t.length)};
            let steps_i = ${xt("uniforms.steps","i",t.length)};
            let signs_i = ${xt("uniforms.signs","i",t.length)};
            let starts_i = ${xt("uniforms.starts","i",t.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${i.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,mP=(i,e)=>{let t=i[0].dims,s=Ae.size(t),r=e.axes.length>0?Ae.normalizeAxes(e.axes,t.length):[...Array(t.length).keys()],n=ud(i,4);n.forEach(g=>g!==0||(()=>{throw new Error("step cannot be 0")})),n.length===0&&(n=Array(r.length).fill(1));let o=e.starts.map((g,_)=>sy(g,_,t,r,n)),a=e.ends.map((g,_)=>sy(g,_,t,r,n));if(r.length!==o.length||r.length!==a.length)throw new Error("start, ends and axes should have the same number of elements");if(r.length!==t.length)for(let g=0;g<t.length;++g)r.includes(g)||(o.splice(g,0,0),a.splice(g,0,t[g]),n.splice(g,0,1));let l=n.map(g=>Math.sign(g));n.forEach((g,_,S)=>{if(g<0){let M=(a[_]-o[_])/g,w=o[_],v=w+M*n[_];o[_]=v,a[_]=w,S[_]=-g}});let u=t.slice(0);r.forEach((g,_)=>{u[g]=Math.ceil((a[g]-o[g])/n[g])});let c={dims:u,dataType:i[0].dataType},d=gt("output",i[0].dataType,u.length),h=Oe("input",i[0].dataType,i[0].dims.length),p=Ae.size(u),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:o.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:n.length}],m=[{type:12,data:p},{type:12,data:o},{type:6,data:l},{type:12,data:n},...Tt(i[0].dims,u)],x=g=>`
      ${g.registerUniforms(f).declareVariables(h,d)}
        ${fP(h,d,t)}
        ${g.mainStart()}
          ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${d.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${d.setByOffset("global_idx",h.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${l.length}_${o.length}_${n.length}`,inputDependencies:["rank"]},getShaderSource:x,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:m})}},qI=(i,e)=>{hP(i.inputs,e);let t=pP(i.inputs,e);i.compute(mP(i.inputs,t),{inputs:[0]})},KI=i=>{let e=i.starts,t=i.ends,s=i.axes;return Ms({starts:e,ends:t,axes:s})}}),gP,_P,XI,YI,Gz=Ze(()=>{kt(),Gt(),oi(),Va(),qt(),gP=i=>{if(!i||i.length!==1)throw new Error("Softmax op requires 1 input.")},_P=(i,e)=>{let t=i.inputs[0],s=t.dims,r=Ae.size(s),n=s.length,o=Ae.normalizeAxis(e.axis,n),a=o<s.length-1,l,u=[];a?(u=Array.from({length:n},(T,E)=>E),u[o]=n-1,u[n-1]=o,l=i.compute(Xr(t,u),{inputs:[t],outputs:[-1]})[0]):l=t;let c=l.dims,d=c[n-1],h=r/d,p=Js(d),f=d/p,m=64;h===1&&(m=256);let x=(T,E)=>E===4?`max(max(${T}.x, ${T}.y), max(${T}.z, ${T}.w))`:E===2?`max(${T}.x, ${T}.y)`:E===3?`max(max(${T}.x, ${T}.y), ${T}.z)`:T,g=Oe("x",l.dataType,l.dims,p),_=gt("result",l.dataType,l.dims,p),S=g.type.value,M=Ui(l.dataType)==="f32"?`var threadMax = ${S}(-3.402823e+38f);`:`var threadMax = ${S}(-65504.0h);`,w=T=>`
      var<workgroup> rowMaxShared : ${S};
      var<workgroup> rowSumShared : ${S};
      var<workgroup> threadShared : array<${S}, ${m}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${S} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${S}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${T.registerUniform("packedCols","i32").declareVariables(g,_)}
      ${T.mainStart(m)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${m};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${M}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${S}(${x("threadShared[0]",p)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${S}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${S}(${Oa("threadShared[0]",p)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,v=i.compute({name:"Softmax",shaderCache:{hint:`${p};${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:c,dataType:l.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:f}]}),getShaderSource:w},{inputs:[l],outputs:[a?-1:0]})[0];a&&i.compute(Xr(v,u),{inputs:[v]})},XI=(i,e)=>{gP(i.inputs),_P(i,e)},YI=i=>Ms({axis:i.axis})}),iy,yP,xP,bP,QI,jz=Ze(()=>{kt(),Gt(),qt(),iy=i=>Array.from(i.getBigInt64Array(),Number),yP=i=>{if(!i||i.length!==2)throw new Error("Tile requires 2 inputs.");if(i[0].dataType!==1&&i[0].dataType!==10&&i[0].dataType!==6&&i[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(i[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(i[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(iy(i[1]).length!==i[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},xP=(i,e)=>{let t=[];for(let s=0;s<i.length;++s)t.push(i[s]*e[s]);return t},bP=(i,e)=>{let t=i[0].dims,s=e??iy(i[1]),r=xP(t,s),n=Ae.size(r),o=i[0].dataType,a=Oe("input",o,t.length),l=gt("output",o,r.length),u=c=>`
      const inputShape = ${a.indices(...t)};
      ${c.registerUniform("output_size","u32").declareVariables(a,l)}
      ${c.mainStart()}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${l.offsetToIndices("global_idx")};
      var input_indices: ${a.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let input_dim_i = ${a.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;

        ${a.indicesSet("input_indices","i","input_dim_value")}
      }
      ${l.setByOffset("global_idx",a.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${s}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:12,data:n},...Tt(i[0].dims,r)]}),getShaderSource:u}},QI=i=>{yP(i.inputs),i.compute(bP(i.inputs),{inputs:[0]})}}),wP,MP,ZI,Wz=Ze(()=>{kt(),Gt(),qt(),wP=(i,e,t,s,r)=>{let n=gt("output_data",r,t.length,4),o=Oe("a_data",e[1].dataType,e[1].dims.length,4),a=Oe("b_data",e[2].dataType,e[2].dims.length,4),l=Oe("c_data",e[0].dataType,e[0].dims.length,4),u,c=(d,h,p)=>`select(${h}, ${d}, ${p})`;if(!s)u=n.setByOffset("global_idx",c(o.getByOffset("global_idx"),a.getByOffset("global_idx"),l.getByOffset("global_idx")));else{let d=(h,p,f="")=>{let m=`a_data[index_a${p}][component_a${p}]`,x=`b_data[index_b${p}][component_b${p}]`,g=`bool(c_data[index_c${p}] & (0xffu << (component_c${p} * 8)))`;return`
            let output_indices${p} = ${n.offsetToIndices(`global_idx * 4u + ${p}u`)};
            let offset_a${p} = ${o.broadcastedIndicesToOffset(`output_indices${p}`,n)};
            let offset_b${p} = ${a.broadcastedIndicesToOffset(`output_indices${p}`,n)};
            let offset_c${p} = ${l.broadcastedIndicesToOffset(`output_indices${p}`,n)};
            let index_a${p} = offset_a${p} / 4u;
            let index_b${p} = offset_b${p} / 4u;
            let index_c${p} = offset_c${p} / 4u;
            let component_a${p} = offset_a${p} % 4u;
            let component_b${p} = offset_b${p} % 4u;
            let component_c${p} = offset_c${p} % 4u;
            ${h}[${p}] = ${f}(${c(m,x,g)});
          `};r===9?u=`
            var data = vec4<u32>(0);
            ${d("data",0,"u32")}
            ${d("data",1,"u32")}
            ${d("data",2,"u32")}
            ${d("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:u=`
            ${d("output_data[global_idx]",0)}
            ${d("output_data[global_idx]",1)}
            ${d("output_data[global_idx]",2)}
            ${d("output_data[global_idx]",3)}
          `}return`
        ${i.registerUniform("vec_size","u32").declareVariables(l,o,a,n)}
        ${i.mainStart()}
        ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${u}
      }`},MP=i=>{let e=i[1].dims,t=i[2].dims,s=i[0].dims,r=i[1].dataType,n=!(Ae.areEqual(e,t)&&Ae.areEqual(t,s)),o=e,a=Ae.size(e);if(n){let u=hc.calcShape(hc.calcShape(e,t,!1),s,!1);if(!u)throw new Error("Can't perform where op on the given tensors");o=u,a=Ae.size(o)}let l=Math.ceil(a/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:u=>wP(u,i,o,n,r),getRunData:()=>({outputs:[{dims:o,dataType:r}],dispatchGroup:{x:Math.ceil(a/64/4)},programUniforms:[{type:12,data:l},...Tt(s,e,t,o)]})}},ZI=i=>{i.compute(MP(i.inputs))}}),JI,Hz=Ze(()=>{oz(),Hb(),az(),lz(),uz(),cz(),dz(),gz(),yz(),xz(),bz(),wz(),Mz(),Tz(),vz(),Sz(),Ez(),Az(),Cz(),Pz(),Nz(),Fz(),Rz(),Iz(),Dz(),yI(),kz(),Lz(),Bz(),Oz(),$z(),Wb(),zz(),TI(),Vz(),Uz(),Gz(),wI(),jz(),Va(),qb(),Wz(),JI=new Map([["Abs",[HF]],["Acos",[qF]],["Acosh",[KF]],["Add",[CR]],["ArgMax",[UF,Ax]],["ArgMin",[VF,Ax]],["Asin",[XF]],["Asinh",[YF]],["Atan",[QF]],["Atanh",[ZF]],["Attention",[GF]],["AveragePool",[RI,FI]],["BatchNormalization",[jF]],["BiasAdd",[WF]],["BiasSplitGelu",[AR]],["Cast",[eR,JF]],["Ceil",[sR]],["Clip",[tR]],["Concat",[OR,$R]],["Conv",[Ix,Rx]],["ConvTranspose",[XR,KR]],["Cos",[iR]],["Cosh",[rR]],["CumSum",[YR,QR]],["DepthToSpace",[ZR,JR]],["DequantizeLinear",[$I,zI]],["Div",[PR]],["Einsum",[eI,tI]],["Elu",[nR,Dd]],["Equal",[NR]],["Erf",[oR]],["Exp",[aR]],["Expand",[sI]],["FastGelu",[iI]],["Floor",[lR]],["FusedConv",[Ix,Rx]],["Gather",[nI,rI]],["GatherElements",[dI,cI]],["GatherBlockQuantized",[lI,uI]],["GatherND",[oI,aI]],["Gelu",[uR]],["Gemm",[pI,hI]],["GlobalAveragePool",[DI,II]],["GlobalMaxPool",[OI,BI]],["Greater",[DR]],["GreaterOrEqual",[LR]],["GridSample",[fI,mI]],["GroupQueryAttention",[vI]],["HardSigmoid",[_R,gR]],["InstanceNormalization",[SI]],["LayerNormalization",[EI]],["LeakyRelu",[cR,Dd]],["Less",[kR]],["LessOrEqual",[BR]],["Log",[SR]],["MatMul",[AI]],["MatMulNBits",[CI,PI]],["MaxPool",[kI,LI]],["Mul",[FR]],["MultiHeadAttention",[_I,gI]],["Neg",[hR]],["Not",[dR]],["Pad",[NI]],["Pow",[RR]],["QuickGelu",[ER,Dd]],["Range",[VI]],["Reciprocal",[pR]],["ReduceMin",[LF]],["ReduceMean",[FF]],["ReduceMax",[kF]],["ReduceSum",[OF]],["ReduceProd",[BF]],["ReduceL1",[RF]],["ReduceL2",[IF]],["ReduceLogSum",[zF]],["ReduceLogSumExp",[DF]],["ReduceSumSquare",[$F]],["Relu",[fR]],["Resize",[jI,WI]],["RotaryEmbedding",[MI]],["ScatterND",[GI,UI]],["Sigmoid",[mR]],["Sin",[yR]],["Sinh",[xR]],["Slice",[qI,KI]],["SkipLayerNormalization",[HI]],["Split",[xI,bI]],["Sqrt",[bR]],["Softmax",[XI,YI]],["Sub",[IR]],["Tan",[wR]],["Tanh",[MR]],["ThresholdedRelu",[vR,Dd]],["Tile",[QI]],["Transpose",[xF,bF]],["Where",[ZI]]])}),eD,qz=Ze(()=>{Xn(),na(),qt(),eD=class{constructor(i){this.backend=i,this.repo=new Map,this.attributesBound=!1}getArtifact(i){return this.repo.get(i)}setArtifact(i,e){this.repo.set(i,e)}run(i,e,t,s,r){qn(i.programInfo.name);let n=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let a=[];for(let u of e)a.push({binding:a.length,resource:{buffer:u.buffer}});for(let u of t)a.push({binding:a.length,resource:{buffer:u.buffer}});r&&a.push({binding:a.length,resource:r});let l=n.createBindGroup({layout:i.computePipeline.getBindGroupLayout(0),entries:a,label:i.programInfo.name});if(this.backend.sessionStatus==="capturing"){let u={kernelId:this.backend.currentKernelId,computePipeline:i.computePipeline,bindGroup:l,dispatchGroup:s};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(u)}o.setPipeline(i.computePipeline),o.setBindGroup(0,l),o.dispatchWorkgroups(...s),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),_n(i.programInfo.name)}dispose(){}build(i,e){qn(i.name);let t=this.backend.device,s=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(u=>{t.features.has(u.feature)&&s.push(`enable ${u.extension};`)});let r=yF(e,this.backend.device.limits),n=i.getShaderSource(r),o=`${s.join(`
`)}
${r.additionalImplementations}
${n}`,a=t.createShaderModule({code:o,label:i.name});ls("verbose",()=>`[WebGPU] ${i.name} shader code: ${o}`);let l=t.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:i.name});return _n(i.name),{programInfo:i,computePipeline:l,uniformVariablesInfo:r.variablesInfo}}normalizeDispatchGroupSize(i){let e=typeof i=="number"?i:i.x,t=typeof i=="number"?1:i.y||1,s=typeof i=="number"?1:i.z||1,r=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=r&&t<=r&&s<=r)return[e,t,s];let n=e*t*s,o=Math.ceil(Math.sqrt(n));if(o>r){if(o=Math.ceil(Math.cbrt(n)),o>r)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}else return[o,o,1]}}}),tD={};vc(tD,{WebGpuBackend:()=>sD});var TP,vP,SP,sD,Kz=Ze(()=>{Xn(),kt(),na(),pF(),rz(),Hz(),qz(),TP=(i,e)=>{if(e.length!==i.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${i.length}.`);let t=[];for(let s=0;s<i.length;++s){let r=i[s].dataType;switch(e[s]){case"none":{t.push("");break}case"type":{t.push(`${r}`);break}case"rank":{let n=i[s].dims.length;t.push(`${r};${n}`);break}case"dims":{let n=i[s].dims.join(",");t.push(`${r};${n}`);break}default:throw new Error(`unsupported input dependency: ${e[s]}`)}}return t.join("|")},vP=(i,e,t)=>{var r,n;let s=i.name;return(r=i.shaderCache)!=null&&r.hint&&(s+="["+i.shaderCache.hint+"]"),s+=":"+t+`:${TP(e,((n=i.shaderCache)==null?void 0:n.inputDependencies)??new Array(e.length).fill("dims"))}`,s},SP=class{constructor(i){i&&(this.architecture=i.architecture,this.vendor=i.vendor)}isArchitecture(i){return this.architecture===i}isVendor(i){return this.vendor===i}},sD=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let i=this.kernelCustomData.get(this.currentKernelId);return i||(i={},this.kernelCustomData.set(this.currentKernelId,i)),i}async initialize(i,e){this.env=i;let t=[],s={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:t},r=n=>e.features.has(n)&&t.push(n)&&!0;r("chromium-experimental-timestamp-query-inside-passes")||r("timestamp-query"),r("shader-f16"),r("subgroups"),this.device=await e.requestDevice(s),this.adapterInfo=new SP(e.info||await e.requestAdapterInfo()),this.gpuDataManager=gF(this),this.programManager=new eD(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Vb(i.logLevel,!!i.debug),this.device.onuncapturederror=n=>{n.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${n.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let i=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=i.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;qn(),this.endComputePass();let i;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),i=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(i,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,i,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&i.mapAsync(GPUMapMode.READ).then(()=>{var s;let e=new BigUint64Array(i.getMappedRange()),t=this.pendingQueries.get(i);for(let r=0;r<e.length/2;r++){let n=t[r],o=n.kernelId,a=this.kernels.get(o),l=a.kernelType,u=a.kernelName,c=n.programName,d=n.inputTensorViews,h=n.outputTensorViews,p=e[r*2],f=e[r*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=p);let m=Number(p-this.queryTimeBase),x=Number(f-this.queryTimeBase);if(!Number.isSafeInteger(m)||!Number.isSafeInteger(x))throw new RangeError("incorrect timestamp range");if((s=this.env.webgpu.profiling)!=null&&s.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:d.map(g=>({dims:g.dims,dataType:Uo(g.dataType)})),outputsMetadata:h.map(g=>({dims:g.dims,dataType:Uo(g.dataType)})),kernelId:o,kernelType:l,kernelName:u,programName:c,startTime:m,endTime:x});else{let g="";d.forEach((S,M)=>{g+=`input[${M}]: [${S.dims}] | ${Uo(S.dataType)}, `});let _="";h.forEach((S,M)=>{_+=`output[${M}]: [${S.dims}] | ${Uo(S.dataType)}, `}),console.log(`[profiling] kernel "${o}|${l}|${u}|${c}" ${g}${_}execution time: ${x-m} ns`)}Zd("GPU",`${c}::${p}::${f}`)}i.unmap(),this.pendingQueries.delete(i)}),_n()}run(i,e,t,s,r,n){qn(i.name);let o=[];for(let _=0;_<e.length;++_){let S=e[_].data;if(S===0)continue;let M=this.gpuDataManager.get(S);if(!M)throw new Error(`no GPU data for input: ${S}`);o.push(M)}let{outputs:a,dispatchGroup:l,programUniforms:u}=i.getRunData(e),c=t.length===0?a.map((_,S)=>S):t;if(c.length!==a.length)throw new Error(`Output size ${c.length} must be equal to ${a.length}.`);let d=[],h=[];for(let _=0;_<a.length;++_){if(!Number.isInteger(c[_])||c[_]<-3||c[_]>=n)throw new Error(`Invalid output index: ${c[_]}`);if(c[_]===-3)continue;let S=c[_]===-1,M=c[_]===-2,w=S||M?r(a[_].dataType,a[_].dims):s(c[_],a[_].dataType,a[_].dims);if(d.push(w),w.data===0)continue;let v=this.gpuDataManager.get(w.data);if(!v)throw new Error(`no GPU data for output: ${w.data}`);if(S&&this.temporaryData.push(v),M){let T=this.kernelPersistentData.get(this.currentKernelId);T||(T=[],this.kernelPersistentData.set(this.currentKernelId,T)),T.push(v)}h.push(v)}if(o.length!==e.length||h.length!==d.length){if(h.length===0)return _n(i.name),d;throw new Error(`Program ${i.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let p;if(u){let _=0,S=[];u.forEach(T=>{let E=typeof T.data=="number"?[T.data]:T.data;if(E.length===0)return;let F=T.type===10?2:4,I,z;T.type===10?(z=E.length>4?16:E.length>2?8:E.length*F,I=E.length>4?16:F*E.length):(z=E.length<=2?E.length*F:16,I=16),_=Math.ceil(_/z)*z,S.push(_);let G=T.type===10?8:4;_+=E.length>4?Math.ceil(E.length/G)*I:E.length*F});let M=16;_=Math.ceil(_/M)*M;let w=new ArrayBuffer(_);u.forEach((T,E)=>{let F=S[E],I=typeof T.data=="number"?[T.data]:T.data;if(T.type===6)new Int32Array(w,F,I.length).set(I);else if(T.type===12)new Uint32Array(w,F,I.length).set(I);else if(T.type===10)new Uint16Array(w,F,I.length).set(I);else if(T.type===1)new Float32Array(w,F,I.length).set(I);else throw new Error(`Unsupported uniform type: ${Uo(T.type)}`)});let v=this.gpuDataManager.create(_,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(v.buffer,0,w,0,_),this.gpuDataManager.release(v.id),p={offset:0,size:_,buffer:v.buffer}}let f=this.programManager.normalizeDispatchGroupSize(l),m=f[1]===1&&f[2]===1,x=vP(i,e,m),g=this.programManager.getArtifact(x);if(g||(g=this.programManager.build(i,f),this.programManager.setArtifact(x,g),ls("info",()=>`[artifact] key: ${x}, programName: ${i.name}`)),u&&g.uniformVariablesInfo){if(u.length!==g.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${g.uniformVariablesInfo.length}, got ${u.length} in program "${g.programInfo.name}".`);for(let _=0;_<u.length;_++){let S=u[_],M=S.type,w=typeof S.data=="number"?1:S.data.length,[v,T]=g.uniformVariablesInfo[_];if(M!==v||w!==T)throw new Error(`Uniform variable ${_} mismatch: expect type ${v} with size ${T}, got type ${M} with size ${w} in program "${g.programInfo.name}".`)}}if(ls("info",()=>`[ProgramManager] run "${i.name}" (key=${x}) with ${f[0]}x${f[1]}x${f[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let _={kernelId:this.currentKernelId,programName:g.programInfo.name,inputTensorViews:e,outputTensorViews:d};this.pendingKernels.push(_),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(_)}return this.programManager.run(g,o,h,f,p),_n(i.name),d}upload(i,e){this.gpuDataManager.upload(i,e)}memcpy(i,e){this.gpuDataManager.memcpy(i,e)}async download(i,e){await this.gpuDataManager.download(i,e)}alloc(i){return this.gpuDataManager.create(i).id}free(i){return this.gpuDataManager.release(i)}createKernel(i,e,t,s){let r=JI.get(i);if(!r)throw new Error(`kernel not implemented: ${i}`);let n={kernelType:i,kernelName:s,kernelEntry:r[0],attributes:[r[1],t]};this.kernels.set(e,n)}releaseKernel(i){let e=this.kernelPersistentData.get(i);if(e){for(let t of e)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(i)}this.kernelCustomData.delete(i),this.kernels.delete(i)}computeKernel(i,e,t){let s=this.kernels.get(i);if(!s)throw new Error(`kernel not created: ${i}`);let r=s.kernelType,n=s.kernelName,o=s.kernelEntry,a=s.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${r}] ${n}" is not allowed to be called recursively`);this.currentKernelId=i,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),ls("info",()=>`[WebGPU] Start to run kernel "[${r}] ${n}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),o(e,a[1]),0}catch(u){return t.push(Promise.resolve(`[WebGPU] Kernel "[${r}] ${n}" failed. ${u}`)),1}finally{l&&t.push(this.device.popErrorScope().then(u=>u?`GPU validation error for kernel "[${r}] ${n}": ${u.message}`:null));for(let u of this.temporaryData)this.gpuDataManager.release(u.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(i,e,t,s){let r=this.sessionExternalDataMapping.get(i);r||(r=new Map,this.sessionExternalDataMapping.set(i,r));let n=r.get(e),o=this.gpuDataManager.registerExternalBuffer(t,s,n);return r.set(e,[o,t]),o}unregisterBuffers(i){let e=this.sessionExternalDataMapping.get(i);e&&(e.forEach(t=>this.gpuDataManager.unregisterExternalBuffer(t[0])),this.sessionExternalDataMapping.delete(i))}getBuffer(i){let e=this.gpuDataManager.get(i);if(!e)throw new Error(`no GPU data for buffer: ${i}`);return e.buffer}createDownloader(i,e,t){return async()=>{let s=await vx(this,i,e);return Ub(s.buffer,t)}}writeTimestamp(i){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,i)}setQueryType(){var i;this.queryType="none",(((i=this.env.webgpu.profiling)==null?void 0:i.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){ls("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){ls("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){ls("info","replay"),this.sessionStatus="replaying";let i=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),t=i.length;this.pendingKernels=[];for(let s=0;s<t;s++){let r=this.getComputePassEncoder(),n=i[s];this.writeTimestamp(this.pendingDispatchNumber*2),r.setPipeline(n.computePipeline),r.setBindGroup(0,n.bindGroup),r.dispatchWorkgroups(...n.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[s]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(i){this.unregisterBuffers(i),this.capturedCommandList.has(i)&&this.capturedCommandList.delete(i),this.capturedPendingKernels.has(i)&&this.capturedPendingKernels.delete(i),this.gpuDataManager.onReleaseSession(i)}onRunStart(i){this.currentSessionId=i,this.setQueryType()}}}),iD={};vc(iD,{init:()=>rD});var Np,EP,rD,Xz=Ze(()=>{kt(),na(),Gt(),iz(),Np=class nD{constructor(e,t,s,r){this.module=e,this.dataType=t,this.data=s,this.dims=r}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=Ae.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=Ae.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=Ae.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let e=Ae.size(this.dims);return e===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(Ae.size(e)!==Ae.size(this.dims))throw new Error("Invalid new shape");return new nD(this.module,this.dataType,this.data,e)}},EP=class{constructor(i,e,t){this.module=i,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo;let s=i.PTR_SIZE,r=t/i.PTR_SIZE,n=s===4?"i32":"i64";this.opKernelContext=Number(i.getValue(s*r++,n));let o=Number(i.getValue(s*r++,n));this.outputCount=Number(i.getValue(s*r++,n)),this.customDataOffset=Number(i.getValue(s*r++,"*")),this.customDataSize=Number(i.getValue(s*r++,n));let a=[];for(let l=0;l<o;l++){let u=Number(i.getValue(s*r++,n)),c=Number(i.getValue(s*r++,"*")),d=Number(i.getValue(s*r++,n)),h=[];for(let p=0;p<d;p++)h.push(Number(i.getValue(s*r++,n)));a.push(new Np(i,u,c,h))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(i,e){var o;let t=((o=e==null?void 0:e.inputs)==null?void 0:o.map(a=>typeof a=="number"?this.inputs[a]:a))??this.inputs,s=(e==null?void 0:e.outputs)??[],r=(a,l,u)=>new Np(this.module,l,this.output(a,u),u),n=(a,l)=>{let u=Il(a,l);if(!u)throw new Error(`Unsupported data type: ${a}`);let c=u>0?this.backend.gpuDataManager.create(u).id:0;return new Np(this.module,a,c,l)};return this.backend.run(i,t,s,r,n,this.outputCount)}output(i,e){let t=this.module.stackSave();try{let s=this.module.PTR_SIZE,r=s===4?"i32":"i64",n=this.module.stackAlloc((1+e.length)*s);this.module.setValue(n,e.length,r);for(let o=0;o<e.length;o++)this.module.setValue(n+s*(o+1),e[o],r);return this.module._JsepOutput(this.opKernelContext,i,n)}catch(s){throw new Error(`Failed to generate kernel's output[${i}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${s}`)}finally{this.module.stackRestore(t)}}},rD=async(i,e,t,s)=>{let r=e.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(i==="webgpu"){let n=(Kz(),Qd(tD)).WebGpuBackend,o=new n;await o.initialize(t,s),r("webgpu",[o,a=>o.alloc(Number(a)),a=>o.free(a),(a,l,u,c=!1)=>{if(c)ls("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(a)}, dst=${Number(l)}, size=${Number(u)}`),o.memcpy(Number(a),Number(l));else{ls("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(a)}, gpuDataId=${Number(l)}, size=${Number(u)}`);let d=e.HEAPU8.subarray(Number(a>>>0),Number(a>>>0)+Number(u));o.upload(Number(l),d)}},async(a,l,u)=>{ls("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${l}, size=${u}`),await o.download(Number(a),()=>e.HEAPU8.subarray(Number(l)>>>0,Number(l+u)>>>0))},(a,l,u)=>o.createKernel(a,Number(l),u,e.UTF8ToString(e._JsepGetNodeName(Number(l)))),a=>o.releaseKernel(a),(a,l,u,c)=>{ls("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${a}, contextDataOffset=${l}`);let d=new EP(e,o,Number(l));return o.computeKernel(Number(a),d,c)},()=>o.captureBegin(),()=>o.captureEnd(),()=>o.replay()])}else{let n=new mF(t);r("webnn",[n,()=>n.reserveTensorId(),o=>n.releaseTensorId(o),async(o,a,l,u,c)=>n.ensureTensor(o,a,l,u,c),(o,a)=>{n.uploadTensor(o,a)},async(o,a)=>n.downloadTensor(o,a)])}}}),AP,Jb,e0,_a,CP,ry,Vf,t0,s0,ny,i0,r0,n0,oD=Ze(()=>{ez(),tz(),kt(),Zl(),Lb(),uF(),AP=(i,e)=>{ks()._OrtInit(i,e)!==0&&As("Can't initialize onnxruntime.")},Jb=async i=>{AP(i.wasm.numThreads,Lf(i.logLevel))},e0=async(i,e)=>{var t,s;(s=(t=ks()).asyncInit)==null||s.call(t);{let r=(Xz(),Qd(iD)).init;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let n=i.webgpu.adapter;if(n){if(typeof n.limits!="object"||typeof n.features!="object"||typeof n.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let o=i.webgpu.powerPreference;if(o!==void 0&&o!=="low-power"&&o!=="high-performance")throw new Error(`Invalid powerPreference setting: "${o}"`);let a=i.webgpu.forceFallbackAdapter;if(a!==void 0&&typeof a!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${a}"`);if(n=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:a}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await r("webgpu",ks(),i,n)}if(e==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await r("webnn",ks(),i)}}},_a=new Map,CP=i=>{let e=ks(),t=e.stackSave();try{let s=e.PTR_SIZE,r=e.stackAlloc(2*s);e._OrtGetInputOutputCount(i,r,r+s)!==0&&As("Can't get session input/output count.");let n=s===4?"i32":"i64";return[Number(e.getValue(r,n)),Number(e.getValue(r+s,n))]}finally{e.stackRestore(t)}},ry=(i,e)=>{let t=ks(),s=t.stackSave(),r=0;try{let n=t.PTR_SIZE,o=t.stackAlloc(2*n);t._OrtGetInputOutputMetadata(i,e,o,o+n)!==0&&As("Can't get session input/output metadata.");let a=Number(t.getValue(o,"*"));r=Number(t.getValue(o+n,"*"));let l=t.HEAP32[r/4];if(l===0)return[a,0];let u=t.HEAPU32[r/4+1],c=[];for(let d=0;d<u;d++){let h=Number(t.getValue(r+8+d*n,"*"));c.push(h!==0?t.UTF8ToString(h):Number(t.getValue(r+8+(d+u)*n,"*")))}return[a,l,c]}finally{t.stackRestore(s),r!==0&&t._OrtFree(r)}},Vf=i=>{let e=ks(),t=e._malloc(i.byteLength);if(t===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${i.byteLength}.`);return e.HEAPU8.set(i,t),[t,i.byteLength]},t0=async(i,e)=>{var d,h,p,f;let t,s,r=ks();Array.isArray(i)?[t,s]=i:i.buffer===r.HEAPU8.buffer?[t,s]=[i.byteOffset,i.byteLength]:[t,s]=Vf(i);let n=0,o=0,a=0,l=[],u=[],c=[];try{if([o,l]=await lF(e),(e==null?void 0:e.externalData)&&r.mountExternalData){let E=[];for(let F of e.externalData){let I=typeof F=="string"?F:F.path;E.push(zb(typeof F=="string"?F:F.data).then(z=>{r.mountExternalData(I,z)}))}await Promise.all(E)}for(let E of(e==null?void 0:e.executionProviders)??[])if((typeof E=="string"?E:E.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof E!="string"){let F=E,I=F==null?void 0:F.context,z=F==null?void 0:F.gpuDevice,G=F==null?void 0:F.deviceType,L=F==null?void 0:F.powerPreference;I?r.currentContext=I:z?r.currentContext=await r.webnnCreateMLContext(z):r.currentContext=await r.webnnCreateMLContext({deviceType:G,powerPreference:L})}else r.currentContext=await r.webnnCreateMLContext();break}n=await r._OrtCreateSession(t,s,o),(d=r.webgpuOnCreateSession)==null||d.call(r,n),n===0&&As("Can't create a session."),(h=r.jsepOnCreateSession)==null||h.call(r),r.currentContext&&(r.webnnRegisterMLContext(n,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[m,x]=CP(n),g=!!(e!=null&&e.enableGraphCapture),_=[],S=[],M=[],w=[],v=[];for(let E=0;E<m;E++){let[F,I,z]=ry(n,E);F===0&&As("Can't get an input name."),u.push(F);let G=r.UTF8ToString(F);_.push(G),M.push(I===0?{name:G,isTensor:!1}:{name:G,isTensor:!0,type:Uo(I),shape:z})}for(let E=0;E<x;E++){let[F,I,z]=ry(n,E+m);F===0&&As("Can't get an output name."),c.push(F);let G=r.UTF8ToString(F);S.push(G),w.push(I===0?{name:G,isTensor:!1}:{name:G,isTensor:!0,type:Uo(I),shape:z});{if(g&&(e==null?void 0:e.preferredOutputLocation)===void 0){v.push("gpu-buffer");continue}let L=typeof(e==null?void 0:e.preferredOutputLocation)=="string"?e.preferredOutputLocation:((p=e==null?void 0:e.preferredOutputLocation)==null?void 0:p[G])??"cpu";if(L!=="cpu"&&L!=="cpu-pinned"&&L!=="gpu-buffer"&&L!=="ml-tensor")throw new Error(`Not supported preferred output location: ${L}.`);if(g&&L!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${L}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);v.push(L)}}let T=null;return v.some(E=>E==="gpu-buffer"||E==="ml-tensor")&&(a=r._OrtCreateBinding(n),a===0&&As("Can't create IO binding."),T={handle:a,outputPreferredLocations:v,outputPreferredLocationsEncoded:v.map(E=>Mx(E))}),_a.set(n,[n,u,c,T,g,!1]),[n,_,S,M,w]}catch(m){throw u.forEach(x=>r._OrtFree(x)),c.forEach(x=>r._OrtFree(x)),a!==0&&r._OrtReleaseBinding(a)!==0&&As("Can't release IO binding."),n!==0&&r._OrtReleaseSession(n)!==0&&As("Can't release session."),m}finally{r._free(t),o!==0&&r._OrtReleaseSessionOptions(o)!==0&&As("Can't release session options."),l.forEach(m=>r._free(m)),(f=r.unmountExternalData)==null||f.call(r)}},s0=i=>{var l,u,c;let e=ks(),t=_a.get(i);if(!t)throw new Error(`cannot release session. invalid session id: ${i}`);let[s,r,n,o,a]=t;o&&(a&&e._OrtClearBoundOutputs(o.handle)!==0&&As("Can't clear bound outputs."),e._OrtReleaseBinding(o.handle)!==0&&As("Can't release IO binding.")),(l=e.jsepOnReleaseSession)==null||l.call(e,i),(u=e.webnnOnReleaseSession)==null||u.call(e,i),(c=e.webgpuOnReleaseSession)==null||c.call(e,i),r.forEach(d=>e._OrtFree(d)),n.forEach(d=>e._OrtFree(d)),e._OrtReleaseSession(s)!==0&&As("Can't release session."),_a.delete(i)},ny=async(i,e,t,s,r,n,o=!1)=>{if(!i){e.push(0);return}let a=ks(),l=a.PTR_SIZE,u=i[0],c=i[1],d=i[3],h=d,p,f;if(u==="string"&&(d==="gpu-buffer"||d==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(o&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${n} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let g=i[2].gpuBuffer;f=Il(Hu(u),c);{let _=a.jsepRegisterBuffer;if(!_)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');p=_(s,n,g,f)}}else if(d==="ml-tensor"){let g=i[2].mlTensor;f=Il(Hu(u),c);let _=a.webnnRegisterMLTensor;if(!_)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');p=_(s,g,Hu(u),c)}else{let g=i[2];if(Array.isArray(g)){f=l*g.length,p=a._malloc(f),t.push(p);for(let _=0;_<g.length;_++){if(typeof g[_]!="string")throw new TypeError(`tensor data at index ${_} is not a string`);a.setValue(p+_*l,zn(g[_],t),"*")}}else{let _=a.webnnIsGraphInput;if(u!=="string"&&_){let S=a.UTF8ToString(r);if(_(s,S)){let M=Hu(u);f=Il(M,c),h="ml-tensor";let w=a.webnnCreateTemporaryTensor,v=a.webnnUploadTensor;if(!w||!v)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let T=await w(s,M,c);v(T,new Uint8Array(g.buffer,g.byteOffset,g.byteLength)),p=T}else f=g.byteLength,p=a._malloc(f),t.push(p),a.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,f),p)}else f=g.byteLength,p=a._malloc(f),t.push(p),a.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,f),p)}}let m=a.stackSave(),x=a.stackAlloc(4*c.length);try{c.forEach((_,S)=>a.setValue(x+S*l,_,l===4?"i32":"i64"));let g=a._OrtCreateTensor(Hu(u),p,f,x,c.length,Mx(h));g===0&&As(`Can't create tensor for input/output. session=${s}, index=${n}.`),e.push(g)}finally{a.stackRestore(m)}},i0=async(i,e,t,s,r,n)=>{var z,G,L,Q;let o=ks(),a=o.PTR_SIZE,l=_a.get(i);if(!l)throw new Error(`cannot run inference. invalid session id: ${i}`);let u=l[0],c=l[1],d=l[2],h=l[3],p=l[4],f=l[5],m=e.length,x=s.length,g=0,_=[],S=[],M=[],w=[],v=o.stackSave(),T=o.stackAlloc(m*a),E=o.stackAlloc(m*a),F=o.stackAlloc(x*a),I=o.stackAlloc(x*a);try{[g,_]=aF(n);for(let ee=0;ee<m;ee++)await ny(t[ee],S,w,i,c[e[ee]],e[ee],p);for(let ee=0;ee<x;ee++)await ny(r[ee],M,w,i,d[s[ee]],m+s[ee],p);for(let ee=0;ee<m;ee++)o.setValue(T+ee*a,S[ee],"*"),o.setValue(E+ee*a,c[e[ee]],"*");for(let ee=0;ee<x;ee++)o.setValue(F+ee*a,M[ee],"*"),o.setValue(I+ee*a,d[s[ee]],"*");if(h&&!f){let{handle:ee,outputPreferredLocations:se,outputPreferredLocationsEncoded:fe}=h;if(c.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${c.length}).`);for(let ue=0;ue<m;ue++){let U=e[ue];await o._OrtBindInput(ee,c[U],S[ue])!==0&&As(`Can't bind input[${ue}] for session=${i}.`)}for(let ue=0;ue<x;ue++){let U=s[ue];(z=r[ue])!=null&&z[3]?o._OrtBindOutput(ee,d[U],M[ue],0)!==0&&As(`Can't bind pre-allocated output[${ue}] for session=${i}.`):o._OrtBindOutput(ee,d[U],0,fe[U])!==0&&As(`Can't bind output[${ue}] to ${se[ue]} for session=${i}.`)}_a.set(i,[u,c,d,h,p,!0])}(G=o.jsepOnRunStart)==null||G.call(o,u),(L=o.webnnOnRunStart)==null||L.call(o,u);let q;h?q=await o._OrtRunWithBinding(u,h.handle,x,F,g):q=await o._OrtRun(u,E,T,m,I,x,F,g),q!==0&&As("failed to call OrtRun().");let J=[];for(let ee=0;ee<x;ee++){let se=Number(o.getValue(F+ee*a,"*"));if(se===M[ee]){J.push(r[ee]);continue}let fe=o.stackSave(),ue=o.stackAlloc(4*a),U=!1,k,j=0;try{o._OrtGetTensorData(se,ue,ue+a,ue+2*a,ue+3*a)!==0&&As(`Can't access output tensor data on index ${ee}.`);let re=a===4?"i32":"i64",we=Number(o.getValue(ue,re));j=o.getValue(ue+a,"*");let de=o.getValue(ue+a*2,"*"),Pe=Number(o.getValue(ue+a*3,re)),Xe=[];for(let X=0;X<Pe;X++)Xe.push(Number(o.getValue(de+X*a,re)));o._OrtFree(de)!==0&&As("Can't free memory for tensor dims.");let et=Xe.reduce((X,oe)=>X*oe,1);k=Uo(we);let Me=h==null?void 0:h.outputPreferredLocations[s[ee]];if(k==="string"){if(Me==="gpu-buffer"||Me==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let X=[];for(let oe=0;oe<et;oe++){let K=o.getValue(j+oe*a,"*"),Ce=o.getValue(j+(oe+1)*a,"*"),Ee=oe===et-1?void 0:Ce-K;X.push(o.UTF8ToString(K,Ee))}J.push([k,Xe,X,"cpu"])}else if(Me==="gpu-buffer"&&et>0){let X=o.jsepGetBuffer;if(!X)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let oe=X(j),K=Il(we,et);if(K===void 0||!Ob(k))throw new Error(`Unsupported data type: ${k}`);U=!0,J.push([k,Xe,{gpuBuffer:oe,download:o.jsepCreateDownloader(oe,K,k),dispose:()=>{o._OrtReleaseTensor(se)!==0&&As("Can't release tensor.")}},"gpu-buffer"])}else if(Me==="ml-tensor"&&et>0){let X=o.webnnEnsureTensor,oe=o.webnnIsInt64Supported;if(!X||!oe)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Il(we,et)===void 0||!$b(k))throw new Error(`Unsupported data type: ${k}`);if(k==="int64"&&!oe(i))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let K=await X(i,j,we,Xe,!1);U=!0,J.push([k,Xe,{mlTensor:K,download:o.webnnCreateMLTensorDownloader(j,k),dispose:()=>{o.webnnReleaseTensorId(j),o._OrtReleaseTensor(se)}},"ml-tensor"])}else{let X=Bb(k),oe=new X(et);new Uint8Array(oe.buffer,oe.byteOffset,oe.byteLength).set(o.HEAPU8.subarray(j,j+oe.byteLength)),J.push([k,Xe,oe,"cpu"])}}finally{o.stackRestore(fe),k==="string"&&j&&o._free(j),U||o._OrtReleaseTensor(se),(Q=o.webnnOnRunEnd)==null||Q.call(o,u)}}return h&&!p&&(o._OrtClearBoundOutputs(h.handle)!==0&&As("Can't clear bound outputs."),_a.set(i,[u,c,d,h,p,!1])),J}finally{o.stackRestore(v),S.forEach(q=>o._OrtReleaseTensor(q)),M.forEach(q=>o._OrtReleaseTensor(q)),w.forEach(q=>o._free(q)),g!==0&&o._OrtReleaseRunOptions(g),_.forEach(q=>o._free(q))}},r0=i=>{let e=ks(),t=_a.get(i);if(!t)throw new Error("invalid session id");let s=t[0],r=e._OrtEndProfiling(s);r===0&&As("Can't get an profile file name."),e._OrtFree(r)},n0=i=>{let e=[];for(let t of i){let s=t[2];!Array.isArray(s)&&"buffer"in s&&e.push(s.buffer)}return e}}),ya,vr,Su,cd,dd,Fp,oy,Rp,gl,_l,PP,aD,lD,uD,cD,dD,hD,pD,fD=Ze(()=>{Xn(),oD(),Zl(),Db(),ya=()=>!!Vs.wasm.proxy&&typeof document<"u",Su=!1,cd=!1,dd=!1,Rp=new Map,gl=(i,e)=>{let t=Rp.get(i);t?t.push(e):Rp.set(i,[e])},_l=()=>{if(Su||!cd||dd||!vr)throw new Error("worker not ready")},PP=i=>{switch(i.data.type){case"init-wasm":Su=!1,i.data.err?(dd=!0,oy[1](i.data.err)):(cd=!0,oy[0]()),Fp&&(URL.revokeObjectURL(Fp),Fp=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=Rp.get(i.data.type);i.data.err?e.shift()[1](i.data.err):e.shift()[0](i.data.out);break}}},aD=async()=>{if(!cd){if(Su)throw new Error("multiple calls to 'initWasm()' detected.");if(dd)throw new Error("previous call to 'initWasm()' failed.");if(Su=!0,ya())return new Promise((i,e)=>{vr==null||vr.terminate(),nF().then(([t,s])=>{try{vr=s,vr.onerror=n=>e(n),vr.onmessage=PP,oy=[i,e];let r={type:"init-wasm",in:Vs};!r.in.wasm.wasmPaths&&(t||wx)&&(r.in.wasm.wasmPaths={wasm:new URL("/magic-eye-yourself/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href}),vr.postMessage(r),Fp=t}catch(r){e(r)}},e)});try{await kb(Vs.wasm),await Jb(Vs),cd=!0}catch(i){throw dd=!0,i}finally{Su=!1}}},lD=async i=>{if(ya())return _l(),new Promise((e,t)=>{gl("init-ep",[e,t]);let s={type:"init-ep",in:{epName:i,env:Vs}};vr.postMessage(s)});await e0(Vs,i)},uD=async i=>ya()?(_l(),new Promise((e,t)=>{gl("copy-from",[e,t]);let s={type:"copy-from",in:{buffer:i}};vr.postMessage(s,[i.buffer])})):Vf(i),cD=async(i,e)=>{if(ya()){if(e!=null&&e.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return _l(),new Promise((t,s)=>{gl("create",[t,s]);let r={type:"create",in:{model:i,options:{...e}}},n=[];i instanceof Uint8Array&&n.push(i.buffer),vr.postMessage(r,n)})}else return t0(i,e)},dD=async i=>{if(ya())return _l(),new Promise((e,t)=>{gl("release",[e,t]);let s={type:"release",in:i};vr.postMessage(s)});s0(i)},hD=async(i,e,t,s,r,n)=>{if(ya()){if(t.some(o=>o[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(o=>o))throw new Error("pre-allocated output tensor is not supported for proxy.");return _l(),new Promise((o,a)=>{gl("run",[o,a]);let l=t,u={type:"run",in:{sessionId:i,inputIndices:e,inputs:l,outputIndices:s,options:n}};vr.postMessage(u,n0(l))})}else return i0(i,e,t,s,r,n)},pD=async i=>{if(ya())return _l(),new Promise((e,t)=>{gl("end-profiling",[e,t]);let s={type:"end-profiling",in:i};vr.postMessage(s)});r0(i)}}),ay,NP,mD,Yz=Ze(()=>{Xn(),fD(),kt(),Ib(),uF(),ay=(i,e)=>{switch(i.location){case"cpu":return[i.type,i.dims,i.data,"cpu"];case"gpu-buffer":return[i.type,i.dims,{gpuBuffer:i.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[i.type,i.dims,{mlTensor:i.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${i.location} for ${e()}`)}},NP=i=>{switch(i[3]){case"cpu":return new Vn(i[0],i[2],i[1]);case"gpu-buffer":{let e=i[0];if(!Ob(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:t,download:s,dispose:r}=i[2];return Vn.fromGpuBuffer(t,{dataType:e,dims:i[1],download:s,dispose:r})}case"ml-tensor":{let e=i[0];if(!$b(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:t,download:s,dispose:r}=i[2];return Vn.fromMLTensor(t,{dataType:e,dims:i[1],download:s,dispose:r})}default:throw new Error(`invalid data location: ${i[3]}`)}},mD=class{async fetchModelAndCopyToWasmMemory(i){return uD(await zb(i))}async loadModel(i,e){qn();let t;typeof i=="string"?t=await this.fetchModelAndCopyToWasmMemory(i):t=i,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await cD(t,e),_n()}async dispose(){return dD(this.sessionId)}async run(i,e,t){qn();let s=[],r=[];Object.entries(i).forEach(d=>{let h=d[0],p=d[1],f=this.inputNames.indexOf(h);if(f===-1)throw new Error(`invalid input '${h}'`);s.push(p),r.push(f)});let n=[],o=[];Object.entries(e).forEach(d=>{let h=d[0],p=d[1],f=this.outputNames.indexOf(h);if(f===-1)throw new Error(`invalid output '${h}'`);n.push(p),o.push(f)});let a=s.map((d,h)=>ay(d,()=>`input "${this.inputNames[r[h]]}"`)),l=n.map((d,h)=>d?ay(d,()=>`output "${this.outputNames[o[h]]}"`):null),u=await hD(this.sessionId,r,a,o,l,t),c={};for(let d=0;d<u.length;d++)c[this.outputNames[o[d]]]=n[d]??NP(u[d]);return _n(),c}startProfiling(){}endProfiling(){pD(this.sessionId)}}}),gD={};vc(gD,{OnnxruntimeWebAssemblyBackend:()=>Lx,initializeFlags:()=>kx,wasmBackend:()=>_D});var kx,Lx,_D,Qz=Ze(()=>{Xn(),fD(),Yz(),kx=()=>{(typeof Vs.wasm.initTimeout!="number"||Vs.wasm.initTimeout<0)&&(Vs.wasm.initTimeout=0);let i=Vs.wasm.simd;if(typeof i!="boolean"&&i!==void 0&&i!=="fixed"&&i!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${i}". Reset it to \`false\` and ignore SIMD feature checking.`),Vs.wasm.simd=!1),typeof Vs.wasm.proxy!="boolean"&&(Vs.wasm.proxy=!1),typeof Vs.wasm.trace!="boolean"&&(Vs.wasm.trace=!1),typeof Vs.wasm.numThreads!="number"||!Number.isInteger(Vs.wasm.numThreads)||Vs.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Vs.wasm.numThreads=1;else{let e=typeof navigator>"u"?B3("node:os").cpus().length:navigator.hardwareConcurrency;Vs.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Lx=class{async init(i){kx(),await aD(),await lD(i)}async createInferenceSessionHandler(i,e){let t=new mD;return await t.loadModel(i,e),t}},_D=new Lx});Xn();Xn();Xn();var Zz="1.22.0-dev.20250409-89f8206ba4",Jz=JN;{let i=(Qz(),Qd(gD)).wasmBackend;Bl("webgpu",i,5),Bl("webnn",i,5),Bl("cpu",i,10),Bl("wasm",i,10)}Object.defineProperty(Vs.versions,"web",{value:Zz,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eV=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return Rb},get TRACE(){return Zd},get TRACE_FUNC_BEGIN(){return qn},get TRACE_FUNC_END(){return _n},get Tensor(){return Vn},default:Jz,get env(){return Vs},get registerBackend(){return Bl}},Symbol.toStringTag,{value:"Module"}));var Ro={},tV={"onnxruntime-common":i=>{i.exports=I3},"onnxruntime-web":i=>{i.exports=eV},"?2ce3":()=>{},"?7992":()=>{},"?5af5":()=>{},"?2b25":()=>{},"?db59":()=>{},"?383f":()=>{},"?fa4b":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(i,e,t)=>{t.r(e),t.d(e,{Environment:()=>Je,Interpreter:()=>it,Template:()=>Qr,parse:()=>j,tokenize:()=>d});var s=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndSet:"EndSet",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro",Break:"Break",Continue:"Continue"}),r=Object.freeze({set:s.Set,for:s.For,in:s.In,is:s.Is,if:s.If,else:s.Else,endset:s.EndSet,endif:s.EndIf,elif:s.ElseIf,endfor:s.EndFor,and:s.And,or:s.Or,not:s.Not,"not in":s.NotIn,macro:s.Macro,endmacro:s.EndMacro,break:s.Break,continue:s.Continue,true:s.BooleanLiteral,false:s.BooleanLiteral,none:s.NullLiteral,True:s.BooleanLiteral,False:s.BooleanLiteral,None:s.NullLiteral}),n=class{constructor(O,le){this.value=O,this.type=le}};function o(O){return/\w/.test(O)}function a(O){return/[0-9]/.test(O)}var l=[["{%",s.OpenStatement],["%}",s.CloseStatement],["{{",s.OpenExpression],["}}",s.CloseExpression],["(",s.OpenParen],[")",s.CloseParen],["{",s.OpenCurlyBracket],["}",s.CloseCurlyBracket],["[",s.OpenSquareBracket],["]",s.CloseSquareBracket],[",",s.Comma],[".",s.Dot],[":",s.Colon],["|",s.Pipe],["<=",s.ComparisonBinaryOperator],[">=",s.ComparisonBinaryOperator],["==",s.ComparisonBinaryOperator],["!=",s.ComparisonBinaryOperator],["<",s.ComparisonBinaryOperator],[">",s.ComparisonBinaryOperator],["+",s.AdditiveBinaryOperator],["-",s.AdditiveBinaryOperator],["*",s.MultiplicativeBinaryOperator],["/",s.MultiplicativeBinaryOperator],["%",s.MultiplicativeBinaryOperator],["=",s.Equals]],u=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function c(O,le={}){return O.endsWith(`
`)&&(O=O.slice(0,-1)),O=O.replace(/{#.*?#}/gs,"{##}"),le.lstrip_blocks&&(O=O.replace(/^[ \t]*({[#%])/gm,"$1")),le.trim_blocks&&(O=O.replace(/([#%]})\n/g,"$1")),O.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function d(O,le={}){var Ne,Ut,ds;const V=[],ie=c(O,le);let ve=0;const He=Ct=>{let Mt="";for(;Ct(ie[ve]);){if(ie[ve]==="\\"){if(++ve,ve>=ie.length)throw new SyntaxError("Unexpected end of input");const _t=ie[ve++],ys=u.get(_t);if(ys===void 0)throw new SyntaxError(`Unexpected escaped character: ${_t}`);Mt+=ys;continue}if(Mt+=ie[ve++],ve>=ie.length)throw new SyntaxError("Unexpected end of input")}return Mt};e:for(;ve<ie.length;){const Ct=(Ne=V.at(-1))==null?void 0:Ne.type;if(Ct===void 0||Ct===s.CloseStatement||Ct===s.CloseExpression){let _t="";for(;ve<ie.length&&!(ie[ve]==="{"&&(ie[ve+1]==="%"||ie[ve+1]==="{"));)_t+=ie[ve++];if(_t.length>0){V.push(new n(_t,s.Text));continue}}He(_t=>/\s/.test(_t));const Mt=ie[ve];if(Mt==="-"||Mt==="+"){const _t=(Ut=V.at(-1))==null?void 0:Ut.type;if(_t===s.Text||_t===void 0)throw new SyntaxError(`Unexpected character: ${Mt}`);switch(_t){case s.Identifier:case s.NumericLiteral:case s.BooleanLiteral:case s.NullLiteral:case s.StringLiteral:case s.CloseParen:case s.CloseSquareBracket:break;default:{++ve;const ys=He(a);V.push(new n(`${Mt}${ys}`,ys.length>0?s.NumericLiteral:s.UnaryOperator));continue}}}for(const[_t,ys]of l)if(ie.slice(ve,ve+_t.length)===_t){V.push(new n(_t,ys)),ve+=_t.length;continue e}if(Mt==="'"||Mt==='"'){++ve;const _t=He(ys=>ys!==Mt);V.push(new n(_t,s.StringLiteral)),++ve;continue}if(a(Mt)){const _t=He(a);V.push(new n(_t,s.NumericLiteral));continue}if(o(Mt)){const _t=He(o),ys=Object.hasOwn(r,_t)?r[_t]:s.Identifier;ys===s.In&&((ds=V.at(-1))==null?void 0:ds.type)===s.Not?(V.pop(),V.push(new n("not in",s.NotIn))):V.push(new n(_t,ys));continue}throw new SyntaxError(`Unexpected character: ${Mt}`)}return V}var h=class{constructor(){Z(this,"type","Statement")}},p=class extends h{constructor(le){super();Z(this,"type","Program");this.body=le}},f=class extends h{constructor(le,V,ie){super();Z(this,"type","If");this.test=le,this.body=V,this.alternate=ie}},m=class extends h{constructor(le,V,ie,ve){super();Z(this,"type","For");this.loopvar=le,this.iterable=V,this.body=ie,this.defaultBlock=ve}},x=class extends h{constructor(){super(...arguments);Z(this,"type","Break")}},g=class extends h{constructor(){super(...arguments);Z(this,"type","Continue")}},_=class extends h{constructor(le,V,ie){super();Z(this,"type","Set");this.assignee=le,this.value=V,this.body=ie}},S=class extends h{constructor(le,V,ie){super();Z(this,"type","Macro");this.name=le,this.args=V,this.body=ie}},M=class extends h{constructor(){super(...arguments);Z(this,"type","Expression")}},w=class extends M{constructor(le,V,ie){super();Z(this,"type","MemberExpression");this.object=le,this.property=V,this.computed=ie}},v=class extends M{constructor(le,V){super();Z(this,"type","CallExpression");this.callee=le,this.args=V}},T=class extends M{constructor(le){super();Z(this,"type","Identifier");this.value=le}},E=class extends M{constructor(le){super();Z(this,"type","Literal");this.value=le}},F=class extends E{constructor(){super(...arguments);Z(this,"type","NumericLiteral")}},I=class extends E{constructor(){super(...arguments);Z(this,"type","StringLiteral")}},z=class extends E{constructor(){super(...arguments);Z(this,"type","BooleanLiteral")}},G=class extends E{constructor(){super(...arguments);Z(this,"type","NullLiteral")}},L=class extends E{constructor(){super(...arguments);Z(this,"type","ArrayLiteral")}},Q=class extends E{constructor(){super(...arguments);Z(this,"type","TupleLiteral")}},q=class extends E{constructor(){super(...arguments);Z(this,"type","ObjectLiteral")}},J=class extends M{constructor(le,V,ie){super();Z(this,"type","BinaryExpression");this.operator=le,this.left=V,this.right=ie}},ee=class extends M{constructor(le,V){super();Z(this,"type","FilterExpression");this.operand=le,this.filter=V}},se=class extends M{constructor(le,V){super();Z(this,"type","SelectExpression");this.iterable=le,this.test=V}},fe=class extends M{constructor(le,V,ie){super();Z(this,"type","TestExpression");this.operand=le,this.negate=V,this.test=ie}},ue=class extends M{constructor(le,V){super();Z(this,"type","UnaryExpression");this.operator=le,this.argument=V}},U=class extends M{constructor(le=void 0,V=void 0,ie=void 0){super();Z(this,"type","SliceExpression");this.start=le,this.stop=V,this.step=ie}},k=class extends M{constructor(le,V){super();Z(this,"type","KeywordArgumentExpression");this.key=le,this.value=V}};function j(O){const le=new p([]);let V=0;function ie(je,dt){const wt=O[V++];if(!wt||wt.type!==je)throw new Error(`Parser Error: ${dt}. ${wt.type} !== ${je}.`);return wt}function ve(){switch(O[V].type){case s.Text:return Ut();case s.OpenStatement:return ds();case s.OpenExpression:return Ct();default:throw new SyntaxError(`Unexpected token type: ${O[V].type}`)}}function He(...je){return V+je.length<=O.length&&je.some((dt,wt)=>dt!==O[V+wt].type)}function Ne(...je){return V+je.length<=O.length&&je.every((dt,wt)=>dt===O[V+wt].type)}function Ut(){return new I(ie(s.Text,"Expected text token").value)}function ds(){ie(s.OpenStatement,"Expected opening statement token");let je;switch(O[V].type){case s.Set:++V,je=Mt(),ie(s.CloseStatement,"Expected closing statement token");break;case s.If:++V,je=_t(),ie(s.OpenStatement,"Expected {% token"),ie(s.EndIf,"Expected endif token"),ie(s.CloseStatement,"Expected %} token");break;case s.Macro:++V,je=ys(),ie(s.OpenStatement,"Expected {% token"),ie(s.EndMacro,"Expected endmacro token"),ie(s.CloseStatement,"Expected %} token");break;case s.For:++V,je=wi(),ie(s.OpenStatement,"Expected {% token"),ie(s.EndFor,"Expected endfor token"),ie(s.CloseStatement,"Expected %} token");break;case s.Break:++V,ie(s.CloseStatement,"Expected closing statement token"),je=new x;break;case s.Continue:++V,ie(s.CloseStatement,"Expected closing statement token"),je=new g;break;default:throw new SyntaxError(`Unknown statement type: ${O[V].type}`)}return je}function Ct(){ie(s.OpenExpression,"Expected opening expression token");const je=$s();return ie(s.CloseExpression,"Expected closing expression token"),je}function Mt(){var dt,wt;const je=$s();if(Ne(s.Equals)){++V;const xs=$s();return new _(je,xs,[])}else{const xs=[];for(ie(s.CloseStatement,"Expected %} token");!(((dt=O[V])==null?void 0:dt.type)===s.OpenStatement&&((wt=O[V+1])==null?void 0:wt.type)===s.EndSet);){const en=ve();xs.push(en)}return ie(s.OpenStatement,"Expected {% token"),ie(s.EndSet,"Expected endset token"),new _(je,null,xs)}}function _t(){var xs,en,tn,Li,hr,ai,fi,sn;const je=$s();ie(s.CloseStatement,"Expected closing statement token");const dt=[],wt=[];for(;!(((xs=O[V])==null?void 0:xs.type)===s.OpenStatement&&(((en=O[V+1])==null?void 0:en.type)===s.ElseIf||((tn=O[V+1])==null?void 0:tn.type)===s.Else||((Li=O[V+1])==null?void 0:Li.type)===s.EndIf));)dt.push(ve());if(((hr=O[V])==null?void 0:hr.type)===s.OpenStatement&&((ai=O[V+1])==null?void 0:ai.type)!==s.EndIf)if(++V,Ne(s.ElseIf))ie(s.ElseIf,"Expected elseif token"),wt.push(_t());else for(ie(s.Else,"Expected else token"),ie(s.CloseStatement,"Expected closing statement token");!(((fi=O[V])==null?void 0:fi.type)===s.OpenStatement&&((sn=O[V+1])==null?void 0:sn.type)===s.EndIf);)wt.push(ve());return new f(je,dt,wt)}function ys(){const je=ir();if(je.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const dt=Sn();ie(s.CloseStatement,"Expected closing statement token");const wt=[];for(;He(s.OpenStatement,s.EndMacro);)wt.push(ve());return new S(je,dt,wt)}function Is(je=!1){const dt=je?ir:$s,wt=[dt()],xs=Ne(s.Comma);for(;xs&&(++V,wt.push(dt()),!!Ne(s.Comma)););return xs?new Q(wt):wt[0]}function wi(){const je=Is(!0);if(!(je instanceof T||je instanceof Q))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${je.type} instead`);ie(s.In,"Expected `in` keyword following loop variable");const dt=$s();ie(s.CloseStatement,"Expected closing statement token");const wt=[];for(;He(s.OpenStatement,s.EndFor)&&He(s.OpenStatement,s.Else);)wt.push(ve());const xs=[];if(Ne(s.OpenStatement,s.Else))for(++V,++V,ie(s.CloseStatement,"Expected closing statement token");He(s.OpenStatement,s.EndFor);)xs.push(ve());return new m(je,dt,wt,xs)}function $s(){return Qi()}function Qi(){const je=Zr();if(Ne(s.If)){++V;const dt=Zr();if(Ne(s.Else)){++V;const wt=Zr();return new f(dt,[je],[wt])}else return new se(je,dt)}return je}function Zr(){let je=vn();for(;Ne(s.Or);){const dt=O[V];++V;const wt=vn();je=new J(dt,je,wt)}return je}function vn(){let je=Jr();for(;Ne(s.And);){const dt=O[V];++V;const wt=Jr();je=new J(dt,je,wt)}return je}function Jr(){let je;for(;Ne(s.Not);){const dt=O[V];++V;const wt=Jr();je=new ue(dt,wt)}return je??Qn()}function Qn(){let je=dr();for(;Ne(s.ComparisonBinaryOperator)||Ne(s.In)||Ne(s.NotIn);){const dt=O[V];++V;const wt=dr();je=new J(dt,je,wt)}return je}function dr(){let je=to();for(;Ne(s.AdditiveBinaryOperator);){const dt=O[V];++V;const wt=to();je=new J(dt,je,wt)}return je}function Zn(){const je=si(ir());return Ne(s.OpenParen)?Lr(je):je}function Lr(je){let dt=new v(je,Sn());return dt=si(dt),Ne(s.OpenParen)&&(dt=Lr(dt)),dt}function Sn(){ie(s.OpenParen,"Expected opening parenthesis for arguments list");const je=Jn();return ie(s.CloseParen,"Expected closing parenthesis for arguments list"),je}function Jn(){const je=[];for(;!Ne(s.CloseParen);){let dt=$s();if(Ne(s.Equals)){if(++V,!(dt instanceof T))throw new SyntaxError("Expected identifier for keyword argument");const wt=$s();dt=new k(dt,wt)}je.push(dt),Ne(s.Comma)&&++V}return je}function eo(){const je=[];let dt=!1;for(;!Ne(s.CloseSquareBracket);)Ne(s.Colon)?(je.push(void 0),++V,dt=!0):(je.push($s()),Ne(s.Colon)&&(++V,dt=!0));if(je.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(dt){if(je.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new U(...je)}return je[0]}function si(je){for(;Ne(s.Dot)||Ne(s.OpenSquareBracket);){const dt=O[V];++V;let wt;const xs=dt.type!==s.Dot;if(xs)wt=eo(),ie(s.CloseSquareBracket,"Expected closing square bracket");else if(wt=ir(),wt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");je=new w(je,wt,xs)}return je}function to(){let je=ki();for(;Ne(s.MultiplicativeBinaryOperator);){const dt=O[V];++V;const wt=ki();je=new J(dt,je,wt)}return je}function ki(){let je=En();for(;Ne(s.Is);){++V;const dt=Ne(s.Not);dt&&++V;let wt=ir();if(wt instanceof z?wt=new T(wt.value.toString()):wt instanceof G&&(wt=new T("none")),!(wt instanceof T))throw new SyntaxError("Expected identifier for the test");je=new fe(je,dt,wt)}return je}function En(){let je=Zn();for(;Ne(s.Pipe);){++V;let dt=ir();if(!(dt instanceof T))throw new SyntaxError("Expected identifier for the filter");Ne(s.OpenParen)&&(dt=Lr(dt)),je=new ee(je,dt)}return je}function ir(){const je=O[V];switch(je.type){case s.NumericLiteral:return++V,new F(Number(je.value));case s.StringLiteral:return++V,new I(je.value);case s.BooleanLiteral:return++V,new z(je.value.toLowerCase()==="true");case s.NullLiteral:return++V,new G(null);case s.Identifier:return++V,new T(je.value);case s.OpenParen:{++V;const dt=Is();if(O[V].type!==s.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${O[V].type} instead`);return++V,dt}case s.OpenSquareBracket:{++V;const dt=[];for(;!Ne(s.CloseSquareBracket);)dt.push($s()),Ne(s.Comma)&&++V;return++V,new L(dt)}case s.OpenCurlyBracket:{++V;const dt=new Map;for(;!Ne(s.CloseCurlyBracket);){const wt=$s();ie(s.Colon,"Expected colon between key and value in object literal");const xs=$s();dt.set(wt,xs),Ne(s.Comma)&&++V}return++V,new q(dt)}default:throw new SyntaxError(`Unexpected token: ${je.type}`)}}for(;V<O.length;)le.body.push(ve());return le}function re(O,le,V=1){le===void 0&&(le=O,O=0);const ie=[];for(let ve=O;ve<le;ve+=V)ie.push(ve);return ie}function we(O,le,V,ie=1){const ve=Math.sign(ie);ve>=0?(le=(le??(le=0))<0?Math.max(O.length+le,0):Math.min(le,O.length),V=(V??(V=O.length))<0?Math.max(O.length+V,0):Math.min(V,O.length)):(le=(le??(le=O.length-1))<0?Math.max(O.length+le,-1):Math.min(le,O.length-1),V=(V??(V=-1))<-1?Math.max(O.length+V,-1):Math.min(V,O.length-1));const He=[];for(let Ne=le;ve*Ne<ve*V;Ne+=ie)He.push(O[Ne]);return He}function de(O){return O.replace(/\b\w/g,le=>le.toUpperCase())}var Pe=class extends Error{},Xe=class extends Error{},et=class{constructor(O=void 0){Z(this,"type","RuntimeValue");Z(this,"value");Z(this,"builtins",new Map);this.value=O}__bool__(){return new oe(!!this.value)}},Me=class extends et{constructor(){super(...arguments);Z(this,"type","NumericValue")}},X=class extends et{constructor(){super(...arguments);Z(this,"type","StringValue");Z(this,"builtins",new Map([["upper",new Be(()=>new X(this.value.toUpperCase()))],["lower",new Be(()=>new X(this.value.toLowerCase()))],["strip",new Be(()=>new X(this.value.trim()))],["title",new Be(()=>new X(de(this.value)))],["length",new Me(this.value.length)],["rstrip",new Be(()=>new X(this.value.trimEnd()))],["lstrip",new Be(()=>new X(this.value.trimStart()))],["startswith",new Be(le=>{if(le.length===0)throw new Error("startswith() requires at least one argument");const V=le[0];if(!(V instanceof X))throw new Error("startswith() argument must be a string");return new oe(this.value.startsWith(V.value))})],["endswith",new Be(le=>{if(le.length===0)throw new Error("endswith() requires at least one argument");const V=le[0];if(!(V instanceof X))throw new Error("endswith() argument must be a string");return new oe(this.value.endsWith(V.value))})],["split",new Be(le=>{const V=le[0]??new Ve;if(!(V instanceof X||V instanceof Ve))throw new Error("sep argument must be a string or null");const ie=le[1]??new Me(-1);if(!(ie instanceof Me))throw new Error("maxsplit argument must be a number");let ve=[];if(V instanceof Ve){const He=this.value.trimStart();for(const{0:Ne,index:Ut}of He.matchAll(/\S+/g)){if(ie.value!==-1&&ve.length>=ie.value&&Ut!==void 0){ve.push(Ne+He.slice(Ut+Ne.length));break}ve.push(Ne)}}else{if(V.value==="")throw new Error("empty separator");ve=this.value.split(V.value),ie.value!==-1&&ve.length>ie.value&&ve.push(ve.splice(ie.value).join(V.value))}return new Ee(ve.map(He=>new X(He)))})]]))}},oe=class extends et{constructor(){super(...arguments);Z(this,"type","BooleanValue")}},K=class extends et{constructor(){super(...arguments);Z(this,"type","ObjectValue");Z(this,"builtins",new Map([["get",new Be(([le,V])=>{if(!(le instanceof X))throw new Error(`Object key must be a string: got ${le.type}`);return this.value.get(le.value)??V??new Ve})],["items",new Be(()=>new Ee(Array.from(this.value.entries()).map(([le,V])=>new Ee([new X(le),V]))))]]))}__bool__(){return new oe(this.value.size>0)}},Ce=class extends K{constructor(){super(...arguments);Z(this,"type","KeywordArgumentsValue")}},Ee=class extends et{constructor(){super(...arguments);Z(this,"type","ArrayValue");Z(this,"builtins",new Map([["length",new Me(this.value.length)]]))}__bool__(){return new oe(this.value.length>0)}},$e=class extends Ee{constructor(){super(...arguments);Z(this,"type","TupleValue")}},Be=class extends et{constructor(){super(...arguments);Z(this,"type","FunctionValue")}},Ve=class extends et{constructor(){super(...arguments);Z(this,"type","NullValue")}},We=class extends et{constructor(){super(...arguments);Z(this,"type","UndefinedValue")}},Je=class{constructor(O){Z(this,"variables",new Map([["namespace",new Be(O=>{if(O.length===0)return new K(new Map);if(O.length!==1||!(O[0]instanceof K))throw new Error("`namespace` expects either zero arguments or a single object argument");return O[0]})]]));Z(this,"tests",new Map([["boolean",O=>O.type==="BooleanValue"],["callable",O=>O instanceof Be],["odd",O=>{if(O.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${O.type}`);return O.value%2!==0}],["even",O=>{if(O.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${O.type}`);return O.value%2===0}],["false",O=>O.type==="BooleanValue"&&!O.value],["true",O=>O.type==="BooleanValue"&&O.value],["none",O=>O.type==="NullValue"],["string",O=>O.type==="StringValue"],["number",O=>O.type==="NumericValue"],["integer",O=>O.type==="NumericValue"&&Number.isInteger(O.value)],["iterable",O=>O.type==="ArrayValue"||O.type==="StringValue"],["mapping",O=>O.type==="ObjectValue"],["lower",O=>{const le=O.value;return O.type==="StringValue"&&le===le.toLowerCase()}],["upper",O=>{const le=O.value;return O.type==="StringValue"&&le===le.toUpperCase()}],["none",O=>O.type==="NullValue"],["defined",O=>O.type!=="UndefinedValue"],["undefined",O=>O.type==="UndefinedValue"],["equalto",(O,le)=>O.value===le.value],["eq",(O,le)=>O.value===le.value]]));this.parent=O}set(O,le){return this.declareVariable(O,lt(le))}declareVariable(O,le){if(this.variables.has(O))throw new SyntaxError(`Variable already declared: ${O}`);return this.variables.set(O,le),le}setVariable(O,le){return this.variables.set(O,le),le}resolve(O){if(this.variables.has(O))return this;if(this.parent)return this.parent.resolve(O);throw new Error(`Unknown variable: ${O}`)}lookupVariable(O){try{return this.resolve(O).variables.get(O)??new We}catch{return new We}}},it=class{constructor(O){Z(this,"global");this.global=O??new Je}run(O){return this.evaluate(O,this.global)}evaluateBinaryExpression(O,le){const V=this.evaluate(O.left,le);switch(O.operator.value){case"and":return V.__bool__().value?this.evaluate(O.right,le):V;case"or":return V.__bool__().value?V:this.evaluate(O.right,le)}const ie=this.evaluate(O.right,le);switch(O.operator.value){case"==":return new oe(V.value==ie.value);case"!=":return new oe(V.value!=ie.value)}if(V instanceof We||ie instanceof We)throw new Error("Cannot perform operation on undefined values");if(V instanceof Ve||ie instanceof Ve)throw new Error("Cannot perform operation on null values");if(V instanceof Me&&ie instanceof Me)switch(O.operator.value){case"+":return new Me(V.value+ie.value);case"-":return new Me(V.value-ie.value);case"*":return new Me(V.value*ie.value);case"/":return new Me(V.value/ie.value);case"%":return new Me(V.value%ie.value);case"<":return new oe(V.value<ie.value);case">":return new oe(V.value>ie.value);case">=":return new oe(V.value>=ie.value);case"<=":return new oe(V.value<=ie.value)}else if(V instanceof Ee&&ie instanceof Ee)switch(O.operator.value){case"+":return new Ee(V.value.concat(ie.value))}else if(ie instanceof Ee){const ve=ie.value.find(He=>He.value===V.value)!==void 0;switch(O.operator.value){case"in":return new oe(ve);case"not in":return new oe(!ve)}}if(V instanceof X||ie instanceof X)switch(O.operator.value){case"+":return new X(V.value.toString()+ie.value.toString())}if(V instanceof X&&ie instanceof X)switch(O.operator.value){case"in":return new oe(ie.value.includes(V.value));case"not in":return new oe(!ie.value.includes(V.value))}if(V instanceof X&&ie instanceof K)switch(O.operator.value){case"in":return new oe(ie.value.has(V.value));case"not in":return new oe(!ie.value.has(V.value))}throw new SyntaxError(`Unknown operator "${O.operator.value}" between ${V.type} and ${ie.type}`)}evaluateArguments(O,le){const V=[],ie=new Map;for(const ve of O)if(ve.type==="KeywordArgumentExpression"){const He=ve;ie.set(He.key.value,this.evaluate(He.value,le))}else{if(ie.size>0)throw new Error("Positional arguments must come before keyword arguments");V.push(this.evaluate(ve,le))}return[V,ie]}evaluateFilterExpression(O,le){const V=this.evaluate(O.operand,le);if(O.filter.type==="Identifier"){const ie=O.filter;if(ie.value==="tojson")return new X(Ue(V));if(V instanceof Ee)switch(ie.value){case"list":return V;case"first":return V.value[0];case"last":return V.value[V.value.length-1];case"length":return new Me(V.value.length);case"reverse":return new Ee(V.value.reverse());case"sort":return new Ee(V.value.sort((ve,He)=>{if(ve.type!==He.type)throw new Error(`Cannot compare different types: ${ve.type} and ${He.type}`);switch(ve.type){case"NumericValue":return ve.value-He.value;case"StringValue":return ve.value.localeCompare(He.value);default:throw new Error(`Cannot compare type: ${ve.type}`)}}));case"join":return new X(V.value.map(ve=>ve.value).join(""));case"string":return new X(Ue(V));default:throw new Error(`Unknown ArrayValue filter: ${ie.value}`)}else if(V instanceof X)switch(ie.value){case"length":return new Me(V.value.length);case"upper":return new X(V.value.toUpperCase());case"lower":return new X(V.value.toLowerCase());case"title":return new X(de(V.value));case"capitalize":return new X(V.value.charAt(0).toUpperCase()+V.value.slice(1));case"trim":return new X(V.value.trim());case"indent":return new X(V.value.split(`
`).map((ve,He)=>He===0||ve.length===0?ve:"    "+ve).join(`
`));case"join":case"string":return V;default:throw new Error(`Unknown StringValue filter: ${ie.value}`)}else if(V instanceof Me)switch(ie.value){case"abs":return new Me(Math.abs(V.value));default:throw new Error(`Unknown NumericValue filter: ${ie.value}`)}else if(V instanceof K)switch(ie.value){case"items":return new Ee(Array.from(V.value.entries()).map(([ve,He])=>new Ee([new X(ve),He])));case"length":return new Me(V.value.size);default:throw new Error(`Unknown ObjectValue filter: ${ie.value}`)}throw new Error(`Cannot apply filter "${ie.value}" to type: ${V.type}`)}else if(O.filter.type==="CallExpression"){const ie=O.filter;if(ie.callee.type!=="Identifier")throw new Error(`Unknown filter: ${ie.callee.type}`);const ve=ie.callee.value;if(ve==="tojson"){const[,He]=this.evaluateArguments(ie.args,le),Ne=He.get("indent")??new Ve;if(!(Ne instanceof Me||Ne instanceof Ve))throw new Error("If set, indent must be a number");return new X(Ue(V,Ne.value))}else if(ve==="join"){let He;if(V instanceof X)He=Array.from(V.value);else if(V instanceof Ee)He=V.value.map(Ct=>Ct.value);else throw new Error(`Cannot apply filter "${ve}" to type: ${V.type}`);const[Ne,Ut]=this.evaluateArguments(ie.args,le),ds=Ne.at(0)??Ut.get("separator")??new X("");if(!(ds instanceof X))throw new Error("separator must be a string");return new X(He.join(ds.value))}if(V instanceof Ee){switch(ve){case"selectattr":case"rejectattr":{const He=ve==="selectattr";if(V.value.some(_t=>!(_t instanceof K)))throw new Error(`\`${ve}\` can only be applied to array of objects`);if(ie.args.some(_t=>_t.type!=="StringLiteral"))throw new Error(`arguments of \`${ve}\` must be strings`);const[Ne,Ut,ds]=ie.args.map(_t=>this.evaluate(_t,le));let Ct;if(Ut){const _t=le.tests.get(Ut.value);if(!_t)throw new Error(`Unknown test: ${Ut.value}`);Ct=_t}else Ct=(..._t)=>_t[0].__bool__().value;const Mt=V.value.filter(_t=>{const ys=_t.value.get(Ne.value),Is=ys?Ct(ys,ds):!1;return He?Is:!Is});return new Ee(Mt)}case"map":{const[,He]=this.evaluateArguments(ie.args,le);if(He.has("attribute")){const Ne=He.get("attribute");if(!(Ne instanceof X))throw new Error("attribute must be a string");const Ut=He.get("default"),ds=V.value.map(Ct=>{if(!(Ct instanceof K))throw new Error("items in map must be an object");return Ct.value.get(Ne.value)??Ut??new We});return new Ee(ds)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${ve}`)}else if(V instanceof X){switch(ve){case"indent":{const[He,Ne]=this.evaluateArguments(ie.args,le),Ut=He.at(0)??Ne.get("width")??new Me(4);if(!(Ut instanceof Me))throw new Error("width must be a number");const ds=He.at(1)??Ne.get("first")??new oe(!1),Ct=He.at(2)??Ne.get("blank")??new oe(!1),Mt=V.value.split(`
`),_t=" ".repeat(Ut.value),ys=Mt.map((Is,wi)=>!ds.value&&wi===0||!Ct.value&&Is.length===0?Is:_t+Is);return new X(ys.join(`
`))}}throw new Error(`Unknown StringValue filter: ${ve}`)}else throw new Error(`Cannot apply filter "${ve}" to type: ${V.type}`)}throw new Error(`Unknown filter: ${O.filter.type}`)}evaluateTestExpression(O,le){const V=this.evaluate(O.operand,le),ie=le.tests.get(O.test.value);if(!ie)throw new Error(`Unknown test: ${O.test.value}`);const ve=ie(V);return new oe(O.negate?!ve:ve)}evaluateUnaryExpression(O,le){const V=this.evaluate(O.argument,le);switch(O.operator.value){case"not":return new oe(!V.value);default:throw new SyntaxError(`Unknown operator: ${O.operator.value}`)}}evalProgram(O,le){return this.evaluateBlock(O.body,le)}evaluateBlock(O,le){let V="";for(const ie of O){const ve=this.evaluate(ie,le);ve.type!=="NullValue"&&ve.type!=="UndefinedValue"&&(V+=ve.value)}return new X(V)}evaluateIdentifier(O,le){return le.lookupVariable(O.value)}evaluateCallExpression(O,le){const[V,ie]=this.evaluateArguments(O.args,le);ie.size>0&&V.push(new Ce(ie));const ve=this.evaluate(O.callee,le);if(ve.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${ve.type}`);return ve.value(V,le)}evaluateSliceExpression(O,le,V){if(!(O instanceof Ee||O instanceof X))throw new Error("Slice object must be an array or string");const ie=this.evaluate(le.start,V),ve=this.evaluate(le.stop,V),He=this.evaluate(le.step,V);if(!(ie instanceof Me||ie instanceof We))throw new Error("Slice start must be numeric or undefined");if(!(ve instanceof Me||ve instanceof We))throw new Error("Slice stop must be numeric or undefined");if(!(He instanceof Me||He instanceof We))throw new Error("Slice step must be numeric or undefined");return O instanceof Ee?new Ee(we(O.value,ie.value,ve.value,He.value)):new X(we(Array.from(O.value),ie.value,ve.value,He.value).join(""))}evaluateMemberExpression(O,le){const V=this.evaluate(O.object,le);let ie;if(O.computed){if(O.property.type==="SliceExpression")return this.evaluateSliceExpression(V,O.property,le);ie=this.evaluate(O.property,le)}else ie=new X(O.property.value);let ve;if(V instanceof K){if(!(ie instanceof X))throw new Error(`Cannot access property with non-string: got ${ie.type}`);ve=V.value.get(ie.value)??V.builtins.get(ie.value)}else if(V instanceof Ee||V instanceof X)if(ie instanceof Me)ve=V.value.at(ie.value),V instanceof X&&(ve=new X(V.value.at(ie.value)));else if(ie instanceof X)ve=V.builtins.get(ie.value);else throw new Error(`Cannot access property with non-string/non-number: got ${ie.type}`);else{if(!(ie instanceof X))throw new Error(`Cannot access property with non-string: got ${ie.type}`);ve=V.builtins.get(ie.value)}return ve instanceof et?ve:new We}evaluateSet(O,le){const V=O.value?this.evaluate(O.value,le):this.evaluateBlock(O.body,le);if(O.assignee.type==="Identifier"){const ie=O.assignee.value;le.setVariable(ie,V)}else if(O.assignee.type==="MemberExpression"){const ie=O.assignee,ve=this.evaluate(ie.object,le);if(!(ve instanceof K))throw new Error("Cannot assign to member of non-object");if(ie.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");ve.value.set(ie.property.value,V)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(O.assignee)}`);return new Ve}evaluateIf(O,le){const V=this.evaluate(O.test,le);return this.evaluateBlock(V.__bool__().value?O.body:O.alternate,le)}evaluateFor(O,le){const V=new Je(le);let ie,ve;if(O.iterable.type==="SelectExpression"){const Ct=O.iterable;ve=this.evaluate(Ct.iterable,V),ie=Ct.test}else ve=this.evaluate(O.iterable,V);if(!(ve instanceof Ee))throw new Error(`Expected iterable type in for loop: got ${ve.type}`);const He=[],Ne=[];for(let Ct=0;Ct<ve.value.length;++Ct){const Mt=new Je(V),_t=ve.value[Ct];let ys;if(O.loopvar.type==="Identifier")ys=Is=>Is.setVariable(O.loopvar.value,_t);else if(O.loopvar.type==="TupleLiteral"){const Is=O.loopvar;if(_t.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${_t.type}`);const wi=_t;if(Is.value.length!==wi.value.length)throw new Error(`Too ${Is.value.length>wi.value.length?"few":"many"} items to unpack`);ys=$s=>{for(let Qi=0;Qi<Is.value.length;++Qi){if(Is.value[Qi].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${Is.value[Qi].type}`);$s.setVariable(Is.value[Qi].value,wi.value[Qi])}}}else throw new Error(`Invalid loop variable(s): ${O.loopvar.type}`);ie&&(ys(Mt),!this.evaluate(ie,Mt).__bool__().value)||(He.push(_t),Ne.push(ys))}let Ut="",ds=!0;for(let Ct=0;Ct<He.length;++Ct){const Mt=new Map([["index",new Me(Ct+1)],["index0",new Me(Ct)],["revindex",new Me(He.length-Ct)],["revindex0",new Me(He.length-Ct-1)],["first",new oe(Ct===0)],["last",new oe(Ct===He.length-1)],["length",new Me(He.length)],["previtem",Ct>0?He[Ct-1]:new We],["nextitem",Ct<He.length-1?He[Ct+1]:new We]]);V.setVariable("loop",new K(Mt)),Ne[Ct](V);try{const _t=this.evaluateBlock(O.body,V);Ut+=_t.value}catch(_t){if(_t instanceof Xe)continue;if(_t instanceof Pe)break;throw _t}ds=!1}if(ds){const Ct=this.evaluateBlock(O.defaultBlock,V);Ut+=Ct.value}return new X(Ut)}evaluateMacro(O,le){return le.setVariable(O.name.value,new Be((V,ie)=>{var Ne;const ve=new Je(ie);V=V.slice();let He;((Ne=V.at(-1))==null?void 0:Ne.type)==="KeywordArgumentsValue"&&(He=V.pop());for(let Ut=0;Ut<O.args.length;++Ut){const ds=O.args[Ut],Ct=V[Ut];if(ds.type==="Identifier"){const Mt=ds;if(!Ct)throw new Error(`Missing positional argument: ${Mt.value}`);ve.setVariable(Mt.value,Ct)}else if(ds.type==="KeywordArgumentExpression"){const Mt=ds,_t=Ct??(He==null?void 0:He.value.get(Mt.key.value))??this.evaluate(Mt.value,ve);ve.setVariable(Mt.key.value,_t)}else throw new Error(`Unknown argument type: ${ds.type}`)}return this.evaluateBlock(O.body,ve)})),new Ve}evaluate(O,le){if(O===void 0)return new We;switch(O.type){case"Program":return this.evalProgram(O,le);case"Set":return this.evaluateSet(O,le);case"If":return this.evaluateIf(O,le);case"For":return this.evaluateFor(O,le);case"Macro":return this.evaluateMacro(O,le);case"Break":throw new Pe;case"Continue":throw new Xe;case"NumericLiteral":return new Me(Number(O.value));case"StringLiteral":return new X(O.value);case"BooleanLiteral":return new oe(O.value);case"NullLiteral":return new Ve(O.value);case"ArrayLiteral":return new Ee(O.value.map(V=>this.evaluate(V,le)));case"TupleLiteral":return new $e(O.value.map(V=>this.evaluate(V,le)));case"ObjectLiteral":{const V=new Map;for(const[ie,ve]of O.value){const He=this.evaluate(ie,le);if(!(He instanceof X))throw new Error(`Object keys must be strings: got ${He.type}`);V.set(He.value,this.evaluate(ve,le))}return new K(V)}case"Identifier":return this.evaluateIdentifier(O,le);case"CallExpression":return this.evaluateCallExpression(O,le);case"MemberExpression":return this.evaluateMemberExpression(O,le);case"UnaryExpression":return this.evaluateUnaryExpression(O,le);case"BinaryExpression":return this.evaluateBinaryExpression(O,le);case"FilterExpression":return this.evaluateFilterExpression(O,le);case"TestExpression":return this.evaluateTestExpression(O,le);default:throw new SyntaxError(`Unknown node type: ${O.type}`)}}};function lt(O){switch(typeof O){case"number":return new Me(O);case"string":return new X(O);case"boolean":return new oe(O);case"undefined":return new We;case"object":return O===null?new Ve:Array.isArray(O)?new Ee(O.map(lt)):new K(new Map(Object.entries(O).map(([le,V])=>[le,lt(V)])));case"function":return new Be((le,V)=>{const ie=O(...le.map(ve=>ve.value))??null;return lt(ie)});default:throw new Error(`Cannot convert to runtime value: ${O}`)}}function Ue(O,le,V){const ie=V??0;switch(O.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(O.value);case"ArrayValue":case"ObjectValue":{const ve=le?" ".repeat(le):"",He=`
`+ve.repeat(ie),Ne=He+ve;if(O.type==="ArrayValue"){const Ut=O.value.map(ds=>Ue(ds,le,ie+1));return le?`[${Ne}${Ut.join(`,${Ne}`)}${He}]`:`[${Ut.join(", ")}]`}else{const Ut=Array.from(O.value.entries()).map(([ds,Ct])=>{const Mt=`"${ds}": ${Ue(Ct,le,ie+1)}`;return le?`${Ne}${Mt}`:Mt});return le?`{${Ut.join(",")}${He}}`:`{${Ut.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${O.type}`)}}var rt=`
`,yt="{%- ",Nt=" -%}",bt={MultiplicativeBinaryOperator:2,AdditiveBinaryOperator:1,ComparisonBinaryOperator:0};function Ye(O,le="	"){const V=typeof le=="number"?" ".repeat(le):le;return pt(O.body,0,V).replace(/\n$/,"")}function tt(...O){return yt+O.join(" ")+Nt}function pt(O,le,V){return O.map(ie=>ss(ie,le,V)).join(rt)}function ss(O,le,V){const ie=V.repeat(le);switch(O.type){case"Program":return pt(O.body,le,V);case"If":return Zt(O,le,V);case"For":return _s(O,le,V);case"Set":return bi(O,le,V);case"Macro":return ti(O,le,V);case"Break":return ie+tt("break");case"Continue":return ie+tt("continue");default:return ie+"{{- "+$t(O)+" -}}"}}function Zt(O,le,V){const ie=V.repeat(le),ve=[];let He=O;for(;He&&(ve.push({test:He.test,body:He.body}),He.alternate.length===1&&He.alternate[0].type==="If");)He=He.alternate[0];let Ne=ie+tt("if",$t(ve[0].test))+rt+pt(ve[0].body,le+1,V);for(let Ut=1;Ut<ve.length;Ut++)Ne+=rt+ie+tt("elif",$t(ve[Ut].test))+rt+pt(ve[Ut].body,le+1,V);return He&&He.alternate.length>0&&(Ne+=rt+ie+tt("else")+rt+pt(He.alternate,le+1,V)),Ne+=rt+ie+tt("endif"),Ne}function _s(O,le,V){const ie=V.repeat(le);let ve="";if(O.iterable.type==="SelectExpression"){const Ne=O.iterable;ve=`${$t(Ne.iterable)} if ${$t(Ne.test)}`}else ve=$t(O.iterable);let He=ie+tt("for",$t(O.loopvar),"in",ve)+rt+pt(O.body,le+1,V);return O.defaultBlock.length>0&&(He+=rt+ie+tt("else")+rt+pt(O.defaultBlock,le+1,V)),He+=rt+ie+tt("endfor"),He}function bi(O,le,V){const ie=V.repeat(le),ve=$t(O.assignee),He=O.value?$t(O.value):"",Ne=ie+tt("set",`${ve}${O.value?" = "+He:""}`);return O.body.length===0?Ne:Ne+rt+pt(O.body,le+1,V)+rt+ie+tt("endset")}function ti(O,le,V){const ie=V.repeat(le),ve=O.args.map($t).join(", ");return ie+tt("macro",`${O.name.value}(${ve})`)+rt+pt(O.body,le+1,V)+rt+ie+tt("endmacro")}function $t(O,le=-1){switch(O.type){case"Identifier":return O.value;case"NullLiteral":return"none";case"NumericLiteral":case"BooleanLiteral":return`${O.value}`;case"StringLiteral":return JSON.stringify(O.value);case"BinaryExpression":{const V=O,ie=bt[V.operator.type]??0,ve=$t(V.left,ie),He=$t(V.right,ie+1),Ne=`${ve} ${V.operator.value} ${He}`;return ie<le?`(${Ne})`:Ne}case"UnaryExpression":{const V=O;return V.operator.value+(V.operator.value==="not"?" ":"")+$t(V.argument,1/0)}case"LogicalNegationExpression":return`not ${$t(O.argument,1/0)}`;case"CallExpression":{const V=O,ie=V.args.map(ve=>$t(ve,-1)).join(", ");return`${$t(V.callee,-1)}(${ie})`}case"MemberExpression":{const V=O;let ie=$t(V.object,-1);V.object.type!=="Identifier"&&(ie=`(${ie})`);let ve=$t(V.property,-1);return!V.computed&&V.property.type!=="Identifier"&&(ve=`(${ve})`),V.computed?`${ie}[${ve}]`:`${ie}.${ve}`}case"FilterExpression":{const V=O,ie=$t(V.operand,1/0);return V.filter.type==="CallExpression"?`${ie} | ${$t(V.filter,-1)}`:`${ie} | ${V.filter.value}`}case"SelectExpression":{const V=O;return`${$t(V.iterable,-1)} | select(${$t(V.test,-1)})`}case"TestExpression":{const V=O;return`${$t(V.operand,-1)} is${V.negate?" not":""} ${V.test.value}`}case"ArrayLiteral":case"TupleLiteral":{const V=O.value.map(ve=>$t(ve,-1)),ie=O.type==="ArrayLiteral"?"[]":"()";return`${ie[0]}${V.join(", ")}${ie[1]}`}case"ObjectLiteral":return`{ ${Array.from(O.value.entries()).map(([ie,ve])=>`${$t(ie,-1)}: ${$t(ve,-1)}`).join(", ")} }`;case"SliceExpression":{const V=O,ie=V.start?$t(V.start,-1):"",ve=V.stop?$t(V.stop,-1):"",He=V.step?`:${$t(V.step,-1)}`:"";return`${ie}:${ve}${He}`}case"KeywordArgumentExpression":{const V=O;return`${V.key.value}=${$t(V.value,-1)}`}case"If":{const V=O,ie=$t(V.test,-1),ve=$t(V.body[0],0),He=$t(V.alternate[0],-1);return`${ve} if ${ie} else ${He}`}default:throw new Error(`Unknown expression type: ${O.type}`)}}var Qr=class{constructor(O){Z(this,"parsed");const le=d(O,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=j(le)}render(O){const le=new Je;if(le.set("false",!1),le.set("true",!0),le.set("raise_exception",ve=>{throw new Error(ve)}),le.set("range",re),O)for(const[ve,He]of Object.entries(O))le.set(ve,He);return new it(le).run(this.parsed).value}format(O){return Ye(this.parsed,(O==null?void 0:O.indent)||"	")}}},"./src/backends/onnx.js":(i,e,t)=>{var s;t.r(e),t.d(e,{Tensor:()=>a.Tensor,createInferenceSession:()=>x,deviceToExecutionProviders:()=>f,isONNXProxy:()=>S,isONNXTensor:()=>g});var r=t("./src/env.js"),n=t("?2ce3"),o=t("onnxruntime-web"),a=t("onnxruntime-common");const l=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),u=[];let c,d;const h=Symbol.for("onnxruntime");if(h in globalThis)d=globalThis[h];else if(r.apis.IS_NODE_ENV){switch(d=n??(s||(s=t.t(n,2))),process.platform){case"win32":u.push("dml");break;case"linux":process.arch==="x64"&&u.push("cuda");break}u.push("cpu"),c=["cpu"]}else d=o,r.apis.IS_WEBNN_AVAILABLE&&u.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),r.apis.IS_WEBGPU_AVAILABLE&&u.push("webgpu"),u.push("wasm"),c=["wasm"];const p=d.InferenceSession;function f(M=null){if(!M)return c;switch(M){case"auto":return u;case"gpu":return u.filter(w=>["webgpu","cuda","dml","webnn-gpu"].includes(w))}if(u.includes(M))return[l[M]??M];throw new Error(`Unsupported device: "${M}". Should be one of: ${u.join(", ")}.`)}let m=null;async function x(M,w,v){m&&await m;const T=p.create(M,w);m??(m=T);const E=await T;return E.config=v,E}function g(M){return M instanceof d.Tensor}const _=d==null?void 0:d.env;_!=null&&_.wasm&&(!(typeof ServiceWorkerGlobalScope<"u"&&self instanceof ServiceWorkerGlobalScope)&&!_.wasm.wasmPaths&&(_.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${r.env.version}/dist/`),_.wasm.proxy=!1),_!=null&&_.webgpu&&(_.webgpu.powerPreference="high-performance");function S(){var M;return(M=_==null?void 0:_.wasm)==null?void 0:M.proxy}r.env.backends.onnx=_},"./src/base/feature_extraction_utils.js":(i,e,t)=>{t.r(e),t.d(e,{FeatureExtractor:()=>o,validate_audio_inputs:()=>a});var s=t("./src/utils/constants.js"),r=t("./src/utils/generic.js"),n=t("./src/utils/hub.js");class o extends r.Callable{constructor(u){super(),this.config=u}static async from_pretrained(u,c={}){const d=await(0,n.getModelJSON)(u,s.FEATURE_EXTRACTOR_NAME,!0,c);return new this(d)}}function a(l,u){var c;if(!(l instanceof Float32Array||l instanceof Float64Array))throw new Error(`${u} expects input to be a Float32Array or a Float64Array, but got ${((c=l==null?void 0:l.constructor)==null?void 0:c.name)??typeof l} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":(i,e,t)=>{t.r(e),t.d(e,{ImageProcessor:()=>M,center_to_corners_format:()=>d,post_process_instance_segmentation:()=>S,post_process_object_detection:()=>h,post_process_panoptic_segmentation:()=>_,post_process_semantic_segmentation:()=>p});var s=t("./src/utils/generic.js"),r=t("./src/utils/tensor.js"),n=t("./src/utils/maths.js");t("./src/utils/image.js");var o=t("./src/utils/core.js"),a=t("./src/utils/hub.js"),l=t("./src/utils/constants.js");function u(w,v,T=0,E=null){const F=w/v;let I=(0,n.bankers_round)(F)*v;return E!==null&&I>E&&(I=Math.floor(F)*v),I<T&&(I=Math.ceil(F)*v),I}function c([w,v],T){return[Math.max(Math.floor(w/T),1)*T,Math.max(Math.floor(v/T),1)*T]}function d([w,v,T,E]){return[w-T/2,v-E/2,w+T/2,v+E/2]}function h(w,v=.5,T=null,E=!1){const F=w.logits,I=w.pred_boxes,[z,G,L]=F.dims;if(T!==null&&T.length!==z)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Q=[];for(let q=0;q<z;++q){let J=T!==null?T[q]:null,ee={boxes:[],classes:[],scores:[]},se=F[q],fe=I[q];for(let ue=0;ue<G;++ue){let U=se[ue],k=[],j;if(E){j=U.sigmoid().data;for(let re=0;re<j.length;++re)j[re]>v&&k.push(re)}else{let re=(0,n.max)(U.data)[1];if(re===L-1||(j=(0,n.softmax)(U.data),j[re]<v))continue;k.push(re)}for(const re of k){let we=fe[ue].data;we=d(we),J!==null&&(we=we.map((de,Pe)=>de*J[(Pe+1)%2])),ee.boxes.push(we),ee.classes.push(re),ee.scores.push(j[re])}}Q.push(ee)}return Q}function p(w,v=null){const T=w.logits,E=T.dims[0];if(v!==null&&v.length!==E)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const F=[];for(let I=0;I<E;++I){const z=v!==null?v[I]:null;let G=T[I];z!==null&&(G=(0,r.interpolate)(G,z,"bilinear",!1));const[L,Q]=z??G.dims.slice(-2),q=new r.Tensor("int32",new Int32Array(L*Q),[L,Q]),J=G[0].data,ee=q.data;for(let ue=1;ue<G.dims[0];++ue){const U=G[ue].data;for(let k=0;k<U.length;++k)U[k]>J[k]&&(J[k]=U[k],ee[k]=ue)}const se=new Array(G.dims[0]);for(let ue=0;ue<ee.length;++ue){const U=ee[ue];se[U]=U}const fe=se.filter(ue=>ue!==void 0);F.push({segmentation:q,labels:fe})}return F}function f(w,v,T,E){const F=[],I=[],z=[];for(let G=0;G<w.dims[0];++G){const L=w[G],Q=v[G],q=(0,n.max)(L.data)[1];if(q===E)continue;const ee=(0,n.softmax)(L.data)[q];ee>T&&(F.push(Q),I.push(ee),z.push(q))}return[F,I,z]}function m(w,v,T,E=.5,F=.8){const I=[];let z=0,G=0;const L=v[T].data;for(let q=0;q<w.length;++q)w[q]===T&&(I.push(q),++z),L[q]>=E&&++G;let Q=z>0&&G>0;return Q&&(Q=z/G>F),[Q,I]}function x(w,v,T,E,F,I=null,z=null){const[G,L]=z??w[0].dims,Q=new r.Tensor("int32",new Int32Array(G*L),[G,L]),q=[];if(z!==null)for(let ue=0;ue<w.length;++ue)w[ue]=(0,r.interpolate)(w[ue],z,"bilinear",!1);const J=new Int32Array(w[0].data.length),ee=new Float32Array(w[0].data.length);for(let ue=0;ue<w.length;++ue){let U=v[ue];const k=w[ue].data;for(let j=0;j<k.length;++j)k[j]*=U,k[j]>ee[j]&&(J[j]=ue,ee[j]=k[j])}let se=0;const fe=Q.data;for(let ue=0;ue<T.length;++ue){const U=T[ue],[k,j]=m(J,w,ue,E,F);if(k){++se;for(const re of j)fe[re]=se;q.push({id:se,label_id:U,score:v[ue]})}}return[Q,q]}function g(w,v,T=28,E=56*56,F=14*14*4*1280){if(w<T||v<T)throw new Error(`height:${w} or width:${v} must be larger than factor:${T}`);if(Math.max(w,v)/Math.min(w,v)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(w,v)/Math.min(w,v)}`);let I=Math.round(w/T)*T,z=Math.round(v/T)*T;if(I*z>F){const G=Math.sqrt(w*v/F);I=Math.floor(w/G/T)*T,z=Math.floor(v/G/T)*T}else if(I*z<E){const G=Math.sqrt(E/(w*v));I=Math.ceil(w*G/T)*T,z=Math.ceil(v*G/T)*T}return[I,z]}function _(w,v=.5,T=.5,E=.8,F=null,I=null){F===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),F=new Set);const z=w.class_queries_logits??w.logits,L=(w.masks_queries_logits??w.pred_masks).sigmoid();let[Q,q,J]=z.dims;if(J-=1,I!==null&&I.length!==Q)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let ee=[];for(let se=0;se<Q;++se){let fe=I!==null?I[se]:null,ue=z[se],U=L[se],[k,j,re]=f(ue,U,v,J);if(re.length===0){let[Pe,Xe]=fe??U.dims.slice(-2),et=new r.Tensor("int32",new Int32Array(Pe*Xe).fill(-1),[Pe,Xe]);ee.push({segmentation:et,segments_info:[]});continue}let[we,de]=x(k,j,re,T,E,F,fe);ee.push({segmentation:we,segments_info:de})}return ee}function S(w,v=.5,T=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class M extends s.Callable{constructor(v){super(),this.image_mean=v.image_mean??v.mean,this.image_std=v.image_std??v.std,this.resample=v.resample??2,this.do_rescale=v.do_rescale??!0,this.rescale_factor=v.rescale_factor??1/255,this.do_normalize=v.do_normalize,this.do_thumbnail=v.do_thumbnail,this.size=v.size??v.image_size,this.do_resize=v.do_resize??this.size!==void 0,this.size_divisibility=v.size_divisibility??v.size_divisor,this.do_center_crop=v.do_center_crop,this.crop_size=v.crop_size,this.do_convert_rgb=v.do_convert_rgb??!0,this.do_crop_margin=v.do_crop_margin,this.pad_size=v.pad_size,this.do_pad=v.do_pad,this.min_pixels=v.min_pixels,this.max_pixels=v.max_pixels,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=v.do_flip_channel_order??!1,this.config=v}async thumbnail(v,T,E=2){const F=v.height,I=v.width,z=T.height,G=T.width;let L=Math.min(F,z),Q=Math.min(I,G);return L===F&&Q===I?v:(F>I?Q=Math.floor(I*L/F):I>F&&(L=Math.floor(F*Q/I)),await v.resize(Q,L,{resample:E}))}async crop_margin(v,T=200){const E=v.clone().grayscale(),F=(0,n.min)(E.data)[0],z=(0,n.max)(E.data)[0]-F;if(z===0)return v;const G=T/255;let L=E.width,Q=E.height,q=0,J=0;const ee=E.data;for(let se=0;se<E.height;++se){const fe=se*E.width;for(let ue=0;ue<E.width;++ue)(ee[fe+ue]-F)/z<G&&(L=Math.min(L,ue),Q=Math.min(Q,se),q=Math.max(q,ue),J=Math.max(J,se))}return v=await v.crop([L,Q,q,J]),v}pad_image(v,T,E,{mode:F="constant",center:I=!1,constant_values:z=0}={}){const[G,L,Q]=T;let q,J;if(typeof E=="number"?(q=E,J=E):E==="square"?q=J=Math.max(G,L):(q=E.width,J=E.height),q!==L||J!==G){const ee=new Float32Array(q*J*Q);if(Array.isArray(z))for(let ue=0;ue<ee.length;++ue)ee[ue]=z[ue%Q];else z!==0&&ee.fill(z);const[se,fe]=I?[Math.floor((q-L)/2),Math.floor((J-G)/2)]:[0,0];for(let ue=0;ue<G;++ue){const U=(ue+fe)*q,k=ue*L;for(let j=0;j<L;++j){const re=(U+j+se)*Q,we=(k+j)*Q;for(let de=0;de<Q;++de)ee[re+de]=v[we+de]}}if(F==="symmetric"){if(I)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const ue=G-1,U=L-1;for(let k=0;k<J;++k){const j=k*q,re=(0,o.calculateReflectOffset)(k,ue)*L;for(let we=0;we<q;++we){if(k<G&&we<L)continue;const de=(j+we)*Q,Pe=(re+(0,o.calculateReflectOffset)(we,U))*Q;for(let Xe=0;Xe<Q;++Xe)ee[de+Xe]=v[Pe+Xe]}}}v=ee,T=[J,q,Q]}return[v,T]}rescale(v){for(let T=0;T<v.length;++T)v[T]=this.rescale_factor*v[T]}get_resize_output_image_size(v,T){const[E,F]=v.size;let I,z;if(this.do_thumbnail){const{height:G,width:L}=T;I=Math.min(G,L)}else Number.isInteger(T)?(I=T,z=this.config.max_size??I):T!==void 0&&(I=T.shortest_edge,z=T.longest_edge);if(I!==void 0||z!==void 0){const G=I===void 0?1:Math.max(I/E,I/F),L=E*G,Q=F*G,q=z===void 0?1:Math.min(z/L,z/Q);let J=Math.floor(Number((L*q).toFixed(2))),ee=Math.floor(Number((Q*q).toFixed(2)));return this.size_divisibility!==void 0&&([J,ee]=c([J,ee],this.size_divisibility)),[J,ee]}else if(T!==void 0&&T.width!==void 0&&T.height!==void 0){let G=T.width,L=T.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let Q=L/F,q=G/E;Math.abs(1-q)<Math.abs(1-Q)?Q=q:q=Q,L=u(Q*F,this.config.ensure_multiple_of),G=u(q*E,this.config.ensure_multiple_of)}return[G,L]}else{if(this.size_divisibility!==void 0)return c([E,F],this.size_divisibility);if(this.min_pixels!==void 0&&this.max_pixels!==void 0){const G=this.config.patch_size*this.config.merge_size;return g(F,E,G,this.min_pixels,this.max_pixels)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(T)}`)}}async resize(v){const[T,E]=this.get_resize_output_image_size(v,this.size);return await v.resize(T,E,{resample:this.resample})}async preprocess(v,{do_normalize:T=null,do_pad:E=null,do_convert_rgb:F=null,do_convert_grayscale:I=null,do_flip_channel_order:z=null}={}){this.do_crop_margin&&(v=await this.crop_margin(v));const[G,L]=v.size;if(F??this.do_convert_rgb?v=v.rgb():I&&(v=v.grayscale()),this.do_resize&&(v=await this.resize(v)),this.do_thumbnail&&(v=await this.thumbnail(v,this.size,this.resample)),this.do_center_crop){let se,fe;Number.isInteger(this.crop_size)?(se=this.crop_size,fe=this.crop_size):(se=this.crop_size.width,fe=this.crop_size.height),v=await v.center_crop(se,fe)}const Q=[v.height,v.width];let q=Float32Array.from(v.data),J=[v.height,v.width,v.channels];if(this.do_rescale&&this.rescale(q),T??this.do_normalize){let se=this.image_mean;Array.isArray(this.image_mean)||(se=new Array(v.channels).fill(se));let fe=this.image_std;if(Array.isArray(this.image_std)||(fe=new Array(v.channels).fill(se)),se.length!==v.channels||fe.length!==v.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${se.length}) and \`image_std\` (${fe.length}) must match the number of channels in the image (${v.channels}).`);for(let ue=0;ue<q.length;ue+=v.channels)for(let U=0;U<v.channels;++U)q[ue+U]=(q[ue+U]-se[U])/fe[U]}if(E??this.do_pad){if(this.pad_size)[q,J]=this.pad_image(q,[v.height,v.width,v.channels],this.pad_size);else if(this.size_divisibility){const[se,fe]=c([J[1],J[0]],this.size_divisibility);[q,J]=this.pad_image(q,J,{width:se,height:fe})}}if(z??this.do_flip_channel_order){if(J[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let se=0;se<q.length;se+=3){const fe=q[se];q[se]=q[se+2],q[se+2]=fe}}const ee=new r.Tensor("float32",q,J).permute(2,0,1);return{original_size:[L,G],reshaped_input_size:Q,pixel_values:ee}}async _call(v,...T){Array.isArray(v)||(v=[v]);const E=await Promise.all(v.map(I=>this.preprocess(I)));return{pixel_values:(0,r.stack)(E.map(I=>I.pixel_values),0),original_sizes:E.map(I=>I.original_size),reshaped_input_sizes:E.map(I=>I.reshaped_input_size)}}static async from_pretrained(v,T={}){const E=await(0,a.getModelJSON)(v,l.IMAGE_PROCESSOR_NAME,!0,T);return new this(E)}}},"./src/base/processing_utils.js":(i,e,t)=>{t.r(e),t.d(e,{Processor:()=>o});var s=t("./src/utils/constants.js"),r=t("./src/utils/generic.js"),n=t("./src/utils/hub.js");class o extends r.Callable{constructor(l,u,c){super(),this.config=l,this.components=u,this.chat_template=c}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(l,u={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(l,{tokenize:!1,chat_template:this.chat_template??void 0,...u})}batch_decode(...l){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...l)}decode(...l){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...l)}async _call(l,...u){for(const c of[this.image_processor,this.feature_extractor,this.tokenizer])if(c)return c(l,...u);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(l,u={}){const[c,d,h]=await Promise.all([this.uses_processor_config?(0,n.getModelJSON)(l,s.PROCESSOR_NAME,!0,u):{},Promise.all(this.classes.filter(p=>p in this).map(async p=>{const f=await this[p].from_pretrained(l,u);return[p.replace(/_class$/,""),f]})).then(Object.fromEntries),this.uses_chat_template_file?(0,n.getModelText)(l,s.CHAT_TEMPLATE_NAME,!0,u):null]);return new this(c,d,h)}}Z(o,"classes",["image_processor_class","tokenizer_class","feature_extractor_class"]),Z(o,"uses_processor_config",!1),Z(o,"uses_chat_template_file",!1)},"./src/configs.js":(i,e,t)=>{t.r(e),t.d(e,{AutoConfig:()=>u,PretrainedConfig:()=>l,getKeyValueShapes:()=>a});var s=t("./src/utils/core.js"),r=t("./src/utils/hub.js");async function n(c,d){return await(0,r.getModelJSON)(c,"config.json",!0,d)}function o(c){const d={};let h={};switch(c.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"smolvlm":case"gemma3n":h=o(c.text_config);break;case"moondream1":h=o(c.phi_config);break;case"musicgen":h=o(c.decoder);break;case"multi_modality":h=o(c.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":d.num_heads="n_head",d.num_layers="n_layer",d.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":d.num_heads="num_attention_heads",d.num_layers="num_hidden_layers",d.hidden_size="hidden_size";break;case"llama":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":case"llava_qwen2":d.num_heads="num_key_value_heads",d.num_layers="num_hidden_layers",d.hidden_size="hidden_size",d.num_attention_heads="num_attention_heads";break;case"qwen3":case"gemma":case"gemma2":case"gemma3_text":case"gemma3n_text":case"glm":case"helium":d.num_heads="num_key_value_heads",d.num_layers="num_hidden_layers",d.dim_kv="head_dim";break;case"openelm":d.num_heads="num_kv_heads",d.num_layers="num_transformer_layers",d.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":d.num_heads="num_heads",d.num_layers="num_layers",d.hidden_size="hidden_size";break;case"bloom":d.num_heads="n_head",d.num_layers="n_layer",d.hidden_size="hidden_size";break;case"mpt":d.num_heads="n_heads",d.num_layers="n_layers",d.hidden_size="d_model";break;case"exaone":d.num_heads="num_key_value_heads",d.num_layers="num_layers",d.dim_kv="head_dim",d.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":d.num_decoder_layers="num_decoder_layers",d.num_decoder_heads="num_heads",d.decoder_dim_kv="d_kv",d.num_encoder_layers="num_layers",d.num_encoder_heads="num_heads",d.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":d.num_decoder_layers="decoder_layers",d.num_decoder_heads="decoder_attention_heads",d.decoder_hidden_size="d_model",d.num_encoder_layers="encoder_layers",d.num_encoder_heads="encoder_attention_heads",d.encoder_hidden_size="d_model";break;case"speecht5":d.num_decoder_layers="decoder_layers",d.num_decoder_heads="decoder_attention_heads",d.decoder_hidden_size="hidden_size",d.num_encoder_layers="encoder_layers",d.num_encoder_heads="encoder_attention_heads",d.encoder_hidden_size="hidden_size";break;case"trocr":d.num_encoder_layers=d.num_decoder_layers="decoder_layers",d.num_encoder_heads=d.num_decoder_heads="decoder_attention_heads",d.encoder_hidden_size=d.decoder_hidden_size="d_model";break;case"musicgen_decoder":d.num_encoder_layers=d.num_decoder_layers="num_hidden_layers",d.num_encoder_heads=d.num_decoder_heads="num_attention_heads",d.encoder_hidden_size=d.decoder_hidden_size="hidden_size";break;case"moonshine":d.num_decoder_layers="decoder_num_hidden_layers",d.num_decoder_heads="decoder_num_key_value_heads",d.num_encoder_layers="encoder_num_hidden_layers",d.num_encoder_heads="encoder_num_key_value_heads",d.encoder_hidden_size=d.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const f=o(c.decoder),m="num_decoder_layers"in f,x=(0,s.pick)(c,["model_type","is_encoder_decoder"]);return m?(x.num_decoder_layers=f.num_decoder_layers,x.num_decoder_heads=f.num_decoder_heads,x.decoder_hidden_size=f.decoder_hidden_size,x.num_encoder_layers=f.num_encoder_layers,x.num_encoder_heads=f.num_encoder_heads,x.encoder_hidden_size=f.encoder_hidden_size):(x.num_layers=f.num_layers,x.num_heads=f.num_heads,x.hidden_size=f.hidden_size),x}const p={...h,...(0,s.pick)(c,["model_type","multi_query","is_encoder_decoder"])};for(const f in d)p[f]=c[d[f]];return p}function a(c,{prefix:d="past_key_values",batch_size:h=1}={}){const p={},f=c.normalized_config;if(f.is_encoder_decoder&&"num_encoder_heads"in f&&"num_decoder_heads"in f){const m=f.encoder_dim_kv??f.encoder_hidden_size/f.num_encoder_heads,x=f.decoder_dim_kv??f.decoder_hidden_size/f.num_decoder_heads,g=[h,f.num_encoder_heads,0,m],_=[h,f.num_decoder_heads,0,x];for(let S=0;S<f.num_decoder_layers;++S)p[`${d}.${S}.encoder.key`]=g,p[`${d}.${S}.encoder.value`]=g,p[`${d}.${S}.decoder.key`]=_,p[`${d}.${S}.decoder.value`]=_}else{const m=f.num_heads,x=f.num_layers,g=f.dim_kv??f.hidden_size/(f.num_attention_heads??m);if(f.model_type==="falcon"){const _=[h*m,0,g];for(let S=0;S<x;++S)p[`${d}.${S}.key`]=_,p[`${d}.${S}.value`]=_}else if(f.multi_query){const _=[h*m,0,2*g];for(let S=0;S<x;++S)p[`${d}.${S}.key_value`]=_}else if(f.model_type==="bloom"){const _=[h*m,g,0],S=[h*m,0,g];for(let M=0;M<x;++M)p[`${d}.${M}.key`]=_,p[`${d}.${M}.value`]=S}else if(f.model_type==="openelm")for(let _=0;_<x;++_){const S=[h,m[_],0,g];p[`${d}.${_}.key`]=S,p[`${d}.${_}.value`]=S}else{const _=[h,m,0,g];for(let S=0;S<x;++S)p[`${d}.${S}.key`]=_,p[`${d}.${S}.value`]=_}}return p}class l{constructor(d){Z(this,"model_type",null);Z(this,"is_encoder_decoder",!1);Z(this,"max_position_embeddings");Z(this,"transformers.js_config");Object.assign(this,d),this.normalized_config=o(this)}static async from_pretrained(d,{progress_callback:h=null,config:p=null,cache_dir:f=null,local_files_only:m=!1,revision:x="main"}={}){p&&!(p instanceof l)&&(p=new l(p));const g=p??await n(d,{progress_callback:h,config:p,cache_dir:f,local_files_only:m,revision:x});return new this(g)}}class u{static async from_pretrained(...d){return l.from_pretrained(...d)}}},"./src/env.js":(i,e,t)=>{var F,I;t.r(e),t.d(e,{apis:()=>g,env:()=>T});var s=t("?db59"),r=t("?383f"),n=t("?fa4b");const o="3.6.1",a=typeof window<"u"&&typeof window.document<"u",l=typeof self<"u"&&["DedicatedWorkerGlobalScope","ServiceWorkerGlobalScope","SharedWorkerGlobalScope"].includes((F=self.constructor)==null?void 0:F.name),u=typeof self<"u"&&"caches"in self,c=typeof navigator<"u"&&"gpu"in navigator,d=typeof navigator<"u"&&"ml"in navigator,h=typeof process<"u",p=h&&((I=process==null?void 0:process.release)==null?void 0:I.name)==="node",f=!E(s),m=!E(r),x=typeof globalThis.Deno<"u",g=Object.freeze({IS_BROWSER_ENV:a,IS_WEBWORKER_ENV:l,IS_WEB_CACHE_AVAILABLE:u,IS_WEBGPU_AVAILABLE:c,IS_WEBNN_AVAILABLE:d,IS_PROCESS_AVAILABLE:h,IS_NODE_ENV:p,IS_FS_AVAILABLE:f,IS_PATH_AVAILABLE:m}),_=f&&m;let S="./";if(_){const z=Object(import.meta).url;z?S=r.dirname(r.dirname(n.fileURLToPath(z))):typeof __dirname<"u"&&(S=r.dirname(__dirname))}const M=_?r.join(S,"/.cache/"):null,w="/models/",v=_?r.join(S,w):w,T={version:o,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(a||l),localModelPath:v,useFS:f,useBrowserCache:u&&!x,useFSCache:f,cacheDir:M,useCustomCache:!1,customCache:null};function E(z){return Object.keys(z).length===0}},"./src/generation/configuration_utils.js":(i,e,t)=>{t.r(e),t.d(e,{GenerationConfig:()=>r});var s=t("./src/utils/core.js");class r{constructor(o){Z(this,"max_length",20);Z(this,"max_new_tokens",null);Z(this,"min_length",0);Z(this,"min_new_tokens",null);Z(this,"early_stopping",!1);Z(this,"max_time",null);Z(this,"do_sample",!1);Z(this,"num_beams",1);Z(this,"num_beam_groups",1);Z(this,"penalty_alpha",null);Z(this,"use_cache",!0);Z(this,"temperature",1);Z(this,"top_k",50);Z(this,"top_p",1);Z(this,"typical_p",1);Z(this,"epsilon_cutoff",0);Z(this,"eta_cutoff",0);Z(this,"diversity_penalty",0);Z(this,"repetition_penalty",1);Z(this,"encoder_repetition_penalty",1);Z(this,"length_penalty",1);Z(this,"no_repeat_ngram_size",0);Z(this,"bad_words_ids",null);Z(this,"force_words_ids",null);Z(this,"renormalize_logits",!1);Z(this,"constraints",null);Z(this,"forced_bos_token_id",null);Z(this,"forced_eos_token_id",null);Z(this,"remove_invalid_values",!1);Z(this,"exponential_decay_length_penalty",null);Z(this,"suppress_tokens",null);Z(this,"streamer",null);Z(this,"begin_suppress_tokens",null);Z(this,"forced_decoder_ids",null);Z(this,"guidance_scale",null);Z(this,"num_return_sequences",1);Z(this,"output_attentions",!1);Z(this,"output_hidden_states",!1);Z(this,"output_scores",!1);Z(this,"return_dict_in_generate",!1);Z(this,"pad_token_id",null);Z(this,"bos_token_id",null);Z(this,"eos_token_id",null);Z(this,"encoder_no_repeat_ngram_size",0);Z(this,"decoder_start_token_id",null);Z(this,"generation_kwargs",{});Object.assign(this,(0,s.pick)(o,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(i,e,t)=>{t.r(e),t.d(e,{ClassifierFreeGuidanceLogitsProcessor:()=>g,ForcedBOSTokenLogitsProcessor:()=>l,ForcedEOSTokenLogitsProcessor:()=>u,LogitsProcessor:()=>n,LogitsProcessorList:()=>a,LogitsWarper:()=>o,MinLengthLogitsProcessor:()=>f,MinNewTokensLengthLogitsProcessor:()=>m,NoBadWordsLogitsProcessor:()=>x,NoRepeatNGramLogitsProcessor:()=>h,RepetitionPenaltyLogitsProcessor:()=>p,SuppressTokensAtBeginLogitsProcessor:()=>c,TemperatureLogitsWarper:()=>_,TopKLogitsWarper:()=>M,TopPLogitsWarper:()=>S,WhisperTimeStampLogitsProcessor:()=>d});var s=t("./src/utils/generic.js");t("./src/utils/tensor.js");var r=t("./src/utils/maths.js");class n extends s.Callable{_call(v,T){throw Error("`_call` should be implemented in a subclass")}}class o extends s.Callable{_call(v,T){throw Error("`_call` should be implemented in a subclass")}}class a extends s.Callable{constructor(){super(),this.processors=[]}push(v){this.processors.push(v)}extend(v){this.processors.push(...v)}_call(v,T){let E=T;for(const F of this.processors)E=F(v,E);return E}[Symbol.iterator](){return this.processors.values()}}class l extends n{constructor(v){super(),this.bos_token_id=v}_call(v,T){for(let E=0;E<v.length;++E)if(v[E].length===1){const F=T[E].data;F.fill(-1/0),F[this.bos_token_id]=0}return T}}class u extends n{constructor(v,T){super(),this.max_length=v,this.eos_token_id=Array.isArray(T)?T:[T]}_call(v,T){for(let E=0;E<v.length;++E)if(v[E].length===this.max_length-1){const F=T[E].data;F.fill(-1/0);for(const I of this.eos_token_id)F[I]=0}return T}}class c extends n{constructor(v,T){super(),this.begin_suppress_tokens=v,this.begin_index=T}_call(v,T){for(let E=0;E<v.length;++E)if(v[E].length===this.begin_index){const F=T[E].data;for(const I of this.begin_suppress_tokens)F[I]=-1/0}return T}}class d extends n{constructor(v,T){super(),this.eos_token_id=Array.isArray(v.eos_token_id)?v.eos_token_id[0]:v.eos_token_id,this.no_timestamps_token_id=v.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=T.length,T.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=v.max_initial_timestamp_index}_call(v,T){for(let E=0;E<v.length;++E){const F=T[E].data;if(F[this.no_timestamps_token_id]=-1/0,v[E].length===this.begin_index-1){F.fill(-1/0),F[this.timestamp_begin]=0;continue}const I=v[E].slice(this.begin_index),z=I.length>=1&&I[I.length-1]>=this.timestamp_begin,G=I.length<2||I[I.length-2]>=this.timestamp_begin;if(z&&(G?F.subarray(this.timestamp_begin).fill(-1/0):F.subarray(0,this.eos_token_id).fill(-1/0)),v[E].length===this.begin_index&&this.max_initial_timestamp_index!==null){const J=this.timestamp_begin+this.max_initial_timestamp_index;F.subarray(J+1).fill(-1/0)}const L=(0,r.log_softmax)(F),Q=Math.log(L.subarray(this.timestamp_begin).map(Math.exp).reduce((J,ee)=>J+ee)),q=(0,r.max)(L.subarray(0,this.timestamp_begin))[0];Q>q&&F.subarray(0,this.timestamp_begin).fill(-1/0)}return T}}class h extends n{constructor(v){super(),this.no_repeat_ngram_size=v}getNgrams(v){const T=v.length,E=[];for(let I=0;I<T+1-this.no_repeat_ngram_size;++I){const z=[];for(let G=0;G<this.no_repeat_ngram_size;++G)z.push(v[I+G]);E.push(z.map(Number))}const F=new Map;for(const I of E){const z=I.slice(0,I.length-1),G=JSON.stringify(z),L=F.get(G)??[];L.push(I[I.length-1]),F.set(G,L)}return F}getGeneratedNgrams(v,T){const E=T.slice(T.length+1-this.no_repeat_ngram_size,T.length);return v.get(JSON.stringify(E.map(Number)))??[]}calcBannedNgramTokens(v){const T=[];if(v.length+1<this.no_repeat_ngram_size)return T;{const E=this.getNgrams(v);return this.getGeneratedNgrams(E,v)}}_call(v,T){for(let E=0;E<v.length;++E){const F=T[E].data,I=this.calcBannedNgramTokens(v[E]);for(const z of I)F[z]=-1/0}return T}}class p extends n{constructor(v){super(),this.penalty=v}_call(v,T){for(let E=0;E<v.length;++E){const F=T[E].data;for(const I of new Set(v[E])){const z=Number(I);F[z]<0?F[z]*=this.penalty:F[z]/=this.penalty}}return T}}class f extends n{constructor(v,T){super(),this.min_length=v,this.eos_token_id=Array.isArray(T)?T:[T]}_call(v,T){for(let E=0;E<v.length;++E)if(v[E].length<this.min_length){const F=T[E].data;for(const I of this.eos_token_id)F[I]=-1/0}return T}}class m extends n{constructor(v,T,E){super(),this.prompt_length_to_skip=v,this.min_new_tokens=T,this.eos_token_id=Array.isArray(E)?E:[E]}_call(v,T){for(let E=0;E<v.length;++E)if(v[E].length-this.prompt_length_to_skip<this.min_new_tokens){const I=T[E].data;for(const z of this.eos_token_id)I[z]=-1/0}return T}}class x extends n{constructor(v,T){super(),this.bad_words_ids=v,this.eos_token_id=Array.isArray(T)?T:[T]}_call(v,T){for(let E=0;E<v.length;++E){const F=T[E].data,I=v[E];for(const z of this.bad_words_ids){if(I.length<z.length-1)continue;let G=!0;for(let L=1;L<=z.length-1;++L)if(z.at(-L-1)!=I.at(-L)){G=!1;break}G&&(F[z.at(-1)]=-1/0)}}return T}}class g extends n{constructor(v){if(super(),v<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${v}.`);this.guidance_scale=v}_call(v,T){if(T.dims[0]!==2*v.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${T.dims[0]} for the logits and ${v.length} for the input ids.`);const E=v.length,F=T.slice([0,E],null),I=T.slice([E,T.dims[0]],null);for(let z=0;z<I.data.length;++z)I.data[z]+=(F.data[z]-I.data[z])*this.guidance_scale;return I}}class _ extends o{constructor(v){super(),this.temperature=v}_call(v,T){const E=T.data;for(let F=0;F<E.length;++F)E[F]/=this.temperature;return T}}class S extends o{constructor(v,{filter_value:T=-1/0,min_tokens_to_keep:E=1}={}){if(super(),v<0||v>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${v}`);if(!Number.isInteger(E)||E<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${E}`);this.top_p=v,this.filter_value=T,this.min_tokens_to_keep=E}}class M extends o{constructor(v,{filter_value:T=-1/0,min_tokens_to_keep:E=1}={}){if(super(),!Number.isInteger(v)||v<0)throw new Error(`\`top_k\` must be a positive integer, but is ${v}`);this.top_k=Math.max(v,E),this.filter_value=T}}},"./src/generation/logits_sampler.js":(i,e,t)=>{t.r(e),t.d(e,{LogitsSampler:()=>o});var s=t("./src/utils/generic.js"),r=t("./src/utils/tensor.js"),n=t("./src/utils/maths.js");t("./src/generation/configuration_utils.js");class o extends s.Callable{constructor(d){super(),this.generation_config=d}async _call(d){return this.sample(d)}async sample(d){throw Error("sample should be implemented in subclasses.")}getLogits(d,h){let p=d.dims.at(-1),f=d.data;if(h===-1)f=f.slice(-p);else{let m=h*p;f=f.slice(m,m+p)}return f}randomSelect(d){let h=0;for(let f=0;f<d.length;++f)h+=d[f];let p=Math.random()*h;for(let f=0;f<d.length;++f)if(p-=d[f],p<=0)return f;return 0}static getSampler(d){if(d.do_sample)return new l(d);if(d.num_beams>1)return new u(d);if(d.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${d.num_return_sequences}.`);return new a(d)}}class a extends o{async sample(d){const h=(0,n.max)(d.data)[1];return[[BigInt(h),0]]}}class l extends o{async sample(d){let h=d.dims.at(-1);this.generation_config.top_k>0&&(h=Math.min(this.generation_config.top_k,h));const[p,f]=await(0,r.topk)(d,h),m=(0,n.softmax)(p.data);return Array.from({length:this.generation_config.num_beams},()=>{const x=this.randomSelect(m);return[f.data[x],Math.log(m[x])]})}}class u extends o{async sample(d){let h=d.dims.at(-1);this.generation_config.top_k>0&&(h=Math.min(this.generation_config.top_k,h));const[p,f]=await(0,r.topk)(d,h),m=(0,n.softmax)(p.data);return Array.from({length:this.generation_config.num_beams},(x,g)=>[f.data[g],Math.log(m[g])])}}},"./src/generation/stopping_criteria.js":(i,e,t)=>{t.r(e),t.d(e,{EosTokenCriteria:()=>a,InterruptableStoppingCriteria:()=>l,MaxLengthCriteria:()=>o,StoppingCriteria:()=>r,StoppingCriteriaList:()=>n});var s=t("./src/utils/generic.js");class r extends s.Callable{_call(c,d){throw Error("StoppingCriteria needs to be subclassed")}}class n extends s.Callable{constructor(){super(),this.criteria=[]}push(c){this.criteria.push(c)}extend(c){c instanceof n?c=c.criteria:c instanceof r&&(c=[c]),this.criteria.push(...c)}_call(c,d){const h=new Array(c.length).fill(!1);for(const p of this.criteria){const f=p(c,d);for(let m=0;m<h.length;++m)h[m]||(h[m]=f[m])}return h}[Symbol.iterator](){return this.criteria.values()}}class o extends r{constructor(c,d=null){super(),this.max_length=c,this.max_position_embeddings=d}_call(c){return c.map(d=>d.length>=this.max_length)}}class a extends r{constructor(c){super(),Array.isArray(c)||(c=[c]),this.eos_token_id=c}_call(c,d){return c.map(h=>{const p=h.at(-1);return this.eos_token_id.some(f=>p==f)})}}class l extends r{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(c,d){return new Array(c.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(i,e,t)=>{t.r(e),t.d(e,{BaseStreamer:()=>o,TextStreamer:()=>l,WhisperTextStreamer:()=>u});var s=t("./src/utils/core.js"),r=t("./src/tokenizers.js"),n=t("./src/env.js");class o{put(d){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const a=n.apis.IS_PROCESS_AVAILABLE?c=>process.stdout.write(c):c=>console.log(c);class l extends o{constructor(d,{skip_prompt:h=!1,callback_function:p=null,token_callback_function:f=null,skip_special_tokens:m=!0,decode_kwargs:x={},...g}={}){super(),this.tokenizer=d,this.skip_prompt=h,this.callback_function=p??a,this.token_callback_function=f,this.decode_kwargs={skip_special_tokens:m,...x,...g},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(d){var x;if(d.length>1)throw Error("TextStreamer only supports batch size of 1");const h=this.next_tokens_are_prompt;if(h&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const p=d[0];(x=this.token_callback_function)==null||x.call(this,p),this.token_cache=(0,s.mergeArrays)(this.token_cache,p);const f=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let m;h||f.endsWith(`
`)?(m=f.slice(this.print_len),this.token_cache=[],this.print_len=0):f.length>0&&(0,r.is_chinese_char)(f.charCodeAt(f.length-1))?(m=f.slice(this.print_len),this.print_len+=m.length):(m=f.slice(this.print_len,f.lastIndexOf(" ")+1),this.print_len+=m.length),this.on_finalized_text(m,!1)}end(){let d;this.token_cache.length>0?(d=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):d="",this.next_tokens_are_prompt=!0,this.on_finalized_text(d,!0)}on_finalized_text(d,h){var p,f;d.length>0&&((p=this.callback_function)==null||p.call(this,d)),h&&this.callback_function===a&&n.apis.IS_PROCESS_AVAILABLE&&((f=this.callback_function)==null||f.call(this,`
`))}}class u extends l{constructor(d,{skip_prompt:h=!1,callback_function:p=null,token_callback_function:f=null,on_chunk_start:m=null,on_chunk_end:x=null,on_finalize:g=null,time_precision:_=.02,skip_special_tokens:S=!0,decode_kwargs:M={}}={}){super(d,{skip_prompt:h,skip_special_tokens:S,callback_function:p,token_callback_function:f,decode_kwargs:M}),this.timestamp_begin=d.timestamp_begin,this.on_chunk_start=m,this.on_chunk_end=x,this.on_finalize=g,this.time_precision=_,this.waiting_for_timestamp=!1}put(d){var p,f,m;if(d.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const h=d[0];if(h.length===1){const x=Number(h[0])-this.timestamp_begin;if(x>=0){const g=x*this.time_precision;this.waiting_for_timestamp?(p=this.on_chunk_end)==null||p.call(this,g):(f=this.on_chunk_start)==null||f.call(this,g),this.waiting_for_timestamp=!this.waiting_for_timestamp,(m=this.token_callback_function)==null||m.call(this,h);return}}return super.put(d)}end(){var d;super.end(),(d=this.on_finalize)==null||d.call(this)}}},"./src/models.js":(i,e,t)=>{t.r(e),t.d(e,{ASTForAudioClassification:()=>Fc,ASTModel:()=>Nc,ASTPreTrainedModel:()=>au,AlbertForMaskedLM:()=>nt,AlbertForQuestionAnswering:()=>ut,AlbertForSequenceClassification:()=>Qe,AlbertModel:()=>Fe,AlbertPreTrainedModel:()=>_e,AutoModel:()=>t_,AutoModelForAudioClassification:()=>kS,AutoModelForAudioFrameClassification:()=>BS,AutoModelForAudioTextToText:()=>HS,AutoModelForCTC:()=>DS,AutoModelForCausalLM:()=>TS,AutoModelForDepthEstimation:()=>VS,AutoModelForDocumentQuestionAnswering:()=>OS,AutoModelForImageClassification:()=>AS,AutoModelForImageFeatureExtraction:()=>jS,AutoModelForImageMatting:()=>$S,AutoModelForImageSegmentation:()=>CS,AutoModelForImageTextToText:()=>WS,AutoModelForImageToImage:()=>zS,AutoModelForMaskGeneration:()=>IS,AutoModelForMaskedLM:()=>vS,AutoModelForNormalEstimation:()=>US,AutoModelForObjectDetection:()=>FS,AutoModelForPoseEstimation:()=>GS,AutoModelForQuestionAnswering:()=>SS,AutoModelForSemanticSegmentation:()=>PS,AutoModelForSeq2SeqLM:()=>xS,AutoModelForSequenceClassification:()=>_S,AutoModelForSpeechSeq2Seq:()=>bS,AutoModelForTextToSpectrogram:()=>wS,AutoModelForTextToWaveform:()=>MS,AutoModelForTokenClassification:()=>yS,AutoModelForUniversalSegmentation:()=>NS,AutoModelForVision2Seq:()=>ES,AutoModelForXVector:()=>LS,AutoModelForZeroShotObjectDetection:()=>RS,BartForConditionalGeneration:()=>Cn,BartForSequenceClassification:()=>Ds,BartModel:()=>Gs,BartPretrainedModel:()=>mi,BaseModelOutput:()=>Ee,BeitForImageClassification:()=>JM,BeitModel:()=>ZM,BeitPreTrainedModel:()=>yg,BertForMaskedLM:()=>Ve,BertForQuestionAnswering:()=>it,BertForSequenceClassification:()=>We,BertForTokenClassification:()=>Je,BertModel:()=>Be,BertPreTrainedModel:()=>$e,BlenderbotForConditionalGeneration:()=>js,BlenderbotModel:()=>Mi,BlenderbotPreTrainedModel:()=>Mr,BlenderbotSmallForConditionalGeneration:()=>Wi,BlenderbotSmallModel:()=>ui,BlenderbotSmallPreTrainedModel:()=>ii,BloomForCausalLM:()=>wM,BloomModel:()=>bM,BloomPreTrainedModel:()=>og,CLIPModel:()=>qh,CLIPPreTrainedModel:()=>No,CLIPSegForImageSegmentation:()=>rl,CLIPSegModel:()=>Wc,CLIPSegPreTrainedModel:()=>mu,CLIPTextModel:()=>$c,CLIPTextModelWithProjection:()=>pu,CLIPVisionModel:()=>Kh,CLIPVisionModelWithProjection:()=>zc,CamembertForMaskedLM:()=>Zr,CamembertForQuestionAnswering:()=>Qn,CamembertForSequenceClassification:()=>vn,CamembertForTokenClassification:()=>Jr,CamembertModel:()=>Qi,CamembertPreTrainedModel:()=>$s,CausalLMOutput:()=>ul,CausalLMOutputWithPast:()=>u3,ChineseCLIPModel:()=>jc,ChineseCLIPPreTrainedModel:()=>Xh,ClapAudioModelWithProjection:()=>Jv,ClapModel:()=>Qv,ClapPreTrainedModel:()=>rp,ClapTextModelWithProjection:()=>Zv,CodeGenForCausalLM:()=>C,CodeGenModel:()=>y,CodeGenPreTrainedModel:()=>wu,CohereForCausalLM:()=>tM,CohereModel:()=>eM,CoherePreTrainedModel:()=>Qm,ConvBertForMaskedLM:()=>He,ConvBertForQuestionAnswering:()=>ds,ConvBertForSequenceClassification:()=>Ne,ConvBertForTokenClassification:()=>Ut,ConvBertModel:()=>ve,ConvBertPreTrainedModel:()=>ie,ConvNextForImageClassification:()=>qT,ConvNextModel:()=>HT,ConvNextPreTrainedModel:()=>Ig,ConvNextV2ForImageClassification:()=>XT,ConvNextV2Model:()=>KT,ConvNextV2PreTrainedModel:()=>Dg,DFineForObjectDetection:()=>hT,DFineModel:()=>dT,DFinePreTrainedModel:()=>vg,DPTForDepthEstimation:()=>CT,DPTModel:()=>AT,DPTPreTrainedModel:()=>Ng,DacDecoderModel:()=>V1,DacDecoderOutput:()=>O1,DacEncoderModel:()=>z1,DacEncoderOutput:()=>B1,DacModel:()=>$1,DacPreTrainedModel:()=>dp,DebertaForMaskedLM:()=>Lr,DebertaForQuestionAnswering:()=>eo,DebertaForSequenceClassification:()=>Sn,DebertaForTokenClassification:()=>Jn,DebertaModel:()=>Zn,DebertaPreTrainedModel:()=>dr,DebertaV2ForMaskedLM:()=>ki,DebertaV2ForQuestionAnswering:()=>je,DebertaV2ForSequenceClassification:()=>En,DebertaV2ForTokenClassification:()=>ir,DebertaV2Model:()=>to,DebertaV2PreTrainedModel:()=>si,DecisionTransformerModel:()=>b1,DecisionTransformerPreTrainedModel:()=>x1,DeiTForImageClassification:()=>_T,DeiTModel:()=>gT,DeiTPreTrainedModel:()=>Eg,DepthAnythingForDepthEstimation:()=>NT,DepthAnythingPreTrainedModel:()=>PT,DepthProForDepthEstimation:()=>kT,DepthProPreTrainedModel:()=>DT,DetrForObjectDetection:()=>tT,DetrForSegmentation:()=>xg,DetrModel:()=>eT,DetrObjectDetectionOutput:()=>bg,DetrPreTrainedModel:()=>Zh,DetrSegmentationOutput:()=>sT,Dinov2ForImageClassification:()=>QT,Dinov2Model:()=>YT,Dinov2PreTrainedModel:()=>kg,Dinov2WithRegistersForImageClassification:()=>JT,Dinov2WithRegistersModel:()=>ZT,Dinov2WithRegistersPreTrainedModel:()=>Lg,DistilBertForMaskedLM:()=>Li,DistilBertForQuestionAnswering:()=>tn,DistilBertForSequenceClassification:()=>xs,DistilBertForTokenClassification:()=>en,DistilBertModel:()=>wt,DistilBertPreTrainedModel:()=>dt,DonutSwinModel:()=>WT,DonutSwinPreTrainedModel:()=>jT,EfficientNetForImageClassification:()=>o1,EfficientNetModel:()=>n1,EfficientNetPreTrainedModel:()=>Hg,ElectraForMaskedLM:()=>_t,ElectraForQuestionAnswering:()=>wi,ElectraForSequenceClassification:()=>ys,ElectraForTokenClassification:()=>Is,ElectraModel:()=>Mt,ElectraPreTrainedModel:()=>Ct,EsmForMaskedLM:()=>fi,EsmForSequenceClassification:()=>sn,EsmForTokenClassification:()=>Ha,EsmModel:()=>ai,EsmPreTrainedModel:()=>hr,ExaoneForCausalLM:()=>Ti,ExaoneModel:()=>vs,ExaonePreTrainedModel:()=>is,FalconForCausalLM:()=>Yv,FalconModel:()=>Xv,FalconPreTrainedModel:()=>Gg,FastViTForImageClassification:()=>VM,FastViTModel:()=>zM,FastViTPreTrainedModel:()=>pg,Florence2ForConditionalGeneration:()=>Vh,Florence2PreTrainedModel:()=>zh,GLPNForDepthEstimation:()=>GT,GLPNModel:()=>UT,GLPNPreTrainedModel:()=>Rg,GPT2LMHeadModel:()=>gu,GPT2Model:()=>nl,GPT2PreTrainedModel:()=>Tr,GPTBigCodeForCausalLM:()=>Jc,GPTBigCodeModel:()=>Zc,GPTBigCodePreTrainedModel:()=>bu,GPTJForCausalLM:()=>Qc,GPTJModel:()=>Yc,GPTJPreTrainedModel:()=>ll,GPTNeoForCausalLM:()=>Xc,GPTNeoModel:()=>Kc,GPTNeoPreTrainedModel:()=>ol,GPTNeoXForCausalLM:()=>xu,GPTNeoXModel:()=>al,GPTNeoXPreTrainedModel:()=>yu,Gemma2ForCausalLM:()=>nM,Gemma2Model:()=>rM,Gemma2PreTrainedModel:()=>Jm,Gemma3ForCausalLM:()=>aM,Gemma3Model:()=>oM,Gemma3PreTrainedModel:()=>eg,Gemma3nForConditionalGeneration:()=>Oc,Gemma3nPreTrainedModel:()=>Wh,GemmaForCausalLM:()=>iM,GemmaModel:()=>sM,GemmaPreTrainedModel:()=>Zm,GlmForCausalLM:()=>zt,GlmModel:()=>mt,GlmPreTrainedModel:()=>at,GraniteForCausalLM:()=>Jw,GraniteModel:()=>Zw,GranitePreTrainedModel:()=>Ym,GroundingDinoForObjectDetection:()=>tv,GroundingDinoPreTrainedModel:()=>ev,GroupViTModel:()=>$M,GroupViTPreTrainedModel:()=>OM,HeliumForCausalLM:()=>qe,HeliumModel:()=>Re,HeliumPreTrainedModel:()=>me,HieraForImageClassification:()=>xT,HieraModel:()=>yT,HieraPreTrainedModel:()=>Ag,HubertForCTC:()=>Fv,HubertForSequenceClassification:()=>Rv,HubertModel:()=>Nv,HubertPreTrainedModel:()=>X$,IJepaForImageClassification:()=>PM,IJepaModel:()=>CM,IJepaPreTrainedModel:()=>cg,Idefics3ForConditionalGeneration:()=>du,Idefics3PreTrainedModel:()=>Hh,ImageMattingOutput:()=>KS,JAISLMHeadModel:()=>qc,JAISModel:()=>Hc,JAISPreTrainedModel:()=>_u,JinaCLIPModel:()=>il,JinaCLIPPreTrainedModel:()=>sl,JinaCLIPTextModel:()=>At,JinaCLIPVisionModel:()=>Yh,LiteWhisperForConditionalGeneration:()=>Ic,LlamaForCausalLM:()=>H,LlamaModel:()=>$,LlamaPreTrainedModel:()=>D,LlavaForConditionalGeneration:()=>uu,LlavaOnevisionForConditionalGeneration:()=>cu,LlavaPreTrainedModel:()=>Lc,LlavaQwen2ForCausalLM:()=>jh,LongT5ForConditionalGeneration:()=>Ts,LongT5Model:()=>zs,LongT5PreTrainedModel:()=>ps,M2M100ForConditionalGeneration:()=>dv,M2M100Model:()=>cv,M2M100PreTrainedModel:()=>$g,MBartForCausalLM:()=>ji,MBartForConditionalGeneration:()=>rn,MBartForSequenceClassification:()=>Br,MBartModel:()=>Ji,MBartPreTrainedModel:()=>Qs,MPNetForMaskedLM:()=>Qa,MPNetForQuestionAnswering:()=>el,MPNetForSequenceClassification:()=>Za,MPNetForTokenClassification:()=>Ja,MPNetModel:()=>ua,MPNetPreTrainedModel:()=>An,MT5ForConditionalGeneration:()=>Bi,MT5Model:()=>Zi,MT5PreTrainedModel:()=>li,MarianMTModel:()=>uv,MarianModel:()=>lv,MarianPreTrainedModel:()=>Og,MaskFormerForInstanceSegmentation:()=>VT,MaskFormerModel:()=>zT,MaskFormerPreTrainedModel:()=>Fg,MaskedLMOutput:()=>Oi,Metric3DForDepthEstimation:()=>BT,Metric3DPreTrainedModel:()=>LT,Metric3Dv2ForDepthEstimation:()=>$T,Metric3Dv2PreTrainedModel:()=>OT,MgpstrForSceneTextRecognition:()=>S1,MgpstrModelOutput:()=>T1,MgpstrPreTrainedModel:()=>v1,MimiDecoderModel:()=>L1,MimiDecoderOutput:()=>I1,MimiEncoderModel:()=>k1,MimiEncoderOutput:()=>R1,MimiModel:()=>D1,MimiPreTrainedModel:()=>cp,MistralForCausalLM:()=>Hv,MistralModel:()=>Wv,MistralPreTrainedModel:()=>Vg,MobileBertForMaskedLM:()=>Ka,MobileBertForQuestionAnswering:()=>Ya,MobileBertForSequenceClassification:()=>Xa,MobileBertModel:()=>qa,MobileBertPreTrainedModel:()=>so,MobileLLMForCausalLM:()=>qw,MobileLLMModel:()=>Qh,MobileLLMPreTrainedModel:()=>io,MobileNetV1ForImageClassification:()=>l1,MobileNetV1ForSemanticSegmentation:()=>u1,MobileNetV1Model:()=>a1,MobileNetV1PreTrainedModel:()=>op,MobileNetV2ForImageClassification:()=>d1,MobileNetV2ForSemanticSegmentation:()=>h1,MobileNetV2Model:()=>c1,MobileNetV2PreTrainedModel:()=>ap,MobileNetV3ForImageClassification:()=>f1,MobileNetV3ForSemanticSegmentation:()=>m1,MobileNetV3Model:()=>p1,MobileNetV3PreTrainedModel:()=>lp,MobileNetV4ForImageClassification:()=>_1,MobileNetV4ForSemanticSegmentation:()=>y1,MobileNetV4Model:()=>g1,MobileNetV4PreTrainedModel:()=>up,MobileViTForImageClassification:()=>WM,MobileViTModel:()=>jM,MobileViTPreTrainedModel:()=>fg,MobileViTV2ForImageClassification:()=>qM,MobileViTV2Model:()=>HM,MobileViTV2PreTrainedModel:()=>mg,ModelOutput:()=>Ce,ModernBertForMaskedLM:()=>pt,ModernBertForSequenceClassification:()=>ss,ModernBertForTokenClassification:()=>Zt,ModernBertModel:()=>tt,ModernBertPreTrainedModel:()=>Ye,Moondream1ForConditionalGeneration:()=>Bc,MoonshineForConditionalGeneration:()=>Dc,MoonshineModel:()=>qm,MoonshinePreTrainedModel:()=>Po,MptForCausalLM:()=>TM,MptModel:()=>MM,MptPreTrainedModel:()=>ag,MultiModalityCausalLM:()=>M1,MultiModalityPreTrainedModel:()=>w1,MusicgenForCausalLM:()=>J$,MusicgenForConditionalGeneration:()=>Kg,MusicgenModel:()=>Z$,MusicgenPreTrainedModel:()=>qg,NeoBertForMaskedLM:()=>rt,NeoBertForQuestionAnswering:()=>bt,NeoBertForSequenceClassification:()=>yt,NeoBertForTokenClassification:()=>Nt,NeoBertModel:()=>Ue,NeoBertPreTrainedModel:()=>lt,NomicBertModel:()=>bi,NomicBertPreTrainedModel:()=>_s,OPTForCausalLM:()=>SM,OPTModel:()=>vM,OPTPreTrainedModel:()=>lg,Olmo2ForCausalLM:()=>Qw,Olmo2Model:()=>Yw,Olmo2PreTrainedModel:()=>Xm,OlmoForCausalLM:()=>Xw,OlmoModel:()=>Kw,OlmoPreTrainedModel:()=>Km,OpenELMForCausalLM:()=>uM,OpenELMModel:()=>lM,OpenELMPreTrainedModel:()=>tg,OwlViTForObjectDetection:()=>XM,OwlViTModel:()=>KM,OwlViTPreTrainedModel:()=>gg,Owlv2ForObjectDetection:()=>QM,Owlv2Model:()=>YM,Owlv2PreTrainedModel:()=>_g,PaliGemmaForConditionalGeneration:()=>Gh,PaliGemmaPreTrainedModel:()=>Uh,PatchTSMixerForPrediction:()=>P1,PatchTSMixerModel:()=>C1,PatchTSMixerPreTrainedModel:()=>Yg,PatchTSTForPrediction:()=>A1,PatchTSTModel:()=>E1,PatchTSTPreTrainedModel:()=>Xg,Phi3ForCausalLM:()=>xM,Phi3Model:()=>yM,Phi3PreTrainedModel:()=>ng,Phi3VForCausalLM:()=>hu,Phi3VPreTrainedModel:()=>pa,PhiForCausalLM:()=>_M,PhiModel:()=>gM,PhiPreTrainedModel:()=>rg,PreTrainedModel:()=>K,PretrainedMixin:()=>fs,PvtForImageClassification:()=>IM,PvtModel:()=>RM,PvtPreTrainedModel:()=>dg,PyAnnoteForAudioFrameClassification:()=>_v,PyAnnoteModel:()=>gv,PyAnnotePreTrainedModel:()=>zg,QuestionAnsweringModelOutput:()=>er,Qwen2ForCausalLM:()=>dM,Qwen2Model:()=>cM,Qwen2PreTrainedModel:()=>sg,Qwen2VLForConditionalGeneration:()=>mM,Qwen2VLPreTrainedModel:()=>fM,Qwen3ForCausalLM:()=>pM,Qwen3Model:()=>hM,Qwen3PreTrainedModel:()=>ig,RFDetrForObjectDetection:()=>uT,RFDetrModel:()=>lT,RFDetrObjectDetectionOutput:()=>cT,RFDetrPreTrainedModel:()=>Tg,RTDetrForObjectDetection:()=>rT,RTDetrModel:()=>iT,RTDetrObjectDetectionOutput:()=>ed,RTDetrPreTrainedModel:()=>wg,RTDetrV2ForObjectDetection:()=>oT,RTDetrV2Model:()=>nT,RTDetrV2ObjectDetectionOutput:()=>aT,RTDetrV2PreTrainedModel:()=>Mg,ResNetForImageClassification:()=>wT,ResNetModel:()=>bT,ResNetPreTrainedModel:()=>Cg,RoFormerForMaskedLM:()=>Qr,RoFormerForQuestionAnswering:()=>V,RoFormerForSequenceClassification:()=>O,RoFormerForTokenClassification:()=>le,RoFormerModel:()=>$t,RoFormerPreTrainedModel:()=>ti,RobertaForMaskedLM:()=>Eh,RobertaForQuestionAnswering:()=>Pc,RobertaForSequenceClassification:()=>Ah,RobertaForTokenClassification:()=>Ch,RobertaModel:()=>tl,RobertaPreTrainedModel:()=>nn,SamImageSegmentationOutput:()=>av,SamModel:()=>ov,SamPreTrainedModel:()=>nv,SapiensForDepthEstimation:()=>RT,SapiensForNormalEstimation:()=>IT,SapiensForSemanticSegmentation:()=>FT,SapiensPreTrainedModel:()=>ep,SegformerForImageClassification:()=>t1,SegformerForSemanticSegmentation:()=>s1,SegformerModel:()=>Q$,SegformerPreTrainedModel:()=>np,Seq2SeqLMOutput:()=>l3,SequenceClassifierOutput:()=>Vt,SiglipModel:()=>Vc,SiglipPreTrainedModel:()=>fu,SiglipTextModel:()=>Uc,SiglipVisionModel:()=>Gc,SmolVLMForConditionalGeneration:()=>ha,SnacDecoderModel:()=>j1,SnacEncoderModel:()=>G1,SnacModel:()=>U1,SnacPreTrainedModel:()=>hp,SpeechT5ForSpeechToText:()=>zv,SpeechT5ForTextToSpeech:()=>Vv,SpeechT5HifiGan:()=>Uv,SpeechT5Model:()=>Y$,SpeechT5PreTrainedModel:()=>ip,SqueezeBertForMaskedLM:()=>W,SqueezeBertForQuestionAnswering:()=>he,SqueezeBertForSequenceClassification:()=>te,SqueezeBertModel:()=>R,SqueezeBertPreTrainedModel:()=>ye,StableLmForCausalLM:()=>r1,StableLmModel:()=>i1,StableLmPreTrainedModel:()=>Wg,Starcoder2ForCausalLM:()=>Kv,Starcoder2Model:()=>qv,Starcoder2PreTrainedModel:()=>Ug,StyleTextToSpeech2Model:()=>$v,StyleTextToSpeech2PreTrainedModel:()=>Ov,Swin2SRForImageSuperResolution:()=>ET,Swin2SRModel:()=>ST,Swin2SRPreTrainedModel:()=>Pg,SwinForImageClassification:()=>TT,SwinForSemanticSegmentation:()=>vT,SwinModel:()=>MT,SwinPreTrainedModel:()=>Jh,T5ForConditionalGeneration:()=>hs,T5Model:()=>Lt,T5PreTrainedModel:()=>ft,TableTransformerForObjectDetection:()=>fT,TableTransformerModel:()=>pT,TableTransformerObjectDetectionOutput:()=>mT,TableTransformerPreTrainedModel:()=>Sg,TokenClassifierOutput:()=>vi,TrOCRForCausalLM:()=>jv,TrOCRPreTrainedModel:()=>Gv,UltravoxModel:()=>F1,UltravoxPreTrainedModel:()=>N1,UniSpeechForCTC:()=>wv,UniSpeechForSequenceClassification:()=>Mv,UniSpeechModel:()=>bv,UniSpeechPreTrainedModel:()=>tp,UniSpeechSatForAudioFrameClassification:()=>Ev,UniSpeechSatForCTC:()=>vv,UniSpeechSatForSequenceClassification:()=>Sv,UniSpeechSatModel:()=>Tv,UniSpeechSatPreTrainedModel:()=>td,ViTForImageClassification:()=>AM,ViTMAEModel:()=>kM,ViTMAEPreTrainedModel:()=>DM,ViTMSNForImageClassification:()=>BM,ViTMSNModel:()=>LM,ViTMSNPreTrainedModel:()=>hg,ViTModel:()=>EM,ViTPreTrainedModel:()=>ug,VisionEncoderDecoderModel:()=>kc,VitMatteForImageMatting:()=>GM,VitMattePreTrainedModel:()=>UM,VitPoseForPoseEstimation:()=>FM,VitPosePreTrainedModel:()=>NM,VitsModel:()=>jg,VitsModelOutput:()=>XS,VitsPreTrainedModel:()=>e1,Wav2Vec2BertForCTC:()=>Cv,Wav2Vec2BertForSequenceClassification:()=>Pv,Wav2Vec2BertModel:()=>Av,Wav2Vec2BertPreTrainedModel:()=>sp,Wav2Vec2ForAudioFrameClassification:()=>mv,Wav2Vec2ForCTC:()=>pv,Wav2Vec2ForSequenceClassification:()=>fv,Wav2Vec2Model:()=>hv,Wav2Vec2PreTrainedModel:()=>fa,WavLMForAudioFrameClassification:()=>Bv,WavLMForCTC:()=>Dv,WavLMForSequenceClassification:()=>kv,WavLMForXVector:()=>Lv,WavLMModel:()=>Iv,WavLMPreTrainedModel:()=>Mu,WeSpeakerResNetModel:()=>xv,WeSpeakerResNetPreTrainedModel:()=>yv,WhisperForConditionalGeneration:()=>lu,WhisperModel:()=>$h,WhisperPreTrainedModel:()=>Rc,XLMForQuestionAnswering:()=>Ih,XLMForSequenceClassification:()=>Fh,XLMForTokenClassification:()=>Rh,XLMModel:()=>Ph,XLMPreTrainedModel:()=>ca,XLMRobertaForMaskedLM:()=>kh,XLMRobertaForQuestionAnswering:()=>Oh,XLMRobertaForSequenceClassification:()=>Lh,XLMRobertaForTokenClassification:()=>Bh,XLMRobertaModel:()=>Dh,XLMRobertaPreTrainedModel:()=>da,XLMWithLMHeadModel:()=>Nh,XVectorOutput:()=>qS,YolosForObjectDetection:()=>iv,YolosModel:()=>sv,YolosObjectDetectionOutput:()=>rv,YolosPreTrainedModel:()=>Bg});var s=t("./src/configs.js"),r=t("./src/backends/onnx.js"),n=t("./src/utils/dtypes.js"),o=t("./src/utils/generic.js"),a=t("./src/utils/core.js"),l=t("./src/utils/hub.js"),u=t("./src/utils/constants.js"),c=t("./src/generation/logits_process.js"),d=t("./src/generation/configuration_utils.js"),h=t("./src/utils/tensor.js"),p=t("./src/utils/image.js"),f=t("./src/utils/maths.js"),m=t("./src/generation/stopping_criteria.js"),x=t("./src/generation/logits_sampler.js"),g=t("./src/env.js"),_=t("./src/models/whisper/generation_whisper.js"),S=t("./src/models/whisper/common_whisper.js");const M={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8,Phi3V:9,AudioTextToText:10,AutoEncoder:11,ImageAudioTextToText:12},w=new Map,v=new Map,T=new Map;async function E(A,N,B){var $i;let ae=(($i=B.config)==null?void 0:$i["transformers.js_config"])??{},Se=B.device??ae.device;Se&&typeof Se!="string"&&(Se.hasOwnProperty(N)?Se=Se[N]:(console.warn(`device not specified for "${N}". Using the default device.`),Se=null));const Te=Se??(g.apis.IS_NODE_ENV?"cpu":"wasm"),Ie=(0,r.deviceToExecutionProviders)(Te),Ke=ae.device_config??{};Ke.hasOwnProperty(Te)&&(ae={...ae,...Ke[Te]});let st=B.dtype??ae.dtype;if(typeof st!="string"&&(st&&st.hasOwnProperty(N)?st=st[N]:(st=n.DEFAULT_DEVICE_DTYPE_MAPPING[Te]??n.DATA_TYPES.fp32,console.warn(`dtype not specified for "${N}". Using the default dtype (${st}) for this device (${Te}).`))),st===n.DATA_TYPES.auto){let Xt=ae.dtype;typeof Xt!="string"&&(Xt=Xt==null?void 0:Xt[N]),Xt&&Xt!==n.DATA_TYPES.auto&&n.DATA_TYPES.hasOwnProperty(Xt)?st=Xt:st=n.DEFAULT_DEVICE_DTYPE_MAPPING[Te]??n.DATA_TYPES.fp32}const ct=st;if(n.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(ct)){if(ct===n.DATA_TYPES.fp16&&Te==="webgpu"&&!await(0,n.isWebGpuFp16Supported)())throw new Error(`The device (${Te}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${ct}. Should be one of: ${Object.keys(n.DATA_TYPES).join(", ")}`);const Pt=ae.kv_cache_dtype,Bt=Pt?typeof Pt=="string"?Pt:Pt[ct]??"float32":void 0;if(Bt&&!["float32","float16"].includes(Bt))throw new Error(`Invalid kv_cache_dtype: ${Bt}. Should be one of: float32, float16`);const Ot={dtype:ct,kv_cache_dtype:Bt,device:Te},os=n.DEFAULT_DTYPE_SUFFIX_MAPPING[ct],It=`${N}${os}.onnx`,Yt=`${B.subfolder??""}/${It}`,vt={...B.session_options};vt.executionProviders??(vt.executionProviders=Ie);const Jt=ae.free_dimension_overrides;Jt?vt.freeDimensionOverrides??(vt.freeDimensionOverrides=Jt):Te.startsWith("webnn")&&!vt.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${Te}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const Ss=g.apis.IS_NODE_ENV&&g.env.useFSCache,Ws=(0,l.getModelFile)(A,Yt,!0,B,Ss),ri=B.use_external_data_format??ae.use_external_data_format;let Zs=[];if(ri){let Xt;typeof ri=="object"?ri.hasOwnProperty(It)?Xt=ri[It]:ri.hasOwnProperty(N)?Xt=ri[N]:Xt=!1:Xt=ri;const Si=+Xt;if(Si>l.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${Si}) exceeds the maximum allowed value (${l.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let Or=0;Or<Si;++Or){const cl=`${It}_data${Or===0?"":"_"+Or}`,pr=`${B.subfolder??""}/${cl}`;Zs.push(new Promise(async(on,pp)=>{const dl=await(0,l.getModelFile)(A,pr,!0,B,Ss);on(dl instanceof Uint8Array?{path:cl,data:dl}:cl)}))}}else vt.externalData!==void 0&&(Zs=vt.externalData.map(async Xt=>{if(typeof Xt.data=="string"){const Si=await(0,l.getModelFile)(A,Xt.data,!0,B);return{...Xt,data:Si}}return Xt}));if(Zs.length>0){const Xt=await Promise.all(Zs);g.apis.IS_NODE_ENV||(vt.externalData=Xt)}if(Te==="webgpu"){const Xt=(0,s.getKeyValueShapes)(B.config,{prefix:"present"});if(Object.keys(Xt).length>0&&!(0,r.isONNXProxy)()){const Si={};for(const Or in Xt)Si[Or]="gpu-buffer";vt.preferredOutputLocation=Si}}return{buffer_or_path:await Ws,session_options:vt,session_config:Ot}}async function F(A,N,B){return Object.fromEntries(await Promise.all(Object.keys(N).map(async ae=>{const{buffer_or_path:Se,session_options:Te,session_config:Ie}=await E(A,N[ae],B),Ke=await(0,r.createInferenceSession)(Se,Te,Ie);return[ae,Ke]})))}async function I(A,N,B){return Object.fromEntries(await Promise.all(Object.keys(N).map(async ae=>{const Se=await(0,l.getModelJSON)(A,N[ae],!1,B);return[ae,Se]})))}function z(A,N){const B=Object.create(null),ae=[];for(const Ie of A.inputNames){const Ke=N[Ie];if(!(Ke instanceof h.Tensor)){ae.push(Ie);continue}B[Ie]=(0,r.isONNXProxy)()?Ke.clone():Ke}if(ae.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${ae.join(", ")}.`);const Se=Object.keys(N).length,Te=A.inputNames.length;if(Se>Te){let Ie=Object.keys(N).filter(Ke=>!A.inputNames.includes(Ke));console.warn(`WARNING: Too many inputs were provided (${Se} > ${Te}). The following inputs will be ignored: "${Ie.join(", ")}".`)}return B}let G=Promise.resolve();async function L(A,N){const B=z(A,N);try{const ae=Object.fromEntries(Object.entries(B).map(([Ie,Ke])=>[Ie,Ke.ort_tensor])),Se=()=>A.run(ae),Te=await(g.apis.IS_BROWSER_ENV||g.apis.IS_WEBWORKER_ENV?G=G.then(Se):Se());return Q(Te)}catch(ae){const Se=Object.fromEntries(Object.entries(B).map(([Te,Ie])=>{const Ke={type:Ie.type,dims:Ie.dims,location:Ie.location};return Ke.location!=="gpu-buffer"&&(Ke.data=Ie.data),[Te,Ke]}));throw console.error(`An error occurred during model execution: "${ae}".`),console.error("Inputs given to model:",Se),ae}}function Q(A){for(let N in A)(0,r.isONNXTensor)(A[N])?A[N]=new h.Tensor(A[N]):typeof A[N]=="object"&&Q(A[N]);return A}function q(A){if(A instanceof h.Tensor)return A;if(A.length===0)throw Error("items must be non-empty");if(Array.isArray(A[0])){if(A.some(N=>N.length!==A[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new h.Tensor("int64",BigInt64Array.from(A.flat().map(N=>BigInt(N))),[A.length,A[0].length])}else return new h.Tensor("int64",BigInt64Array.from(A.map(N=>BigInt(N))),[1,A.length])}function J(A){return new h.Tensor("bool",[A],[1])}async function ee(A,N){let{encoder_outputs:B,input_ids:ae,decoder_input_ids:Se,...Te}=N;if(!B){const Ke=(0,a.pick)(N,A.sessions.model.inputNames);B=(await se(A,Ke)).last_hidden_state}return Te.input_ids=Se,Te.encoder_hidden_states=B,A.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(Te.encoder_attention_mask=N.attention_mask),await ue(A,Te,!0)}async function se(A,N){const B=A.sessions.model,ae=(0,a.pick)(N,B.inputNames);if(B.inputNames.includes("inputs_embeds")&&!ae.inputs_embeds){if(!N.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");ae.inputs_embeds=await A.encode_text({input_ids:N.input_ids})}if(B.inputNames.includes("token_type_ids")&&!ae.token_type_ids){if(!ae.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");ae.token_type_ids=(0,h.zeros_like)(ae.input_ids)}if(B.inputNames.includes("pixel_mask")&&!ae.pixel_mask){if(!ae.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const Se=ae.pixel_values.dims;ae.pixel_mask=(0,h.ones)([Se[0],Se[2],Se[3]])}return await L(B,ae)}async function fe(A,N){const B=await A.encode(N);return await A.decode(B)}async function ue(A,N,B=!1){const ae=A.sessions[B?"decoder_model_merged":"model"],{past_key_values:Se,...Te}=N;if(ae.inputNames.includes("use_cache_branch")&&(Te.use_cache_branch=J(!!Se)),ae.inputNames.includes("position_ids")&&Te.attention_mask&&!Te.position_ids){const Ke=["paligemma","gemma3_text","gemma3"].includes(A.config.model_type)?1:0;Te.position_ids=Xe(Te,Se,Ke)}A.addPastKeyValues(Te,Se);const Ie=(0,a.pick)(Te,ae.inputNames);return await L(ae,Ie)}function U({modality_token_id:A,inputs_embeds:N,modality_features:B,input_ids:ae,attention_mask:Se}){const Te=ae.tolist().map(ct=>ct.reduce((Pt,Bt,Ot)=>(Bt==A&&Pt.push(Ot),Pt),[])),Ie=Te.reduce((ct,Pt)=>ct+Pt.length,0),Ke=B.dims[0];if(Ie!==Ke)throw new Error(`Number of tokens and features do not match: tokens: ${Ie}, features ${Ke}`);let st=0;for(let ct=0;ct<Te.length;++ct){const Pt=Te[ct],Bt=N[ct];for(let Ot=0;Ot<Pt.length;++Ot)Bt[Pt[Ot]].data.set(B[st++].data)}return{inputs_embeds:N,attention_mask:Se}}function k({image_token_id:A,inputs_embeds:N,image_features:B,input_ids:ae,attention_mask:Se}){return U({modality_token_id:A,inputs_embeds:N,modality_features:B,input_ids:ae,attention_mask:Se})}function j({audio_token_id:A,inputs_embeds:N,audio_features:B,input_ids:ae,attention_mask:Se}){return U({modality_token_id:A,inputs_embeds:N,modality_features:B,input_ids:ae,attention_mask:Se})}async function re(A,{encode_function:N,merge_function:B,modality_input_name:ae,modality_output_name:Se,input_ids:Te=null,attention_mask:Ie=null,position_ids:Ke=null,inputs_embeds:st=null,past_key_values:ct=null,generation_config:Pt=null,logits_processor:Bt=null,...Ot}){const os=Ot[ae];if(!st){if(st=await A.encode_text({input_ids:Te,...Ot}),os&&Te.dims[1]!==1){const Yt=await N({[ae]:os,...Ot});({inputs_embeds:st,attention_mask:Ie}=B({[Se]:Yt,inputs_embeds:st,input_ids:Te,attention_mask:Ie}))}else if(ct&&os&&Te.dims[1]===1){const Yt=Te.dims[1],vt=Object.values(ct)[0].dims.at(-2);Ie=(0,h.cat)([(0,h.ones)([Te.dims[0],vt]),Ie.slice(null,[Ie.dims[1]-Yt,Ie.dims[1]])],1)}}if(!Ke&&A.config.model_type==="qwen2_vl"){const{image_grid_thw:Yt,video_grid_thw:vt}=Ot;[Ke]=A.get_rope_index(Te,Yt,vt,Ie)}return await ue(A,{inputs_embeds:st,past_key_values:ct,attention_mask:Ie,position_ids:Ke,generation_config:Pt,logits_processor:Bt},!0)}async function we(A,N){return await re(A,{...N,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:A.encode_audio.bind(A),merge_function:A._merge_input_ids_with_audio_features.bind(A)})}async function de(A,N){return await re(A,{...N,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:A.encode_image.bind(A),merge_function:A._merge_input_ids_with_image_features.bind(A)})}function Pe(A,N=0){const[B,ae]=A.dims,Se=A.data,Te=new BigInt64Array(Se.length);for(let Ie=0;Ie<B;++Ie){const Ke=Ie*ae;let st=BigInt(N);for(let ct=0;ct<ae;++ct){const Pt=Ke+ct;Se[Pt]===0n?Te[Pt]=BigInt(1):(Te[Pt]=st,st+=Se[Pt])}}return{data:Te,dims:A.dims}}function Xe(A,N=null,B=0){const{input_ids:ae,inputs_embeds:Se,attention_mask:Te}=A,{data:Ie,dims:Ke}=Pe(Te,B);let st=new h.Tensor("int64",Ie,Ke);if(N){const ct=-(ae??Se).dims.at(1);st=st.slice(null,[ct,null])}return st}function et(A,N,B,ae){const Se=B.past_key_values?Object.values(B.past_key_values)[0].dims.at(-2):0;if(!B.attention_mask){let Te;for(const Ie of["input_ids","inputs_embeds","position_ids"])if(B[Ie]){Te=B[Ie].dims;break}if(!Te)throw new Error("attention_mask is not provided, and unable to infer its shape from model inputs.");B.attention_mask=(0,h.ones)([Te[0],Se+Te[1]])}if(B.past_key_values){const{input_ids:Te,attention_mask:Ie}=B;Ie&&Ie.dims[1]>Te.dims[1]||Se<Te.dims[1]&&(B.input_ids=Te.slice(null,[Se,null]))}return B}function Me(A,N,B,ae){return B.past_key_values&&(N=N.map(Se=>[Se.at(-1)])),{...B,decoder_input_ids:q(N)}}function X(A,...N){return A.config.is_encoder_decoder?Me(A,...N):et(A,...N)}function oe(A,N,B,ae){const Se=!!B.past_key_values;return ae.guidance_scale!==null&&ae.guidance_scale>1&&(Se?B.input_ids=(0,h.cat)([B.input_ids,B.input_ids],0):(B.input_ids=(0,h.cat)([B.input_ids,(0,h.full_like)(B.input_ids,BigInt(ae.pad_token_id))],0),B.attention_mask=(0,h.cat)([B.attention_mask,(0,h.full_like)(B.attention_mask,0n)],0))),(Se||!B.pixel_values)&&(B.pixel_values=(0,h.full)([0,0,3,384,384],1)),Se&&(B.images_seq_mask=new h.Tensor("bool",new Array(1).fill(!0).fill(!1,0,1),[1,1]),B.images_emb_mask=new h.Tensor("bool",new Array(0).fill(!1),[1,1,0])),B}class K extends o.Callable{constructor(B,ae,Se){super();Z(this,"main_input_name","input_ids");Z(this,"forward_params",["input_ids","attention_mask"]);this.config=B,this.sessions=ae,this.configs=Se;const Te=T.get(this.constructor),Ie=w.get(Te);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,Ie){case M.DecoderOnly:this.can_generate=!0,this._forward=ue,this._prepare_inputs_for_generation=et;break;case M.Seq2Seq:case M.Vision2Seq:case M.Musicgen:this.can_generate=!0,this._forward=ee,this._prepare_inputs_for_generation=Me;break;case M.EncoderDecoder:this._forward=ee;break;case M.ImageTextToText:this.can_generate=!0,this._forward=de,this._prepare_inputs_for_generation=X;break;case M.AudioTextToText:this.can_generate=!0,this._forward=we,this._prepare_inputs_for_generation=X;break;case M.Phi3V:case M.ImageAudioTextToText:this.can_generate=!0,this._prepare_inputs_for_generation=X;break;case M.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=oe;break;case M.AutoEncoder:this._forward=fe;break;default:this._forward=se;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var ae;const B=[];for(const Se of Object.values(this.sessions))(ae=Se==null?void 0:Se.handler)!=null&&ae.dispose&&B.push(Se.handler.dispose());return await Promise.all(B)}static async from_pretrained(B,{progress_callback:ae=null,config:Se=null,cache_dir:Te=null,local_files_only:Ie=!1,revision:Ke="main",model_file_name:st=null,subfolder:ct="onnx",device:Pt=null,dtype:Bt=null,use_external_data_format:Ot=null,session_options:os={}}={}){let It={progress_callback:ae,config:Se,cache_dir:Te,local_files_only:Ie,revision:Ke,model_file_name:st,subfolder:ct,device:Pt,dtype:Bt,use_external_data_format:Ot,session_options:os};const Yt=T.get(this),vt=w.get(Yt);Se=It.config=await s.AutoConfig.from_pretrained(B,It);let Jt;if(vt===M.DecoderOnly)Jt=await Promise.all([F(B,{model:It.model_file_name??"model"},It),I(B,{generation_config:"generation_config.json"},It)]);else if(vt===M.Seq2Seq||vt===M.Vision2Seq)Jt=await Promise.all([F(B,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},It),I(B,{generation_config:"generation_config.json"},It)]);else if(vt===M.MaskGeneration)Jt=await Promise.all([F(B,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},It)]);else if(vt===M.EncoderDecoder)Jt=await Promise.all([F(B,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},It)]);else if(vt===M.ImageTextToText){const Ss={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};Se.is_encoder_decoder&&(Ss.model="encoder_model"),Jt=await Promise.all([F(B,Ss,It),I(B,{generation_config:"generation_config.json"},It)])}else if(vt===M.AudioTextToText){const Ss={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};Jt=await Promise.all([F(B,Ss,It),I(B,{generation_config:"generation_config.json"},It)])}else if(vt===M.ImageAudioTextToText){const Ss={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};Jt=await Promise.all([F(B,Ss,It),I(B,{generation_config:"generation_config.json"},It)])}else if(vt===M.Musicgen)Jt=await Promise.all([F(B,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},It),I(B,{generation_config:"generation_config.json"},It)]);else if(vt===M.MultiModality)Jt=await Promise.all([F(B,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},It),I(B,{generation_config:"generation_config.json"},It)]);else if(vt===M.Phi3V)Jt=await Promise.all([F(B,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},It),I(B,{generation_config:"generation_config.json"},It)]);else if(vt===M.AutoEncoder)Jt=await Promise.all([F(B,{encoder_model:"encoder_model",decoder_model:"decoder_model"},It)]);else{if(vt!==M.EncoderOnly){const Ss=Yt??(Se==null?void 0:Se.model_type);Ss!=="custom"&&console.warn(`Model type for '${Ss}' not found, assuming encoder-only architecture. Please report this at ${u.GITHUB_ISSUE_URL}.`)}Jt=await Promise.all([F(B,{model:It.model_file_name??"model"},It)])}return new this(Se,...Jt)}async _call(B){return await this.forward(B)}async forward(B){return await this._forward(this,B)}get generation_config(){var B;return((B=this.configs)==null?void 0:B.generation_config)??null}_get_logits_warper(B){const ae=new c.LogitsProcessorList;return B.temperature!==null&&B.temperature!==1&&ae.push(new c.TemperatureLogitsWarper(B.temperature)),B.top_k!==null&&B.top_k!==0&&ae.push(new c.TopKLogitsWarper(B.top_k)),B.top_p!==null&&B.top_p<1&&ae.push(new c.TopPLogitsWarper(B.top_p)),ae}_get_logits_processor(B,ae,Se=null){const Te=new c.LogitsProcessorList;if(B.repetition_penalty!==null&&B.repetition_penalty!==1&&Te.push(new c.RepetitionPenaltyLogitsProcessor(B.repetition_penalty)),B.no_repeat_ngram_size!==null&&B.no_repeat_ngram_size>0&&Te.push(new c.NoRepeatNGramLogitsProcessor(B.no_repeat_ngram_size)),B.bad_words_ids!==null&&Te.push(new c.NoBadWordsLogitsProcessor(B.bad_words_ids,B.eos_token_id)),B.min_length!==null&&B.eos_token_id!==null&&B.min_length>0&&Te.push(new c.MinLengthLogitsProcessor(B.min_length,B.eos_token_id)),B.min_new_tokens!==null&&B.eos_token_id!==null&&B.min_new_tokens>0&&Te.push(new c.MinNewTokensLengthLogitsProcessor(ae,B.min_new_tokens,B.eos_token_id)),B.forced_bos_token_id!==null&&Te.push(new c.ForcedBOSTokenLogitsProcessor(B.forced_bos_token_id)),B.forced_eos_token_id!==null&&Te.push(new c.ForcedEOSTokenLogitsProcessor(B.max_length,B.forced_eos_token_id)),B.begin_suppress_tokens!==null){const Ie=ae>1||B.forced_bos_token_id===null?ae:ae+1;Te.push(new c.SuppressTokensAtBeginLogitsProcessor(B.begin_suppress_tokens,Ie))}return B.guidance_scale!==null&&B.guidance_scale>1&&Te.push(new c.ClassifierFreeGuidanceLogitsProcessor(B.guidance_scale)),Se!==null&&Te.extend(Se),Te}_prepare_generation_config(B,ae,Se=d.GenerationConfig){const Te={...this.config};for(const Ke of["decoder","generator","text_config"])Ke in Te&&Object.assign(Te,Te[Ke]);const Ie=new Se(Te);return Object.assign(Ie,this.generation_config??{}),B&&Object.assign(Ie,B),ae&&Object.assign(Ie,(0,a.pick)(ae,Object.getOwnPropertyNames(Ie))),Ie}_get_stopping_criteria(B,ae=null){const Se=new m.StoppingCriteriaList;return B.max_length!==null&&Se.push(new m.MaxLengthCriteria(B.max_length,this.config.max_position_embeddings??null)),B.eos_token_id!==null&&Se.push(new m.EosTokenCriteria(B.eos_token_id)),ae&&Se.extend(ae),Se}_validate_model_class(){if(!this.can_generate){const B=[Jg,e_,Zg,Qg],ae=T.get(this.constructor),Se=new Set,Te=this.config.model_type;for(const Ke of B){const st=Ke.get(Te);st&&Se.add(st[0])}let Ie=`The current model class (${ae}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw Se.size>0&&(Ie+=` Please use the following class instead: ${[...Se].join(", ")}`),Error(Ie)}}prepare_inputs_for_generation(...B){return this._prepare_inputs_for_generation(this,...B)}_update_model_kwargs_for_generation({generated_input_ids:B,outputs:ae,model_inputs:Se,is_encoder_decoder:Te}){return Se.past_key_values=this.getPastKeyValues(ae,Se.past_key_values),Se.input_ids=new h.Tensor("int64",B.flat(),[B.length,1]),Te||(Se.attention_mask=(0,h.cat)([Se.attention_mask,(0,h.ones)([Se.attention_mask.dims[0],1])],1)),Se.position_ids=null,Se}_prepare_model_inputs({inputs:B,bos_token_id:ae,model_kwargs:Se}){const Te=(0,a.pick)(Se,this.forward_params),Ie=this.main_input_name;if(Ie in Te){if(B)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else Te[Ie]=B;return{inputs_tensor:Te[Ie],model_inputs:Te,model_input_name:Ie}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:B,model_inputs:ae,model_input_name:Se,generation_config:Te}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!ae.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:Ke,pixel_values:st,attention_mask:ct,...Pt}=ae,Bt=await this._prepare_inputs_embeds(ae);ae={...Pt,...(0,a.pick)(Bt,["inputs_embeds","attention_mask"])}}let{last_hidden_state:Ie}=await se(this,ae);if(Te.guidance_scale!==null&&Te.guidance_scale>1)Ie=(0,h.cat)([Ie,(0,h.full_like)(Ie,0)],0),"attention_mask"in ae&&(ae.attention_mask=(0,h.cat)([ae.attention_mask,(0,h.zeros_like)(ae.attention_mask)],0));else if(ae.decoder_input_ids){const Ke=q(ae.decoder_input_ids).dims[0];if(Ke!==Ie.dims[0]){if(Ie.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${Ie.dims[0]}) than the decoder inputs (${Ke}).`);Ie=(0,h.cat)(Array.from({length:Ke},()=>Ie),0)}}return ae.encoder_outputs=Ie,ae}_prepare_decoder_input_ids_for_generation({batch_size:B,model_input_name:ae,model_kwargs:Se,decoder_start_token_id:Te,bos_token_id:Ie,generation_config:Ke}){let{decoder_input_ids:st,...ct}=Se;if(!(st instanceof h.Tensor)){if(st)Array.isArray(st[0])||(st=Array.from({length:B},()=>st));else if(Te??(Te=Ie),this.config.model_type==="musicgen")st=Array.from({length:B*this.config.decoder.num_codebooks},()=>[Te]);else if(Array.isArray(Te)){if(Te.length!==B)throw new Error(`\`decoder_start_token_id\` expcted to have length ${B} but got ${Te.length}`);st=Te}else st=Array.from({length:B},()=>[Te]);st=q(st)}return Se.decoder_attention_mask=(0,h.ones_like)(st),{input_ids:st,model_inputs:ct}}async generate({inputs:B=null,generation_config:ae=null,logits_processor:Se=null,stopping_criteria:Te=null,streamer:Ie=null,...Ke}){this._validate_model_class(),ae=this._prepare_generation_config(ae,Ke);let{inputs_tensor:st,model_inputs:ct,model_input_name:Pt}=this._prepare_model_inputs({inputs:B,model_kwargs:Ke});const Bt=this.config.is_encoder_decoder;Bt&&("encoder_outputs"in ct||(ct=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:st,model_inputs:ct,model_input_name:Pt,generation_config:ae})));let Ot;Bt?{input_ids:Ot,model_inputs:ct}=this._prepare_decoder_input_ids_for_generation({batch_size:ct[Pt].dims.at(0),model_input_name:Pt,model_kwargs:ct,decoder_start_token_id:ae.decoder_start_token_id,bos_token_id:ae.bos_token_id,generation_config:ae}):Ot=ct[Pt];let os=Ot.dims.at(-1);ae.max_new_tokens!==null&&(ae.max_length=os+ae.max_new_tokens);const It=this._get_logits_processor(ae,os,Se),Yt=this._get_stopping_criteria(ae,Te),vt=ct[Pt].dims.at(0),Jt=x.LogitsSampler.getSampler(ae),Ss=new Array(vt).fill(0),Ws=Ot.tolist();Ie&&Ie.put(Ws);let ri,Zs={};for(;;){if(ct=this.prepare_inputs_for_generation(Ws,ct,ae),ri=await this.forward(ct),ae.output_attentions&&ae.return_dict_in_generate){const pr=this.getAttentions(ri);for(const on in pr)on in Zs||(Zs[on]=[]),Zs[on].push(pr[on])}const Xt=ri.logits.slice(null,-1,null),Si=It(Ws,Xt),Or=[];for(let pr=0;pr<Si.dims.at(0);++pr){const on=Si[pr],pp=await Jt(on);for(const[dl,fp]of pp){const mp=BigInt(dl);Ss[pr]+=fp,Ws[pr].push(mp),Or.push([mp]);break}}if(Ie&&Ie.put(Or),Yt(Ws).every(pr=>pr))break;ct=this._update_model_kwargs_for_generation({generated_input_ids:Or,outputs:ri,model_inputs:ct,is_encoder_decoder:Bt})}Ie&&Ie.end();const gi=this.getPastKeyValues(ri,ct.past_key_values,!0),$i=new h.Tensor("int64",Ws.flat(),[Ws.length,Ws[0].length]);if(ae.return_dict_in_generate)return{sequences:$i,past_key_values:gi,...Zs};for(const Xt of Object.values(ri))Xt.location==="gpu-buffer"&&Xt.dispose();return $i}getPastKeyValues(B,ae,Se=!1){const Te=Object.create(null);for(const Ie in B)if(Ie.startsWith("present")){const Ke=Ie.replace("present","past_key_values"),st=Ie.includes("encoder");if(st&&ae?Te[Ke]=ae[Ke]:Te[Ke]=B[Ie],ae&&(!st||Se)){const ct=ae[Ke];ct.location==="gpu-buffer"&&ct.dispose()}}return Te}getAttentions(B){const ae={};for(const Se of["cross_attentions","encoder_attentions","decoder_attentions"])for(const Te in B)Te.startsWith(Se)&&(Se in ae||(ae[Se]=[]),ae[Se].push(B[Te]));return ae}addPastKeyValues(B,ae){var Se,Te,Ie;if(ae)Object.assign(B,ae);else{const Ke=this.sessions.decoder_model_merged??this.sessions.model,st=((Se=Ke==null?void 0:Ke.config)==null?void 0:Se.kv_cache_dtype)??"float32",ct=st==="float16"?new h.DataTypeMap.float16:[],Pt=((Ie=(Te=B[this.main_input_name]??B.attention_mask)==null?void 0:Te.dims)==null?void 0:Ie[0])??1,Bt=(0,s.getKeyValueShapes)(this.config,{batch_size:Pt});for(const Ot in Bt)B[Ot]=new h.Tensor(st,ct,Bt[Ot])}}async encode_image({pixel_values:B}){return(await L(this.sessions.vision_encoder,{pixel_values:B})).image_features}async encode_text({input_ids:B}){return(await L(this.sessions.embed_tokens,{input_ids:B})).inputs_embeds}async encode_audio({audio_values:B}){return(await L(this.sessions.audio_encoder,{audio_values:B})).audio_features}}class Ce{}class Ee extends Ce{constructor({last_hidden_state:N,hidden_states:B=null,attentions:ae=null}){super(),this.last_hidden_state=N,this.hidden_states=B,this.attentions=ae}}class $e extends K{}class Be extends $e{}class Ve extends $e{async _call(N){return new Oi(await super._call(N))}}class We extends $e{async _call(N){return new Vt(await super._call(N))}}class Je extends $e{async _call(N){return new vi(await super._call(N))}}class it extends $e{async _call(N){return new er(await super._call(N))}}class lt extends K{}class Ue extends lt{}class rt extends lt{async _call(N){return new Oi(await super._call(N))}}class yt extends lt{async _call(N){return new Vt(await super._call(N))}}class Nt extends lt{async _call(N){return new vi(await super._call(N))}}class bt extends lt{async _call(N){return new er(await super._call(N))}}class Ye extends K{}class tt extends Ye{}class pt extends Ye{async _call(N){return new Oi(await super._call(N))}}class ss extends Ye{async _call(N){return new Vt(await super._call(N))}}class Zt extends Ye{async _call(N){return new vi(await super._call(N))}}class _s extends K{}class bi extends _s{}class ti extends K{}class $t extends ti{}class Qr extends ti{async _call(N){return new Oi(await super._call(N))}}class O extends ti{async _call(N){return new Vt(await super._call(N))}}class le extends ti{async _call(N){return new vi(await super._call(N))}}class V extends ti{async _call(N){return new er(await super._call(N))}}class ie extends K{}class ve extends ie{}class He extends ie{async _call(N){return new Oi(await super._call(N))}}class Ne extends ie{async _call(N){return new Vt(await super._call(N))}}class Ut extends ie{async _call(N){return new vi(await super._call(N))}}class ds extends ie{async _call(N){return new er(await super._call(N))}}class Ct extends K{}class Mt extends Ct{}class _t extends Ct{async _call(N){return new Oi(await super._call(N))}}class ys extends Ct{async _call(N){return new Vt(await super._call(N))}}class Is extends Ct{async _call(N){return new vi(await super._call(N))}}class wi extends Ct{async _call(N){return new er(await super._call(N))}}class $s extends K{}class Qi extends $s{}class Zr extends $s{async _call(N){return new Oi(await super._call(N))}}class vn extends $s{async _call(N){return new Vt(await super._call(N))}}class Jr extends $s{async _call(N){return new vi(await super._call(N))}}class Qn extends $s{async _call(N){return new er(await super._call(N))}}class dr extends K{}class Zn extends dr{}class Lr extends dr{async _call(N){return new Oi(await super._call(N))}}class Sn extends dr{async _call(N){return new Vt(await super._call(N))}}class Jn extends dr{async _call(N){return new vi(await super._call(N))}}class eo extends dr{async _call(N){return new er(await super._call(N))}}class si extends K{}class to extends si{}class ki extends si{async _call(N){return new Oi(await super._call(N))}}class En extends si{async _call(N){return new Vt(await super._call(N))}}class ir extends si{async _call(N){return new vi(await super._call(N))}}class je extends si{async _call(N){return new er(await super._call(N))}}class dt extends K{}class wt extends dt{}class xs extends dt{async _call(N){return new Vt(await super._call(N))}}class en extends dt{async _call(N){return new vi(await super._call(N))}}class tn extends dt{async _call(N){return new er(await super._call(N))}}class Li extends dt{async _call(N){return new Oi(await super._call(N))}}class hr extends K{}class ai extends hr{}class fi extends hr{async _call(N){return new Oi(await super._call(N))}}class sn extends hr{async _call(N){return new Vt(await super._call(N))}}class Ha extends hr{async _call(N){return new vi(await super._call(N))}}class so extends K{}class qa extends so{}class Ka extends so{async _call(N){return new Oi(await super._call(N))}}class Xa extends so{async _call(N){return new Vt(await super._call(N))}}class Ya extends so{async _call(N){return new er(await super._call(N))}}class An extends K{}class ua extends An{}class Qa extends An{async _call(N){return new Oi(await super._call(N))}}class Za extends An{async _call(N){return new Vt(await super._call(N))}}class Ja extends An{async _call(N){return new vi(await super._call(N))}}class el extends An{async _call(N){return new er(await super._call(N))}}class ye extends K{}class R extends ye{}class W extends ye{async _call(N){return new Oi(await super._call(N))}}class te extends ye{async _call(N){return new Vt(await super._call(N))}}class he extends ye{async _call(N){return new er(await super._call(N))}}class _e extends K{}class Fe extends _e{}class Qe extends _e{async _call(N){return new Vt(await super._call(N))}}class ut extends _e{async _call(N){return new er(await super._call(N))}}class nt extends _e{async _call(N){return new Oi(await super._call(N))}}class ft extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class Lt extends ft{}class hs extends ft{}class ps extends K{}class zs extends ps{}class Ts extends ps{}class li extends K{}class Zi extends li{}class Bi extends li{}class mi extends K{}class Gs extends mi{}class Cn extends mi{}class Ds extends mi{async _call(N){return new Vt(await super._call(N))}}class Qs extends K{}class Ji extends Qs{}class rn extends Qs{}class Br extends Qs{async _call(N){return new Vt(await super._call(N))}}class ji extends Qs{}class Mr extends K{}class Mi extends Mr{}class js extends Mr{}class ii extends K{}class ui extends ii{}class Wi extends ii{}class nn extends K{}class tl extends nn{}class Eh extends nn{async _call(N){return new Oi(await super._call(N))}}class Ah extends nn{async _call(N){return new Vt(await super._call(N))}}class Ch extends nn{async _call(N){return new vi(await super._call(N))}}class Pc extends nn{async _call(N){return new er(await super._call(N))}}class ca extends K{}class Ph extends ca{}class Nh extends ca{async _call(N){return new Oi(await super._call(N))}}class Fh extends ca{async _call(N){return new Vt(await super._call(N))}}class Rh extends ca{async _call(N){return new vi(await super._call(N))}}class Ih extends ca{async _call(N){return new er(await super._call(N))}}class da extends K{}class Dh extends da{}class kh extends da{async _call(N){return new Oi(await super._call(N))}}class Lh extends da{async _call(N){return new Vt(await super._call(N))}}class Bh extends da{async _call(N){return new vi(await super._call(N))}}class Oh extends da{async _call(N){return new er(await super._call(N))}}class au extends K{}class Nc extends au{}class Fc extends au{}class Rc extends K{constructor(){super(...arguments);Z(this,"requires_attention_mask",!1);Z(this,"main_input_name","input_features");Z(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class $h extends Rc{}class lu extends Rc{_prepare_generation_config(N,B){return super._prepare_generation_config(N,B,_.WhisperGenerationConfig)}_retrieve_init_tokens(N){const B=[N.decoder_start_token_id];let ae=N.language;const Se=N.task;if(N.is_multilingual){ae||(console.warn("No language specified - defaulting to English (en)."),ae="en");const Ie=`<|${(0,S.whisper_language_to_code)(ae)}|>`;B.push(N.lang_to_id[Ie]),B.push(N.task_to_id[Se??"transcribe"])}else if(ae||Se)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!N.return_timestamps&&N.no_timestamps_token_id&&B.at(-1)!==N.no_timestamps_token_id?B.push(N.no_timestamps_token_id):N.return_timestamps&&B.at(-1)===N.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),B.pop()),B.filter(Te=>Te!=null)}async generate({inputs:N=null,generation_config:B=null,logits_processor:ae=null,stopping_criteria:Se=null,...Te}){B=this._prepare_generation_config(B,Te);const Ie=Te.decoder_input_ids??this._retrieve_init_tokens(B);if(B.return_timestamps&&(ae??(ae=new c.LogitsProcessorList),ae.push(new c.WhisperTimeStampLogitsProcessor(B,Ie))),B.begin_suppress_tokens&&(ae??(ae=new c.LogitsProcessorList),ae.push(new c.SuppressTokensAtBeginLogitsProcessor(B.begin_suppress_tokens,Ie.length))),B.return_token_timestamps){if(!B.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");B.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),B.output_attentions=!0,B.return_dict_in_generate=!0}const Ke=await super.generate({inputs:N,generation_config:B,logits_processor:ae,decoder_input_ids:Ie,...Te});return B.return_token_timestamps&&(Ke.token_timestamps=this._extract_token_timestamps(Ke,B.alignment_heads,B.num_frames)),Ke}_extract_token_timestamps(N,B,ae=null,Se=.02){if(!N.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");ae==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let Te=this.config.median_filter_width;Te===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),Te=7);const Ie=N.cross_attentions,Ke=Array.from({length:this.config.decoder_layers},(Yt,vt)=>(0,h.cat)(Ie.map(Jt=>Jt[vt]),2)),st=(0,h.stack)(B.map(([Yt,vt])=>{if(Yt>=Ke.length)throw new Error(`Layer index ${Yt} is out of bounds for cross attentions (length ${Ke.length}).`);return ae?Ke[Yt].slice(null,vt,null,[0,ae]):Ke[Yt].slice(null,vt)})).transpose(1,0,2,3),[ct,Pt]=(0,h.std_mean)(st,-2,0,!0),Bt=st.clone();for(let Yt=0;Yt<Bt.dims[0];++Yt){const vt=Bt[Yt];for(let Jt=0;Jt<vt.dims[0];++Jt){const Ss=vt[Jt],Ws=ct[Yt][Jt][0].data,ri=Pt[Yt][Jt][0].data;for(let Zs=0;Zs<Ss.dims[0];++Zs){let gi=Ss[Zs].data;for(let $i=0;$i<gi.length;++$i)gi[$i]=(gi[$i]-ri[$i])/Ws[$i];gi.set((0,f.medianFilter)(gi,Te))}}}const Ot=[(0,h.mean)(Bt,1)],os=N.sequences.dims,It=new h.Tensor("float32",new Float32Array(os[0]*os[1]),os);for(let Yt=0;Yt<os[0];++Yt){const vt=Ot[Yt].neg().squeeze_(0),[Jt,Ss]=(0,f.dynamic_time_warping)(vt.tolist()),Ws=Array.from({length:Jt.length-1},(gi,$i)=>Jt[$i+1]-Jt[$i]),ri=(0,a.mergeArrays)([1],Ws).map(gi=>!!gi),Zs=[];for(let gi=0;gi<ri.length;++gi)ri[gi]&&Zs.push(Ss[gi]*Se);It[Yt].data.set(Zs,1)}return It}}class Ic extends lu{}class Po extends K{constructor(){super(...arguments);Z(this,"requires_attention_mask",!1);Z(this,"main_input_name","input_values");Z(this,"forward_params",["input_values","decoder_input_ids","past_key_values"])}}class qm extends Po{}class Dc extends Po{}class kc extends K{constructor(){super(...arguments);Z(this,"main_input_name","pixel_values");Z(this,"forward_params",["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"])}}class Lc extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class uu extends Lc{_merge_input_ids_with_image_features(N){const B=N.image_features.dims.at(-1),ae=N.image_features.view(-1,B);return k({image_token_id:this.config.image_token_index,...N,image_features:ae})}}class cu extends uu{}class Bc extends uu{}class zh extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);Z(this,"main_input_name","inputs_embeds")}}class Vh extends zh{_merge_input_ids_with_image_features({inputs_embeds:N,image_features:B,input_ids:ae,attention_mask:Se}){return{inputs_embeds:(0,h.cat)([B,N],1),attention_mask:(0,h.cat)([(0,h.ones)(B.dims.slice(0,2)),Se],1)}}async _prepare_inputs_embeds({input_ids:N,pixel_values:B,inputs_embeds:ae,attention_mask:Se}){if(!N&&!B)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let Te,Ie;return N&&(Te=await this.encode_text({input_ids:N})),B&&(Ie=await this.encode_image({pixel_values:B})),Te&&Ie?{inputs_embeds:ae,attention_mask:Se}=this._merge_input_ids_with_image_features({inputs_embeds:Te,image_features:Ie,input_ids:N,attention_mask:Se}):ae=Te||Ie,{inputs_embeds:ae,attention_mask:Se}}async forward({input_ids:N,pixel_values:B,attention_mask:ae,decoder_input_ids:Se,decoder_attention_mask:Te,encoder_outputs:Ie,past_key_values:Ke,inputs_embeds:st,decoder_inputs_embeds:ct}){if(st||({inputs_embeds:st,attention_mask:ae}=await this._prepare_inputs_embeds({input_ids:N,pixel_values:B,inputs_embeds:st,attention_mask:ae})),!Ie){let{last_hidden_state:Ot}=await se(this,{inputs_embeds:st,attention_mask:ae});Ie=Ot}if(!ct){if(!Se)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");ct=await this.encode_text({input_ids:Se})}return await ue(this,{inputs_embeds:ct,attention_mask:Te,encoder_attention_mask:ae,encoder_hidden_states:Ie,past_key_values:Ke},!0)}}class Uh extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class Gh extends Uh{_merge_input_ids_with_image_features(N){const B=N.image_features.dims.at(-1),ae=N.image_features.view(-1,B);return k({image_token_id:this.config.image_token_index,...N,image_features:ae})}}class jh extends Lc{_merge_input_ids_with_image_features(N){const B=N.image_features.dims.at(-1),ae=N.image_features.view(-1,B);return k({image_token_id:this.config.image_token_index,...N,image_features:ae})}}class Wh extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","attention_mask","inputs_embeds","per_layer_inputs","position_ids","pixel_values","input_features","input_features_mask","past_key_values"])}}class Oc extends Wh{async forward({input_ids:N=null,attention_mask:B=null,pixel_values:ae=null,input_features:Se=null,input_features_mask:Te=null,position_ids:Ie=null,inputs_embeds:Ke=null,per_layer_inputs:st=null,past_key_values:ct=null,generation_config:Pt=null,logits_processor:Bt=null,...Ot}){if((!Ke||!st)&&({inputs_embeds:Ke,per_layer_inputs:st}=await L(this.sessions.embed_tokens,{input_ids:N}),N.dims[1]!==1)){if(ae){const{image_features:It}=await L(this.sessions.vision_encoder,{pixel_values:ae});({inputs_embeds:Ke,attention_mask:B}=this._merge_input_ids_with_image_features({image_features:It,inputs_embeds:Ke,input_ids:N,attention_mask:B}))}if(Se){const{audio_features:It}=await L(this.sessions.audio_encoder,{input_features:Se,input_features_mask:Te});({inputs_embeds:Ke,attention_mask:B}=this._merge_input_ids_with_audio_features({audio_features:It,inputs_embeds:Ke,input_ids:N,attention_mask:B}))}}return await ue(this,{inputs_embeds:Ke,per_layer_inputs:st,past_key_values:ct,attention_mask:B,position_ids:Ie,generation_config:Pt,logits_processor:Bt},!0)}_merge_input_ids_with_image_features(N){const B=N.image_features.dims.at(-1),ae=N.image_features.view(-1,B);return k({image_token_id:this.config.image_token_id,...N,image_features:ae})}_merge_input_ids_with_audio_features(N){const B=N.audio_features.dims.at(-1),ae=N.audio_features.view(-1,B);return j({audio_token_id:this.config.audio_token_id,...N,audio_features:ae})}}class Hh extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"])}}class du extends Hh{async encode_image({pixel_values:N,pixel_attention_mask:B}){return(await L(this.sessions.vision_encoder,{pixel_values:N,pixel_attention_mask:B})).image_features}_merge_input_ids_with_image_features(N){const B=N.image_features.dims.at(-1),ae=N.image_features.view(-1,B);return k({image_token_id:this.config.image_token_id,...N,image_features:ae})}}class ha extends du{}class pa extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"])}}class hu extends pa{async forward({input_ids:N=null,attention_mask:B=null,pixel_values:ae=null,image_sizes:Se=null,position_ids:Te=null,inputs_embeds:Ie=null,past_key_values:Ke=null,generation_config:st=null,logits_processor:ct=null,...Pt}){if(!Ie){let Ot;if(ae&&N.dims[1]!==1){if(!Se)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:Ot}=await L(this.sessions.vision_encoder,{pixel_values:ae,image_sizes:Se}))}else{const os=this.config.normalized_config.hidden_size;Ot=new h.Tensor("float32",[],[0,os])}({inputs_embeds:Ie}=await L(this.sessions.prepare_inputs_embeds,{input_ids:N,image_features:Ot}))}return await ue(this,{inputs_embeds:Ie,past_key_values:Ke,attention_mask:B,position_ids:Te,generation_config:st,logits_processor:ct},!1)}}class No extends K{}class qh extends No{}class $c extends No{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"text_model"})}}class pu extends No{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"text_model"})}}class Kh extends No{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"vision_model"})}}class zc extends No{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"vision_model"})}}class fu extends K{}class Vc extends fu{}class Uc extends fu{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"text_model"})}}class Gc extends No{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"vision_model"})}}class Xh extends K{}class jc extends Xh{}class sl extends K{}class il extends sl{async forward(N){const B=!N.input_ids,ae=!N.pixel_values;if(B&&ae)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(B&&(N.input_ids=(0,h.ones)([N.pixel_values.dims[0],1])),ae){const{image_size:ct}=this.config.vision_config;N.pixel_values=(0,h.full)([0,3,ct,ct],0)}const{text_embeddings:Se,image_embeddings:Te,l2norm_text_embeddings:Ie,l2norm_image_embeddings:Ke}=await super.forward(N),st={};return B||(st.text_embeddings=Se,st.l2norm_text_embeddings=Ie),ae||(st.image_embeddings=Te,st.l2norm_image_embeddings=Ke),st}}class At extends sl{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"text_model"})}}class Yh extends sl{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"vision_model"})}}class mu extends K{}class Wc extends mu{}class rl extends mu{}class Tr extends K{}class nl extends Tr{}class gu extends Tr{}class _u extends K{}class Hc extends _u{}class qc extends _u{}class ol extends K{}class Kc extends ol{}class Xc extends ol{}class yu extends K{}class al extends yu{}class xu extends yu{}class ll extends K{}class Yc extends ll{}class Qc extends ll{}class bu extends K{}class Zc extends bu{}class Jc extends bu{}class wu extends K{}class y extends wu{}class C extends wu{}class D extends K{}class $ extends D{}class H extends D{}class me extends K{}class Re extends me{}class qe extends me{}class at extends K{}class mt extends at{}class zt extends at{}class is extends K{}class vs extends is{}class Ti extends is{}class io extends K{}class Qh extends io{}class qw extends io{}class Km extends K{}class Kw extends Km{}class Xw extends Km{}class Xm extends K{}class Yw extends Xm{}class Qw extends Xm{}class Ym extends K{}class Zw extends Ym{}class Jw extends Ym{}class Qm extends K{}class eM extends Qm{}class tM extends Qm{}class Zm extends K{}class sM extends Zm{}class iM extends Zm{}class Jm extends K{}class rM extends Jm{}class nM extends Jm{}class eg extends K{}class oM extends eg{}class aM extends eg{}class tg extends K{}class lM extends tg{}class uM extends tg{}class sg extends K{}class cM extends sg{}class dM extends sg{}class ig extends K{}class hM extends ig{}class pM extends ig{}class fM extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"])}}class mM extends fM{get_rope_index(N,B,ae,Se){const{vision_config:Te,image_token_id:Ie,video_token_id:Ke,vision_start_token_id:st}=this.config,ct=Te.spatial_merge_size??2,Pt=[];if(B||ae){let Bt=N.tolist();Se||(Se=(0,h.ones_like)(N));const Ot=Se.tolist(),os=Array.from({length:3},Ss=>Array.from({length:N.dims[0]},Ws=>Array.from({length:N.dims[1]},ri=>1))),It=B?B.tolist():[],Yt=ae?ae.tolist():[];let vt=0,Jt=0;for(let Ss=0;Ss<Bt.length;++Ss){const Ws=Bt[Ss].filter((Hs,Ei)=>Ot[Ss][Ei]==1),Zs=Ws.reduce((Hs,Ei,ma)=>(Ei==st&&Hs.push(ma),Hs),[]).map(Hs=>Ws[Hs+1]),gi=Zs.filter(Hs=>Hs==Ie).length,$i=Zs.filter(Hs=>Hs==Ke).length;let Xt=[],Si=0,Or=gi,cl=$i;for(let Hs=0;Hs<Zs.length;++Hs){const Ei=Ws.findIndex((pl,Pn)=>Pn>Si&&pl==Ie),ma=Ws.findIndex((pl,Pn)=>Pn>Si&&pl==Ke),hl=Or>0&&Ei!==-1?Ei:Ws.length+1,vu=cl>0&&ma!==-1?ma:Ws.length+1;let gp,s_,i_,r_;hl<vu?([s_,i_,r_]=It[vt],++vt,--Or,gp=hl):([s_,i_,r_]=Yt[Jt],++Jt,--cl,gp=vu);const[c3,n_,_p]=[Number(s_),Math.floor(Number(i_)/ct),Math.floor(Number(r_)/ct)],o_=gp-Si,YS=Xt.length>0?(0,f.max)(Xt.at(-1))[0]+1:0;Xt.push(Array.from({length:3*o_},(pl,Pn)=>YS+Pn%o_));const a_=o_+YS,yp=c3*n_*_p,d3=Array.from({length:yp},(pl,Pn)=>a_+Math.floor(Pn/(n_*_p))),h3=Array.from({length:yp},(pl,Pn)=>a_+Math.floor(Pn/_p)%n_),p3=Array.from({length:yp},(pl,Pn)=>a_+Pn%_p);Xt.push([d3,h3,p3].flat()),Si=gp+yp}if(Si<Ws.length){const Hs=Xt.length>0?(0,f.max)(Xt.at(-1))[0]+1:0,Ei=Ws.length-Si;Xt.push(Array.from({length:3*Ei},(ma,hl)=>Hs+hl%Ei))}const pr=Xt.reduce((Hs,Ei)=>Hs+Ei.length,0),on=new Array(pr);let pp=0;for(let Hs=0;Hs<3;++Hs)for(let Ei=0;Ei<Xt.length;++Ei){const ma=Xt[Ei],hl=ma.length/3;for(let vu=Hs*hl;vu<(Hs+1)*hl;++vu)on[pp++]=ma[vu]}let dl=0;const fp=Ot[Ss];for(let Hs=0;Hs<fp.length;++Hs)if(fp[Hs]==1){for(let Ei=0;Ei<3;++Ei)os[Ei][Ss][Hs]=on[Ei*pr/3+dl];++dl}const mp=(0,f.max)(on)[0];Pt.push(mp+1-Bt[Ss].length)}return[new h.Tensor("int64",os.flat(1/0),[3,N.dims[0],N.dims[1]]),new h.Tensor("int64",Pt,[Pt.length,1])]}else if(Se){const{data:Bt,dims:Ot}=Pe(Se),os=BigInt64Array.from({length:3*Bt.length},(Yt,vt)=>Bt[vt%Bt.length]),It=Array.from({length:Ot[0]},(Yt,vt)=>(0,f.max)(Bt.subarray(Ot[1]*vt,Ot[1]*(vt+1)))[0]+1n+BigInt(Ot[1]));return[new h.Tensor("int64",os,[3,...Ot]),new h.Tensor("int64",It,[It.length,1])]}else{const[Bt,Ot]=N.dims,os=BigInt64Array.from({length:3*Bt*Ot},(It,Yt)=>BigInt(Math.floor(Yt%Ot/Bt)));return[new h.Tensor("int64",os,[3,...N.dims]),(0,h.zeros)([Bt,1])]}}async encode_image({pixel_values:N,image_grid_thw:B}){return(await L(this.sessions.vision_encoder,{pixel_values:N,grid_thw:B})).image_features}_merge_input_ids_with_image_features(N){return k({image_token_id:this.config.image_token_id,...N})}prepare_inputs_for_generation(N,B,ae){if(B.attention_mask&&!B.position_ids)if(!B.past_key_values)[B.position_ids,B.rope_deltas]=this.get_rope_index(B.input_ids,B.image_grid_thw,B.video_grid_thw,B.attention_mask);else{B.pixel_values=null;const Se=BigInt(Object.values(B.past_key_values)[0].dims.at(-2)),Te=B.rope_deltas.map(Ie=>Se+Ie);B.position_ids=(0,h.stack)([Te,Te,Te],0)}return B}}class rg extends K{}class gM extends rg{}class _M extends rg{}class ng extends K{}class yM extends ng{}class xM extends ng{}class og extends K{}class bM extends og{}class wM extends og{}class ag extends K{}class MM extends ag{}class TM extends ag{}class lg extends K{}class vM extends lg{}class SM extends lg{}class ug extends K{}class EM extends ug{}class AM extends ug{async _call(N){return new Vt(await super._call(N))}}class cg extends K{}class CM extends cg{}class PM extends cg{async _call(N){return new Vt(await super._call(N))}}class NM extends K{}class FM extends NM{}class dg extends K{}class RM extends dg{}class IM extends dg{async _call(N){return new Vt(await super._call(N))}}class DM extends K{}class kM extends DM{}class hg extends K{}class LM extends hg{}class BM extends hg{async _call(N){return new Vt(await super._call(N))}}class OM extends K{}class $M extends OM{}class pg extends K{}class zM extends pg{}class VM extends pg{async _call(N){return new Vt(await super._call(N))}}class UM extends K{}class GM extends UM{async _call(N){return new KS(await super._call(N))}}class fg extends K{}class jM extends fg{}class WM extends fg{async _call(N){return new Vt(await super._call(N))}}class mg extends K{}class HM extends mg{}class qM extends mg{async _call(N){return new Vt(await super._call(N))}}class gg extends K{}class KM extends gg{}class XM extends gg{}class _g extends K{}class YM extends _g{}class QM extends _g{}class yg extends K{}class ZM extends yg{}class JM extends yg{async _call(N){return new Vt(await super._call(N))}}class Zh extends K{}class eT extends Zh{}class tT extends Zh{async _call(N){return new bg(await super._call(N))}}class xg extends Zh{async _call(N){return new sT(await super._call(N))}}class bg extends Ce{constructor({logits:N,pred_boxes:B}){super(),this.logits=N,this.pred_boxes=B}}class sT extends Ce{constructor({logits:N,pred_boxes:B,pred_masks:ae}){super(),this.logits=N,this.pred_boxes=B,this.pred_masks=ae}}class wg extends K{}class iT extends wg{}class rT extends wg{async _call(N){return new ed(await super._call(N))}}class ed extends Ce{constructor({logits:N,pred_boxes:B}){super(),this.logits=N,this.pred_boxes=B}}class Mg extends K{}class nT extends Mg{}class oT extends Mg{async _call(N){return new aT(await super._call(N))}}class aT extends ed{}class Tg extends K{}class lT extends Tg{}class uT extends Tg{async _call(N){return new cT(await super._call(N))}}class cT extends ed{}class vg extends K{}class dT extends vg{}class hT extends vg{async _call(N){return new ed(await super._call(N))}}class Sg extends K{}class pT extends Sg{}class fT extends Sg{async _call(N){return new mT(await super._call(N))}}class mT extends bg{}class Eg extends K{}class gT extends Eg{}class _T extends Eg{async _call(N){return new Vt(await super._call(N))}}class Ag extends K{}class yT extends Ag{}class xT extends Ag{async _call(N){return new Vt(await super._call(N))}}class Cg extends K{}class bT extends Cg{}class wT extends Cg{async _call(N){return new Vt(await super._call(N))}}class Jh extends K{}class MT extends Jh{}class TT extends Jh{async _call(N){return new Vt(await super._call(N))}}class vT extends Jh{}class Pg extends K{}class ST extends Pg{}class ET extends Pg{}class Ng extends K{}class AT extends Ng{}class CT extends Ng{}class PT extends K{}class NT extends PT{}class ep extends K{}class FT extends ep{}class RT extends ep{}class IT extends ep{}class DT extends K{}class kT extends DT{}class LT extends K{}class BT extends LT{}class OT extends K{}class $T extends OT{}class Fg extends K{}class zT extends Fg{}class VT extends Fg{}class Rg extends K{}class UT extends Rg{}class GT extends Rg{}class jT extends K{}class WT extends jT{}class Ig extends K{}class HT extends Ig{}class qT extends Ig{async _call(N){return new Vt(await super._call(N))}}class Dg extends K{}class KT extends Dg{}class XT extends Dg{async _call(N){return new Vt(await super._call(N))}}class kg extends K{}class YT extends kg{}class QT extends kg{async _call(N){return new Vt(await super._call(N))}}class Lg extends K{}class ZT extends Lg{}class JT extends Lg{async _call(N){return new Vt(await super._call(N))}}class ev extends K{}class tv extends ev{}class Bg extends K{}class sv extends Bg{}class iv extends Bg{async _call(N){return new rv(await super._call(N))}}class rv extends Ce{constructor({logits:N,pred_boxes:B}){super(),this.logits=N,this.pred_boxes=B}}class nv extends K{}class ov extends nv{async get_image_embeddings({pixel_values:N}){return await se(this,{pixel_values:N})}async forward(N){if((!N.image_embeddings||!N.image_positional_embeddings)&&(N={...N,...await this.get_image_embeddings(N)}),!N.input_labels&&N.input_points){const ae=N.input_points.dims.slice(0,-1),Se=ae.reduce((Te,Ie)=>Te*Ie,1);N.input_labels=new h.Tensor("int64",new BigInt64Array(Se).fill(1n),ae)}const B={image_embeddings:N.image_embeddings,image_positional_embeddings:N.image_positional_embeddings};return N.input_points&&(B.input_points=N.input_points),N.input_labels&&(B.input_labels=N.input_labels),N.input_boxes&&(B.input_boxes=N.input_boxes),await L(this.sessions.prompt_encoder_mask_decoder,B)}async _call(N){return new av(await super._call(N))}}class av extends Ce{constructor({iou_scores:N,pred_masks:B}){super(),this.iou_scores=N,this.pred_masks=B}}class Og extends K{}class lv extends Og{}class uv extends Og{}class $g extends K{}class cv extends $g{}class dv extends $g{}class fa extends K{}class hv extends fa{}class pv extends fa{async _call(N){return new ul(await super._call(N))}}class fv extends fa{async _call(N){return new Vt(await super._call(N))}}class mv extends fa{async _call(N){return new vi(await super._call(N))}}class zg extends K{}class gv extends zg{}class _v extends zg{async _call(N){return new vi(await super._call(N))}}class yv extends K{}class xv extends yv{}class tp extends K{}class bv extends tp{}class wv extends tp{async _call(N){return new ul(await super._call(N))}}class Mv extends tp{async _call(N){return new Vt(await super._call(N))}}class td extends K{}class Tv extends td{}class vv extends td{async _call(N){return new ul(await super._call(N))}}class Sv extends td{async _call(N){return new Vt(await super._call(N))}}class Ev extends td{async _call(N){return new vi(await super._call(N))}}class sp extends K{}class Av extends sp{}class Cv extends sp{async _call(N){return new ul(await super._call(N))}}class Pv extends sp{async _call(N){return new Vt(await super._call(N))}}class X$ extends K{}class Nv extends fa{}class Fv extends fa{async _call(N){return new ul(await super._call(N))}}class Rv extends fa{async _call(N){return new Vt(await super._call(N))}}class Mu extends K{}class Iv extends Mu{}class Dv extends Mu{async _call(N){return new ul(await super._call(N))}}class kv extends Mu{async _call(N){return new Vt(await super._call(N))}}class Lv extends Mu{async _call(N){return new qS(await super._call(N))}}class Bv extends Mu{async _call(N){return new vi(await super._call(N))}}class Ov extends K{}class $v extends Ov{}class ip extends K{}class Y$ extends ip{}class zv extends ip{}class Vv extends ip{async generate_speech(N,B,{threshold:ae=.5,minlenratio:Se=0,maxlenratio:Te=20,vocoder:Ie=null}={}){const Ke={input_ids:N},{encoder_outputs:st,encoder_attention_mask:ct}=await se(this,Ke),Pt=st.dims[1]/this.config.reduction_factor,Bt=Math.floor(Pt*Te),Ot=Math.floor(Pt*Se),os=this.config.num_mel_bins;let It=[],Yt=null,vt=null,Jt=0;for(;;){++Jt;const ri=J(!!vt);let Zs;vt?Zs=vt.output_sequence_out:Zs=new h.Tensor("float32",new Float32Array(os),[1,1,os]);let gi={use_cache_branch:ri,output_sequence:Zs,encoder_attention_mask:ct,speaker_embeddings:B,encoder_hidden_states:st};this.addPastKeyValues(gi,Yt),vt=await L(this.sessions.decoder_model_merged,gi),Yt=this.getPastKeyValues(vt,Yt);const{prob:$i,spectrum:Xt}=vt;if(It.push(Xt),Jt>=Ot&&(Array.from($i.data).filter(Si=>Si>=ae).length>0||Jt>=Bt))break}const Ss=(0,h.cat)(It),{waveform:Ws}=await L(Ie.sessions.model,{spectrogram:Ss});return{spectrogram:Ss,waveform:Ws}}}class Uv extends K{constructor(){super(...arguments);Z(this,"main_input_name","spectrogram")}}class Gv extends K{}class jv extends Gv{}class Vg extends K{}class Wv extends Vg{}class Hv extends Vg{}class Ug extends K{}class qv extends Ug{}class Kv extends Ug{}class Gg extends K{}class Xv extends Gg{}class Yv extends Gg{}class rp extends K{}class Qv extends rp{}class Zv extends rp{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"text_model"})}}class Jv extends rp{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"audio_model"})}}class e1 extends K{}class jg extends e1{async _call(N){return new XS(await super._call(N))}}class np extends K{}class Q$ extends np{}class t1 extends np{}class s1 extends np{}class Wg extends K{}class i1 extends Wg{}class r1 extends Wg{}class Hg extends K{}class n1 extends Hg{}class o1 extends Hg{async _call(N){return new Vt(await super._call(N))}}class qg extends K{}class Z$ extends qg{}class J$ extends qg{}class Kg extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}_apply_and_filter_by_delay_pattern_mask(B){const[ae,Se]=B.dims,Te=this.config.decoder.num_codebooks,Ie=Se-Te;let Ke=0;for(let Pt=0;Pt<B.size;++Pt){if(B.data[Pt]===this.config.decoder.pad_token_id)continue;const Bt=Pt%Se,Ot=Math.floor(Pt/Se)%Te,os=Bt-Ot;os>0&&os<=Ie&&(B.data[Ke++]=B.data[Pt])}const st=Math.floor(ae/Te),ct=Ke/(st*Te);return new h.Tensor(B.type,B.data.slice(0,Ke),[st,Te,ct])}prepare_inputs_for_generation(B,ae,Se){let Te=structuredClone(B);for(let Ke=0;Ke<Te.length;++Ke)for(let st=0;st<Te[Ke].length;++st)Ke%this.config.decoder.num_codebooks>=st&&(Te[Ke][st]=BigInt(this.config.decoder.pad_token_id));return Se.guidance_scale!==null&&Se.guidance_scale>1&&(Te=Te.concat(Te)),super.prepare_inputs_for_generation(Te,ae,Se)}async generate(B){const ae=await super.generate(B),Se=this._apply_and_filter_by_delay_pattern_mask(ae).unsqueeze_(0),{audio_values:Te}=await L(this.sessions.encodec_decode,{audio_codes:Se});return Te}}class op extends K{}class a1 extends op{}class l1 extends op{async _call(N){return new Vt(await super._call(N))}}class u1 extends op{}class ap extends K{}class c1 extends ap{}class d1 extends ap{async _call(N){return new Vt(await super._call(N))}}class h1 extends ap{}class lp extends K{}class p1 extends lp{}class f1 extends lp{async _call(N){return new Vt(await super._call(N))}}class m1 extends lp{}class up extends K{}class g1 extends up{}class _1 extends up{async _call(N){return new Vt(await super._call(N))}}class y1 extends up{}class x1 extends K{}class b1 extends x1{}class w1 extends K{}class M1 extends w1{constructor(...B){super(...B);Z(this,"forward_params",["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"]);this._generation_mode="text"}async forward(B){const ae=this._generation_mode??"text";let Se;if(ae==="text"||!B.past_key_values){const ct=this.sessions.prepare_inputs_embeds,Pt=(0,a.pick)(B,ct.inputNames);Se=await L(ct,Pt)}else{const ct=this.sessions.gen_img_embeds,Pt=(0,a.pick)({image_ids:B.input_ids},ct.inputNames);Se=await L(ct,Pt)}const Te={...B,...Se},Ie=await ue(this,Te),Ke=this.sessions[ae==="text"?"lm_head":"gen_head"];if(!Ke)throw new Error(`Unable to find "${Ke}" generation head`);const st=await L(Ke,(0,a.pick)(Ie,Ke.inputNames));return{...Se,...Ie,...st}}async generate(B){return this._generation_mode="text",super.generate(B)}async generate_images(B){this._generation_mode="image";const ae=(B.inputs??B[this.main_input_name]).dims[1],Te=(await super.generate(B)).slice(null,[ae,null]),Ie=this.sessions.image_decode,{decoded_image:Ke}=await L(Ie,{generated_tokens:Te}),st=Ke.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),ct=[];for(const Pt of st){const Bt=p.RawImage.fromTensor(Pt);ct.push(Bt)}return ct}}class T1 extends Ce{constructor({char_logits:N,bpe_logits:B,wp_logits:ae}){super(),this.char_logits=N,this.bpe_logits=B,this.wp_logits=ae}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class v1 extends K{}class S1 extends v1{async _call(N){return new T1(await super._call(N))}}class Xg extends K{}class E1 extends Xg{}class A1 extends Xg{}class Yg extends K{}class C1 extends Yg{}class P1 extends Yg{}class N1 extends K{constructor(){super(...arguments);Z(this,"forward_params",["input_ids","attention_mask","position_ids","audio_values","past_key_values"])}}class F1 extends N1{_merge_input_ids_with_audio_features(N){const B=N.audio_features.dims.at(-1),ae=N.audio_features.view(-1,B);return j({audio_token_id:this.config.ignore_index,...N,audio_features:ae})}}class cp extends K{constructor(){super(...arguments);Z(this,"main_input_name","input_values");Z(this,"forward_params",["input_values"])}}class R1 extends Ce{constructor({audio_codes:N}){super(),this.audio_codes=N}}class I1 extends Ce{constructor({audio_values:N}){super(),this.audio_values=N}}class D1 extends cp{async encode(N){return new R1(await L(this.sessions.encoder_model,N))}async decode(N){return new I1(await L(this.sessions.decoder_model,N))}}class k1 extends cp{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"encoder_model"})}}class L1 extends cp{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"decoder_model"})}}class dp extends K{constructor(){super(...arguments);Z(this,"main_input_name","input_values");Z(this,"forward_params",["input_values"])}}class B1 extends Ce{constructor({audio_codes:N}){super(),this.audio_codes=N}}class O1 extends Ce{constructor({audio_values:N}){super(),this.audio_values=N}}class $1 extends dp{async encode(N){return new B1(await L(this.sessions.encoder_model,N))}async decode(N){return new O1(await L(this.sessions.decoder_model,N))}}class z1 extends dp{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"encoder_model"})}}class V1 extends dp{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"decoder_model"})}}class hp extends K{constructor(){super(...arguments);Z(this,"main_input_name","input_values");Z(this,"forward_params",["input_values"])}}class U1 extends hp{async encode(N){return await L(this.sessions.encoder_model,N)}async decode(N){return await L(this.sessions.decoder_model,N)}}class G1 extends hp{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"encoder_model"})}}class j1 extends hp{static async from_pretrained(N,B={}){return super.from_pretrained(N,{...B,model_file_name:B.model_file_name??"decoder_model"})}}class fs{static async from_pretrained(N,{progress_callback:B=null,config:ae=null,cache_dir:Se=null,local_files_only:Te=!1,revision:Ie="main",model_file_name:Ke=null,subfolder:st="onnx",device:ct=null,dtype:Pt=null,use_external_data_format:Bt=null,session_options:Ot={}}={}){const os={progress_callback:B,config:ae,cache_dir:Se,local_files_only:Te,revision:Ie,model_file_name:Ke,subfolder:st,device:ct,dtype:Pt,use_external_data_format:Bt,session_options:Ot};if(os.config=await s.AutoConfig.from_pretrained(N,os),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const It=os.config.model_type;for(const Yt of this.MODEL_CLASS_MAPPINGS){let vt=Yt.get(It);if(!vt){for(const Jt of Yt.values())if(Jt[0]===It){vt=Jt;break}if(!vt)continue}return await vt[1].from_pretrained(N,os)}if(this.BASE_IF_FAIL)return gS.has(It)||console.warn(`Unknown model class "${It}", attempting to construct from base class.`),await K.from_pretrained(N,os);throw Error(`Unsupported model type: ${It}`)}}Z(fs,"MODEL_CLASS_MAPPINGS",null),Z(fs,"BASE_IF_FAIL",!1);const e3=new Map([["bert",["BertModel",Be]],["neobert",["NeoBertModel",Ue]],["modernbert",["ModernBertModel",tt]],["nomic_bert",["NomicBertModel",bi]],["roformer",["RoFormerModel",$t]],["electra",["ElectraModel",Mt]],["esm",["EsmModel",ai]],["convbert",["ConvBertModel",ve]],["camembert",["CamembertModel",Qi]],["deberta",["DebertaModel",Zn]],["deberta-v2",["DebertaV2Model",to]],["mpnet",["MPNetModel",ua]],["albert",["AlbertModel",Fe]],["distilbert",["DistilBertModel",wt]],["roberta",["RobertaModel",tl]],["xlm",["XLMModel",Ph]],["xlm-roberta",["XLMRobertaModel",Dh]],["clap",["ClapModel",Qv]],["clip",["CLIPModel",qh]],["clipseg",["CLIPSegModel",Wc]],["chinese_clip",["ChineseCLIPModel",jc]],["siglip",["SiglipModel",Vc]],["jina_clip",["JinaCLIPModel",il]],["mobilebert",["MobileBertModel",qa]],["squeezebert",["SqueezeBertModel",R]],["wav2vec2",["Wav2Vec2Model",hv]],["wav2vec2-bert",["Wav2Vec2BertModel",Av]],["unispeech",["UniSpeechModel",bv]],["unispeech-sat",["UniSpeechSatModel",Tv]],["hubert",["HubertModel",Nv]],["wavlm",["WavLMModel",Iv]],["audio-spectrogram-transformer",["ASTModel",Nc]],["vits",["VitsModel",jg]],["pyannote",["PyAnnoteModel",gv]],["wespeaker-resnet",["WeSpeakerResNetModel",xv]],["detr",["DetrModel",eT]],["rt_detr",["RTDetrModel",iT]],["rt_detr_v2",["RTDetrV2Model",nT]],["rf_detr",["RFDetrModel",lT]],["d_fine",["DFineModel",dT]],["table-transformer",["TableTransformerModel",pT]],["vit",["ViTModel",EM]],["ijepa",["IJepaModel",CM]],["pvt",["PvtModel",RM]],["vit_msn",["ViTMSNModel",LM]],["vit_mae",["ViTMAEModel",kM]],["groupvit",["GroupViTModel",$M]],["fastvit",["FastViTModel",zM]],["mobilevit",["MobileViTModel",jM]],["mobilevitv2",["MobileViTV2Model",HM]],["owlvit",["OwlViTModel",KM]],["owlv2",["Owlv2Model",YM]],["beit",["BeitModel",ZM]],["deit",["DeiTModel",gT]],["hiera",["HieraModel",yT]],["convnext",["ConvNextModel",HT]],["convnextv2",["ConvNextV2Model",KT]],["dinov2",["Dinov2Model",YT]],["dinov2_with_registers",["Dinov2WithRegistersModel",ZT]],["resnet",["ResNetModel",bT]],["swin",["SwinModel",MT]],["swin2sr",["Swin2SRModel",ST]],["donut-swin",["DonutSwinModel",WT]],["yolos",["YolosModel",sv]],["dpt",["DPTModel",AT]],["glpn",["GLPNModel",UT]],["hifigan",["SpeechT5HifiGan",Uv]],["efficientnet",["EfficientNetModel",n1]],["decision_transformer",["DecisionTransformerModel",b1]],["patchtst",["PatchTSTForPrediction",E1]],["patchtsmixer",["PatchTSMixerForPrediction",C1]],["mobilenet_v1",["MobileNetV1Model",a1]],["mobilenet_v2",["MobileNetV2Model",c1]],["mobilenet_v3",["MobileNetV3Model",p1]],["mobilenet_v4",["MobileNetV4Model",g1]],["maskformer",["MaskFormerModel",zT]],["mgp-str",["MgpstrForSceneTextRecognition",S1]],["style_text_to_speech_2",["StyleTextToSpeech2Model",$v]]]),t3=new Map([["t5",["T5Model",Lt]],["longt5",["LongT5Model",zs]],["mt5",["MT5Model",Zi]],["bart",["BartModel",Gs]],["mbart",["MBartModel",Ji]],["marian",["MarianModel",lv]],["whisper",["WhisperModel",$h]],["m2m_100",["M2M100Model",cv]],["blenderbot",["BlenderbotModel",Mi]],["blenderbot-small",["BlenderbotSmallModel",ui]]]),s3=new Map([["mimi",["MimiModel",D1]],["dac",["DacModel",$1]],["snac",["SnacModel",U1]]]),i3=new Map([["bloom",["BloomModel",bM]],["jais",["JAISModel",Hc]],["gpt2",["GPT2Model",nl]],["gptj",["GPTJModel",Yc]],["gpt_bigcode",["GPTBigCodeModel",Zc]],["gpt_neo",["GPTNeoModel",Kc]],["gpt_neox",["GPTNeoXModel",al]],["codegen",["CodeGenModel",y]],["llama",["LlamaModel",$]],["exaone",["ExaoneModel",vs]],["olmo",["OlmoModel",Kw]],["olmo2",["Olmo2Model",Yw]],["mobilellm",["MobileLLMModel",Qh]],["granite",["GraniteModel",Zw]],["cohere",["CohereModel",eM]],["gemma",["GemmaModel",sM]],["gemma2",["Gemma2Model",rM]],["gemma3_text",["Gemma3Model",oM]],["helium",["HeliumModel",Re]],["glm",["GlmModel",mt]],["openelm",["OpenELMModel",lM]],["qwen2",["Qwen2Model",cM]],["qwen3",["Qwen3Model",hM]],["phi",["PhiModel",gM]],["phi3",["Phi3Model",yM]],["mpt",["MptModel",MM]],["opt",["OPTModel",vM]],["mistral",["MistralModel",Wv]],["starcoder2",["Starcoder2Model",qv]],["falcon",["FalconModel",Xv]],["stablelm",["StableLmModel",i1]]]),Qg=new Map([["speecht5",["SpeechT5ForSpeechToText",zv]],["whisper",["WhisperForConditionalGeneration",lu]],["lite-whisper",["LiteWhisperForConditionalGeneration",Ic]],["moonshine",["MoonshineForConditionalGeneration",Dc]]]),W1=new Map([["speecht5",["SpeechT5ForTextToSpeech",Vv]]]),H1=new Map([["vits",["VitsModel",jg]],["musicgen",["MusicgenForConditionalGeneration",Kg]]]),q1=new Map([["bert",["BertForSequenceClassification",We]],["neobert",["NeoBertForSequenceClassification",yt]],["modernbert",["ModernBertForSequenceClassification",ss]],["roformer",["RoFormerForSequenceClassification",O]],["electra",["ElectraForSequenceClassification",ys]],["esm",["EsmForSequenceClassification",sn]],["convbert",["ConvBertForSequenceClassification",Ne]],["camembert",["CamembertForSequenceClassification",vn]],["deberta",["DebertaForSequenceClassification",Sn]],["deberta-v2",["DebertaV2ForSequenceClassification",En]],["mpnet",["MPNetForSequenceClassification",Za]],["albert",["AlbertForSequenceClassification",Qe]],["distilbert",["DistilBertForSequenceClassification",xs]],["roberta",["RobertaForSequenceClassification",Ah]],["xlm",["XLMForSequenceClassification",Fh]],["xlm-roberta",["XLMRobertaForSequenceClassification",Lh]],["bart",["BartForSequenceClassification",Ds]],["mbart",["MBartForSequenceClassification",Br]],["mobilebert",["MobileBertForSequenceClassification",Xa]],["squeezebert",["SqueezeBertForSequenceClassification",te]]]),K1=new Map([["bert",["BertForTokenClassification",Je]],["neobert",["NeoBertForTokenClassification",Nt]],["modernbert",["ModernBertForTokenClassification",Zt]],["roformer",["RoFormerForTokenClassification",le]],["electra",["ElectraForTokenClassification",Is]],["esm",["EsmForTokenClassification",Ha]],["convbert",["ConvBertForTokenClassification",Ut]],["camembert",["CamembertForTokenClassification",Jr]],["deberta",["DebertaForTokenClassification",Jn]],["deberta-v2",["DebertaV2ForTokenClassification",ir]],["mpnet",["MPNetForTokenClassification",Ja]],["distilbert",["DistilBertForTokenClassification",en]],["roberta",["RobertaForTokenClassification",Ch]],["xlm",["XLMForTokenClassification",Rh]],["xlm-roberta",["XLMRobertaForTokenClassification",Bh]]]),Zg=new Map([["t5",["T5ForConditionalGeneration",hs]],["longt5",["LongT5ForConditionalGeneration",Ts]],["mt5",["MT5ForConditionalGeneration",Bi]],["bart",["BartForConditionalGeneration",Cn]],["mbart",["MBartForConditionalGeneration",rn]],["marian",["MarianMTModel",uv]],["m2m_100",["M2M100ForConditionalGeneration",dv]],["blenderbot",["BlenderbotForConditionalGeneration",js]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",Wi]]]),Jg=new Map([["bloom",["BloomForCausalLM",wM]],["gpt2",["GPT2LMHeadModel",gu]],["jais",["JAISLMHeadModel",qc]],["gptj",["GPTJForCausalLM",Qc]],["gpt_bigcode",["GPTBigCodeForCausalLM",Jc]],["gpt_neo",["GPTNeoForCausalLM",Xc]],["gpt_neox",["GPTNeoXForCausalLM",xu]],["codegen",["CodeGenForCausalLM",C]],["llama",["LlamaForCausalLM",H]],["exaone",["ExaoneForCausalLM",Ti]],["olmo",["OlmoForCausalLM",Xw]],["olmo2",["Olmo2ForCausalLM",Qw]],["mobilellm",["MobileLLMForCausalLM",qw]],["granite",["GraniteForCausalLM",Jw]],["cohere",["CohereForCausalLM",tM]],["gemma",["GemmaForCausalLM",iM]],["gemma2",["Gemma2ForCausalLM",nM]],["gemma3_text",["Gemma3ForCausalLM",aM]],["helium",["HeliumForCausalLM",qe]],["glm",["GlmForCausalLM",zt]],["openelm",["OpenELMForCausalLM",uM]],["qwen2",["Qwen2ForCausalLM",dM]],["qwen3",["Qwen3ForCausalLM",pM]],["phi",["PhiForCausalLM",_M]],["phi3",["Phi3ForCausalLM",xM]],["mpt",["MptForCausalLM",TM]],["opt",["OPTForCausalLM",SM]],["mbart",["MBartForCausalLM",ji]],["mistral",["MistralForCausalLM",Hv]],["starcoder2",["Starcoder2ForCausalLM",Kv]],["falcon",["FalconForCausalLM",Yv]],["trocr",["TrOCRForCausalLM",jv]],["stablelm",["StableLmForCausalLM",r1]],["phi3_v",["Phi3VForCausalLM",hu]]]),r3=new Map([["multi_modality",["MultiModalityCausalLM",M1]]]),X1=new Map([["bert",["BertForMaskedLM",Ve]],["neobert",["NeoBertForMaskedLM",rt]],["modernbert",["ModernBertForMaskedLM",pt]],["roformer",["RoFormerForMaskedLM",Qr]],["electra",["ElectraForMaskedLM",_t]],["esm",["EsmForMaskedLM",fi]],["convbert",["ConvBertForMaskedLM",He]],["camembert",["CamembertForMaskedLM",Zr]],["deberta",["DebertaForMaskedLM",Lr]],["deberta-v2",["DebertaV2ForMaskedLM",ki]],["mpnet",["MPNetForMaskedLM",Qa]],["albert",["AlbertForMaskedLM",nt]],["distilbert",["DistilBertForMaskedLM",Li]],["roberta",["RobertaForMaskedLM",Eh]],["xlm",["XLMWithLMHeadModel",Nh]],["xlm-roberta",["XLMRobertaForMaskedLM",kh]],["mobilebert",["MobileBertForMaskedLM",Ka]],["squeezebert",["SqueezeBertForMaskedLM",W]]]),Y1=new Map([["bert",["BertForQuestionAnswering",it]],["neobert",["NeoBertForQuestionAnswering",bt]],["roformer",["RoFormerForQuestionAnswering",V]],["electra",["ElectraForQuestionAnswering",wi]],["convbert",["ConvBertForQuestionAnswering",ds]],["camembert",["CamembertForQuestionAnswering",Qn]],["deberta",["DebertaForQuestionAnswering",eo]],["deberta-v2",["DebertaV2ForQuestionAnswering",je]],["mpnet",["MPNetForQuestionAnswering",el]],["albert",["AlbertForQuestionAnswering",ut]],["distilbert",["DistilBertForQuestionAnswering",tn]],["roberta",["RobertaForQuestionAnswering",Pc]],["xlm",["XLMForQuestionAnswering",Ih]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Oh]],["mobilebert",["MobileBertForQuestionAnswering",Ya]],["squeezebert",["SqueezeBertForQuestionAnswering",he]]]),e_=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",kc]],["idefics3",["Idefics3ForConditionalGeneration",du]],["smolvlm",["SmolVLMForConditionalGeneration",ha]]]),Q1=new Map([["llava",["LlavaForConditionalGeneration",uu]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",cu]],["moondream1",["Moondream1ForConditionalGeneration",Bc]],["florence2",["Florence2ForConditionalGeneration",Vh]],["qwen2-vl",["Qwen2VLForConditionalGeneration",mM]],["idefics3",["Idefics3ForConditionalGeneration",du]],["smolvlm",["SmolVLMForConditionalGeneration",ha]],["paligemma",["PaliGemmaForConditionalGeneration",Gh]],["llava_qwen2",["LlavaQwen2ForCausalLM",jh]],["gemma3n",["Gemma3nForConditionalGeneration",Oc]]]),Z1=new Map([["ultravox",["UltravoxModel",F1]]]),n3=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",kc]]]),J1=new Map([["vit",["ViTForImageClassification",AM]],["ijepa",["IJepaForImageClassification",PM]],["pvt",["PvtForImageClassification",IM]],["vit_msn",["ViTMSNForImageClassification",BM]],["fastvit",["FastViTForImageClassification",VM]],["mobilevit",["MobileViTForImageClassification",WM]],["mobilevitv2",["MobileViTV2ForImageClassification",qM]],["beit",["BeitForImageClassification",JM]],["deit",["DeiTForImageClassification",_T]],["hiera",["HieraForImageClassification",xT]],["convnext",["ConvNextForImageClassification",qT]],["convnextv2",["ConvNextV2ForImageClassification",XT]],["dinov2",["Dinov2ForImageClassification",QT]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",JT]],["resnet",["ResNetForImageClassification",wT]],["swin",["SwinForImageClassification",TT]],["segformer",["SegformerForImageClassification",t1]],["efficientnet",["EfficientNetForImageClassification",o1]],["mobilenet_v1",["MobileNetV1ForImageClassification",l1]],["mobilenet_v2",["MobileNetV2ForImageClassification",d1]],["mobilenet_v3",["MobileNetV3ForImageClassification",f1]],["mobilenet_v4",["MobileNetV4ForImageClassification",_1]]]),eS=new Map([["detr",["DetrForObjectDetection",tT]],["rt_detr",["RTDetrForObjectDetection",rT]],["rt_detr_v2",["RTDetrV2ForObjectDetection",oT]],["rf_detr",["RFDetrForObjectDetection",uT]],["d_fine",["DFineForObjectDetection",hT]],["table-transformer",["TableTransformerForObjectDetection",fT]],["yolos",["YolosForObjectDetection",iv]]]),tS=new Map([["owlvit",["OwlViTForObjectDetection",XM]],["owlv2",["Owlv2ForObjectDetection",QM]],["grounding-dino",["GroundingDinoForObjectDetection",tv]]]),Tu=new Map([["detr",["DetrForSegmentation",xg]],["clipseg",["CLIPSegForImageSegmentation",rl]]]),sS=new Map([["segformer",["SegformerForSemanticSegmentation",s1]],["sapiens",["SapiensForSemanticSegmentation",FT]],["swin",["SwinForSemanticSegmentation",vT]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",u1]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",h1]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",m1]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",y1]]]),iS=new Map([["detr",["DetrForSegmentation",xg]],["maskformer",["MaskFormerForInstanceSegmentation",VT]]]),rS=new Map([["sam",["SamModel",ov]]]),nS=new Map([["wav2vec2",["Wav2Vec2ForCTC",pv]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Cv]],["unispeech",["UniSpeechForCTC",wv]],["unispeech-sat",["UniSpeechSatForCTC",vv]],["wavlm",["WavLMForCTC",Dv]],["hubert",["HubertForCTC",Fv]]]),oS=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",fv]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Pv]],["unispeech",["UniSpeechForSequenceClassification",Mv]],["unispeech-sat",["UniSpeechSatForSequenceClassification",Sv]],["wavlm",["WavLMForSequenceClassification",kv]],["hubert",["HubertForSequenceClassification",Rv]],["audio-spectrogram-transformer",["ASTForAudioClassification",Fc]]]),aS=new Map([["wavlm",["WavLMForXVector",Lv]]]),lS=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",Ev]],["wavlm",["WavLMForAudioFrameClassification",Bv]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",mv]],["pyannote",["PyAnnoteForAudioFrameClassification",_v]]]),uS=new Map([["vitmatte",["VitMatteForImageMatting",GM]]]),o3=new Map([["patchtst",["PatchTSTForPrediction",A1]],["patchtsmixer",["PatchTSMixerForPrediction",P1]]]),cS=new Map([["swin2sr",["Swin2SRForImageSuperResolution",ET]]]),dS=new Map([["dpt",["DPTForDepthEstimation",CT]],["depth_anything",["DepthAnythingForDepthEstimation",NT]],["glpn",["GLPNForDepthEstimation",GT]],["sapiens",["SapiensForDepthEstimation",RT]],["depth_pro",["DepthProForDepthEstimation",kT]],["metric3d",["Metric3DForDepthEstimation",BT]],["metric3dv2",["Metric3Dv2ForDepthEstimation",$T]]]),hS=new Map([["sapiens",["SapiensForNormalEstimation",IT]]]),pS=new Map([["vitpose",["VitPoseForPoseEstimation",FM]]]),fS=new Map([["clip",["CLIPVisionModelWithProjection",zc]],["siglip",["SiglipVisionModel",Gc]],["jina_clip",["JinaCLIPVisionModel",Yh]]]),mS=[[e3,M.EncoderOnly],[t3,M.EncoderDecoder],[i3,M.DecoderOnly],[s3,M.AutoEncoder],[q1,M.EncoderOnly],[K1,M.EncoderOnly],[Zg,M.Seq2Seq],[Qg,M.Seq2Seq],[Jg,M.DecoderOnly],[r3,M.MultiModality],[X1,M.EncoderOnly],[Y1,M.EncoderOnly],[e_,M.Vision2Seq],[Q1,M.ImageTextToText],[Z1,M.AudioTextToText],[J1,M.EncoderOnly],[Tu,M.EncoderOnly],[iS,M.EncoderOnly],[sS,M.EncoderOnly],[uS,M.EncoderOnly],[o3,M.EncoderOnly],[cS,M.EncoderOnly],[dS,M.EncoderOnly],[hS,M.EncoderOnly],[pS,M.EncoderOnly],[eS,M.EncoderOnly],[tS,M.EncoderOnly],[rS,M.MaskGeneration],[nS,M.EncoderOnly],[oS,M.EncoderOnly],[W1,M.Seq2Seq],[H1,M.EncoderOnly],[aS,M.EncoderOnly],[lS,M.EncoderOnly],[fS,M.EncoderOnly]];for(const[A,N]of mS)for(const[B,ae]of A.values())w.set(B,N),T.set(ae,B),v.set(B,ae);const a3=[["MusicgenForConditionalGeneration",Kg,M.Musicgen],["Phi3VForCausalLM",hu,M.Phi3V],["CLIPTextModelWithProjection",pu,M.EncoderOnly],["SiglipTextModel",Uc,M.EncoderOnly],["JinaCLIPTextModel",At,M.EncoderOnly],["ClapTextModelWithProjection",Zv,M.EncoderOnly],["ClapAudioModelWithProjection",Jv,M.EncoderOnly],["DacEncoderModel",z1,M.EncoderOnly],["DacDecoderModel",V1,M.EncoderOnly],["MimiEncoderModel",k1,M.EncoderOnly],["MimiDecoderModel",L1,M.EncoderOnly],["SnacEncoderModel",G1,M.EncoderOnly],["SnacDecoderModel",j1,M.EncoderOnly],["Gemma3nForConditionalGeneration",Oc,M.ImageAudioTextToText]];for(const[A,N,B]of a3)w.set(A,B),T.set(N,A),v.set(A,N);const gS=new Map([["modnet",Tu],["birefnet",Tu],["isnet",Tu],["ben",Tu]]);for(const[A,N]of gS.entries())N.set(A,["PreTrainedModel",K]),w.set(A,M.EncoderOnly),T.set(K,A),v.set(A,K);class t_ extends fs{}Z(t_,"MODEL_CLASS_MAPPINGS",mS.map(N=>N[0])),Z(t_,"BASE_IF_FAIL",!0);class _S extends fs{}Z(_S,"MODEL_CLASS_MAPPINGS",[q1]);class yS extends fs{}Z(yS,"MODEL_CLASS_MAPPINGS",[K1]);class xS extends fs{}Z(xS,"MODEL_CLASS_MAPPINGS",[Zg]);class bS extends fs{}Z(bS,"MODEL_CLASS_MAPPINGS",[Qg]);class wS extends fs{}Z(wS,"MODEL_CLASS_MAPPINGS",[W1]);class MS extends fs{}Z(MS,"MODEL_CLASS_MAPPINGS",[H1]);class TS extends fs{}Z(TS,"MODEL_CLASS_MAPPINGS",[Jg]);class vS extends fs{}Z(vS,"MODEL_CLASS_MAPPINGS",[X1]);class SS extends fs{}Z(SS,"MODEL_CLASS_MAPPINGS",[Y1]);class ES extends fs{}Z(ES,"MODEL_CLASS_MAPPINGS",[e_]);class AS extends fs{}Z(AS,"MODEL_CLASS_MAPPINGS",[J1]);class CS extends fs{}Z(CS,"MODEL_CLASS_MAPPINGS",[Tu]);class PS extends fs{}Z(PS,"MODEL_CLASS_MAPPINGS",[sS]);class NS extends fs{}Z(NS,"MODEL_CLASS_MAPPINGS",[iS]);class FS extends fs{}Z(FS,"MODEL_CLASS_MAPPINGS",[eS]);class RS extends fs{}Z(RS,"MODEL_CLASS_MAPPINGS",[tS]);class IS extends fs{}Z(IS,"MODEL_CLASS_MAPPINGS",[rS]);class DS extends fs{}Z(DS,"MODEL_CLASS_MAPPINGS",[nS]);class kS extends fs{}Z(kS,"MODEL_CLASS_MAPPINGS",[oS]);class LS extends fs{}Z(LS,"MODEL_CLASS_MAPPINGS",[aS]);class BS extends fs{}Z(BS,"MODEL_CLASS_MAPPINGS",[lS]);class OS extends fs{}Z(OS,"MODEL_CLASS_MAPPINGS",[n3]);class $S extends fs{}Z($S,"MODEL_CLASS_MAPPINGS",[uS]);class zS extends fs{}Z(zS,"MODEL_CLASS_MAPPINGS",[cS]);class VS extends fs{}Z(VS,"MODEL_CLASS_MAPPINGS",[dS]);class US extends fs{}Z(US,"MODEL_CLASS_MAPPINGS",[hS]);class GS extends fs{}Z(GS,"MODEL_CLASS_MAPPINGS",[pS]);class jS extends fs{}Z(jS,"MODEL_CLASS_MAPPINGS",[fS]);class WS extends fs{}Z(WS,"MODEL_CLASS_MAPPINGS",[Q1]);class HS extends fs{}Z(HS,"MODEL_CLASS_MAPPINGS",[Z1]);class l3 extends Ce{constructor({logits:N,past_key_values:B,encoder_outputs:ae,decoder_attentions:Se=null,cross_attentions:Te=null}){super(),this.logits=N,this.past_key_values=B,this.encoder_outputs=ae,this.decoder_attentions=Se,this.cross_attentions=Te}}class Vt extends Ce{constructor({logits:N,...B}){super(),this.logits=N;const ae=Object.values(B);ae.length>0&&(this.attentions=ae)}}class qS extends Ce{constructor({logits:N,embeddings:B}){super(),this.logits=N,this.embeddings=B}}class vi extends Ce{constructor({logits:N}){super(),this.logits=N}}class Oi extends Ce{constructor({logits:N}){super(),this.logits=N}}class er extends Ce{constructor({start_logits:N,end_logits:B}){super(),this.start_logits=N,this.end_logits=B}}class ul extends Ce{constructor({logits:N}){super(),this.logits=N}}class u3 extends Ce{constructor({logits:N,past_key_values:B}){super(),this.logits=N,this.past_key_values=B}}class KS extends Ce{constructor({alphas:N}){super(),this.alphas=N}}class XS extends Ce{constructor({waveform:N,spectrogram:B}){super(),this.waveform=N,this.spectrogram=B}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":(i,e,t)=>{t.r(e),t.d(e,{ASTFeatureExtractor:()=>n});var s=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var r=t("./src/utils/audio.js");class n extends s.FeatureExtractor{constructor(a){super(a);const l=this.config.sampling_rate,u=(0,r.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(l/2),l,null,"kaldi",!0);this.mel_filters=u,this.window=(0,r.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(a,l){return(0,r.spectrogram)(a,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:l,transpose:!0})}async _call(a){(0,s.validate_audio_inputs)(a,"ASTFeatureExtractor");const l=await this._extract_fbank_features(a,this.config.max_length);if(this.config.do_normalize){const u=this.std*2,c=l.data;for(let d=0;d<c.length;++d)c[d]=(c[d]-this.mean)/u}return{input_values:l.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":(i,e,t)=>{t.r(e),t.d(e,{AutoFeatureExtractor:()=>o});var s=t("./src/utils/constants.js"),r=t("./src/utils/hub.js");t("./src/base/feature_extraction_utils.js");var n=t("./src/models/feature_extractors.js");class o{static async from_pretrained(l,u={}){const c=await(0,r.getModelJSON)(l,s.FEATURE_EXTRACTOR_NAME,!0,u),d=c.feature_extractor_type,h=n[d];if(!h)throw new Error(`Unknown feature_extractor_type: '${d}'. Please report this at ${s.GITHUB_ISSUE_URL}.`);return new h(c)}}},"./src/models/auto/image_processing_auto.js":(i,e,t)=>{t.r(e),t.d(e,{AutoImageProcessor:()=>a});var s=t("./src/utils/constants.js"),r=t("./src/utils/hub.js"),n=t("./src/base/image_processors_utils.js"),o=t("./src/models/image_processors.js");class a{static async from_pretrained(u,c={}){const d=await(0,r.getModelJSON)(u,s.IMAGE_PROCESSOR_NAME,!0,c),h=d.image_processor_type??d.feature_extractor_type;let p=o[h==null?void 0:h.replace(/Fast$/,"")];return p||(h!==void 0&&console.warn(`Image processor type '${h}' not found, assuming base ImageProcessor. Please report this at ${s.GITHUB_ISSUE_URL}.`),p=n.ImageProcessor),new p(d)}}},"./src/models/auto/processing_auto.js":(i,e,t)=>{t.r(e),t.d(e,{AutoProcessor:()=>u});var s=t("./src/utils/constants.js"),r=t("./src/utils/hub.js"),n=t("./src/base/processing_utils.js"),o=t("./src/models/processors.js"),a=t("./src/models/image_processors.js"),l=t("./src/models/feature_extractors.js");class u{static async from_pretrained(d,h={}){const p=await(0,r.getModelJSON)(d,s.IMAGE_PROCESSOR_NAME,!0,h),{image_processor_type:f,feature_extractor_type:m,processor_class:x}=p;if(x&&o[x])return o[x].from_pretrained(d,h);if(!f&&!m)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const g={};if(f){const S=a[f.replace(/Fast$/,"")];if(!S)throw new Error(`Unknown image_processor_type: '${f}'.`);g.image_processor=new S(p)}if(m){const S=a[m];if(S)g.image_processor=new S(p);else{const M=l[m];if(!M)throw new Error(`Unknown feature_extractor_type: '${m}'.`);g.feature_extractor=new M(p)}}const _={};return new n.Processor(_,g,null)}}},"./src/models/beit/image_processing_beit.js":(i,e,t)=>{t.r(e),t.d(e,{BeitFeatureExtractor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":(i,e,t)=>{t.r(e),t.d(e,{BitImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":(i,e,t)=>{t.r(e),t.d(e,{ChineseCLIPFeatureExtractor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":(i,e,t)=>{t.r(e),t.d(e,{ClapFeatureExtractor:()=>n});var s=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var r=t("./src/utils/audio.js");class n extends s.FeatureExtractor{constructor(a){super(a),this.mel_filters=(0,r.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,r.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,r.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(a,l,u,c){let d;const h=a.length-l;if(h>0)if(u==="rand_trunc"){const p=Math.floor(Math.random()*(h+1));a=a.subarray(p,p+l),d=await this._extract_fbank_features(a,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${u}" not implemented`);else{if(h<0){let p=new Float64Array(l);if(p.set(a),c==="repeat")for(let f=a.length;f<l;f+=a.length)p.set(a.subarray(0,Math.min(a.length,l-f)),f);else if(c==="repeatpad")for(let f=a.length;f<-h;f+=a.length)p.set(a,f);a=p}if(u==="fusion")throw new Error(`Truncation strategy "${u}" not implemented`);d=await this._extract_fbank_features(a,this.mel_filters_slaney,this.config.nb_max_samples)}return d.unsqueeze_(0)}async _extract_fbank_features(a,l,u=null){return(0,r.spectrogram)(a,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:l,log_mel:"dB",max_num_frames:u,do_pad:!1,transpose:!0})}async _call(a,{max_length:l=null}={}){return(0,s.validate_audio_inputs)(a,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(a,l??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":(i,e,t)=>{t.r(e),t.d(e,{CLIPFeatureExtractor:()=>n,CLIPImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/convnext/image_processing_convnext.js":(i,e,t)=>{t.r(e),t.d(e,{ConvNextFeatureExtractor:()=>n,ConvNextImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{constructor(a){super(a),this.crop_pct=this.config.crop_pct??224/256}async resize(a){var u;const l=(u=this.size)==null?void 0:u.shortest_edge;if(l===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(l<384){const c=Math.floor(l/this.crop_pct),[d,h]=this.get_resize_output_image_size(a,{shortest_edge:c});a=await a.resize(d,h,{resample:this.resample}),a=await a.center_crop(l,l)}else a=await a.resize(l,l,{resample:this.resample});return a}}class n extends r{}},"./src/models/dac/feature_extraction_dac.js":(i,e,t)=>{t.r(e),t.d(e,{DacFeatureExtractor:()=>r});var s=t("./src/models/encodec/feature_extraction_encodec.js");class r extends s.EncodecFeatureExtractor{}},"./src/models/deit/image_processing_deit.js":(i,e,t)=>{t.r(e),t.d(e,{DeiTFeatureExtractor:()=>n,DeiTImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/detr/image_processing_detr.js":(i,e,t)=>{t.r(e),t.d(e,{DetrFeatureExtractor:()=>o,DetrImageProcessor:()=>n});var s=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class n extends s.ImageProcessor{async _call(l){const u=await super._call(l),c=[u.pixel_values.dims[0],64,64],d=(0,r.full)(c,1n);return{...u,pixel_mask:d}}post_process_object_detection(...l){return(0,s.post_process_object_detection)(...l)}post_process_panoptic_segmentation(...l){return(0,s.post_process_panoptic_segmentation)(...l)}post_process_instance_segmentation(...l){return(0,s.post_process_instance_segmentation)(...l)}}class o extends n{}},"./src/models/donut/image_processing_donut.js":(i,e,t)=>{t.r(e),t.d(e,{DonutFeatureExtractor:()=>n,DonutImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{pad_image(a,l,u,c={}){const[d,h,p]=l;let f=this.image_mean;Array.isArray(this.image_mean)||(f=new Array(p).fill(f));let m=this.image_std;Array.isArray(m)||(m=new Array(p).fill(f));const x=f.map((g,_)=>-g/m[_]);return super.pad_image(a,l,u,{center:!0,constant_values:x,...c})}}class n extends r{}},"./src/models/dpt/image_processing_dpt.js":(i,e,t)=>{t.r(e),t.d(e,{DPTFeatureExtractor:()=>n,DPTImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/efficientnet/image_processing_efficientnet.js":(i,e,t)=>{t.r(e),t.d(e,{EfficientNetImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{constructor(o){super(o),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(a=>a*a))}}},"./src/models/encodec/feature_extraction_encodec.js":(i,e,t)=>{t.r(e),t.d(e,{EncodecFeatureExtractor:()=>n});var s=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js");class n extends s.FeatureExtractor{async _call(a){(0,s.validate_audio_inputs)(a,"EncodecFeatureExtractor"),a instanceof Float64Array&&(a=new Float32Array(a));const l=this.config.feature_size;if(a.length%l!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${l}).`);const u=[1,l,a.length/l];return{input_values:new r.Tensor("float32",a,u)}}}},"./src/models/feature_extractors.js":(i,e,t)=>{t.r(e),t.d(e,{ASTFeatureExtractor:()=>s.ASTFeatureExtractor,ClapFeatureExtractor:()=>n.ClapFeatureExtractor,DacFeatureExtractor:()=>o.DacFeatureExtractor,EncodecFeatureExtractor:()=>r.EncodecFeatureExtractor,Gemma3nAudioFeatureExtractor:()=>a.Gemma3nAudioFeatureExtractor,ImageFeatureExtractor:()=>x.ImageProcessor,MoonshineFeatureExtractor:()=>l.MoonshineFeatureExtractor,PyAnnoteFeatureExtractor:()=>u.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>c.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>d.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>h.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>p.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>f.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>m.WhisperFeatureExtractor});var s=t("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),r=t("./src/models/encodec/feature_extraction_encodec.js"),n=t("./src/models/clap/feature_extraction_clap.js"),o=t("./src/models/dac/feature_extraction_dac.js"),a=t("./src/models/gemma3n/feature_extraction_gemma3n.js"),l=t("./src/models/moonshine/feature_extraction_moonshine.js"),u=t("./src/models/pyannote/feature_extraction_pyannote.js"),c=t("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),d=t("./src/models/snac/feature_extraction_snac.js"),h=t("./src/models/speecht5/feature_extraction_speecht5.js"),p=t("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),f=t("./src/models/wespeaker/feature_extraction_wespeaker.js"),m=t("./src/models/whisper/feature_extraction_whisper.js"),x=t("./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":(i,e,t)=>{t.r(e),t.d(e,{Florence2Processor:()=>o});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js");class o extends s.Processor{constructor(l,u,c){super(l,u,c);const{tasks_answer_post_processing_type:d,task_prompts_without_inputs:h,task_prompts_with_input:p}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(d??{})),this.task_prompts_without_inputs=new Map(Object.entries(h??{})),this.task_prompts_with_input=new Map(Object.entries(p??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(l){typeof l=="string"&&(l=[l]);const u=[];for(const c of l)if(this.task_prompts_without_inputs.has(c))u.push(this.task_prompts_without_inputs.get(c));else{for(const[d,h]of this.task_prompts_with_input)if(c.includes(d)){u.push(h.replaceAll("{input}",c).replaceAll(d,""));break}u.length!==l.length&&u.push(c)}return u}post_process_generation(l,u,c){const d=this.tasks_answer_post_processing_type.get(u)??"pure_text";l=l.replaceAll("<s>","").replaceAll("</s>","");let h;switch(d){case"pure_text":h=l;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const p=d==="ocr"?"quad_boxes":"bboxes",f=l.matchAll(this.regexes[p]),m=[],x=[];for(const[g,_,...S]of f)m.push(_?_.trim():m.at(-1)??""),x.push(S.map((M,w)=>(Number(M)+.5)/this.size_per_bin*c[w%2]));h={labels:m,[p]:x};break;default:throw new Error(`Task "${u}" (of type "${d}") not yet implemented.`)}return{[u]:h}}async _call(l,u=null,c={}){if(!l&&!u)throw new Error("Either text or images must be provided");const d=await this.image_processor(l,c),h=u?this.tokenizer(this.construct_prompts(u),c):{};return{...d,...h}}}Z(o,"tokenizer_class",n.AutoTokenizer),Z(o,"image_processor_class",r.AutoImageProcessor)},"./src/models/gemma3n/feature_extraction_gemma3n.js":(i,e,t)=>{t.r(e),t.d(e,{Gemma3nAudioFeatureExtractor:()=>o});var s=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js"),n=t("./src/utils/audio.js");class o extends s.FeatureExtractor{constructor(l){super(l);const{fft_length:u,feature_size:c,min_frequency:d,max_frequency:h,sampling_rate:p,frame_length:f}=this.config,m=(0,n.mel_filter_bank)(Math.floor(1+u/2),c,d,h,p,null,"htk",!1);this.mel_filters=m,this.window=(0,n.window_function)(f,"hann")}async _extract_fbank_features(l,u){return(0,n.spectrogram)(l,this.window,this.config.frame_length,this.config.hop_length,{fft_length:this.config.fft_length,center:!1,onesided:!0,preemphasis:this.config.preemphasis,preemphasis_htk_flavor:this.config.preemphasis_htk_flavor,mel_filters:this.mel_filters,log_mel:"log",mel_floor:this.config.mel_floor,remove_dc_offset:!1,transpose:!0})}async _call(l,{max_length:u=48e4,truncation:c=!0,padding:d=!0,pad_to_multiple_of:h=128}={}){if((0,s.validate_audio_inputs)(l,"Gemma3nAudioFeatureExtractor"),c&&l.length>u&&(l=l.slice(0,u)),d&&l.length%h!==0){const m=h-l.length%h,x=new Float64Array(l.length+m);x.set(l),this.config.padding_value!==0&&x.fill(this.config.padding_value,l.length),l=x}const p=await this._extract_fbank_features(l,this.config.max_length),f=(0,r.full)([1,p.dims[0]],!0);return{input_features:p.unsqueeze_(0),input_features_mask:f}}}},"./src/models/gemma3n/processing_gemma3n.js":(i,e,t)=>{t.r(e),t.d(e,{Gemma3nProcessor:()=>a});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/models/auto/feature_extraction_auto.js"),o=t("./src/tokenizers.js");t("./src/utils/image.js"),t("./src/utils/audio.js");class a extends s.Processor{constructor(u,c,d){super(u,c,d),this.audio_seq_length=this.config.audio_seq_length,this.image_seq_length=this.config.image_seq_length;const{audio_token_id:h,boa_token:p,audio_token:f,eoa_token:m,image_token_id:x,boi_token:g,image_token:_,eoi_token:S}=this.tokenizer.config;this.audio_token_id=h,this.boa_token=p,this.audio_token=f;const M=f.repeat(this.audio_seq_length);this.full_audio_sequence=`

${p}${M}${m}

`,this.image_token_id=x,this.boi_token=g,this.image_token=_;const w=_.repeat(this.image_seq_length);this.full_image_sequence=`

${g}${w}${S}

`}async _call(u,c=null,d=null,h={}){typeof u=="string"&&(u=[u]);let p;d&&(p=await this.feature_extractor(d,h),u=u.map(x=>x.replaceAll(this.audio_token,this.full_audio_sequence)));let f;return c&&(f=await this.image_processor(c,h),u=u.map(x=>x.replaceAll(this.image_token,this.full_image_sequence))),{...this.tokenizer(u,h),...f,...p}}}Z(a,"image_processor_class",r.AutoImageProcessor),Z(a,"feature_extractor_class",n.AutoFeatureExtractor),Z(a,"tokenizer_class",o.AutoTokenizer),Z(a,"uses_processor_config",!0),Z(a,"uses_chat_template_file",!0)},"./src/models/glpn/image_processing_glpn.js":(i,e,t)=>{t.r(e),t.d(e,{GLPNFeatureExtractor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}},"./src/models/grounding_dino/image_processing_grounding_dino.js":(i,e,t)=>{t.r(e),t.d(e,{GroundingDinoImageProcessor:()=>n});var s=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class n extends s.ImageProcessor{async _call(a){const l=await super._call(a),u=l.pixel_values.dims,c=(0,r.ones)([u[0],u[2],u[3]]);return{...l,pixel_mask:c}}}},"./src/models/grounding_dino/processing_grounding_dino.js":(i,e,t)=>{t.r(e),t.d(e,{GroundingDinoProcessor:()=>l});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js"),o=t("./src/base/image_processors_utils.js");function a(u,c){const h=u.dims.at(-1)-1,p=u.tolist();p.fill(!1,0,1),p.fill(!1,h);const f=c.tolist();return p.map((m,x)=>m?x:null).filter(m=>m!==null).map(m=>f[m])}class l extends s.Processor{async _call(c,d,h={}){const p=c?await this.image_processor(c,h):{};return{...d?this.tokenizer(d,h):{},...p}}post_process_grounded_object_detection(c,d,{box_threshold:h=.25,text_threshold:p=.25,target_sizes:f=null}={}){const{logits:m,pred_boxes:x}=c,g=m.dims[0];if(f!==null&&f.length!==g)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const _=m.dims.at(1),S=m.sigmoid(),M=S.max(-1).tolist(),w=x.tolist().map(T=>T.map(E=>(0,o.center_to_corners_format)(E))),v=[];for(let T=0;T<g;++T){const E=f!==null?f[T]:null;E!==null&&(w[T]=w[T].map(L=>L.map((Q,q)=>Q*E[(q+1)%2])));const F=M[T],I=[],z=[],G=[];for(let L=0;L<_;++L){const Q=F[L];if(Q<=h)continue;const q=w[T][L],J=S[T][L];I.push(Q),G.push(q);const ee=a(J.gt(p),d[T]);z.push(ee)}v.push({scores:I,boxes:G,labels:this.batch_decode(z)})}return v}}Z(l,"tokenizer_class",n.AutoTokenizer),Z(l,"image_processor_class",r.AutoImageProcessor)},"./src/models/idefics3/image_processing_idefics3.js":(i,e,t)=>{t.r(e),t.d(e,{Idefics3ImageProcessor:()=>n});var s=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class n extends s.ImageProcessor{constructor(a){super(a),this.do_image_splitting=a.do_image_splitting??!0,this.max_image_size=a.max_image_size}get_resize_for_vision_encoder(a,l){let[u,c]=a.dims.slice(-2);const d=c/u;return c>=u?(c=Math.ceil(c/l)*l,u=Math.floor(c/d),u=Math.ceil(u/l)*l):(u=Math.ceil(u/l)*l,c=Math.floor(u*d),c=Math.ceil(c/l)*l),{height:u,width:c}}async _call(a,{do_image_splitting:l=null,return_row_col_info:u=!1}={}){let c;if(!Array.isArray(a))c=[[a]];else{if(a.length===0||!a[0])throw new Error("No images provided.");Array.isArray(a[0])?c=a:c=[a]}let d=[],h=[],p=[];const f=[],m=[];for(const T of c){let E=await Promise.all(T.map(z=>this.preprocess(z)));f.push(...E.map(z=>z.original_size)),m.push(...E.map(z=>z.reshaped_input_size)),E.forEach(z=>z.pixel_values.unsqueeze_(0));const{longest_edge:F}=this.max_image_size;let I;if(l??this.do_image_splitting){let z=new Array(E.length),G=new Array(E.length);I=await Promise.all(E.map(async(L,Q)=>{const q=this.get_resize_for_vision_encoder(L.pixel_values,F),J=await(0,r.interpolate_4d)(L.pixel_values,{size:[q.height,q.width]}),{frames:ee,num_splits_h:se,num_splits_w:fe}=await this.split_image(J,this.max_image_size);return z[Q]=se,G[Q]=fe,(0,r.cat)(ee,0)})),h.push(z),p.push(G)}else{const z=[F,F];I=await Promise.all(E.map(G=>(0,r.interpolate_4d)(G.pixel_values,{size:z}))),h.push(new Array(E.length).fill(0)),p.push(new Array(E.length).fill(0))}d.push((0,r.cat)(I,0))}const x=d.length,[g,_,S,M]=d[0].dims;let w,v;if(x===1)w=d[0].unsqueeze_(0),v=(0,r.full)([x,g,S,M],!0);else{const T=Math.max(...d.map(I=>I.dims.at(0)));v=(0,r.full)([x,T,S,M],!0);const E=v.data,F=T*S*M;for(let I=0;I<x;++I){const z=d[I].dims[0];if(z<T){d[I]=(0,r.cat)([d[I],(0,r.full)([T-z,_,S,M],0)],0);const G=I*F+z*S*M,L=(I+1)*F;E.fill(!1,G,L)}}w=(0,r.stack)(d,0)}return{pixel_values:w,pixel_attention_mask:v,original_sizes:f,reshaped_input_sizes:m,...u?{rows:h,cols:p}:{}}}async split_image(a,{longest_edge:l}){const u=l,c=l,d=[],[h,p]=a.dims.slice(-2);let f=0,m=0;if(h>u||p>c){f=Math.ceil(h/u),m=Math.ceil(p/c);const x=Math.ceil(h/f),g=Math.ceil(p/m);for(let M=0;M<f;++M)for(let w=0;w<m;++w){let v,T,E,F;M===f-1?(T=h-x,F=h):(T=M*x,F=(M+1)*x),w===m-1?(v=p-g,E=p):(v=w*g,E=(w+1)*g);const I=[T,v],z=[F,E],G=await(0,r.slice)(a,I,z,[2,3]);d.push(G)}const _=u,S=c;(h!==_||p!==S)&&(a=await(0,r.interpolate_4d)(a,{size:[_,S]}))}return d.push(a),{frames:d,num_splits_h:f,num_splits_w:m}}}},"./src/models/idefics3/processing_idefics3.js":(i,e,t)=>{t.r(e),t.d(e,{Idefics3Processor:()=>c});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js");t("./src/utils/image.js");var o=t("./src/utils/core.js");function a(d,h,p,f,m,x){let g="";for(let _=0;_<h;++_){for(let S=0;S<p;++S)g+=f+`<row_${_+1}_col_${S+1}>`+m.repeat(d);g+=`
`}return g+=`
${f}${x}`+m.repeat(d)+`${f}`,g}function l(d,h,p,f){return`${h}${f}`+p.repeat(d)+`${h}`}function u(d,h,p,f,m,x){return d===0&&h===0?l(p,f,m,x):a(p,d,h,f,m,x)}class c extends s.Processor{constructor(){super(...arguments);Z(this,"fake_image_token","<fake_token_around_image>");Z(this,"image_token","<image>");Z(this,"global_img_token","<global-img>")}async _call(p,f=null,m={}){m.return_row_col_info??(m.return_row_col_info=!0);let x;f&&(x=await this.image_processor(f,m)),Array.isArray(p)||(p=[p]);const g=x.rows??[new Array(p.length).fill(0)],_=x.cols??[new Array(p.length).fill(0)],S=this.config.image_seq_len,M=[],w=[];for(let T=0;T<p.length;++T){const E=p[T],F=g[T],I=_[T];M.push((0,o.count)(E,this.image_token));const z=F.map((Q,q)=>u(Q,I[q],S,this.fake_image_token,this.image_token,this.global_img_token)),G=E.split(this.image_token);if(G.length===0)throw new Error("The image token should be present in the text.");let L=G[0];for(let Q=0;Q<z.length;++Q)L+=z[Q]+G[Q+1];w.push(L)}return{...this.tokenizer(w),...x}}}Z(c,"image_processor_class",r.AutoImageProcessor),Z(c,"tokenizer_class",n.AutoTokenizer),Z(c,"uses_processor_config",!0)},"./src/models/image_processors.js":(i,e,t)=>{t.r(e),t.d(e,{BeitFeatureExtractor:()=>s.BeitFeatureExtractor,BitImageProcessor:()=>r.BitImageProcessor,CLIPFeatureExtractor:()=>o.CLIPFeatureExtractor,CLIPImageProcessor:()=>o.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>n.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>a.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>a.ConvNextImageProcessor,DPTFeatureExtractor:()=>d.DPTFeatureExtractor,DPTImageProcessor:()=>d.DPTImageProcessor,DeiTFeatureExtractor:()=>l.DeiTFeatureExtractor,DeiTImageProcessor:()=>l.DeiTImageProcessor,DetrFeatureExtractor:()=>u.DetrFeatureExtractor,DetrImageProcessor:()=>u.DetrImageProcessor,DonutFeatureExtractor:()=>c.DonutFeatureExtractor,DonutImageProcessor:()=>c.DonutImageProcessor,EfficientNetImageProcessor:()=>h.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>p.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>f.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>m.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>g.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>_.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>S.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>M.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>M.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>w.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>w.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>v.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>v.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>T.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>T.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>E.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>E.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>F.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>F.MobileViTImageProcessor,NougatImageProcessor:()=>I.NougatImageProcessor,OwlViTFeatureExtractor:()=>G.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>G.OwlViTImageProcessor,Owlv2ImageProcessor:()=>z.Owlv2ImageProcessor,Phi3VImageProcessor:()=>L.Phi3VImageProcessor,PvtImageProcessor:()=>Q.PvtImageProcessor,Qwen2VLImageProcessor:()=>q.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>J.RTDetrImageProcessor,SamImageProcessor:()=>ee.SamImageProcessor,SegformerFeatureExtractor:()=>se.SegformerFeatureExtractor,SegformerImageProcessor:()=>se.SegformerImageProcessor,SiglipImageProcessor:()=>fe.SiglipImageProcessor,SmolVLMImageProcessor:()=>ue.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>U.Swin2SRImageProcessor,VLMImageProcessor:()=>x.VLMImageProcessor,ViTFeatureExtractor:()=>k.ViTFeatureExtractor,ViTImageProcessor:()=>k.ViTImageProcessor,VitMatteImageProcessor:()=>j.VitMatteImageProcessor,VitPoseImageProcessor:()=>re.VitPoseImageProcessor,YolosFeatureExtractor:()=>we.YolosFeatureExtractor,YolosImageProcessor:()=>we.YolosImageProcessor});var s=t("./src/models/beit/image_processing_beit.js"),r=t("./src/models/bit/image_processing_bit.js"),n=t("./src/models/chinese_clip/image_processing_chinese_clip.js"),o=t("./src/models/clip/image_processing_clip.js"),a=t("./src/models/convnext/image_processing_convnext.js"),l=t("./src/models/deit/image_processing_deit.js"),u=t("./src/models/detr/image_processing_detr.js"),c=t("./src/models/donut/image_processing_donut.js"),d=t("./src/models/dpt/image_processing_dpt.js"),h=t("./src/models/efficientnet/image_processing_efficientnet.js"),p=t("./src/models/glpn/image_processing_glpn.js"),f=t("./src/models/grounding_dino/image_processing_grounding_dino.js"),m=t("./src/models/idefics3/image_processing_idefics3.js"),x=t("./src/models/janus/image_processing_janus.js"),g=t("./src/models/jina_clip/image_processing_jina_clip.js"),_=t("./src/models/llava_onevision/image_processing_llava_onevision.js"),S=t("./src/models/mask2former/image_processing_mask2former.js"),M=t("./src/models/maskformer/image_processing_maskformer.js"),w=t("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),v=t("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),T=t("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),E=t("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),F=t("./src/models/mobilevit/image_processing_mobilevit.js"),I=t("./src/models/nougat/image_processing_nougat.js"),z=t("./src/models/owlv2/image_processing_owlv2.js"),G=t("./src/models/owlvit/image_processing_owlvit.js"),L=t("./src/models/phi3_v/image_processing_phi3_v.js"),Q=t("./src/models/pvt/image_processing_pvt.js"),q=t("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),J=t("./src/models/rt_detr/image_processing_rt_detr.js"),ee=t("./src/models/sam/image_processing_sam.js"),se=t("./src/models/segformer/image_processing_segformer.js"),fe=t("./src/models/siglip/image_processing_siglip.js"),ue=t("./src/models/smolvlm/image_processing_smolvlm.js"),U=t("./src/models/swin2sr/image_processing_swin2sr.js"),k=t("./src/models/vit/image_processing_vit.js"),j=t("./src/models/vitmatte/image_processing_vitmatte.js"),re=t("./src/models/vitpose/image_processing_vitpose.js"),we=t("./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":(i,e,t)=>{t.r(e),t.d(e,{VLMImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{constructor(o){super({do_pad:!0,pad_size:{width:o.image_size,height:o.image_size},...o}),this.constant_values=this.config.background_color.map(a=>a*this.rescale_factor)}pad_image(o,a,l,u){return super.pad_image(o,a,l,{constant_values:this.constant_values,center:!0,...u})}}},"./src/models/janus/processing_janus.js":(i,e,t)=>{t.r(e),t.d(e,{VLChatProcessor:()=>u});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js"),o=t("./src/utils/core.js"),a=t("./src/utils/tensor.js"),l=t("./src/utils/image.js");class u extends s.Processor{constructor(d,h,p){super(d,h,p),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(d,{images:h=null,chat_template:p="default"}={}){h?Array.isArray(h)||(h=[h]):h=await Promise.all(d.filter(I=>I.images).flatMap(I=>I.images).map(I=>l.RawImage.read(I)));const f=this.tokenizer,m=f.apply_chat_template(d,{tokenize:!1,add_generation_prompt:!0,chat_template:p}),x=I=>f.encode(I,{add_special_tokens:!1}),g=m.split(this.image_tag),_=g.length-1;if(h.length!==_)throw new Error(`Number of images provided (${h.length}) does not match number of "${this.image_tag}" image tags (${_})`);const[S,M,w]=f.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let v=x(g[0]),T=new Array(v.length).fill(!1);for(let I=1;I<g.length;++I){const z=new Array(this.num_image_tokens).fill(S),G=x(g[I]);v=(0,o.mergeArrays)(v,[M],z,[w],G);const L=new Array(this.num_image_tokens).fill(!0);T=(0,o.mergeArrays)(T,[!1],L,[!1],new Array(G.length).fill(!1))}const E=[1,v.length],F={input_ids:new a.Tensor("int64",v,E),attention_mask:new a.Tensor("int64",new Array(v.length).fill(1),E),images_seq_mask:new a.Tensor("bool",T,E),images_emb_mask:new a.Tensor("bool",new Array(_*this.num_image_tokens).fill(!0),[1,_,this.num_image_tokens])};if(h&&h.length>0){const I=await this.image_processor(h);return I.pixel_values.unsqueeze_(0),{...F,...I}}return F}}Z(u,"image_processor_class",r.AutoImageProcessor),Z(u,"tokenizer_class",n.AutoTokenizer),Z(u,"uses_processor_config",!0)},"./src/models/jina_clip/image_processing_jina_clip.js":(i,e,t)=>{t.r(e),t.d(e,{JinaCLIPImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{constructor(o){const{resize_mode:a,fill_color:l,interpolation:u,size:c,...d}=o,h=a==="squash"?{width:c,height:c}:a==="shortest"?{shortest_edge:c}:{longest_edge:c},p=u==="bicubic"?3:2;super({...d,size:h,resample:p,do_center_crop:!0,crop_size:c,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":(i,e,t)=>{t.r(e),t.d(e,{JinaCLIPProcessor:()=>o});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js");class o extends s.Processor{async _call(l=null,u=null,c={}){if(!l&&!u)throw new Error("Either text or images must be provided");const d=l?this.tokenizer(l,c):{},h=u?await this.image_processor(u,c):{};return{...d,...h}}}Z(o,"tokenizer_class",n.AutoTokenizer),Z(o,"image_processor_class",r.AutoImageProcessor)},"./src/models/llava/processing_llava.js":(i,e,t)=>{t.r(e),t.d(e,{LlavaProcessor:()=>o});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js");class o extends s.Processor{async _call(l,u=null,c={}){const d=await this.image_processor(l,c);if(u){const[p,f]=d.pixel_values.dims.slice(-2),{image_token:m,patch_size:x,num_additional_image_tokens:g}=this.config,_=Math.floor(p/x)*Math.floor(f/x)+g;u=structuredClone(u),Array.isArray(u)||(u=[u]);for(let S=0;S<u.length;++S)u[S]=u[S].replace(m,m.repeat(_))}const h=u?this.tokenizer(u,c):{};return{...d,...h}}}Z(o,"tokenizer_class",n.AutoTokenizer),Z(o,"image_processor_class",r.AutoImageProcessor),Z(o,"uses_processor_config",!0)},"./src/models/llava_onevision/image_processing_llava_onevision.js":(i,e,t)=>{t.r(e),t.d(e,{LlavaOnevisionImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":(i,e,t)=>{t.r(e),t.d(e,{Mask2FormerImageProcessor:()=>r});var s=t("./src/models/maskformer/image_processing_maskformer.js");class r extends s.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":(i,e,t)=>{t.r(e),t.d(e,{MaskFormerFeatureExtractor:()=>n,MaskFormerImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{post_process_panoptic_segmentation(...a){return(0,s.post_process_panoptic_segmentation)(...a)}post_process_instance_segmentation(...a){return(0,s.post_process_instance_segmentation)(...a)}}class n extends r{}},"./src/models/mgp_str/processing_mgp_str.js":(i,e,t)=>{t.r(e),t.d(e,{MgpstrProcessor:()=>l});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js"),o=t("./src/utils/maths.js");const a={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class l extends s.Processor{get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(c,d){if(!a.hasOwnProperty(d))throw new Error(`Format ${d} is not supported.`);const[h,p]=a[d],f=this[h].bind(this),[m,x]=c.dims,g=[],_=[],S=c.tolist();for(let w=0;w<m;++w){const v=S[w],T=[],E=[];for(let I=1;I<x;++I){const[z,G]=(0,o.max)((0,o.softmax)(v[I]));if(E.push(z),G==p)break;T.push(G)}const F=E.length>0?E.reduce((I,z)=>I*z,1):0;_.push(T),g.push(F)}return[f(_),g]}char_decode(c){return this.char_tokenizer.batch_decode(c).map(d=>d.replaceAll(" ",""))}bpe_decode(c){return this.bpe_tokenizer.batch_decode(c)}wp_decode(c){return this.wp_tokenizer.batch_decode(c).map(d=>d.replaceAll(" ",""))}batch_decode([c,d,h]){const[p,f]=this._decode_helper(c,"char"),[m,x]=this._decode_helper(d,"bpe"),[g,_]=this._decode_helper(h,"wp"),S=[],M=[];for(let w=0;w<p.length;++w){const[v,T]=(0,o.max)([f[w],x[w],_[w]]);S.push([p[w],m[w],g[w]][T]),M.push(v)}return{generated_text:S,scores:M,char_preds:p,bpe_preds:m,wp_preds:g}}static async from_pretrained(...c){const d=await super.from_pretrained(...c),h=await n.AutoTokenizer.from_pretrained("Xenova/gpt2"),p=await n.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return d.components={image_processor:d.image_processor,char_tokenizer:d.tokenizer,bpe_tokenizer:h,wp_tokenizer:p},d}async _call(c,d=null){const h=await this.image_processor(c);return d&&(h.labels=this.tokenizer(d).input_ids),h}}Z(l,"tokenizer_class",n.AutoTokenizer),Z(l,"image_processor_class",r.AutoImageProcessor)},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":(i,e,t)=>{t.r(e),t.d(e,{MobileNetV1FeatureExtractor:()=>n,MobileNetV1ImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":(i,e,t)=>{t.r(e),t.d(e,{MobileNetV2FeatureExtractor:()=>n,MobileNetV2ImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":(i,e,t)=>{t.r(e),t.d(e,{MobileNetV3FeatureExtractor:()=>n,MobileNetV3ImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":(i,e,t)=>{t.r(e),t.d(e,{MobileNetV4FeatureExtractor:()=>n,MobileNetV4ImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/mobilevit/image_processing_mobilevit.js":(i,e,t)=>{t.r(e),t.d(e,{MobileViTFeatureExtractor:()=>n,MobileViTImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/moonshine/feature_extraction_moonshine.js":(i,e,t)=>{t.r(e),t.d(e,{MoonshineFeatureExtractor:()=>n});var s=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js");class n extends s.FeatureExtractor{async _call(a){(0,s.validate_audio_inputs)(a,"MoonshineFeatureExtractor"),a instanceof Float64Array&&(a=new Float32Array(a));const l=[1,a.length];return{input_values:new r.Tensor("float32",a,l)}}}},"./src/models/moonshine/processing_moonshine.js":(i,e,t)=>{t.r(e),t.d(e,{MoonshineProcessor:()=>o});var s=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/tokenizers.js"),n=t("./src/base/processing_utils.js");class o extends n.Processor{async _call(l){return await this.feature_extractor(l)}}Z(o,"tokenizer_class",r.AutoTokenizer),Z(o,"feature_extractor_class",s.AutoFeatureExtractor)},"./src/models/nougat/image_processing_nougat.js":(i,e,t)=>{t.r(e),t.d(e,{NougatImageProcessor:()=>r});var s=t("./src/models/donut/image_processing_donut.js");class r extends s.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":(i,e,t)=>{t.r(e),t.d(e,{Owlv2ImageProcessor:()=>r});var s=t("./src/models/owlvit/image_processing_owlvit.js");class r extends s.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":(i,e,t)=>{t.r(e),t.d(e,{OwlViTFeatureExtractor:()=>n,OwlViTImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{post_process_object_detection(...a){return(0,s.post_process_object_detection)(...a)}}class n extends r{}},"./src/models/owlvit/processing_owlvit.js":(i,e,t)=>{t.r(e),t.d(e,{OwlViTProcessor:()=>o});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js");class o extends s.Processor{}Z(o,"tokenizer_class",n.AutoTokenizer),Z(o,"image_processor_class",r.AutoImageProcessor)},"./src/models/paligemma/processing_paligemma.js":(i,e,t)=>{t.r(e),t.d(e,{PaliGemmaProcessor:()=>l});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js");const o="<image>";function a(u,c,d,h,p){return`${h.repeat(d*p)}${c}${u}
`}class l extends s.Processor{async _call(c,d=null,h={}){d||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),d=""),Array.isArray(c)||(c=[c]),Array.isArray(d)||(d=[d]);const p=this.tokenizer.bos_token,f=this.image_processor.config.image_seq_length;let m;d.some(_=>_.includes(o))?m=d.map(_=>{const S=_.replaceAll(o,o.repeat(f)),M=S.lastIndexOf(o),w=M===-1?0:M+o.length;return S.slice(0,w)+p+S.slice(w)+`
`}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),m=d.map(_=>a(_,p,f,o,c.length)));const x=this.tokenizer(m,h);return{...await this.image_processor(c,h),...x}}}Z(l,"tokenizer_class",n.AutoTokenizer),Z(l,"image_processor_class",r.AutoImageProcessor),Z(l,"uses_processor_config",!1)},"./src/models/phi3_v/image_processing_phi3_v.js":(i,e,t)=>{t.r(e),t.d(e,{Phi3VImageProcessor:()=>c});var s=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");const n=336,o=[2,3],{ceil:a,floor:l,sqrt:u}=Math;class c extends s.ImageProcessor{constructor(h){super({...h,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=h.num_crops}calc_num_image_tokens_from_image_size(h,p){const{num_img_tokens:f}=this.config;return l((l(p/n)*l(h/n)+1)*f+1+(l(p/n)+1)*u(f))}get_resize_output_image_size(h,p){const f=this._num_crops,[m,x]=h.size;let g=m/x,_=1;for(;_*Math.ceil(_/g)<=f;)_+=1;_-=1;const S=Math.floor(_*336),M=Math.floor(S/g);return[S,M]}pad_image(h,p,f,m={}){const[x,g]=p,_=n*a(x/n),S=n*a(g/n),M=[1,1,1].map((w,v)=>(w-this.image_mean[v])/this.image_std[v]);return super.pad_image(h,p,{width:S,height:_},{center:!0,constant_values:M,...m})}async _call(h,{num_crops:p=null}={}){if(this._num_crops=p??(p=this.config.num_crops),p<4||u(p)%1!==0)throw new Error("num_crops must be a square number >= 4");Array.isArray(h)||(h=[h]);const f=h.length,m=await Promise.all(h.map(T=>this.preprocess(T))),x=m.map(T=>T.original_size),g=m.map(T=>T.reshaped_input_size),_=[];for(const{pixel_values:T}of m){T.unsqueeze_(0);const[E,F]=T.dims.slice(-2),I=await(0,r.interpolate_4d)(T,{size:[n,n],mode:"bicubic"});if(p>0){const z=[],G=u(p),L=l(F/G),Q=l(E/G);for(let J=0;J<G;++J)for(let ee=0;ee<G;++ee){let se,fe,ue,U;J===G-1?(fe=E-Q,U=E):(fe=J*Q,U=(J+1)*Q),ee===G-1?(se=F-L,ue=F):(se=ee*L,ue=(ee+1)*L);const k=[fe,se],j=[U,ue],re=await(0,r.slice)(T,k,j,o);z.push(re)}const q=await(0,r.interpolate_4d)((0,r.cat)(z,0),{size:[n,n],mode:"bicubic"});_.push((0,r.cat)([I,q],0))}else _.push(I)}const S=(0,r.stack)(_,0),M=g.map(T=>T.map(E=>n*a(E/n))),w=new r.Tensor("int64",M.flat(),[f,2]),v=M.map(([T,E])=>this.calc_num_image_tokens_from_image_size(E,T));return{pixel_values:S,original_sizes:x,reshaped_input_sizes:g,image_sizes:w,num_img_tokens:v}}}},"./src/models/phi3_v/processing_phi3_v.js":(i,e,t)=>{t.r(e),t.d(e,{Phi3VProcessor:()=>l});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js");t("./src/utils/image.js");const o="<|image|>",a=/<\|image_\d+\|>/g;class l extends s.Processor{async _call(c,d=null,{padding:h=!0,truncation:p=!0,num_crops:f=null}={}){Array.isArray(c)||(c=[c]);let m,x;if(d){x=await this.image_processor(d,{num_crops:f});const{num_img_tokens:g}=x,_=c.map((M,w)=>M.split(a).join(o.repeat(g[w])));m=this.tokenizer(_,{padding:h,truncation:p});const S=this.tokenizer.model.convert_tokens_to_ids([o])[0];m.input_ids.map_(M=>M==S?-M:M)}else m=this.tokenizer(c);return{...m,...x}}}Z(l,"image_processor_class",r.AutoImageProcessor),Z(l,"tokenizer_class",n.AutoTokenizer)},"./src/models/processors.js":(i,e,t)=>{t.r(e),t.d(e,{Florence2Processor:()=>s.Florence2Processor,Gemma3nProcessor:()=>r.Gemma3nProcessor,GroundingDinoProcessor:()=>n.GroundingDinoProcessor,Idefics3Processor:()=>o.Idefics3Processor,JinaCLIPProcessor:()=>l.JinaCLIPProcessor,LlavaProcessor:()=>u.LlavaProcessor,MgpstrProcessor:()=>c.MgpstrProcessor,MoonshineProcessor:()=>d.MoonshineProcessor,OwlViTProcessor:()=>h.OwlViTProcessor,PaliGemmaProcessor:()=>f.PaliGemmaProcessor,Phi3VProcessor:()=>p.Phi3VProcessor,PyAnnoteProcessor:()=>m.PyAnnoteProcessor,Qwen2VLProcessor:()=>x.Qwen2VLProcessor,SamProcessor:()=>g.SamProcessor,SmolVLMProcessor:()=>_.SmolVLMProcessor,SpeechT5Processor:()=>S.SpeechT5Processor,UltravoxProcessor:()=>M.UltravoxProcessor,VLChatProcessor:()=>a.VLChatProcessor,Wav2Vec2Processor:()=>w.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>v.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>T.WhisperProcessor});var s=t("./src/models/florence2/processing_florence2.js"),r=t("./src/models/gemma3n/processing_gemma3n.js"),n=t("./src/models/grounding_dino/processing_grounding_dino.js"),o=t("./src/models/idefics3/processing_idefics3.js"),a=t("./src/models/janus/processing_janus.js"),l=t("./src/models/jina_clip/processing_jina_clip.js"),u=t("./src/models/llava/processing_llava.js"),c=t("./src/models/mgp_str/processing_mgp_str.js"),d=t("./src/models/moonshine/processing_moonshine.js"),h=t("./src/models/owlvit/processing_owlvit.js"),p=t("./src/models/phi3_v/processing_phi3_v.js"),f=t("./src/models/paligemma/processing_paligemma.js"),m=t("./src/models/pyannote/processing_pyannote.js"),x=t("./src/models/qwen2_vl/processing_qwen2_vl.js"),g=t("./src/models/sam/processing_sam.js"),_=t("./src/models/smolvlm/processing_smolvlm.js"),S=t("./src/models/speecht5/processing_speecht5.js"),M=t("./src/models/ultravox/processing_ultravox.js"),w=t("./src/models/wav2vec2/processing_wav2vec2.js"),v=t("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),T=t("./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":(i,e,t)=>{t.r(e),t.d(e,{PvtImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":(i,e,t)=>{t.r(e),t.d(e,{PyAnnoteFeatureExtractor:()=>o});var s=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js"),n=t("./src/utils/maths.js");class o extends s.FeatureExtractor{async _call(l){(0,s.validate_audio_inputs)(l,"PyAnnoteFeatureExtractor"),l instanceof Float64Array&&(l=new Float32Array(l));const u=[1,1,l.length];return{input_values:new r.Tensor("float32",l,u)}}samples_to_frames(l){return(l-this.config.offset)/this.config.step}post_process_speaker_diarization(l,u){const c=u/this.samples_to_frames(u)/this.config.sampling_rate,d=[];for(const h of l.tolist()){const p=[];let f=-1;for(let m=0;m<h.length;++m){const x=(0,n.softmax)(h[m]),[g,_]=(0,n.max)(x),[S,M]=[m,m+1];_!==f?(f=_,p.push({id:_,start:S,end:M,score:g})):(p.at(-1).end=M,p.at(-1).score+=g)}d.push(p.map(({id:m,start:x,end:g,score:_})=>({id:m,start:x*c,end:g*c,confidence:_/(g-x)})))}return d}}},"./src/models/pyannote/processing_pyannote.js":(i,e,t)=>{t.r(e),t.d(e,{PyAnnoteProcessor:()=>n});var s=t("./src/base/processing_utils.js"),r=t("./src/models/pyannote/feature_extraction_pyannote.js");class n extends s.Processor{async _call(a){return await this.feature_extractor(a)}post_process_speaker_diarization(...a){return this.feature_extractor.post_process_speaker_diarization(...a)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}Z(n,"feature_extractor_class",r.PyAnnoteFeatureExtractor)},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":(i,e,t)=>{t.r(e),t.d(e,{Qwen2VLImageProcessor:()=>n});var s=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class n extends s.ImageProcessor{async _call(a,...l){const{pixel_values:u,original_sizes:c,reshaped_input_sizes:d}=await super._call(a,...l);let h=u;const{temporal_patch_size:p,merge_size:f,patch_size:m}=this.config;h.dims[0]===1&&(h=(0,r.cat)(Array.from({length:p},()=>h),0));const x=h.dims[0]/p,g=h.dims[1],_=Math.floor(h.dims[2]/m),S=Math.floor(h.dims[3]/m),M=h.view(x,p,g,Math.floor(_/f),f,m,Math.floor(S/f),f,m).permute(0,3,6,4,7,2,1,5,8).view(x*_*S,g*p*m*m),w=new r.Tensor("int64",[x,_,S],[1,3]);return{pixel_values:M,image_grid_thw:w,original_sizes:c,reshaped_input_sizes:d}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":(i,e,t)=>{t.r(e),t.d(e,{Qwen2VLProcessor:()=>o});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js"),n=t("./src/tokenizers.js");t("./src/utils/image.js");class o extends s.Processor{async _call(l,u=null,...c){Array.isArray(l)||(l=[l]);let d,h;if(u&&(d=await this.image_processor(u),h=d.image_grid_thw),h){let f=this.image_processor.config.merge_size**2,m=0;const x=h.tolist();l=l.map(g=>{for(;g.includes("<|image_pad|>");){const _=Number(x[m++].reduce((S,M)=>S*M,1n));g=g.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(_/f)))}return g.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(l),...d}}}Z(o,"image_processor_class",r.AutoImageProcessor),Z(o,"tokenizer_class",n.AutoTokenizer)},"./src/models/rt_detr/image_processing_rt_detr.js":(i,e,t)=>{t.r(e),t.d(e,{RTDetrImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{post_process_object_detection(...o){return(0,s.post_process_object_detection)(...o)}}},"./src/models/sam/image_processing_sam.js":(i,e,t)=>{t.r(e),t.d(e,{SamImageProcessor:()=>o});var s=t("./src/base/image_processors_utils.js"),r=t("./src/utils/core.js"),n=t("./src/utils/tensor.js");class o extends s.ImageProcessor{reshape_input_points(l,u,c,d=!1){l=structuredClone(l);let h=(0,r.calculateDimensions)(l);if(h.length===3)d||(h=[1,...h]),l=[l];else if(h.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let p=0;p<l.length;++p){let f=u[p],m=c[p],x=[m[0]/f[0],m[1]/f[1]];for(let g=0;g<l[p].length;++g)for(let _=0;_<l[p][g].length;++_)for(let S=0;S<l[p][g][_].length;++S)l[p][g][_][S]*=x[S%2]}return new n.Tensor("float32",Float32Array.from(l.flat(1/0)),h)}add_input_labels(l,u){let c=(0,r.calculateDimensions)(l);if(c.length===2)c=[1,...c],l=[l];else if(c.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(c.some((d,h)=>d!==u.dims[h]))throw Error(`The first ${c.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new n.Tensor("int64",l.flat(1/0).map(BigInt),c)}async _call(l,{input_points:u=null,input_labels:c=null,input_boxes:d=null}={}){const h=await super._call(l);if(u&&(h.input_points=this.reshape_input_points(u,h.original_sizes,h.reshaped_input_sizes)),c){if(!h.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");h.input_labels=this.add_input_labels(c,h.input_points)}return d&&(h.input_boxes=this.reshape_input_points(d,h.original_sizes,h.reshaped_input_sizes,!0)),h}async post_process_masks(l,u,c,{mask_threshold:d=0,binarize:h=!0,pad_size:p=null}={}){const f=[];p=p??this.pad_size;const m=[p.height,p.width];for(let x=0;x<u.length;++x){const g=u[x],_=c[x];let S=await(0,n.interpolate_4d)(l[x],{mode:"bilinear",size:m});if(S=S.slice(null,null,[0,_[0]],[0,_[1]]),S=await(0,n.interpolate_4d)(S,{mode:"bilinear",size:g}),h){const M=S.data,w=new Uint8Array(M.length);for(let v=0;v<M.length;++v)M[v]>d&&(w[v]=1);S=new n.Tensor("bool",w,S.dims)}f.push(S)}return f}generate_crop_boxes(l,u,{crop_n_layers:c=0,overlap_ratio:d=512/1500,points_per_crop:h=32,crop_n_points_downscale_factor:p=1}={}){}}},"./src/models/sam/processing_sam.js":(i,e,t)=>{t.r(e),t.d(e,{SamProcessor:()=>n});var s=t("./src/base/processing_utils.js"),r=t("./src/models/auto/image_processing_auto.js");class n extends s.Processor{async _call(...a){return await this.image_processor(...a)}post_process_masks(...a){return this.image_processor.post_process_masks(...a)}reshape_input_points(...a){return this.image_processor.reshape_input_points(...a)}}Z(n,"image_processor_class",r.AutoImageProcessor)},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":(i,e,t)=>{t.r(e),t.d(e,{SeamlessM4TFeatureExtractor:()=>o});var s=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js"),n=t("./src/utils/audio.js");class o extends s.FeatureExtractor{constructor(l){super(l);const u=this.config.sampling_rate,c=(0,n.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(u/2),u,null,"kaldi",!0);this.mel_filters=c,this.window=(0,n.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(l,u){return l=l.map(c=>c*32768),(0,n.spectrogram)(l,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:u,transpose:!0})}async _call(l,{padding:u=!0,pad_to_multiple_of:c=2,do_normalize_per_mel_bins:d=!0,return_attention_mask:h=!0}={}){(0,s.validate_audio_inputs)(l,"SeamlessM4TFeatureExtractor");let p=await this._extract_fbank_features(l,this.config.max_length);if(d){const[w,v]=p.dims,T=p.data;for(let E=0;E<v;++E){let F=0;for(let L=0;L<w;++L)F+=T[L*v+E];const I=F/w;let z=0;for(let L=0;L<w;++L)z+=(T[L*v+E]-I)**2;z/=w-1;const G=Math.sqrt(z+1e-7);for(let L=0;L<w;++L){const Q=L*v+E;T[Q]=(T[Q]-I)/G}}}let f;if(u){const[w,v]=p.dims,T=p.data,E=w%c;if(E>0){const F=new Float32Array(v*(w+E));F.set(T),F.fill(this.config.padding_value,T.length);const I=w+E;p=new r.Tensor(p.type,F,[I,v]),h&&(f=new r.Tensor("int64",new BigInt64Array(I),[1,I]),f.data.fill(1n,0,w))}}const[m,x]=p.dims,g=this.config.stride;if(m%g!==0)throw new Error(`The number of frames (${m}) must be a multiple of the stride (${g}).`);const S=p.view(1,Math.floor(m/g),x*g),M={input_features:S};if(h){const w=S.dims[1],v=new BigInt64Array(w);if(f){const T=f.data;for(let E=1,F=0;E<m;E+=g,++F)v[F]=T[E]}else v.fill(1n);M.attention_mask=new r.Tensor("int64",v,[1,w])}return M}}},"./src/models/segformer/image_processing_segformer.js":(i,e,t)=>{t.r(e),t.d(e,{SegformerFeatureExtractor:()=>n,SegformerImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{post_process_semantic_segmentation(...a){return(0,s.post_process_semantic_segmentation)(...a)}}class n extends r{}},"./src/models/siglip/image_processing_siglip.js":(i,e,t)=>{t.r(e),t.d(e,{SiglipImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}},"./src/models/smolvlm/image_processing_smolvlm.js":(i,e,t)=>{t.r(e),t.d(e,{SmolVLMImageProcessor:()=>s.Idefics3ImageProcessor});var s=t("./src/models/idefics3/image_processing_idefics3.js")},"./src/models/smolvlm/processing_smolvlm.js":(i,e,t)=>{t.r(e),t.d(e,{SmolVLMProcessor:()=>s.Idefics3Processor});var s=t("./src/models/idefics3/processing_idefics3.js")},"./src/models/snac/feature_extraction_snac.js":(i,e,t)=>{t.r(e),t.d(e,{SnacFeatureExtractor:()=>r});var s=t("./src/models/dac/feature_extraction_dac.js");class r extends s.DacFeatureExtractor{}},"./src/models/speecht5/feature_extraction_speecht5.js":(i,e,t)=>{t.r(e),t.d(e,{SpeechT5FeatureExtractor:()=>r});var s=t("./src/base/feature_extraction_utils.js");class r extends s.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":(i,e,t)=>{t.r(e),t.d(e,{SpeechT5Processor:()=>o});var s=t("./src/base/processing_utils.js"),r=t("./src/tokenizers.js"),n=t("./src/models/auto/feature_extraction_auto.js");class o extends s.Processor{async _call(l){return await this.feature_extractor(l)}}Z(o,"tokenizer_class",r.AutoTokenizer),Z(o,"feature_extractor_class",n.AutoFeatureExtractor)},"./src/models/swin2sr/image_processing_swin2sr.js":(i,e,t)=>{t.r(e),t.d(e,{Swin2SRImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{pad_image(o,a,l,u={}){const[c,d,h]=a;return super.pad_image(o,a,{width:d+(l-d%l)%l,height:c+(l-c%l)%l},{mode:"symmetric",center:!1,constant_values:-1,...u})}}},"./src/models/ultravox/processing_ultravox.js":(i,e,t)=>{t.r(e),t.d(e,{UltravoxProcessor:()=>o});var s=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/tokenizers.js"),n=t("./src/base/processing_utils.js");class o extends n.Processor{async _call(l,u=null,c={}){if(Array.isArray(l))throw new Error("Batched inputs are not supported yet.");let d={};if(u){const p=u.length,{input_features:f}=await this.feature_extractor(u,{...c,max_length:p}),m=Math.round(p/this.config.encoder_ds_factor+1e-4),x=1+Math.ceil(m/this.config.stack_factor);d.audio_token_len=[x],d.audio_values=f;const g=this.config.audio_placeholder;if(!l.includes(g))throw new Error(`The input text does not contain the image token ${g}.`);l=l.replaceAll(g,g.repeat(x))}return{...this.tokenizer(l,{add_special_tokens:!1,...c}),...d}}}Z(o,"tokenizer_class",r.AutoTokenizer),Z(o,"feature_extractor_class",s.AutoFeatureExtractor),Z(o,"uses_processor_config",!0)},"./src/models/vit/image_processing_vit.js":(i,e,t)=>{t.r(e),t.d(e,{ViTFeatureExtractor:()=>n,ViTImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{}class n extends r{}},"./src/models/vitmatte/image_processing_vitmatte.js":(i,e,t)=>{t.r(e),t.d(e,{VitMatteImageProcessor:()=>n});var s=t("./src/base/image_processors_utils.js"),r=t("./src/utils/tensor.js");class n extends s.ImageProcessor{async _call(a,l){Array.isArray(a)||(a=[a]),Array.isArray(l)||(l=[l]);const u=await Promise.all(a.map(h=>this.preprocess(h))),c=await Promise.all(l.map(h=>this.preprocess(h,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,r.stack)(u.map((h,p)=>(0,r.cat)([h.pixel_values,c[p].pixel_values],0)),0),original_sizes:u.map(h=>h.original_size),reshaped_input_sizes:u.map(h=>h.reshaped_input_size)}}}},"./src/models/vitpose/image_processing_vitpose.js":(i,e,t)=>{t.r(e),t.d(e,{VitPoseImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{post_process_pose_estimation(o,a,{threshold:l=null}={}){const u=o.tolist(),[c,d,h,p]=o.dims,f=[];for(let m=0;m<c;++m){const x=u[m],g=a[m],_=[];for(let S=0;S<g.length;++S){const M=g[S],w=[],v=[],T=[],E=M.at(-2)/p,F=M.at(-1)/h;for(let I=0;I<x.length;++I){let[z,G]=[0,0],L=0,Q=-1/0;const q=x[I];for(let ee=0;ee<q.length;++ee){const se=q[ee];for(let fe=0;fe<se.length;++fe){const ue=se[fe];L+=ue,Q=Math.max(Q,ue),z+=(fe+.5)*ue,G+=ee*ue}}if(l!=null&&Q<l)continue;const J=[E*z/L,F*G/L];w.push(J),T.push(I),v.push(Q)}_.push({bbox:M,scores:v,labels:T,keypoints:w})}f.push(_)}return f}}},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":(i,e,t)=>{t.r(e),t.d(e,{Wav2Vec2FeatureExtractor:()=>n});var s=t("./src/base/feature_extraction_utils.js"),r=t("./src/utils/tensor.js");class n extends s.FeatureExtractor{_zero_mean_unit_var_norm(a){const u=a.reduce((d,h)=>d+h,0)/a.length,c=a.reduce((d,h)=>d+(h-u)**2,0)/a.length;return a.map(d=>(d-u)/Math.sqrt(c+1e-7))}async _call(a){(0,s.validate_audio_inputs)(a,"Wav2Vec2FeatureExtractor"),a instanceof Float64Array&&(a=new Float32Array(a));let l=a;this.config.do_normalize&&(l=this._zero_mean_unit_var_norm(l));const u=[1,l.length];return{input_values:new r.Tensor("float32",l,u),attention_mask:new r.Tensor("int64",new BigInt64Array(l.length).fill(1n),u)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":(i,e,t)=>{t.r(e),t.d(e,{Wav2Vec2Processor:()=>o});var s=t("./src/tokenizers.js"),r=t("./src/models/auto/feature_extraction_auto.js"),n=t("./src/base/processing_utils.js");class o extends n.Processor{async _call(l){return await this.feature_extractor(l)}}Z(o,"tokenizer_class",s.AutoTokenizer),Z(o,"feature_extractor_class",r.AutoFeatureExtractor)},"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":(i,e,t)=>{t.r(e),t.d(e,{Wav2Vec2ProcessorWithLM:()=>o});var s=t("./src/tokenizers.js"),r=t("./src/models/auto/feature_extraction_auto.js"),n=t("./src/base/processing_utils.js");class o extends n.Processor{async _call(l){return await this.feature_extractor(l)}}Z(o,"tokenizer_class",s.AutoTokenizer),Z(o,"feature_extractor_class",r.AutoFeatureExtractor)},"./src/models/wespeaker/feature_extraction_wespeaker.js":(i,e,t)=>{t.r(e),t.d(e,{WeSpeakerFeatureExtractor:()=>n});var s=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var r=t("./src/utils/audio.js");class n extends s.FeatureExtractor{constructor(a){super(a);const l=this.config.sampling_rate,u=(0,r.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(l/2),l,null,"kaldi",!0);this.mel_filters=u,this.window=(0,r.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(a){return a=a.map(l=>l*32768),(0,r.spectrogram)(a,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(a){(0,s.validate_audio_inputs)(a,"WeSpeakerFeatureExtractor");const l=(await this._extract_fbank_features(a)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const u=l.mean(1).data,c=l.data,[d,h,p]=l.dims;for(let f=0;f<d;++f){const m=f*h*p,x=f*p;for(let g=0;g<h;++g){const _=m+g*p;for(let S=0;S<p;++S)c[_+S]-=u[x+S]}}}return{input_features:l}}}},"./src/models/whisper/common_whisper.js":(i,e,t)=>{t.r(e),t.d(e,{WHISPER_LANGUAGE_MAPPING:()=>r,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>n,whisper_language_to_code:()=>o});const s=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],r=new Map(s),n=new Map([...s.map(([a,l])=>[l,a]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function o(a){a=a.toLowerCase();let l=n.get(a);if(l===void 0){const u=a.match(/^<\|([a-z]{2})\|>$/);if(u&&(a=u[1]),r.has(a))l=a;else{const d=a.length===2?r.keys():r.values();throw new Error(`Language "${a}" is not supported. Must be one of: ${JSON.stringify(Array.from(d))}`)}}return l}},"./src/models/whisper/feature_extraction_whisper.js":(i,e,t)=>{t.r(e),t.d(e,{WhisperFeatureExtractor:()=>o});var s=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var r=t("./src/utils/audio.js"),n=t("./src/utils/maths.js");class o extends s.FeatureExtractor{constructor(l){var u;super(l),(u=this.config).mel_filters??(u.mel_filters=(0,r.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,r.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(l){const u=await(0,r.spectrogram)(l,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(l.length/this.config.hop_length),this.config.nb_max_frames)}),c=u.data,d=(0,n.max)(c)[0];for(let h=0;h<c.length;++h)c[h]=(Math.max(c[h],d-8)+4)/4;return u}async _call(l,{max_length:u=null}={}){(0,s.validate_audio_inputs)(l,"WhisperFeatureExtractor");let c;const d=u??this.config.n_samples;return l.length>d?(l.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),c=l.slice(0,d)):(c=new Float32Array(d),c.set(l)),{input_features:(await this._extract_fbank_features(c)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":(i,e,t)=>{t.r(e),t.d(e,{WhisperGenerationConfig:()=>r});var s=t("./src/generation/configuration_utils.js");class r extends s.GenerationConfig{constructor(){super(...arguments);Z(this,"return_timestamps",null);Z(this,"return_token_timestamps",null);Z(this,"num_frames",null);Z(this,"alignment_heads",null);Z(this,"task",null);Z(this,"language",null);Z(this,"no_timestamps_token_id",null);Z(this,"prompt_ids",null);Z(this,"is_multilingual",null);Z(this,"lang_to_id",null);Z(this,"task_to_id",null);Z(this,"max_initial_timestamp_index",1)}}},"./src/models/whisper/processing_whisper.js":(i,e,t)=>{t.r(e),t.d(e,{WhisperProcessor:()=>o});var s=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/tokenizers.js"),n=t("./src/base/processing_utils.js");class o extends n.Processor{async _call(l){return await this.feature_extractor(l)}}Z(o,"tokenizer_class",r.AutoTokenizer),Z(o,"feature_extractor_class",s.AutoFeatureExtractor)},"./src/models/yolos/image_processing_yolos.js":(i,e,t)=>{t.r(e),t.d(e,{YolosFeatureExtractor:()=>n,YolosImageProcessor:()=>r});var s=t("./src/base/image_processors_utils.js");class r extends s.ImageProcessor{post_process_object_detection(...a){return(0,s.post_process_object_detection)(...a)}}class n extends r{}},"./src/ops/registry.js":(i,e,t)=>{t.r(e),t.d(e,{TensorOpRegistry:()=>l});var s=t("./src/backends/onnx.js"),r=t("./src/utils/tensor.js"),n=t("./src/env.js");const o=n.apis.IS_BROWSER_ENV||n.apis.IS_WEBWORKER_ENV,a=async(u,c,d)=>{const h=await(0,s.createInferenceSession)(new Uint8Array(u),c);let p=Promise.resolve();return async f=>{const m=(0,s.isONNXProxy)(),x=Object.fromEntries(Object.entries(f).map(([_,S])=>[_,(m?S.clone():S).ort_tensor])),g=await(p=o?p.then(()=>h.run(x)):h.run(x));return Array.isArray(d)?d.map(_=>new r.Tensor(g[_])):new r.Tensor(g[d])}};class l{static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=a([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=a([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=a([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=a([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=a([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=a([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=a([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=a([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}Z(l,"session_options",{})},"./src/pipelines.js":(i,e,t)=>{t.r(e),t.d(e,{AudioClassificationPipeline:()=>G,AutomaticSpeechRecognitionPipeline:()=>Q,BackgroundRemovalPipeline:()=>se,DepthEstimationPipeline:()=>we,DocumentQuestionAnsweringPipeline:()=>k,FeatureExtractionPipeline:()=>I,FillMaskPipeline:()=>S,ImageClassificationPipeline:()=>J,ImageFeatureExtractionPipeline:()=>z,ImageSegmentationPipeline:()=>ee,ImageToImagePipeline:()=>re,ImageToTextPipeline:()=>q,ObjectDetectionPipeline:()=>ue,Pipeline:()=>m,QuestionAnsweringPipeline:()=>_,SummarizationPipeline:()=>w,Text2TextGenerationPipeline:()=>M,TextClassificationPipeline:()=>x,TextGenerationPipeline:()=>E,TextToAudioPipeline:()=>j,TokenClassificationPipeline:()=>g,TranslationPipeline:()=>v,ZeroShotAudioClassificationPipeline:()=>L,ZeroShotClassificationPipeline:()=>F,ZeroShotImageClassificationPipeline:()=>fe,ZeroShotObjectDetectionPipeline:()=>U,pipeline:()=>Xe});var s=t("./src/tokenizers.js"),r=t("./src/models.js"),n=t("./src/models/auto/processing_auto.js");t("./src/base/processing_utils.js");var o=t("./src/utils/generic.js"),a=t("./src/utils/core.js"),l=t("./src/utils/maths.js"),u=t("./src/utils/audio.js"),c=t("./src/utils/tensor.js"),d=t("./src/utils/image.js");async function h(Me){return Array.isArray(Me)||(Me=[Me]),await Promise.all(Me.map(X=>d.RawImage.read(X)))}async function p(Me,X){return Array.isArray(Me)||(Me=[Me]),await Promise.all(Me.map(oe=>typeof oe=="string"||oe instanceof URL?(0,u.read_audio)(oe,X):oe instanceof Float64Array?new Float32Array(oe):oe))}function f(Me,X){X&&(Me=Me.map($e=>$e|0));const[oe,K,Ce,Ee]=Me;return{xmin:oe,ymin:K,xmax:Ce,ymax:Ee}}class m extends o.Callable{constructor({task:X,model:oe,tokenizer:K=null,processor:Ce=null}){super(),this.task=X,this.model=oe,this.tokenizer=K,this.processor=Ce}async dispose(){await this.model.dispose()}}class x extends m{constructor(X){super(X)}async _call(X,{top_k:oe=1}={}){const K=this.tokenizer(X,{padding:!0,truncation:!0}),Ce=await this.model(K),Ee=this.model.config.problem_type==="multi_label_classification"?Ve=>Ve.sigmoid():Ve=>new c.Tensor("float32",(0,l.softmax)(Ve.data),Ve.dims),$e=this.model.config.id2label,Be=[];for(const Ve of Ce.logits){const We=Ee(Ve),Je=await(0,c.topk)(We,oe),it=Je[0].tolist(),Ue=Je[1].tolist().map((rt,yt)=>({label:$e?$e[rt]:`LABEL_${rt}`,score:it[yt]}));oe===1?Be.push(...Ue):Be.push(Ue)}return Array.isArray(X)||oe===1?Be:Be[0]}}class g extends m{constructor(X){super(X)}async _call(X,{ignore_labels:oe=["O"]}={}){const K=Array.isArray(X),Ce=this.tokenizer(K?X:[X],{padding:!0,truncation:!0}),$e=(await this.model(Ce)).logits,Be=this.model.config.id2label,Ve=[];for(let We=0;We<$e.dims[0];++We){const Je=Ce.input_ids[We],it=$e[We],lt=[];for(let Ue=0;Ue<it.dims[0];++Ue){const rt=it[Ue],yt=(0,l.max)(rt.data)[1],Nt=Be?Be[yt]:`LABEL_${yt}`;if(oe.includes(Nt))continue;const bt=this.tokenizer.decode([Je[Ue].item()],{skip_special_tokens:!0});if(bt==="")continue;const Ye=(0,l.softmax)(rt.data);lt.push({entity:Nt,score:Ye[yt],index:Ue,word:bt})}Ve.push(lt)}return K?Ve:Ve[0]}}class _ extends m{constructor(X){super(X)}async _call(X,oe,{top_k:K=1}={}){const Ce=this.tokenizer(X,{text_pair:oe,padding:!0,truncation:!0}),{start_logits:Ee,end_logits:$e}=await this.model(Ce),Be=Ce.input_ids.tolist(),Ve=Ce.attention_mask.tolist(),We=this.tokenizer.all_special_ids,Je=[];for(let it=0;it<Ee.dims[0];++it){const lt=Be[it],Ue=lt.findIndex(tt=>tt==this.tokenizer.sep_token_id);Ve[it].map((tt,pt)=>tt==1&&(pt===0||pt>Ue&&We.findIndex(ss=>ss==lt[pt])===-1));const rt=Ee[it].tolist(),yt=$e[it].tolist();for(let tt=1;tt<rt.length;++tt)(Ve[it]==0||tt<=Ue||We.findIndex(pt=>pt==lt[tt])!==-1)&&(rt[tt]=-1/0,yt[tt]=-1/0);const Nt=(0,l.softmax)(rt).map((tt,pt)=>[tt,pt]),bt=(0,l.softmax)(yt).map((tt,pt)=>[tt,pt]);Nt[0][0]=0,bt[0][0]=0;const Ye=(0,a.product)(Nt,bt).filter(tt=>tt[0][1]<=tt[1][1]).map(tt=>[tt[0][1],tt[1][1],tt[0][0]*tt[1][0]]).sort((tt,pt)=>pt[2]-tt[2]);for(let tt=0;tt<Math.min(Ye.length,K);++tt){const[pt,ss,Zt]=Ye[tt],_s=lt.slice(pt,ss+1),bi=this.tokenizer.decode(_s,{skip_special_tokens:!0});Je.push({answer:bi,score:Zt})}}return K===1?Je[0]:Je}}class S extends m{constructor(X){super(X)}async _call(X,{top_k:oe=5}={}){const K=this.tokenizer(X,{padding:!0,truncation:!0}),{logits:Ce}=await this.model(K),Ee=[],$e=K.input_ids.tolist();for(let Be=0;Be<$e.length;++Be){const Ve=$e[Be],We=Ve.findIndex(rt=>rt==this.tokenizer.mask_token_id);if(We===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const Je=Ce[Be][We],it=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)(Je.data),Je.dims),oe),lt=it[0].tolist(),Ue=it[1].tolist();Ee.push(Ue.map((rt,yt)=>{const Nt=Ve.slice();return Nt[We]=rt,{score:lt[yt],token:Number(rt),token_str:this.tokenizer.decode([rt]),sequence:this.tokenizer.decode(Nt,{skip_special_tokens:!0})}}))}return Array.isArray(X)?Ee:Ee[0]}}class M extends m{constructor(oe){super(oe);Z(this,"_key","generated_text")}async _call(oe,K={}){Array.isArray(oe)||(oe=[oe]),this.model.config.prefix&&(oe=oe.map(We=>this.model.config.prefix+We));const Ce=this.model.config.task_specific_params;Ce&&Ce[this.task]&&Ce[this.task].prefix&&(oe=oe.map(We=>Ce[this.task].prefix+We));const Ee=this.tokenizer,$e={padding:!0,truncation:!0};let Be;this instanceof v&&"_build_translation_inputs"in Ee?Be=Ee._build_translation_inputs(oe,$e,K):Be=Ee(oe,$e);const Ve=await this.model.generate({...Be,...K});return Ee.batch_decode(Ve,{skip_special_tokens:!0}).map(We=>({[this._key]:We}))}}class w extends M{constructor(oe){super(oe);Z(this,"_key","summary_text")}}class v extends M{constructor(oe){super(oe);Z(this,"_key","translation_text")}}function T(Me){return Array.isArray(Me)&&Me.every(X=>"role"in X&&"content"in X)}class E extends m{constructor(X){super(X)}async _call(X,oe={}){let K=!1,Ce=!1,Ee;if(typeof X=="string")Ee=X=[X];else if(Array.isArray(X)&&X.every(Ue=>typeof Ue=="string"))K=!0,Ee=X;else{if(T(X))X=[X];else if(Array.isArray(X)&&X.every(T))K=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");Ce=!0,Ee=X.map(Ue=>this.tokenizer.apply_chat_template(Ue,{tokenize:!1,add_generation_prompt:!0}))}const $e=oe.add_special_tokens??!1,Be=Ce?!1:oe.return_full_text??!0;this.tokenizer.padding_side="left";const Ve=this.tokenizer(Ee,{add_special_tokens:$e,padding:!0,truncation:!0}),We=await this.model.generate({...Ve,...oe}),Je=this.tokenizer.batch_decode(We,{skip_special_tokens:!0});let it;!Be&&Ve.input_ids.dims.at(-1)>0&&(it=this.tokenizer.batch_decode(Ve.input_ids,{skip_special_tokens:!0}).map(Ue=>Ue.length));const lt=Array.from({length:X.length},Ue=>[]);for(let Ue=0;Ue<Je.length;++Ue){const rt=Math.floor(Ue/We.dims[0]*X.length);it&&(Je[Ue]=Je[Ue].slice(it[rt])),lt[rt].push({generated_text:Ce?[...X[rt],{role:"assistant",content:Je[Ue]}]:Je[Ue]})}return!K&&lt.length===1?lt[0]:lt}}class F extends m{constructor(X){super(X),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([oe,K])=>[oe.toLowerCase(),K])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(X,oe,{hypothesis_template:K="This example is {}.",multi_label:Ce=!1}={}){const Ee=Array.isArray(X);Ee||(X=[X]),Array.isArray(oe)||(oe=[oe]);const $e=oe.map(We=>K.replace("{}",We)),Be=Ce||oe.length===1,Ve=[];for(const We of X){const Je=[];for(const Ue of $e){const rt=this.tokenizer(We,{text_pair:Ue,padding:!0,truncation:!0}),yt=await this.model(rt);Be?Je.push([yt.logits.data[this.contradiction_id],yt.logits.data[this.entailment_id]]):Je.push(yt.logits.data[this.entailment_id])}const lt=(Be?Je.map(Ue=>(0,l.softmax)(Ue)[1]):(0,l.softmax)(Je)).map((Ue,rt)=>[Ue,rt]).sort((Ue,rt)=>rt[0]-Ue[0]);Ve.push({sequence:We,labels:lt.map(Ue=>oe[Ue[1]]),scores:lt.map(Ue=>Ue[0])})}return Ee?Ve:Ve[0]}}class I extends m{constructor(X){super(X)}async _call(X,{pooling:oe="none",normalize:K=!1,quantize:Ce=!1,precision:Ee="binary"}={}){const $e=this.tokenizer(X,{padding:!0,truncation:!0}),Be=await this.model($e);let Ve=Be.last_hidden_state??Be.logits??Be.token_embeddings;switch(oe){case"none":break;case"mean":Ve=(0,c.mean_pooling)(Ve,$e.attention_mask);break;case"first_token":case"cls":Ve=Ve.slice(null,0);break;case"last_token":case"eos":Ve=Ve.slice(null,-1);break;default:throw Error(`Pooling method '${oe}' not supported.`)}return K&&(Ve=Ve.normalize(2,-1)),Ce&&(Ve=(0,c.quantize_embeddings)(Ve,Ee)),Ve}}class z extends m{constructor(X){super(X)}async _call(X,{pool:oe=null}={}){const K=await h(X),{pixel_values:Ce}=await this.processor(K),Ee=await this.model({pixel_values:Ce});let $e;if(oe){if(!("pooler_output"in Ee))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");$e=Ee.pooler_output}else $e=Ee.last_hidden_state??Ee.logits??Ee.image_embeds;return $e}}class G extends m{constructor(X){super(X)}async _call(X,{top_k:oe=5}={}){const K=this.processor.feature_extractor.config.sampling_rate,Ce=await p(X,K),Ee=this.model.config.id2label,$e=[];for(const Be of Ce){const Ve=await this.processor(Be),Je=(await this.model(Ve)).logits[0],it=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)(Je.data),Je.dims),oe),lt=it[0].tolist(),rt=it[1].tolist().map((yt,Nt)=>({label:Ee?Ee[yt]:`LABEL_${yt}`,score:lt[Nt]}));$e.push(rt)}return Array.isArray(X)?$e:$e[0]}}class L extends m{constructor(X){super(X)}async _call(X,oe,{hypothesis_template:K="This is a sound of {}."}={}){const Ce=!Array.isArray(X);Ce&&(X=[X]);const Ee=oe.map(Je=>K.replace("{}",Je)),$e=this.tokenizer(Ee,{padding:!0,truncation:!0}),Be=this.processor.feature_extractor.config.sampling_rate,Ve=await p(X,Be),We=[];for(const Je of Ve){const it=await this.processor(Je),lt=await this.model({...$e,...it}),Ue=(0,l.softmax)(lt.logits_per_audio.data);We.push([...Ue].map((rt,yt)=>({score:rt,label:oe[yt]})))}return Ce?We[0]:We}}class Q extends m{constructor(X){super(X)}async _call(X,oe={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(X,oe);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(X,oe);case"moonshine":return this._call_moonshine(X,oe);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(X,oe){oe.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),oe.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const K=!Array.isArray(X);K&&(X=[X]);const Ce=this.processor.feature_extractor.config.sampling_rate,Ee=await p(X,Ce),$e=[];for(const Be of Ee){const Ve=await this.processor(Be),Je=(await this.model(Ve)).logits[0],it=[];for(const Ue of Je)it.push((0,l.max)(Ue.data)[1]);const lt=this.tokenizer.decode(it);$e.push({text:lt})}return K?$e[0]:$e}async _call_whisper(X,oe){const K=oe.return_timestamps??!1,Ce=oe.chunk_length_s??0,Ee=oe.force_full_sequences??!1;let $e=oe.stride_length_s??null;const Be={...oe};K==="word"&&(Be.return_token_timestamps=!0,Be.return_timestamps=!1);const Ve=!Array.isArray(X);Ve&&(X=[X]);const We=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,Je=this.processor.feature_extractor.config.hop_length,it=this.processor.feature_extractor.config.sampling_rate,lt=await p(X,it),Ue=[];for(const rt of lt){let yt=[];if(Ce>0){if($e===null)$e=Ce/6;else if(Ce<=$e)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const Ye=it*Ce,tt=it*$e,pt=Ye-2*tt;let ss=0;for(;;){const Zt=ss+Ye,_s=rt.subarray(ss,Zt),bi=await this.processor(_s),ti=ss===0,$t=Zt>=rt.length;if(yt.push({stride:[_s.length,ti?0:tt,$t?0:tt],input_features:bi.input_features,is_last:$t}),$t)break;ss+=pt}}else yt=[{stride:[rt.length,0,0],input_features:(await this.processor(rt)).input_features,is_last:!0}];for(const Ye of yt){Be.num_frames=Math.floor(Ye.stride[0]/Je);const tt=await this.model.generate({inputs:Ye.input_features,...Be});K==="word"?(Ye.tokens=tt.sequences.tolist()[0],Ye.token_timestamps=tt.token_timestamps.tolist()[0].map(pt=>(0,l.round)(pt,2))):Ye.tokens=tt[0].tolist(),Ye.stride=Ye.stride.map(pt=>pt/it)}const[Nt,bt]=this.tokenizer._decode_asr(yt,{time_precision:We,return_timestamps:K,force_full_sequences:Ee});Ue.push({text:Nt,...bt})}return Ve?Ue[0]:Ue}async _call_moonshine(X,oe){const K=!Array.isArray(X);K&&(X=[X]);const Ce=this.processor.feature_extractor.config.sampling_rate,Ee=await p(X,Ce),$e=[];for(const Be of Ee){const Ve=await this.processor(Be),We=Math.floor(Be.length/Ce)*6,Je=await this.model.generate({max_new_tokens:We,...oe,...Ve}),it=this.processor.batch_decode(Je,{skip_special_tokens:!0})[0];$e.push({text:it})}return K?$e[0]:$e}}class q extends m{constructor(X){super(X)}async _call(X,oe={}){const K=Array.isArray(X),Ce=await h(X),{pixel_values:Ee}=await this.processor(Ce),$e=[];for(const Be of Ee){Be.dims=[1,...Be.dims];const Ve=await this.model.generate({inputs:Be,...oe}),We=this.tokenizer.batch_decode(Ve,{skip_special_tokens:!0}).map(Je=>({generated_text:Je.trim()}));$e.push(We)}return K?$e:$e[0]}}class J extends m{constructor(X){super(X)}async _call(X,{top_k:oe=5}={}){const K=await h(X),{pixel_values:Ce}=await this.processor(K),Ee=await this.model({pixel_values:Ce}),$e=this.model.config.id2label,Be=[];for(const Ve of Ee.logits){const We=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)(Ve.data),Ve.dims),oe),Je=We[0].tolist(),lt=We[1].tolist().map((Ue,rt)=>({label:$e?$e[Ue]:`LABEL_${Ue}`,score:Je[rt]}));Be.push(lt)}return Array.isArray(X)?Be:Be[0]}}class ee extends m{constructor(X){super(X),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(X,{threshold:oe=.5,mask_threshold:K=.5,overlap_mask_area_threshold:Ce=.8,label_ids_to_fuse:Ee=null,target_sizes:$e=null,subtask:Be=null}={}){if(Array.isArray(X)&&X.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const We=await h(X),Je=We.map(Ye=>[Ye.height,Ye.width]),it=await this.processor(We),{inputNames:lt,outputNames:Ue}=this.model.sessions.model;if(!lt.includes("pixel_values")){if(lt.length!==1)throw Error(`Expected a single input name, but got ${lt.length} inputs: ${lt}.`);const Ye=lt[0];if(Ye in it)throw Error(`Input name ${Ye} already exists in the inputs.`);it[Ye]=it.pixel_values}const rt=await this.model(it);let yt=null;if(Be!==null)yt=this.subtasks_mapping[Be];else if(this.processor.image_processor){for(const[Ye,tt]of Object.entries(this.subtasks_mapping))if(tt in this.processor.image_processor){yt=this.processor.image_processor[tt].bind(this.processor.image_processor),Be=Ye;break}}const Nt=this.model.config.id2label,bt=[];if(Be)if(Be==="panoptic"||Be==="instance"){const Ye=yt(rt,oe,K,Ce,Ee,$e??Je)[0],tt=Ye.segmentation;for(const pt of Ye.segments_info){const ss=new Uint8ClampedArray(tt.data.length);for(let _s=0;_s<tt.data.length;++_s)tt.data[_s]===pt.id&&(ss[_s]=255);const Zt=new d.RawImage(ss,tt.dims[1],tt.dims[0],1);bt.push({score:pt.score,label:Nt[pt.label_id],mask:Zt})}}else if(Be==="semantic"){const{segmentation:Ye,labels:tt}=yt(rt,$e??Je)[0];for(const pt of tt){const ss=new Uint8ClampedArray(Ye.data.length);for(let _s=0;_s<Ye.data.length;++_s)Ye.data[_s]===pt&&(ss[_s]=255);const Zt=new d.RawImage(ss,Ye.dims[1],Ye.dims[0],1);bt.push({score:null,label:Nt[pt],mask:Zt})}}else throw Error(`Subtask ${Be} not supported.`);else{const tt=rt[Ue[0]];for(let pt=0;pt<Je.length;++pt){const ss=Je[pt],Zt=tt[pt];Zt.data.some(bi=>bi<-1e-5||bi>1+1e-5)&&Zt.sigmoid_();const _s=await d.RawImage.fromTensor(Zt.mul_(255).to("uint8")).resize(ss[1],ss[0]);bt.push({label:null,score:null,mask:_s})}}return bt}}class se extends ee{constructor(X){super(X)}async _call(X,oe={}){if(Array.isArray(X)&&X.length!==1)throw Error("Background removal pipeline currently only supports a batch size of 1.");const Ce=await h(X),Ee=await super._call(X,oe);return Ce.map((Be,Ve)=>{const We=Be.clone();return We.putAlpha(Ee[Ve].mask),We})}}class fe extends m{constructor(X){super(X)}async _call(X,oe,{hypothesis_template:K="This is a photo of {}"}={}){const Ce=Array.isArray(X),Ee=await h(X),$e=oe.map(lt=>K.replace("{}",lt)),Be=this.tokenizer($e,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:Ve}=await this.processor(Ee),We=await this.model({...Be,pixel_values:Ve}),Je=this.model.config.model_type==="siglip"?lt=>lt.sigmoid().data:lt=>(0,l.softmax)(lt.data),it=[];for(const lt of We.logits_per_image){const rt=[...Je(lt)].map((yt,Nt)=>({score:yt,label:oe[Nt]}));rt.sort((yt,Nt)=>Nt.score-yt.score),it.push(rt)}return Ce?it:it[0]}}class ue extends m{constructor(X){super(X)}async _call(X,{threshold:oe=.9,percentage:K=!1}={}){const Ce=Array.isArray(X);if(Ce&&X.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const Ee=await h(X),$e=K?null:Ee.map(Ue=>[Ue.height,Ue.width]),{pixel_values:Be,pixel_mask:Ve}=await this.processor(Ee),We=await this.model({pixel_values:Be,pixel_mask:Ve}),Je=this.processor.image_processor.post_process_object_detection(We,oe,$e),it=this.model.config.id2label,lt=Je.map(Ue=>Ue.boxes.map((rt,yt)=>({score:Ue.scores[yt],label:it[Ue.classes[yt]],box:f(rt,!K)})));return Ce?lt:lt[0]}}class U extends m{constructor(X){super(X)}async _call(X,oe,{threshold:K=.1,top_k:Ce=null,percentage:Ee=!1}={}){const $e=Array.isArray(X),Be=await h(X),Ve=this.tokenizer(oe,{padding:!0,truncation:!0}),We=await this.processor(Be),Je=[];for(let it=0;it<Be.length;++it){const lt=Be[it],Ue=Ee?null:[[lt.height,lt.width]],rt=We.pixel_values[it].unsqueeze_(0),yt=await this.model({...Ve,pixel_values:rt});let Nt;if("post_process_grounded_object_detection"in this.processor){const bt=this.processor.post_process_grounded_object_detection(yt,Ve.input_ids,{box_threshold:K,text_threshold:K,target_sizes:Ue})[0];Nt=bt.boxes.map((Ye,tt)=>({score:bt.scores[tt],label:bt.labels[tt],box:f(Ye,!Ee)}))}else{const bt=this.processor.image_processor.post_process_object_detection(yt,K,Ue,!0)[0];Nt=bt.boxes.map((Ye,tt)=>({score:bt.scores[tt],label:oe[bt.classes[tt]],box:f(Ye,!Ee)}))}Nt.sort((bt,Ye)=>Ye.score-bt.score),Ce!==null&&(Nt=Nt.slice(0,Ce)),Je.push(Nt)}return $e?Je:Je[0]}}class k extends m{constructor(X){super(X)}async _call(X,oe,K={}){const Ce=(await h(X))[0],{pixel_values:Ee}=await this.processor(Ce),$e=`<s_docvqa><s_question>${oe}</s_question><s_answer>`,Be=this.tokenizer($e,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,Ve=await this.model.generate({inputs:Ee,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:Be,...K}),Je=this.tokenizer.batch_decode(Ve)[0].match(/<s_answer>(.*?)<\/s_answer>/);let it=null;return Je&&Je.length>=2&&(it=Je[1].trim()),[{answer:it}]}}class j extends m{constructor(oe){super(oe);Z(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=oe.vocoder??null}async _call(oe,{speaker_embeddings:K=null}={}){return this.processor?this._call_text_to_spectrogram(oe,{speaker_embeddings:K}):this._call_text_to_waveform(oe)}async _call_text_to_waveform(oe){const K=this.tokenizer(oe,{padding:!0,truncation:!0}),{waveform:Ce}=await this.model(K),Ee=this.model.config.sampling_rate;return new u.RawAudio(Ce.data,Ee)}async _call_text_to_spectrogram(oe,{speaker_embeddings:K}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await r.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof K=="string"||K instanceof URL)&&(K=new Float32Array(await(await fetch(K)).arrayBuffer())),K instanceof Float32Array)K=new c.Tensor("float32",K,[1,K.length]);else if(!(K instanceof c.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:Ce}=this.tokenizer(oe,{padding:!0,truncation:!0}),{waveform:Ee}=await this.model.generate_speech(Ce,K,{vocoder:this.vocoder}),$e=this.processor.feature_extractor.config.sampling_rate;return new u.RawAudio(Ee.data,$e)}}class re extends m{constructor(X){super(X)}async _call(X){const oe=await h(X),K=await this.processor(oe),Ce=await this.model(K),Ee=[];for(const $e of Ce.reconstruction){const Be=$e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");Ee.push(d.RawImage.fromTensor(Be))}return Ee.length>1?Ee:Ee[0]}}class we extends m{constructor(X){super(X)}async _call(X){const oe=await h(X),K=await this.processor(oe),{predicted_depth:Ce}=await this.model(K),Ee=[];for(let $e=0;$e<oe.length;++$e){const Be=Ce[$e],[Ve,We]=Be.dims.slice(-2),[Je,it]=oe[$e].size,lt=(await(0,c.interpolate_4d)(Be.view(1,1,Ve,We),{size:[it,Je],mode:"bilinear"})).view(it,Je),Ue=lt.min().item(),rt=lt.max().item(),yt=lt.sub(Ue).div_(rt-Ue).mul_(255).to("uint8").unsqueeze(0),Nt=d.RawImage.fromTensor(yt);Ee.push({predicted_depth:lt,depth:Nt})}return Ee.length>1?Ee:Ee[0]}}const de=Object.freeze({"text-classification":{tokenizer:s.AutoTokenizer,pipeline:x,model:r.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:s.AutoTokenizer,pipeline:g,model:r.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:s.AutoTokenizer,pipeline:_,model:r.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:s.AutoTokenizer,pipeline:S,model:r.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:s.AutoTokenizer,pipeline:w,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:s.AutoTokenizer,pipeline:v,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:s.AutoTokenizer,pipeline:M,model:r.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:s.AutoTokenizer,pipeline:E,model:r.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:s.AutoTokenizer,pipeline:F,model:r.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:G,model:r.AutoModelForAudioClassification,processor:n.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:s.AutoTokenizer,pipeline:L,model:r.AutoModel,processor:n.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:s.AutoTokenizer,pipeline:Q,model:[r.AutoModelForSpeechSeq2Seq,r.AutoModelForCTC],processor:n.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:s.AutoTokenizer,pipeline:j,model:[r.AutoModelForTextToWaveform,r.AutoModelForTextToSpectrogram],processor:[n.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:s.AutoTokenizer,pipeline:q,model:r.AutoModelForVision2Seq,processor:n.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:J,model:r.AutoModelForImageClassification,processor:n.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:ee,model:[r.AutoModelForImageSegmentation,r.AutoModelForSemanticSegmentation,r.AutoModelForUniversalSegmentation],processor:n.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:se,model:[r.AutoModelForImageSegmentation,r.AutoModelForSemanticSegmentation,r.AutoModelForUniversalSegmentation],processor:n.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:s.AutoTokenizer,pipeline:fe,model:r.AutoModel,processor:n.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:ue,model:r.AutoModelForObjectDetection,processor:n.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:s.AutoTokenizer,pipeline:U,model:r.AutoModelForZeroShotObjectDetection,processor:n.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:s.AutoTokenizer,pipeline:k,model:r.AutoModelForDocumentQuestionAnswering,processor:n.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:re,model:r.AutoModelForImageToImage,processor:n.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:we,model:r.AutoModelForDepthEstimation,processor:n.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:s.AutoTokenizer,pipeline:I,model:r.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:n.AutoProcessor,pipeline:z,model:[r.AutoModelForImageFeatureExtraction,r.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),Pe=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Xe(Me,X=null,{progress_callback:oe=null,config:K=null,cache_dir:Ce=null,local_files_only:Ee=!1,revision:$e="main",device:Be=null,dtype:Ve=null,subfolder:We="onnx",use_external_data_format:Je=null,model_file_name:it=null,session_options:lt={}}={}){Me=Pe[Me]??Me;const Ue=de[Me.split("_",1)[0]];if(!Ue)throw Error(`Unsupported pipeline: ${Me}. Must be one of [${Object.keys(de)}]`);X||(X=Ue.default.model,console.log(`No model specified. Using default model: "${X}".`));const rt={progress_callback:oe,config:K,cache_dir:Ce,local_files_only:Ee,revision:$e,device:Be,dtype:Ve,subfolder:We,use_external_data_format:Je,model_file_name:it,session_options:lt},yt=new Map([["tokenizer",Ue.tokenizer],["model",Ue.model],["processor",Ue.processor]]),Nt=await et(yt,X,rt);Nt.task=Me,(0,a.dispatchCallback)(oe,{status:"ready",task:Me,model:X});const bt=Ue.pipeline;return new bt(Nt)}async function et(Me,X,oe){const K=Object.create(null),Ce=[];for(const[Ee,$e]of Me.entries()){if(!$e)continue;let Be;Array.isArray($e)?Be=new Promise(async(Ve,We)=>{var it,lt;let Je;for(const Ue of $e){if(Ue===null){Ve(null);return}try{Ve(await Ue.from_pretrained(X,oe));return}catch(rt){if((it=rt.message)!=null&&it.includes("Unsupported model type"))Je=rt;else if((lt=rt.message)!=null&&lt.includes("Could not locate file"))Je=rt;else{We(rt);return}}}We(Je)}):Be=$e.from_pretrained(X,oe),K[Ee]=Be,Ce.push(Be)}await Promise.all(Ce);for(const[Ee,$e]of Object.entries(K))K[Ee]=await $e;return K}},"./src/tokenizers.js":(i,e,t)=>{t.r(e),t.d(e,{AlbertTokenizer:()=>ds,AutoTokenizer:()=>el,BartTokenizer:()=>Zn,BertTokenizer:()=>Ut,BlenderbotSmallTokenizer:()=>Ya,BlenderbotTokenizer:()=>Xa,BloomTokenizer:()=>eo,CLIPTokenizer:()=>Ha,CamembertTokenizer:()=>Zr,CodeGenTokenizer:()=>sn,CodeLlamaTokenizer:()=>ki,CohereTokenizer:()=>Za,ConvBertTokenizer:()=>wi,DebertaTokenizer:()=>_t,DebertaV2Tokenizer:()=>ys,DistilBertTokenizer:()=>Qi,ElectraTokenizer:()=>Jr,EsmTokenizer:()=>wt,FalconTokenizer:()=>je,GPT2Tokenizer:()=>dr,GPTNeoXTokenizer:()=>dt,GemmaTokenizer:()=>en,Grok1Tokenizer:()=>tn,HerbertTokenizer:()=>Is,LlamaTokenizer:()=>to,M2M100Tokenizer:()=>ai,MBart50Tokenizer:()=>Sn,MBartTokenizer:()=>Lr,MPNetTokenizer:()=>ir,MarianTokenizer:()=>qa,MgpstrTokenizer:()=>Ja,MobileBertTokenizer:()=>Ct,NllbTokenizer:()=>hr,NougatTokenizer:()=>ua,PreTrainedTokenizer:()=>Ne,Qwen2Tokenizer:()=>xs,RoFormerTokenizer:()=>$s,RobertaTokenizer:()=>Jn,SiglipTokenizer:()=>so,SpeechT5Tokenizer:()=>An,SqueezeBertTokenizer:()=>Mt,T5Tokenizer:()=>Qn,TokenizerModel:()=>z,VitsTokenizer:()=>Qa,Wav2Vec2CTCTokenizer:()=>Ka,WhisperTokenizer:()=>fi,XLMRobertaTokenizer:()=>En,XLMTokenizer:()=>vn,is_chinese_char:()=>S});var s=t("./src/utils/generic.js"),r=t("./src/utils/core.js"),n=t("./src/utils/hub.js"),o=t("./src/utils/maths.js"),a=t("./src/utils/tensor.js"),l=t("./src/utils/data-structures.js"),u=t("./node_modules/@huggingface/jinja/dist/index.js"),c=t("./src/models/whisper/common_whisper.js");async function d(ye,R){const W=await Promise.all([(0,n.getModelJSON)(ye,"tokenizer.json",!0,R),(0,n.getModelJSON)(ye,"tokenizer_config.json",!0,R)]);return R.legacy!==null&&(W[1].legacy=R.legacy),W}function h(ye,R){const W=[];let te=0;for(const he of ye.matchAll(R)){const _e=he[0];te<he.index&&W.push(ye.slice(te,he.index)),_e.length>0&&W.push(_e),te=he.index+_e.length}return te<ye.length&&W.push(ye.slice(te)),W}function p(ye,R=!0){if(ye.Regex!==void 0){let W=ye.Regex.replace(/\\([#&~])/g,"$1");for(const[te,he]of F)W=W.replaceAll(te,he);return new RegExp(W,"gu")}else if(ye.String!==void 0){const W=(0,r.escapeRegExp)(ye.String);return new RegExp(R?W:`(${W})`,"gu")}else return console.warn("Unknown pattern type:",ye),null}function f(ye){return new Map(Object.entries(ye))}function m(ye){const R=ye.dims;switch(R.length){case 1:return ye.tolist();case 2:if(R[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return ye.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${R.length}.`)}}function x(ye){return ye.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function g(ye){return ye.replace(new RegExp("\\p{M}","gu"),"")}function _(ye){return g(ye.toLowerCase())}function S(ye){return ye>=19968&&ye<=40959||ye>=13312&&ye<=19903||ye>=131072&&ye<=173791||ye>=173824&&ye<=177983||ye>=177984&&ye<=178207||ye>=178208&&ye<=183983||ye>=63744&&ye<=64255||ye>=194560&&ye<=195103}function M(ye,R,W){const te=[];let he=0;for(;he<ye.length;){if(te.push(ye[he]),(R.get(ye[he])??W)!==W){++he;continue}for(;++he<ye.length&&(R.get(ye[he])??W)===W;)R.get(te.at(-1))!==W&&(te[te.length-1]+=ye[he])}return te}function w(ye){return ye.match(/\S+/g)||[]}const v="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",T=new RegExp(`^[${v}]+$`,"gu"),E=".,!?…。，、।۔،",F=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${E}])]+`,` ?[^\\s${E}]+`]]);class I{constructor(R){this.content=R.content,this.id=R.id,this.single_word=R.single_word??!1,this.lstrip=R.lstrip??!1,this.rstrip=R.rstrip??!1,this.special=R.special??!1,this.normalized=R.normalized??null}}class z extends s.Callable{constructor(R){super(),this.config=R,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(R,...W){switch(R.type){case"WordPiece":return new G(R);case"Unigram":return new L(R,...W);case"BPE":return new J(R);default:if(R.vocab)return Array.isArray(R.vocab)?new L(R,...W):Object.hasOwn(R,"continuing_subword_prefix")&&Object.hasOwn(R,"unk_token")?Object.hasOwn(R,"merges")?new J(R):new G(R):new ee(R,...W);throw new Error(`Unknown TokenizerModel type: ${R.type}`)}}_call(R){return R=this.encode(R),this.fuse_unk&&(R=M(R,this.tokens_to_ids,this.unk_token_id)),R}encode(R){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(R){return R.map(W=>this.tokens_to_ids.get(W)??this.unk_token_id)}convert_ids_to_tokens(R){return R.map(W=>this.vocab[W]??this.unk_token)}}class G extends z{constructor(R){super(R),this.tokens_to_ids=f(R.vocab),this.unk_token_id=this.tokens_to_ids.get(R.unk_token),this.unk_token=R.unk_token,this.max_input_chars_per_word=R.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[W,te]of this.tokens_to_ids)this.vocab[te]=W}encode(R){const W=[];for(const te of R){const he=[...te];if(he.length>this.max_input_chars_per_word){W.push(this.unk_token);continue}let _e=!1,Fe=0;const Qe=[];for(;Fe<he.length;){let ut=he.length,nt=null;for(;Fe<ut;){let ft=he.slice(Fe,ut).join("");if(Fe>0&&(ft=this.config.continuing_subword_prefix+ft),this.tokens_to_ids.has(ft)){nt=ft;break}--ut}if(nt===null){_e=!0;break}Qe.push(nt),Fe=ut}_e?W.push(this.unk_token):W.push(...Qe)}return W}}class L extends z{constructor(R,W){super(R);const te=R.vocab.length;this.vocab=new Array(te),this.scores=new Array(te);for(let he=0;he<te;++he)[this.vocab[he],this.scores[he]]=R.vocab[he];this.unk_token_id=R.unk_id,this.unk_token=this.vocab[R.unk_id],this.tokens_to_ids=new Map(this.vocab.map((he,_e)=>[he,_e])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=W.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,o.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new l.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(R){const W=R.chars,te=1;let he=0;for(;he<W.length;){let _e=!1;const Fe=W.slice(he).join(""),Qe=this.trie.commonPrefixSearch(Fe);for(const ut of Qe){const nt=this.tokens_to_ids.get(ut),ft=this.scores[nt],Lt=(0,r.len)(ut);R.insert(he,Lt,ft,nt),!_e&&Lt===te&&(_e=!0)}_e||R.insert(he,te,this.unk_score,this.unk_token_id),he+=te}}tokenize(R){const W=new l.TokenLattice(R,this.bos_token_id,this.eos_token_id);return this.populateNodes(W),W.tokens()}encode(R){const W=[];for(const te of R){const he=this.tokenize(te);W.push(...he)}return W}}const Q=(()=>{const ye=[...Array.from({length:94},(he,_e)=>_e+33),...Array.from({length:12},(he,_e)=>_e+161),...Array.from({length:82},(he,_e)=>_e+174)],R=ye.slice();let W=0;for(let he=0;he<256;++he)ye.includes(he)||(ye.push(he),R.push(256+W),W+=1);const te=R.map(he=>String.fromCharCode(he));return Object.fromEntries(ye.map((he,_e)=>[he,te[_e]]))})(),q=(0,r.reverseDictionary)(Q);class J extends z{constructor(R){super(R),this.tokens_to_ids=f(R.vocab),this.unk_token_id=this.tokens_to_ids.get(R.unk_token),this.unk_token=R.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[te,he]of this.tokens_to_ids)this.vocab[he]=te;const W=Array.isArray(R.merges[0]);this.merges=W?R.merges:R.merges.map(te=>te.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((te,he)=>[JSON.stringify(te),he])),this.end_of_word_suffix=R.end_of_word_suffix,this.continuing_subword_suffix=R.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new l.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(R){if(R.length===0)return[];const W=this.cache.get(R);if(W!==void 0)return W;const te=Array.from(R);this.end_of_word_suffix&&(te[te.length-1]+=this.end_of_word_suffix);let he=[];if(te.length>1){const _e=new l.PriorityQueue((ut,nt)=>ut.score<nt.score);let Fe={token:te[0],bias:0,prev:null,next:null},Qe=Fe;for(let ut=1;ut<te.length;++ut){const nt={bias:ut/te.length,token:te[ut],prev:Qe,next:null};Qe.next=nt,this._add_node(_e,Qe),Qe=nt}for(;!_e.isEmpty();){const ut=_e.pop();if(ut.deleted||!ut.next||ut.next.deleted)continue;if(ut.deleted=!0,ut.next.deleted=!0,ut.prev){const ft={...ut.prev};ut.prev.deleted=!0,ut.prev=ft,ft.prev?ft.prev.next=ft:Fe=ft}const nt={token:ut.token+ut.next.token,bias:ut.bias,prev:ut.prev,next:ut.next.next};nt.prev?(nt.prev.next=nt,this._add_node(_e,nt.prev)):Fe=nt,nt.next&&(nt.next.prev=nt,this._add_node(_e,nt))}for(let ut=Fe;ut!==null;ut=ut.next)he.push(ut.token)}else he=te;if(this.continuing_subword_suffix)for(let _e=0;_e<he.length-1;++_e)he[_e]+=this.continuing_subword_suffix;return R.length<this.max_length_to_cache&&this.cache.put(R,he),he}_add_node(R,W){const te=this.bpe_ranks.get(JSON.stringify([W.token,W.next.token]));te!==void 0&&(W.score=te+W.bias,R.push(W))}encode(R){const W=[];for(const te of R){if(this.ignore_merges&&this.tokens_to_ids.has(te)){W.push(te);continue}const he=this.bpe(te);for(const _e of he)if(this.tokens_to_ids.has(_e))W.push(_e);else if(this.byte_fallback){const Fe=Array.from(this.text_encoder.encode(_e)).map(Qe=>`<0x${Qe.toString(16).toUpperCase().padStart(2,"0")}>`);Fe.every(Qe=>this.tokens_to_ids.has(Qe))?W.push(...Fe):W.push(this.unk_token)}else W.push(this.unk_token)}return W}}class ee extends z{constructor(R,W){super(R),this.tokens_to_ids=f(W.target_lang?R.vocab[W.target_lang]:R.vocab),this.bos_token=W.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=W.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=W.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=W.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[te,he]of this.tokens_to_ids)this.vocab[he]=te}encode(R){return R}}class se extends s.Callable{constructor(R){super(),this.config=R}static fromConfig(R){if(R===null)return null;switch(R.type){case"BertNormalizer":return new Me(R);case"Precompiled":return new $t(R);case"Sequence":return new et(R);case"Replace":return new fe(R);case"NFC":return new U(R);case"NFD":return new k(R);case"NFKC":return new j(R);case"NFKD":return new re(R);case"Strip":return new we(R);case"StripAccents":return new de(R);case"Lowercase":return new Pe(R);case"Prepend":return new Xe(R);default:throw new Error(`Unknown Normalizer type: ${R.type}`)}}normalize(R){throw Error("normalize should be implemented in subclass.")}_call(R){return this.normalize(R)}}class fe extends se{normalize(R){const W=p(this.config.pattern);return W===null?R:R.replaceAll(W,this.config.content)}}class ue extends se{constructor(){super(...arguments);Z(this,"form")}normalize(W){return W=W.normalize(this.form),W}}class U extends ue{constructor(){super(...arguments);Z(this,"form","NFC")}}class k extends ue{constructor(){super(...arguments);Z(this,"form","NFD")}}class j extends ue{constructor(){super(...arguments);Z(this,"form","NFKC")}}class re extends ue{constructor(){super(...arguments);Z(this,"form","NFKD")}}class we extends se{normalize(R){return this.config.strip_left&&this.config.strip_right?R=R.trim():(this.config.strip_left&&(R=R.trimStart()),this.config.strip_right&&(R=R.trimEnd())),R}}class de extends se{normalize(R){return R=g(R),R}}class Pe extends se{normalize(R){return R=R.toLowerCase(),R}}class Xe extends se{normalize(R){return R=this.config.prepend+R,R}}class et extends se{constructor(R){super(R),this.normalizers=R.normalizers.map(W=>se.fromConfig(W))}normalize(R){return this.normalizers.reduce((W,te)=>te.normalize(W),R)}}class Me extends se{_tokenize_chinese_chars(R){const W=[];for(let te=0;te<R.length;++te){const he=R[te],_e=he.charCodeAt(0);S(_e)?(W.push(" "),W.push(he),W.push(" ")):W.push(he)}return W.join("")}stripAccents(R){return R.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(R){switch(R){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(R)}}_clean_text(R){const W=[];for(const te of R){const he=te.charCodeAt(0);he===0||he===65533||this._is_control(te)||(/^\s$/.test(te)?W.push(" "):W.push(te))}return W.join("")}normalize(R){return this.config.clean_text&&(R=this._clean_text(R)),this.config.handle_chinese_chars&&(R=this._tokenize_chinese_chars(R)),this.config.lowercase?(R=R.toLowerCase(),this.config.strip_accents!==!1&&(R=this.stripAccents(R))):this.config.strip_accents&&(R=this.stripAccents(R)),R}}class X extends s.Callable{static fromConfig(R){if(R===null)return null;switch(R.type){case"BertPreTokenizer":return new oe(R);case"Sequence":return new Qr(R);case"Whitespace":return new O(R);case"WhitespaceSplit":return new le(R);case"Metaspace":return new bi(R);case"ByteLevel":return new K(R);case"Split":return new Ce(R);case"Punctuation":return new Ee(R);case"Digits":return new $e(R);case"Replace":return new V(R);default:throw new Error(`Unknown PreTokenizer type: ${R.type}`)}}pre_tokenize_text(R,W){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(R,W){return(Array.isArray(R)?R.map(te=>this.pre_tokenize_text(te,W)):this.pre_tokenize_text(R,W)).flat()}_call(R,W){return this.pre_tokenize(R,W)}}class oe extends X{constructor(R){super(),this.pattern=new RegExp(`[^\\s${v}]+|[${v}]`,"gu")}pre_tokenize_text(R,W){return R.trim().match(this.pattern)||[]}}class K extends X{constructor(R){super(),this.config=R,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=Q,this.text_encoder=new TextEncoder}pre_tokenize_text(R,W){return this.add_prefix_space&&!R.startsWith(" ")&&(R=" "+R),(this.use_regex?R.match(this.pattern)||[]:[R]).map(he=>Array.from(this.text_encoder.encode(he),_e=>this.byte_encoder[_e]).join(""))}}class Ce extends X{constructor(R){super(),this.config=R,this.pattern=p(this.config.pattern,this.config.invert)}pre_tokenize_text(R,W){var te;return this.pattern===null?[]:this.config.invert?R.match(this.pattern)||[]:((te=this.config.behavior)==null?void 0:te.toLowerCase())==="removed"?R.split(this.pattern).filter(he=>he):h(R,this.pattern)}}class Ee extends X{constructor(R){super(),this.config=R,this.pattern=new RegExp(`[^${v}]+|[${v}]+`,"gu")}pre_tokenize_text(R,W){return R.match(this.pattern)||[]}}class $e extends X{constructor(R){super(),this.config=R;const W=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(W,"gu")}pre_tokenize_text(R,W){return R.match(this.pattern)||[]}}class Be extends s.Callable{constructor(R){super(),this.config=R}static fromConfig(R){if(R===null)return null;switch(R.type){case"TemplateProcessing":return new Je(R);case"ByteLevel":return new it(R);case"RobertaProcessing":return new We(R);case"BertProcessing":return new Ve(R);case"Sequence":return new lt(R);default:throw new Error(`Unknown PostProcessor type: ${R.type}`)}}post_process(R,...W){throw Error("post_process should be implemented in subclass.")}_call(R,...W){return this.post_process(R,...W)}}class Ve extends Be{constructor(R){super(R),this.cls=R.cls[0],this.sep=R.sep[0]}post_process(R,W=null,{add_special_tokens:te=!0}={}){te&&(R=(0,r.mergeArrays)([this.cls],R,[this.sep]));let he=new Array(R.length).fill(0);if(W!==null){const _e=te&&this instanceof We?[this.sep]:[],Fe=te?[this.sep]:[];R=(0,r.mergeArrays)(R,_e,W,Fe),he=(0,r.mergeArrays)(he,new Array(W.length+_e.length+Fe.length).fill(1))}return{tokens:R,token_type_ids:he}}}class We extends Ve{}class Je extends Be{constructor(R){super(R),this.single=R.single,this.pair=R.pair}post_process(R,W=null,{add_special_tokens:te=!0}={}){const he=W===null?this.single:this.pair;let _e=[],Fe=[];for(const Qe of he)"SpecialToken"in Qe?te&&(_e.push(Qe.SpecialToken.id),Fe.push(Qe.SpecialToken.type_id)):"Sequence"in Qe&&(Qe.Sequence.id==="A"?(_e=(0,r.mergeArrays)(_e,R),Fe=(0,r.mergeArrays)(Fe,new Array(R.length).fill(Qe.Sequence.type_id))):Qe.Sequence.id==="B"&&(_e=(0,r.mergeArrays)(_e,W),Fe=(0,r.mergeArrays)(Fe,new Array(W.length).fill(Qe.Sequence.type_id))));return{tokens:_e,token_type_ids:Fe}}}class it extends Be{post_process(R,W=null){return W&&(R=(0,r.mergeArrays)(R,W)),{tokens:R}}}class lt extends Be{constructor(R){super(R),this.processors=R.processors.map(W=>Be.fromConfig(W))}post_process(R,W=null,te={}){let he;for(const _e of this.processors)if(_e instanceof it)R=_e.post_process(R).tokens,W&&(W=_e.post_process(W).tokens);else{const Fe=_e.post_process(R,W,te);R=Fe.tokens,he=Fe.token_type_ids}return{tokens:R,token_type_ids:he}}}class Ue extends s.Callable{constructor(R){super(),this.config=R,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=R.trim_offsets}static fromConfig(R){if(R===null)return null;switch(R.type){case"WordPiece":return new Ye(R);case"Metaspace":return new ti(R);case"ByteLevel":return new tt(R);case"Replace":return new rt(R);case"ByteFallback":return new yt(R);case"Fuse":return new Nt(R);case"Strip":return new bt(R);case"Sequence":return new ss(R);case"CTC":return new pt(R);case"BPEDecoder":return new Zt(R);default:throw new Error(`Unknown Decoder type: ${R.type}`)}}_call(R){return this.decode(R)}decode(R){return this.decode_chain(R).join("")}decode_chain(R){throw Error("`decode_chain` should be implemented in subclass.")}}class rt extends Ue{decode_chain(R){const W=p(this.config.pattern);return W===null?R:R.map(te=>te.replaceAll(W,this.config.content))}}class yt extends Ue{constructor(R){super(R),this.text_decoder=new TextDecoder}decode_chain(R){const W=[];let te=[];for(const he of R){let _e=null;if(he.length===6&&he.startsWith("<0x")&&he.endsWith(">")){const Fe=parseInt(he.slice(3,5),16);isNaN(Fe)||(_e=Fe)}if(_e!==null)te.push(_e);else{if(te.length>0){const Fe=this.text_decoder.decode(Uint8Array.from(te));W.push(Fe),te=[]}W.push(he)}}if(te.length>0){const he=this.text_decoder.decode(Uint8Array.from(te));W.push(he),te=[]}return W}}class Nt extends Ue{decode_chain(R){return[R.join("")]}}class bt extends Ue{constructor(R){super(R),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(R){return R.map(W=>{let te=0;for(let _e=0;_e<this.start&&W[_e]===this.content;++_e){te=_e+1;continue}let he=W.length;for(let _e=0;_e<this.stop;++_e){const Fe=W.length-_e-1;if(W[Fe]===this.content){he=Fe;continue}else break}return W.slice(te,he)})}}class Ye extends Ue{constructor(R){super(R),this.cleanup=R.cleanup}decode_chain(R){return R.map((W,te)=>(te!==0&&(W.startsWith(this.config.prefix)?W=W.replace(this.config.prefix,""):W=" "+W),this.cleanup&&(W=x(W)),W))}}class tt extends Ue{constructor(R){super(R),this.byte_decoder=q,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(R){const W=R.join(""),te=new Uint8Array([...W].map(_e=>this.byte_decoder[_e]));return this.text_decoder.decode(te)}decode_chain(R){const W=[];let te=[];for(const he of R)this.added_tokens.find(_e=>_e.content===he)!==void 0?(te.length>0&&(W.push(this.convert_tokens_to_string(te)),te=[]),W.push(he)):te.push(he);return te.length>0&&W.push(this.convert_tokens_to_string(te)),W}}class pt extends Ue{constructor(R){super(R),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(R){if(R.length===0)return"";const W=[R[0]];for(let _e=1;_e<R.length;++_e)R[_e]!==W.at(-1)&&W.push(R[_e]);let he=W.filter(_e=>_e!==this.pad_token).join("");return this.cleanup&&(he=x(he).replaceAll(this.word_delimiter_token," ").trim()),he}decode_chain(R){return[this.convert_tokens_to_string(R)]}}class ss extends Ue{constructor(R){super(R),this.decoders=R.decoders.map(W=>Ue.fromConfig(W))}decode_chain(R){return this.decoders.reduce((W,te)=>te.decode_chain(W),R)}}class Zt extends Ue{constructor(R){super(R),this.suffix=this.config.suffix}decode_chain(R){return R.map((W,te)=>W.replaceAll(this.suffix,te===R.length-1?"":" "))}}class _s extends Ue{decode_chain(R){let W="";for(let te=1;te<R.length;te+=2)W+=R[te];return[W]}}class bi extends X{constructor(R){super(),this.addPrefixSpace=R.add_prefix_space,this.replacement=R.replacement,this.strRep=R.str_rep||this.replacement,this.prepend_scheme=R.prepend_scheme??"always"}pre_tokenize_text(R,{section_index:W=void 0}={}){let te=R.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!te.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&W===0)&&(te=this.strRep+te),[te]}}class ti extends Ue{constructor(R){super(R),this.addPrefixSpace=R.add_prefix_space,this.replacement=R.replacement}decode_chain(R){const W=[];for(let te=0;te<R.length;++te){let he=R[te].replaceAll(this.replacement," ");this.addPrefixSpace&&te==0&&he.startsWith(" ")&&(he=he.substring(1)),W.push(he)}return W}}class $t extends se{constructor(R){super(R),this.charsmap=R.precompiled_charsmap}normalize(R){return R=R.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),R=R.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),R.includes("～")?R=R.split("～").map(te=>te.normalize("NFKC")).join("～"):R=R.normalize("NFKC"),R}}class Qr extends X{constructor(R){super(),this.tokenizers=R.pretokenizers.map(W=>X.fromConfig(W))}pre_tokenize_text(R,W){return this.tokenizers.reduce((te,he)=>he.pre_tokenize(te,W),[R])}}class O extends X{constructor(R){super()}pre_tokenize_text(R,W){return R.match(/\w+|[^\w\s]+/g)||[]}}class le extends X{constructor(R){super()}pre_tokenize_text(R,W){return w(R)}}class V extends X{constructor(R){super(),this.config=R,this.pattern=p(this.config.pattern),this.content=this.config.content}pre_tokenize_text(R,W){return this.pattern===null?[R]:[R.replaceAll(this.pattern,this.config.content)]}}const ie=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function ve(ye,R,W,te){for(const he of Object.keys(ye)){const _e=R-ye[he].length,Fe=W(he),Qe=new Array(_e).fill(Fe);ye[he]=te==="right"?(0,r.mergeArrays)(ye[he],Qe):(0,r.mergeArrays)(Qe,ye[he])}}function He(ye,R){for(const W of Object.keys(ye))ye[W].length=R}class Ne extends s.Callable{constructor(W,te){super();Z(this,"return_token_type_ids",!1);Z(this,"padding_side","right");this.config=te,this.normalizer=se.fromConfig(W.normalizer),this.pre_tokenizer=X.fromConfig(W.pre_tokenizer),this.model=z.fromConfig(W.model,te),this.post_processor=Be.fromConfig(W.post_processor),this.decoder=Ue.fromConfig(W.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const he of W.added_tokens){const _e=new I(he);this.added_tokens.push(_e),this.model.tokens_to_ids.set(_e.content,_e.id),this.model.vocab[_e.id]=_e.content,_e.special&&(this.special_tokens.push(_e.content),this.all_special_ids.push(_e.id))}if(this.additional_special_tokens=te.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new l.DictionarySplitter(this.added_tokens.map(he=>he.content)),this.added_tokens_map=new Map(this.added_tokens.map(he=>[he.content,he])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=te.model_max_length,this.remove_space=te.remove_space,this.clean_up_tokenization_spaces=te.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=te.do_lowercase_and_remove_accent??!1,te.padding_side&&(this.padding_side=te.padding_side),this.legacy=!1,this.chat_template=te.chat_template??null,Array.isArray(this.chat_template)){const he=Object.create(null);for(const{name:_e,template:Fe}of this.chat_template){if(typeof _e!="string"||typeof Fe!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');he[_e]=Fe}this.chat_template=he}this._compiled_template_cache=new Map}getToken(...W){for(const te of W){const he=this.config[te];if(he)if(typeof he=="object"){if(he.__type==="AddedToken")return he.content;throw Error(`Unknown token: ${he}`)}else return he}return null}static async from_pretrained(W,{progress_callback:te=null,config:he=null,cache_dir:_e=null,local_files_only:Fe=!1,revision:Qe="main",legacy:ut=null}={}){const nt=await d(W,{progress_callback:te,config:he,cache_dir:_e,local_files_only:Fe,revision:Qe,legacy:ut});return new this(...nt)}_call(W,{text_pair:te=null,add_special_tokens:he=!0,padding:_e=!1,truncation:Fe=null,max_length:Qe=null,return_tensor:ut=!0,return_token_type_ids:nt=null}={}){const ft=Array.isArray(W);let Lt;if(ft){if(W.length===0)throw Error("text array must be non-empty");if(te!==null){if(Array.isArray(te)){if(W.length!==te.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");Lt=W.map((ps,zs)=>this._encode_plus(ps,{text_pair:te[zs],add_special_tokens:he,return_token_type_ids:nt}))}else Lt=W.map(ps=>this._encode_plus(ps,{add_special_tokens:he,return_token_type_ids:nt}))}else{if(W==null)throw Error("text may not be null or undefined");if(Array.isArray(te))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");Lt=[this._encode_plus(W,{text_pair:te,add_special_tokens:he,return_token_type_ids:nt})]}if(Qe===null?Qe=this.model_max_length:Fe===null&&(_e===!0?(console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. To pad to max length, use `padding: 'max_length'`."),Qe=this.model_max_length):_e===!1&&(console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length."),Fe=!0)),_e===!0&&(Qe=Math.min((0,o.max)(Lt.map(ps=>ps.input_ids.length))[0],Qe??1/0)),Qe=Math.min(Qe,this.model_max_length??1/0),_e||Fe)for(let ps=0;ps<Lt.length;++ps)Lt[ps].input_ids.length!==Qe&&(Lt[ps].input_ids.length>Qe?Fe&&He(Lt[ps],Qe):_e&&ve(Lt[ps],Qe,zs=>zs==="input_ids"?this.pad_token_id:0,this.padding_side));const hs={};if(ut){if(!(_e&&Fe)&&Lt.some(zs=>{var Ts;for(const li of Object.keys(zs))if(zs[li].length!==((Ts=Lt[0][li])==null?void 0:Ts.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const ps=[Lt.length,Lt[0].input_ids.length];for(const zs of Object.keys(Lt[0]))hs[zs]=new a.Tensor("int64",BigInt64Array.from(Lt.flatMap(Ts=>Ts[zs]).map(BigInt)),ps)}else{for(const ps of Object.keys(Lt[0]))hs[ps]=Lt.map(zs=>zs[ps]);if(!ft)for(const ps of Object.keys(hs))hs[ps]=hs[ps][0]}return hs}_encode_text(W){if(W===null)return null;const te=this.added_tokens_splitter.split(W);for(let _e=0;_e<te.length;++_e){const Fe=this.added_tokens_map.get(te[_e]);Fe&&(Fe.lstrip&&_e>0&&(te[_e-1]=te[_e-1].trimEnd()),Fe.rstrip&&_e<te.length-1&&(te[_e+1]=te[_e+1].trimStart()))}return te.flatMap((_e,Fe)=>{if(_e.length===0)return[];if(this.added_tokens_map.has(_e))return[_e];if(this.remove_space===!0&&(_e=_e.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(_e=_(_e)),this.normalizer!==null&&(_e=this.normalizer(_e)),_e.length===0)return[];const Qe=this.pre_tokenizer!==null?this.pre_tokenizer(_e,{section_index:Fe}):[_e];return this.model(Qe)})}_encode_plus(W,{text_pair:te=null,add_special_tokens:he=!0,return_token_type_ids:_e=null}={}){const{tokens:Fe,token_type_ids:Qe}=this._tokenize_helper(W,{pair:te,add_special_tokens:he}),ut=this.model.convert_tokens_to_ids(Fe),nt={input_ids:ut,attention_mask:new Array(ut.length).fill(1)};return(_e??this.return_token_type_ids)&&Qe&&(nt.token_type_ids=Qe),nt}_tokenize_helper(W,{pair:te=null,add_special_tokens:he=!1}={}){const _e=this._encode_text(W),Fe=this._encode_text(te);return this.post_processor?this.post_processor(_e,Fe,{add_special_tokens:he}):{tokens:(0,r.mergeArrays)(_e??[],Fe??[])}}tokenize(W,{pair:te=null,add_special_tokens:he=!1}={}){return this._tokenize_helper(W,{pair:te,add_special_tokens:he}).tokens}encode(W,{text_pair:te=null,add_special_tokens:he=!0,return_token_type_ids:_e=null}={}){return this._encode_plus(W,{text_pair:te,add_special_tokens:he,return_token_type_ids:_e}).input_ids}batch_decode(W,te={}){return W instanceof a.Tensor&&(W=W.tolist()),W.map(he=>this.decode(he,te))}decode(W,te={}){if(W instanceof a.Tensor&&(W=m(W)),!Array.isArray(W)||W.length===0||!(0,r.isIntegralNumber)(W[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(W,te)}decode_single(W,{skip_special_tokens:te=!1,clean_up_tokenization_spaces:he=null}){let _e=this.model.convert_ids_to_tokens(W);te&&(_e=_e.filter(Qe=>!this.special_tokens.includes(Qe)));let Fe=this.decoder?this.decoder(_e):_e.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(Fe=Fe.replaceAll(this.decoder.end_of_word_suffix," "),te&&(Fe=Fe.trim())),(he??this.clean_up_tokenization_spaces)&&(Fe=x(Fe)),Fe}get_chat_template({chat_template:W=null,tools:te=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const he=this.chat_template;if(W!==null&&Object.hasOwn(he,W))W=he[W];else if(W===null)if(te!==null&&"tool_use"in he)W=he.tool_use;else if("default"in he)W=he.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(he).sort()}.`)}else if(W===null)if(this.chat_template)W=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return W}apply_chat_template(W,{tools:te=null,documents:he=null,chat_template:_e=null,add_generation_prompt:Fe=!1,tokenize:Qe=!0,padding:ut=!1,truncation:nt=!1,max_length:ft=null,return_tensor:Lt=!0,return_dict:hs=!1,tokenizer_kwargs:ps={},...zs}={}){if(_e=this.get_chat_template({chat_template:_e,tools:te}),typeof _e!="string")throw Error(`chat_template must be a string, but got ${typeof _e}`);let Ts=this._compiled_template_cache.get(_e);Ts===void 0&&(Ts=new u.Template(_e),this._compiled_template_cache.set(_e,Ts));const li=Object.create(null);for(const Bi of ie){const mi=this.getToken(Bi);mi&&(li[Bi]=mi)}const Zi=Ts.render({messages:W,add_generation_prompt:Fe,tools:te,documents:he,...li,...zs});if(Qe){const Bi=this._call(Zi,{add_special_tokens:!1,padding:ut,truncation:nt,max_length:ft,return_tensor:Lt,...ps});return hs?Bi:Bi.input_ids}return Zi}}class Ut extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class ds extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class Ct extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class Mt extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class _t extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class ys extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class Is extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class wi extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class $s extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class Qi extends Ne{}class Zr extends Ne{}class vn extends Ne{constructor(W,te){super(W,te);Z(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Jr extends Ne{constructor(){super(...arguments);Z(this,"return_token_type_ids",!0)}}class Qn extends Ne{}class dr extends Ne{}class Zn extends Ne{}class Lr extends Ne{constructor(R,W){super(R,W),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(te=>this.languageRegex.test(te)),this.lang_to_token=te=>te}_build_translation_inputs(R,W,te){return Li(this,R,W,te)}}class Sn extends Lr{}class Jn extends Ne{}class eo extends Ne{}const si="▁";class to extends Ne{constructor(W,te){super(W,te);Z(this,"padding_side","left");this.legacy=te.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new bi({replacement:si,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(W){if(W===null)return null;if(this.legacy||W.length===0)return super._encode_text(W);let te=super._encode_text(si+W.replaceAll(si," "));return te.length>1&&te[0]===si&&this.special_tokens.includes(te[1])&&(te=te.slice(1)),te}}class ki extends Ne{}class En extends Ne{}class ir extends Ne{}class je extends Ne{}class dt extends Ne{}class wt extends Ne{}class xs extends Ne{}class en extends Ne{}class tn extends Ne{}function Li(ye,R,W,te){if(!("language_codes"in ye)||!Array.isArray(ye.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in ye)||!(ye.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in ye)||typeof ye.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const he=te.src_lang,_e=te.tgt_lang;if(!ye.language_codes.includes(_e))throw new Error(`Target language code "${_e}" is not valid. Must be one of: {${ye.language_codes.join(", ")}}`);if(he!==void 0){if(!ye.language_codes.includes(he))throw new Error(`Source language code "${he}" is not valid. Must be one of: {${ye.language_codes.join(", ")}}`);for(const Fe of ye.post_processor.config.single)if("SpecialToken"in Fe&&ye.languageRegex.test(Fe.SpecialToken.id)){Fe.SpecialToken.id=ye.lang_to_token(he);break}}return te.forced_bos_token_id=ye.model.convert_tokens_to_ids([ye.lang_to_token(_e)])[0],ye._call(R,W)}class hr extends Ne{constructor(R,W){super(R,W),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(te=>this.languageRegex.test(te)),this.lang_to_token=te=>te}_build_translation_inputs(R,W,te){return Li(this,R,W,te)}}class ai extends Ne{constructor(R,W){super(R,W),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(te=>this.languageRegex.test(te)).map(te=>te.slice(2,-2)),this.lang_to_token=te=>`__${te}__`}_build_translation_inputs(R,W,te){return Li(this,R,W,te)}}class fi extends Ne{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(R,{return_timestamps:W=!1,return_language:te=!1,time_precision:he=null,force_full_sequences:_e=!0}={}){if(he===null)throw Error("Must specify time_precision");let Fe=null;const Qe=W==="word";function ut(){return{language:Fe,timestamp:[null,null],text:""}}const nt=[];let ft=ut(),Lt=0;const hs=this.timestamp_begin,zs=hs+1500;let Ts=[],li=[],Zi=!1,Bi=null;const mi=new Set(this.all_special_ids);for(const Ds of R){const Qs=Ds.tokens,Ji=Qe?Ds.token_timestamps:null;let rn=null,Br=hs;if("stride"in Ds){const[Mi,js,ii]=Ds.stride;if(Lt-=js,Bi=Mi-ii,js&&(Br=js/he+hs),ii)for(let ui=Qs.length-1;ui>=0;--ui){const Wi=Number(Qs[ui]);if(Wi>=hs){if(rn!==null&&(Wi-hs)*he<Bi)break;rn=Wi}}}let ji=[],Mr=[];for(let Mi=0;Mi<Qs.length;++Mi){const js=Number(Qs[Mi]);if(mi.has(js)){const ii=this.decode([js]),ui=c.WHISPER_LANGUAGE_MAPPING.get(ii.slice(2,-2));if(ui!==void 0){if(Fe!==null&&ui!==Fe&&!W){Ts.push(ji);const Wi=this.findLongestCommonSequence(Ts)[0],nn=this.decode(Wi);ft.text=nn,nt.push(ft),Ts=[],ji=[],ft=ut()}Fe=ft.language=ui}}else if(js>=hs&&js<=zs){const ii=(js-hs)*he+Lt,ui=(0,o.round)(ii,2);if(rn!==null&&js>=rn)Zi=!0;else if(Zi||Ts.length>0&&js<Br)Zi=!1;else if(ft.timestamp[0]===null)ft.timestamp[0]=ui;else if(ui!==ft.timestamp[0]){ft.timestamp[1]=ui,Ts.push(ji),Qe&&li.push(Mr);const[Wi,nn]=this.findLongestCommonSequence(Ts,li),tl=this.decode(Wi);ft.text=tl,Qe&&(ft.words=this.collateWordTimestamps(Wi,nn,Fe)),nt.push(ft),Ts=[],ji=[],li=[],Mr=[],ft=ut()}}else if(ji.push(js),Qe){let ii=(0,o.round)(Ji[Mi]+Lt,2),ui;if(Mi+1<Ji.length){ui=(0,o.round)(Ji[Mi+1]+Lt,2);const Wi=this.decode([js]);T.test(Wi)&&(ui=(0,o.round)(Math.min(ii+he,ui),2))}else ui=null;Mr.push([ii,ui])}}if("stride"in Ds){const[Mi,js,ii]=Ds.stride;Lt+=Mi-ii}ji.length>0?(Ts.push(ji),Qe&&li.push(Mr)):Ts.every(Mi=>Mi.length===0)&&(ft=ut(),Ts=[],ji=[],li=[],Mr=[])}if(Ts.length>0){if(_e&&W)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[Ds,Qs]=this.findLongestCommonSequence(Ts,li),Ji=this.decode(Ds);ft.text=Ji,Qe&&(ft.words=this.collateWordTimestamps(Ds,Qs,Fe)),nt.push(ft)}let Gs=Object.create(null);const Cn=nt.map(Ds=>Ds.text).join("");if(W||te){for(let Ds=0;Ds<nt.length;++Ds){const Qs=nt[Ds];W||delete Qs.timestamp,te||delete Qs.language}if(Qe){const Ds=[];for(const Qs of nt)for(const Ji of Qs.words)Ds.push(Ji);Gs={chunks:Ds}}else Gs={chunks:nt}}return[Cn,Gs]}findLongestCommonSequence(R,W=null){let te=R[0],he=te.length,_e=[];const Fe=Array.isArray(W)&&W.length>0;let Qe=Fe?[]:null,ut=Fe?W[0]:null;for(let nt=1;nt<R.length;++nt){const ft=R[nt];let Lt=0,hs=[he,he,0,0];const ps=ft.length;for(let Gs=1;Gs<he+ps;++Gs){const Cn=Math.max(0,he-Gs),Ds=Math.min(he,he+ps-Gs),Qs=te.slice(Cn,Ds),Ji=Math.max(0,Gs-he),rn=Math.min(ps,Gs),Br=ft.slice(Ji,rn);if(Qs.length!==Br.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let ji;Fe?ji=Qs.filter((js,ii)=>js===Br[ii]&&ut[Cn+ii]<=W[nt][Ji+ii]).length:ji=Qs.filter((js,ii)=>js===Br[ii]).length;const Mr=Gs/1e4,Mi=ji/Gs+Mr;ji>1&&Mi>Lt&&(Lt=Mi,hs=[Cn,Ds,Ji,rn])}const[zs,Ts,li,Zi]=hs,Bi=Math.floor((Ts+zs)/2),mi=Math.floor((Zi+li)/2);_e.push(...te.slice(0,Bi)),te=ft.slice(mi),he=te.length,Fe&&(Qe.push(...ut.slice(0,Bi)),ut=W[nt].slice(mi))}return _e.push(...te),Fe?(Qe.push(...ut),[_e,Qe]):[_e,[]]}collateWordTimestamps(R,W,te){const[he,_e,Fe]=this.combineTokensIntoWords(R,te),Qe=[];for(let ut=0;ut<he.length;++ut){const nt=Fe[ut];Qe.push({text:he[ut],timestamp:[W[nt.at(0)][0],W[nt.at(-1)][1]]})}return Qe}combineTokensIntoWords(R,W,te=`"'“¡¿([{-`,he=`"'.。,，!！?？:：”)]}、`){W=W??"english";let _e,Fe,Qe;return["chinese","japanese","thai","lao","myanmar"].includes(W)?[_e,Fe,Qe]=this.splitTokensOnUnicode(R):[_e,Fe,Qe]=this.splitTokensOnSpaces(R),this.mergePunctuations(_e,Fe,Qe,te,he)}decode(R,W){let te;return W!=null&&W.decode_with_timestamps?(R instanceof a.Tensor&&(R=m(R)),te=this.decodeWithTimestamps(R,W)):te=super.decode(R,W),te}decodeWithTimestamps(R,W){const te=(W==null?void 0:W.time_precision)??.02,he=Array.from(this.all_special_ids).at(-1)+1;let _e=[[]];for(let Fe of R)if(Fe=Number(Fe),Fe>=he){const Qe=((Fe-he)*te).toFixed(2);_e.push(`<|${Qe}|>`),_e.push([])}else _e[_e.length-1].push(Fe);return _e=_e.map(Fe=>typeof Fe=="string"?Fe:super.decode(Fe,W)),_e.join("")}splitTokensOnUnicode(R){const W=this.decode(R,{decode_with_timestamps:!0}),te="�",he=[],_e=[],Fe=[];let Qe=[],ut=[],nt=0;for(let ft=0;ft<R.length;++ft){const Lt=R[ft];Qe.push(Lt),ut.push(ft);const hs=this.decode(Qe,{decode_with_timestamps:!0});(!hs.includes(te)||W[nt+hs.indexOf(te)]===te)&&(he.push(hs),_e.push(Qe),Fe.push(ut),Qe=[],ut=[],nt+=hs.length)}return[he,_e,Fe]}splitTokensOnSpaces(R){const[W,te,he]=this.splitTokensOnUnicode(R),_e=[],Fe=[],Qe=[],ut=new RegExp(`^[${v}]$`,"gu");for(let nt=0;nt<W.length;++nt){const ft=W[nt],Lt=te[nt],hs=he[nt],ps=Lt[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),zs=ft.startsWith(" "),Ts=ft.trim(),li=ut.test(Ts);if(ps||zs||li||_e.length===0)_e.push(ft),Fe.push(Lt),Qe.push(hs);else{const Zi=_e.length-1;_e[Zi]+=ft,Fe[Zi].push(...Lt),Qe[Zi].push(...hs)}}return[_e,Fe,Qe]}mergePunctuations(R,W,te,he,_e){const Fe=structuredClone(R),Qe=structuredClone(W),ut=structuredClone(te);let nt=Fe.length-2,ft=Fe.length-1;for(;nt>=0;)Fe[nt].startsWith(" ")&&he.includes(Fe[nt].trim())?(Fe[ft]=Fe[nt]+Fe[ft],Qe[ft]=(0,r.mergeArrays)(Qe[nt],Qe[ft]),ut[ft]=(0,r.mergeArrays)(ut[nt],ut[ft]),Fe[nt]="",Qe[nt]=[],ut[nt]=[]):ft=nt,--nt;for(nt=0,ft=1;ft<Fe.length;)!Fe[nt].endsWith(" ")&&_e.includes(Fe[ft])?(Fe[nt]+=Fe[ft],Qe[nt]=(0,r.mergeArrays)(Qe[nt],Qe[ft]),ut[nt]=(0,r.mergeArrays)(ut[nt],ut[ft]),Fe[ft]="",Qe[ft]=[],ut[ft]=[]):nt=ft,++ft;return[Fe.filter(Lt=>Lt),Qe.filter(Lt=>Lt.length>0),ut.filter(Lt=>Lt.length>0)]}}class sn extends Ne{}class Ha extends Ne{}class so extends Ne{}class qa extends Ne{constructor(R,W){super(R,W),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(te=>this.languageRegex.test(te)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(R){if(R===null)return null;const[W,...te]=R.trim().split(this.languageRegex);if(te.length===0)return super._encode_text(W);if(te.length===2){const[he,_e]=te;return this.supported_language_codes.includes(he)||console.warn(`Unsupported language code "${he}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,r.mergeArrays)([he],super._encode_text(_e))}}}class Ka extends Ne{}class Xa extends Ne{}class Ya extends Ne{}class An extends Ne{}class ua extends Ne{}class Qa extends Ne{constructor(R,W){super(R,W),this.decoder=new _s({})}}class Za extends Ne{}class Ja extends Ne{}class el{static async from_pretrained(R,{progress_callback:W=null,config:te=null,cache_dir:he=null,local_files_only:_e=!1,revision:Fe="main",legacy:Qe=null}={}){var hs;const[ut,nt]=await d(R,{progress_callback:W,config:te,cache_dir:he,local_files_only:_e,revision:Fe,legacy:Qe}),ft=((hs=nt.tokenizer_class)==null?void 0:hs.replace(/Fast$/,""))??"PreTrainedTokenizer";let Lt=this.TOKENIZER_CLASS_MAPPING[ft];return Lt||(console.warn(`Unknown tokenizer class "${ft}", attempting to construct from base class.`),Lt=Ne),new Lt(ut,nt)}}Z(el,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:Qn,DistilBertTokenizer:Qi,CamembertTokenizer:Zr,DebertaTokenizer:_t,DebertaV2Tokenizer:ys,BertTokenizer:Ut,HerbertTokenizer:Is,ConvBertTokenizer:wi,RoFormerTokenizer:$s,XLMTokenizer:vn,ElectraTokenizer:Jr,MobileBertTokenizer:Ct,SqueezeBertTokenizer:Mt,AlbertTokenizer:ds,GPT2Tokenizer:dr,BartTokenizer:Zn,MBartTokenizer:Lr,MBart50Tokenizer:Sn,RobertaTokenizer:Jn,WhisperTokenizer:fi,CodeGenTokenizer:sn,CLIPTokenizer:Ha,SiglipTokenizer:so,MarianTokenizer:qa,BloomTokenizer:eo,NllbTokenizer:hr,M2M100Tokenizer:ai,LlamaTokenizer:to,CodeLlamaTokenizer:ki,XLMRobertaTokenizer:En,MPNetTokenizer:ir,FalconTokenizer:je,GPTNeoXTokenizer:dt,EsmTokenizer:wt,Wav2Vec2CTCTokenizer:Ka,BlenderbotTokenizer:Xa,BlenderbotSmallTokenizer:Ya,SpeechT5Tokenizer:An,NougatTokenizer:ua,VitsTokenizer:Qa,Qwen2Tokenizer:xs,GemmaTokenizer:en,Grok1Tokenizer:tn,CohereTokenizer:Za,MgpstrTokenizer:Ja,PreTrainedTokenizer:Ne})},"./src/utils/audio.js":(i,e,t)=>{t.r(e),t.d(e,{RawAudio:()=>G,hamming:()=>h,hanning:()=>d,mel_filter_bank:()=>S,read_audio:()=>u,spectrogram:()=>E,window_function:()=>F});var s=t("./src/utils/hub.js"),r=t("./src/utils/maths.js"),n=t("./src/utils/core.js"),o=t("./src/env.js"),a=t("./src/utils/tensor.js"),l=t("?7992");async function u(L,Q){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const q=await(await(0,s.getFile)(L)).arrayBuffer(),J=new AudioContext({sampleRate:Q});typeof Q>"u"&&console.warn(`No sampling rate provided, using default of ${J.sampleRate}Hz.`);const ee=await J.decodeAudioData(q);let se;if(ee.numberOfChannels===2){const fe=Math.sqrt(2),ue=ee.getChannelData(0),U=ee.getChannelData(1);se=new Float32Array(ue.length);for(let k=0;k<ee.length;++k)se[k]=fe*(ue[k]+U[k])/2}else se=ee.getChannelData(0);return se}function c(L,Q){if(L<1)return new Float64Array;if(L===1)return new Float64Array([1]);const q=1-Q,J=2*Math.PI/(L-1),ee=new Float64Array(L);for(let se=0;se<L;++se)ee[se]=Q-q*Math.cos(se*J);return ee}function d(L){return c(L,.5)}function h(L){return c(L,.54)}const p={htk:L=>2595*Math.log10(1+L/700),kaldi:L=>1127*Math.log(1+L/700),slaney:(L,Q=1e3,q=15,J=27/Math.log(6.4))=>L>=Q?q+Math.log(L/Q)*J:3*L/200};function f(L,Q="htk"){const q=p[Q];if(!q)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof L=="number"?q(L):L.map(J=>q(J))}const m={htk:L=>700*(10**(L/2595)-1),kaldi:L=>700*(Math.exp(L/1127)-1),slaney:(L,Q=1e3,q=15,J=Math.log(6.4)/27)=>L>=q?Q*Math.exp(J*(L-q)):200*L/3};function x(L,Q="htk"){const q=m[Q];if(!q)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof L=="number"?q(L):L.map(J=>q(J))}function g(L,Q){const q=Float64Array.from({length:Q.length-1},(fe,ue)=>Q[ue+1]-Q[ue]),J=Array.from({length:L.length},()=>new Array(Q.length));for(let fe=0;fe<L.length;++fe){const ue=J[fe];for(let U=0;U<Q.length;++U)ue[U]=Q[U]-L[fe]}const ee=Q.length-2,se=Array.from({length:ee},()=>new Array(L.length));for(let fe=0;fe<L.length;++fe){const ue=J[fe];for(let U=0;U<ee;++U){const k=-ue[U]/q[U],j=ue[U+2]/q[U+1];se[U][fe]=Math.max(0,Math.min(k,j))}}return se}function _(L,Q,q){const J=(Q-L)/(q-1);return Float64Array.from({length:q},(ee,se)=>L+J*se)}function S(L,Q,q,J,ee,se=null,fe="htk",ue=!1){if(se!==null&&se!=="slaney")throw new Error('norm must be one of null or "slaney"');if(L<2)throw new Error(`Require num_frequency_bins: ${L} >= 2`);if(q>J)throw new Error(`Require min_frequency: ${q} <= max_frequency: ${J}`);const U=f(q,fe),k=f(J,fe),j=_(U,k,Q+2);let re=x(j,fe),we;if(ue){const Pe=ee/((L-1)*2);we=f(Float64Array.from({length:L},(Xe,et)=>et*Pe),fe),re=j}else we=_(0,Math.floor(ee/2),L);const de=g(we,re);if(se!==null&&se==="slaney")for(let Pe=0;Pe<Q;++Pe){const Xe=de[Pe],et=2/(re[Pe+2]-re[Pe]);for(let Me=0;Me<L;++Me)Xe[Me]*=et}return de}function M(L,Q,q){const J=new L.constructor(L.length+Q+q),ee=L.length-1;for(let se=0;se<L.length;++se)J[Q+se]=L[se];for(let se=1;se<=Q;++se)J[Q-se]=L[(0,n.calculateReflectOffset)(se,ee)];for(let se=1;se<=q;++se)J[ee+Q+se]=L[(0,n.calculateReflectOffset)(ee-se,ee)];return J}function w(L,Q,q,J,ee){if(q<=0)throw new Error("reference must be greater than zero");if(J<=0)throw new Error("min_value must be greater than zero");q=Math.max(J,q);const se=Math.log10(q);for(let fe=0;fe<L.length;++fe)L[fe]=Q*Math.log10(Math.max(J,L[fe])-se);if(ee!==null){if(ee<=0)throw new Error("db_range must be greater than zero");const fe=(0,r.max)(L)[0]-ee;for(let ue=0;ue<L.length;++ue)L[ue]=Math.max(L[ue],fe)}return L}function v(L,Q=1,q=1e-5,J=null){return w(L,20,Q,q,J)}function T(L,Q=1,q=1e-10,J=null){return w(L,10,Q,q,J)}async function E(L,Q,q,J,{fft_length:ee=null,power:se=1,center:fe=!0,pad_mode:ue="reflect",onesided:U=!0,preemphasis:k=null,preemphasis_htk_flavor:j=!0,mel_filters:re=null,mel_floor:we=1e-10,log_mel:de=null,reference:Pe=1,min_value:Xe=1e-10,db_range:et=null,remove_dc_offset:Me=null,min_num_frames:X=null,max_num_frames:oe=null,do_pad:K=!0,transpose:Ce=!1}={}){const Ee=Q.length;if(ee===null&&(ee=q),q>ee)throw Error(`frame_length (${q}) may not be larger than fft_length (${ee})`);if(Ee!==q)throw new Error(`Length of the window (${Ee}) must equal frame_length (${q})`);if(J<=0)throw new Error("hop_length must be greater than zero");if(se===null&&re!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(!j)throw new Error("`preemphasis_htk_flavor=false` is not currently supported.");if(fe){if(ue!=="reflect")throw new Error(`pad_mode="${ue}" not implemented yet.`);const bt=Math.floor((ee-1)/2)+1;L=M(L,bt,bt)}let $e=Math.floor(1+Math.floor((L.length-q)/J));X!==null&&$e<X&&($e=X);const Be=U?Math.floor(ee/2)+1:ee;let Ve=$e,We=$e;oe!==null&&(oe>$e?K&&(We=oe):We=Ve=oe);const Je=new r.FFT(ee),it=new Float64Array(ee),lt=new Float64Array(Je.outputBufferSize),Ue=new Float32Array(Be*We);for(let bt=0;bt<Ve;++bt){const Ye=bt*J,tt=Math.min(L.length-Ye,q);tt!==q&&it.fill(0,0,q);for(let pt=0;pt<tt;++pt)it[pt]=L[Ye+pt];if(Me){let pt=0;for(let Zt=0;Zt<tt;++Zt)pt+=it[Zt];const ss=pt/tt;for(let Zt=0;Zt<tt;++Zt)it[Zt]-=ss}if(k!==null){for(let pt=tt-1;pt>=1;--pt)it[pt]-=k*it[pt-1];it[0]*=1-k}for(let pt=0;pt<Q.length;++pt)it[pt]*=Q[pt];Je.realTransform(lt,it);for(let pt=0;pt<Be;++pt){const ss=pt<<1;Ue[pt*We+bt]=lt[ss]**2+lt[ss+1]**2}}if(se!==null&&se!==2){const bt=se/2;for(let Ye=0;Ye<Ue.length;++Ye)Ue[Ye]**=bt}const rt=re.length;let yt=await(0,a.matmul)(new a.Tensor("float32",re.flat(),[rt,Be]),new a.Tensor("float32",Ue,[Be,We]));Ce&&(yt=yt.transpose(1,0));const Nt=yt.data;for(let bt=0;bt<Nt.length;++bt)Nt[bt]=Math.max(we,Nt[bt]);if(se!==null&&de!==null){const bt=Math.min(Nt.length,Ve*rt);switch(de){case"log":for(let Ye=0;Ye<bt;++Ye)Nt[Ye]=Math.log(Nt[Ye]);break;case"log10":for(let Ye=0;Ye<bt;++Ye)Nt[Ye]=Math.log10(Nt[Ye]);break;case"dB":if(se===1)v(Nt,Pe,Xe,et);else if(se===2)T(Nt,Pe,Xe,et);else throw new Error(`Cannot use log_mel option '${de}' with power ${se}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${de}'`)}}return yt}function F(L,Q,{periodic:q=!0,frame_length:J=null,center:ee=!0}={}){const se=q?L+1:L;let fe;switch(Q){case"boxcar":fe=new Float64Array(se).fill(1);break;case"hann":case"hann_window":fe=d(se);break;case"hamming":fe=h(se);break;case"povey":fe=d(se).map(ue=>Math.pow(ue,.85));break;default:throw new Error(`Unknown window type ${Q}.`)}if(q&&(fe=fe.subarray(0,L)),J===null)return fe;if(L>J)throw new Error(`Length of the window (${L}) may not be larger than frame_length (${J})`);return fe}function I(L,Q){let q=44;const J=new ArrayBuffer(q+L.length*4),ee=new DataView(J);z(ee,0,"RIFF"),ee.setUint32(4,36+L.length*4,!0),z(ee,8,"WAVE"),z(ee,12,"fmt "),ee.setUint32(16,16,!0),ee.setUint16(20,3,!0),ee.setUint16(22,1,!0),ee.setUint32(24,Q,!0),ee.setUint32(28,Q*4,!0),ee.setUint16(32,4,!0),ee.setUint16(34,32,!0),z(ee,36,"data"),ee.setUint32(40,L.length*4,!0);for(let se=0;se<L.length;++se,q+=4)ee.setFloat32(q,L[se],!0);return J}function z(L,Q,q){for(let J=0;J<q.length;++J)L.setUint8(Q+J,q.charCodeAt(J))}class G{constructor(Q,q){this.audio=Q,this.sampling_rate=q}toWav(){return I(this.audio,this.sampling_rate)}toBlob(){const Q=this.toWav();return new Blob([Q],{type:"audio/wav"})}async save(Q){let q;if(o.apis.IS_BROWSER_ENV){if(o.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");q=n.saveBlob}else if(o.apis.IS_FS_AVAILABLE)q=async(J,ee)=>{let se=await ee.arrayBuffer();l.writeFileSync(J,Buffer.from(se))};else throw new Error("Unable to save because filesystem is disabled in this environment.");await q(Q,this.toBlob())}}},"./src/utils/constants.js":(i,e,t)=>{t.r(e),t.d(e,{CHAT_TEMPLATE_NAME:()=>l,CONFIG_NAME:()=>r,FEATURE_EXTRACTOR_NAME:()=>n,GENERATION_CONFIG_NAME:()=>u,GITHUB_ISSUE_URL:()=>s,IMAGE_PROCESSOR_NAME:()=>o,PROCESSOR_NAME:()=>a});const s="https://github.com/huggingface/transformers.js/issues/new/choose",r="config.json",n="preprocessor_config.json",o=n,a="processor_config.json",l="chat_template.jinja",u="generation_config.json"},"./src/utils/core.js":(i,e,t)=>{t.r(e),t.d(e,{calculateDimensions:()=>u,calculateReflectOffset:()=>p,count:()=>g,dispatchCallback:()=>s,escapeRegExp:()=>n,isIntegralNumber:()=>a,isNullishDimension:()=>l,isTypedArray:()=>o,len:()=>x,mergeArrays:()=>d,pick:()=>m,pop:()=>c,product:()=>h,reverseDictionary:()=>r,saveBlob:()=>f});function s(_,S){_&&_(S)}function r(_){return Object.fromEntries(Object.entries(_).map(([S,M])=>[M,S]))}function n(_){return _.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function o(_){var S,M,w;return((w=(M=(S=_==null?void 0:_.prototype)==null?void 0:S.__proto__)==null?void 0:M.constructor)==null?void 0:w.name)==="TypedArray"}function a(_){return Number.isInteger(_)||typeof _=="bigint"}function l(_){return _==null||_===-1}function u(_){const S=[];let M=_;for(;Array.isArray(M);)S.push(M.length),M=M[0];return S}function c(_,S,M=void 0){const w=_[S];if(w!==void 0)return delete _[S],w;if(M===void 0)throw Error(`Key ${S} does not exist in object.`);return M}function d(..._){return Array.prototype.concat.apply([],_)}function h(..._){return _.reduce((S,M)=>S.flatMap(w=>M.map(v=>[w,v])))}function p(_,S){return Math.abs((_+S)%(2*S)-S)}function f(_,S){const M=URL.createObjectURL(S),w=document.createElement("a");w.href=M,w.download=_,w.click(),w.remove(),URL.revokeObjectURL(M)}function m(_,S){return Object.assign({},...S.map(M=>{if(_[M]!==void 0)return{[M]:_[M]}}))}function x(_){let S=0;for(const M of _)++S;return S}function g(_,S){let M=0;for(const w of _)w===S&&++M;return M}},"./src/utils/data-structures.js":(i,e,t)=>{t.r(e),t.d(e,{CharTrie:()=>r,DictionarySplitter:()=>l,LRUCache:()=>u,PriorityQueue:()=>s,TokenLattice:()=>o});class s{constructor(d=(p,f)=>p>f,h=1/0){this._heap=[],this._comparator=d,this._maxSize=h}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...d){return this.extend(d)}extend(d){for(const h of d)if(this.size<this._maxSize)this._heap.push(h),this._siftUp();else{const p=this._smallest();this._comparator(h,this._heap[p])&&(this._heap[p]=h,this._siftUpFrom(p))}return this.size}pop(){const d=this.peek(),h=this.size-1;return h>0&&this._swap(0,h),this._heap.pop(),this._siftDown(),d}replace(d){const h=this.peek();return this._heap[0]=d,this._siftDown(),h}_parent(d){return(d+1>>>1)-1}_left(d){return(d<<1)+1}_right(d){return d+1<<1}_greater(d,h){return this._comparator(this._heap[d],this._heap[h])}_swap(d,h){const p=this._heap[d];this._heap[d]=this._heap[h],this._heap[h]=p}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(d){for(;d>0&&this._greater(d,this._parent(d));)this._swap(d,this._parent(d)),d=this._parent(d)}_siftDown(){let d=0;for(;this._left(d)<this.size&&this._greater(this._left(d),d)||this._right(d)<this.size&&this._greater(this._right(d),d);){const h=this._right(d)<this.size&&this._greater(this._right(d),this._left(d))?this._right(d):this._left(d);this._swap(d,h),d=h}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class r{constructor(){this.root=n.default()}extend(d){for(const h of d)this.push(h)}push(d){let h=this.root;for(const p of d){let f=h.children.get(p);f===void 0&&(f=n.default(),h.children.set(p,f)),h=f}h.isLeaf=!0}*commonPrefixSearch(d){let h=this.root;if(h===void 0)return;let p="";for(const f of d){if(p+=f,h=h.children.get(f),h===void 0)return;h.isLeaf&&(yield p)}}}class n{constructor(d,h){this.isLeaf=d,this.children=h}static default(){return new n(!1,new Map)}}class o{constructor(d,h,p){this.chars=Array.from(d),this.len=this.chars.length,this.bosTokenId=h,this.eosTokenId=p,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const f=new a(this.bosTokenId,0,0,0,0),m=new a(this.eosTokenId,1,this.len,0,0);this.nodes.push(f.clone()),this.nodes.push(m.clone()),this.beginNodes[this.len].push(m),this.endNodes[0].push(f)}insert(d,h,p,f){const m=this.nodes.length,x=new a(f,m,d,h,p);this.beginNodes[d].push(x),this.endNodes[d+h].push(x),this.nodes.push(x)}viterbi(){const d=this.len;let h=0;for(;h<=d;){if(this.beginNodes[h].length==0)return[];for(let g of this.beginNodes[h]){g.prev=null;let _=0,S=null;for(let M of this.endNodes[h]){const w=M.backtraceScore+g.score;(S===null||w>_)&&(S=M.clone(),_=w)}if(S!==null)g.prev=S,g.backtraceScore=_;else return[]}++h}const p=[],m=this.beginNodes[d][0].prev;if(m===null)return[];let x=m.clone();for(;x.prev!==null;)p.push(x.clone()),x=x.clone().prev.clone();return p.reverse(),p}piece(d){return this.chars.slice(d.pos,d.pos+d.length).join("")}tokens(){return this.viterbi().map(h=>this.piece(h))}tokenIds(){return this.viterbi().map(h=>h.tokenId)}}class a{constructor(d,h,p,f,m){this.tokenId=d,this.nodeId=h,this.pos=p,this.length=f,this.score=m,this.prev=null,this.backtraceScore=0}clone(){const d=new a(this.tokenId,this.nodeId,this.pos,this.length,this.score);return d.prev=this.prev,d.backtraceScore=this.backtraceScore,d}}class l{constructor(d){this.trie=this._buildTrie(d)}_buildTrie(d){var p;const h=Object.create(null);for(const f of d){let m=h;for(let x=0;x<f.length;++x)m=m[p=f[x]]??(m[p]=Object.create(null));m.end=f}return h}split(d){const h=[],p=d.length;let f=0,m=0;for(;m<p;){let x=this.trie,g=null,_=m;for(;_<p&&(x=x[d[_]]);)x.end&&(g=x.end),++_;g?(m>f&&h.push(d.slice(f,m)),h.push(g),m+=g.length,f=m):++m}return f<p&&h.push(d.slice(f)),h}}class u{constructor(d){this.capacity=d,this.cache=new Map}get(d){if(!this.cache.has(d))return;const h=this.cache.get(d);return this.cache.delete(d),this.cache.set(d,h),h}put(d,h){this.cache.has(d)&&this.cache.delete(d),this.cache.set(d,h),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}},"./src/utils/devices.js":(i,e,t)=>{t.r(e),t.d(e,{DEVICE_TYPES:()=>s});const s=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(i,e,t)=>{t.r(e),t.d(e,{DATA_TYPES:()=>o,DEFAULT_DEVICE_DTYPE_MAPPING:()=>a,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>l,isWebGpuFp16Supported:()=>n});var s=t("./src/env.js"),r=t("./src/utils/devices.js");const n=function(){let u;return async function(){if(u===void 0)if(!s.apis.IS_WEBGPU_AVAILABLE)u=!1;else try{u=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{u=!1}return u}}(),o=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),a=Object.freeze({[r.DEVICE_TYPES.wasm]:o.q8}),l=Object.freeze({[o.fp32]:"",[o.fp16]:"_fp16",[o.int8]:"_int8",[o.uint8]:"_uint8",[o.q8]:"_quantized",[o.q4]:"_q4",[o.q4f16]:"_q4f16",[o.bnb4]:"_bnb4"})},"./src/utils/generic.js":(i,e,t)=>{t.r(e),t.d(e,{Callable:()=>s});const s=class{constructor(){let r=function(...n){return r._call(...n)};return Object.setPrototypeOf(r,new.target.prototype)}_call(...r){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(i,e,t)=>{t.r(e),t.d(e,{MAX_EXTERNAL_DATA_CHUNKS:()=>a,getFile:()=>p,getModelFile:()=>_,getModelJSON:()=>M,getModelText:()=>S});var s=t("?7992"),r=t("?5af5"),n=t("./src/env.js"),o=t("./src/utils/core.js");const a=100,l={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class u{constructor(E){if(this.filePath=E,this.headers=new Headers,this.exists=s.existsSync(E),this.exists){this.status=200,this.statusText="OK";let F=s.statSync(E);this.headers.set("content-length",F.size.toString()),this.updateContentType();const I=s.createReadStream(E);this.body=new ReadableStream({start(z){I.on("data",G=>z.enqueue(G)),I.on("end",()=>z.close()),I.on("error",G=>z.error(G))},cancel(){I.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const E=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",l[E]??"application/octet-stream")}clone(){let E=new u(this.filePath);return E.exists=this.exists,E.status=this.status,E.statusText=this.statusText,E.headers=new Headers(this.headers),E}async arrayBuffer(){return(await s.promises.readFile(this.filePath)).buffer}async blob(){const E=await s.promises.readFile(this.filePath);return new Blob([E],{type:this.headers.get("content-type")})}async text(){return await s.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function c(T,E=null,F=null){let I;try{I=new URL(T)}catch{return!1}return!(E&&!E.includes(I.protocol)||F&&!F.includes(I.hostname))}const d=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;function h(T){return!(!d.test(T)||T.includes("..")||T.includes("--")||T.endsWith(".git")||T.endsWith(".ipynb"))}async function p(T){var E;if(n.env.useFS&&!c(T,["http:","https:","blob:"]))return new u(T instanceof URL?T.protocol==="file:"?T.pathname:T.toString():T);if(typeof process<"u"&&((E=process==null?void 0:process.release)==null?void 0:E.name)==="node"){const F=!!(Ro!=null&&Ro.TESTING_REMOTELY),I=n.env.version,z=new Headers;if(z.set("User-Agent",`transformers.js/${I}; is_ci/${F};`),c(T,["http:","https:"],["huggingface.co","hf.co"])){const L=(Ro==null?void 0:Ro.HF_TOKEN)??(Ro==null?void 0:Ro.HF_ACCESS_TOKEN);L&&z.set("Authorization",`Bearer ${L}`)}return fetch(T,{headers:z})}else return fetch(T)}const f={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function m(T,E,F){if(!F)return null;const I=f[T]??`Error (${T}) occurred while trying to load file`;throw Error(`${I}: "${E}".`)}class x{constructor(E){this.path=E}async match(E){let F=r.join(this.path,E),I=new u(F);if(I.exists)return I}async put(E,F,I=void 0){let z=r.join(this.path,E);try{const G=F.headers.get("Content-Length"),L=parseInt(G??"0");let Q=0;await s.promises.mkdir(r.dirname(z),{recursive:!0});const q=s.createWriteStream(z),J=F.body.getReader();for(;;){const{done:ee,value:se}=await J.read();if(ee)break;await new Promise((ue,U)=>{q.write(se,k=>{if(k){U(k);return}ue()})}),Q+=se.length;const fe=L?Q/L*100:0;I==null||I({progress:fe,loaded:Q,total:L})}q.close()}catch(G){try{await s.promises.unlink(z)}catch{}throw G}}}async function g(T,...E){for(let F of E)try{let I=await T.match(F);if(I)return I}catch{continue}}async function _(T,E,F=!0,I={},z=!1){if(!n.env.allowLocalModels){if(I.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!n.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,o.dispatchCallback)(I.progress_callback,{status:"initiate",name:T,file:E});let G;if(!G&&n.env.useCustomCache){if(!n.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!n.env.customCache.match||!n.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");G=n.env.customCache}if(!G&&n.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{G=await caches.open("transformers-cache")}catch(we){console.warn("An error occurred while opening the browser cache:",we)}}if(!G&&n.env.useFSCache){if(!n.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");G=new x(I.cache_dir??n.env.cacheDir)}const L=I.revision??"main",Q=v(T,E),q=h(T),J=q?v(n.env.localModelPath,Q):Q,ee=v(n.env.remoteHost,n.env.remotePathTemplate.replaceAll("{model}",T).replaceAll("{revision}",encodeURIComponent(L)),E);let se;const fe=G instanceof x?L==="main"?Q:v(T,L,E):ee;let ue=!1,U;G&&(U=await g(G,J,fe));const k=U!==void 0;if(U===void 0){if(n.env.allowLocalModels)if(c(Q,["http:","https:"])){if(I.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${Q}.`);if(!n.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${Q}.`)}else try{U=await p(J),se=J}catch(de){console.warn(`Unable to load from local path "${J}": "${de}"`)}if(U===void 0||U.status===404){if(I.local_files_only||!n.env.allowRemoteModels){if(F)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${J}".`);return null}if(!q)throw Error(`Local file missing at "${J}" and download aborted due to invalid model ID "${T}".`);if(U=await p(ee),U.status!==200)return m(U.status,ee,F);se=fe}ue=G&&typeof Response<"u"&&U instanceof Response&&U.status===200}(0,o.dispatchCallback)(I.progress_callback,{status:"download",name:T,file:E});let j;if(!(n.apis.IS_NODE_ENV&&z)){let we;I.progress_callback?k&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(we=new Uint8Array(await U.arrayBuffer()),(0,o.dispatchCallback)(I.progress_callback,{status:"progress",name:T,file:E,progress:100,loaded:we.length,total:we.length})):we=await w(U,de=>{(0,o.dispatchCallback)(I.progress_callback,{status:"progress",name:T,file:E,...de})}):we=new Uint8Array(await U.arrayBuffer()),j=we}if(ue&&se&&await G.match(se)===void 0&&(j?await G.put(se,new Response(j,{headers:U.headers})).catch(we=>{console.warn(`Unable to add response to browser cache: ${we}.`)}):await G.put(se,U,I.progress_callback)),(0,o.dispatchCallback)(I.progress_callback,{status:"done",name:T,file:E}),j){if(!n.apis.IS_NODE_ENV&&z)throw new Error("Cannot return path in a browser environment.");return j}if(U instanceof u)return U.filePath;const re=await(G==null?void 0:G.match(se));if(re instanceof u)return re.filePath;if(re instanceof Response)return new Uint8Array(await re.arrayBuffer());if(typeof re=="string")return re;throw new Error("Unable to get model file path or buffer.")}async function S(T,E,F=!0,I={}){const z=await _(T,E,F,I,!1);return z===null?null:new TextDecoder("utf-8").decode(z)}async function M(T,E,F=!0,I={}){const z=await S(T,E,F,I);return z===null?{}:JSON.parse(z)}async function w(T,E){const F=T.headers.get("Content-Length");F===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let I=parseInt(F??"0"),z=new Uint8Array(I),G=0;const L=T.body.getReader();async function Q(){const{done:q,value:J}=await L.read();if(q)return;const ee=G+J.length;if(ee>I){I=ee;const fe=new Uint8Array(I);fe.set(z),z=fe}z.set(J,G),G=ee;const se=G/I*100;return E({progress:se,loaded:G,total:I}),Q()}return await Q(),z}function v(...T){return T=T.map((E,F)=>(F&&(E=E.replace(new RegExp("^/"),"")),F!==T.length-1&&(E=E.replace(new RegExp("/$"),"")),E)),T.join("/")}},"./src/utils/image.js":(i,e,t)=>{t.r(e),t.d(e,{RawImage:()=>f,load_image:()=>m});var s=t("./src/utils/core.js"),r=t("./src/utils/hub.js"),n=t("./src/env.js"),o=t("./src/utils/tensor.js"),a=t("?2b25");let l,u,c;const d=n.apis.IS_BROWSER_ENV||n.apis.IS_WEBWORKER_ENV;if(d)l=(x,g)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(x,g)},c=self.createImageBitmap,u=self.ImageData;else if(a)c=async x=>{const _=(await x.metadata()).channels,{data:S,info:M}=await x.rotate().raw().toBuffer({resolveWithObject:!0}),w=new f(new Uint8ClampedArray(S),M.width,M.height,M.channels);return _!==void 0&&_!==M.channels&&w.convert(_),w};else throw new Error("Unable to load image processing library.");const h={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},p=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class f{constructor(g,_,S,M){this.data=g,this.width=_,this.height=S,this.channels=M}get size(){return[this.width,this.height]}static async read(g){if(g instanceof f)return g;if(typeof g=="string"||g instanceof URL)return await this.fromURL(g);if(g instanceof Blob)return await this.fromBlob(g);if(typeof HTMLCanvasElement<"u"&&g instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&g instanceof OffscreenCanvas)return this.fromCanvas(g);throw new Error(`Unsupported input type: ${typeof g}`)}static fromCanvas(g){if(!d)throw new Error("fromCanvas() is only supported in browser environments.");const S=g.getContext("2d").getImageData(0,0,g.width,g.height).data;return new f(S,g.width,g.height,4)}static async fromURL(g){const _=await(0,r.getFile)(g);if(_.status!==200)throw new Error(`Unable to read image from "${g}" (${_.status} ${_.statusText})`);const S=await _.blob();return this.fromBlob(S)}static async fromBlob(g){if(d){const _=await c(g),S=l(_.width,_.height).getContext("2d");return S.drawImage(_,0,0),new this(S.getImageData(0,0,_.width,_.height).data,_.width,_.height,4)}else{const _=a(await g.arrayBuffer());return await c(_)}}static fromTensor(g,_="CHW"){if(g.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${g.dims.length} dimensions.`);if(_==="CHW")g=g.transpose(1,2,0);else if(_!=="HWC")throw new Error(`Unsupported channel format: ${_}`);if(!(g.data instanceof Uint8ClampedArray||g.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${g.type}`);switch(g.dims[2]){case 1:case 2:case 3:case 4:return new f(g.data,g.dims[1],g.dims[0],g.dims[2]);default:throw new Error(`Unsupported number of channels: ${g.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const g=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let _=0,S=0;_<this.data.length;_+=this.channels){const M=this.data[_],w=this.data[_+1],v=this.data[_+2];g[S++]=Math.round(.2989*M+.587*w+.114*v)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(g,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const g=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let _=0,S=0;_<this.data.length;++_)g[S++]=this.data[_],g[S++]=this.data[_],g[S++]=this.data[_];break;case 4:for(let _=0,S=0;_<this.data.length;_+=4)g[S++]=this.data[_],g[S++]=this.data[_+1],g[S++]=this.data[_+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(g,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const g=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let _=0,S=0;_<this.data.length;++_)g[S++]=this.data[_],g[S++]=this.data[_],g[S++]=this.data[_],g[S++]=255;break;case 3:for(let _=0,S=0;_<this.data.length;_+=3)g[S++]=this.data[_],g[S++]=this.data[_+1],g[S++]=this.data[_+2],g[S++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(g,this.width,this.height,4)}putAlpha(g){if(g.width!==this.width||g.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${g.width}x${g.height}`);if(g.channels!==1)throw new Error(`Expected mask to have 1 channel, but got ${g.channels}`);const _=this.data,S=g.data,M=this.width*this.height;if(this.channels===3){const w=new Uint8ClampedArray(M*4);for(let v=0,T=0,E=0;v<M;++v)w[E++]=_[T++],w[E++]=_[T++],w[E++]=_[T++],w[E++]=S[v];return this._update(w,this.width,this.height,4)}else if(this.channels===4){for(let w=0;w<M;++w)_[4*w+3]=S[w];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(g,_,{resample:S=2}={}){if(this.width===g&&this.height===_)return this;let M=h[S]??S;const w=(0,s.isNullishDimension)(g),v=(0,s.isNullishDimension)(_);if(w&&v)return this;if(w?g=_/this.height*this.width:v&&(_=g/this.width*this.height),d){const T=this.channels,E=this.toCanvas(),F=l(g,_).getContext("2d");return F.drawImage(E,0,0,g,_),new f(F.getImageData(0,0,g,_).data,g,_,4).convert(T)}else{let T=this.toSharp();switch(M){case"box":case"hamming":(M==="box"||M==="hamming")&&(console.warn(`Resampling method ${M} is not yet supported. Using bilinear instead.`),M="bilinear");case"nearest":case"bilinear":case"bicubic":T=T.affine([g/this.width,0,0,_/this.height],{interpolator:M});break;case"lanczos":T=T.resize({width:g,height:_,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${M} is not supported.`)}return await c(T)}}async pad([g,_,S,M]){if(g=Math.max(g,0),_=Math.max(_,0),S=Math.max(S,0),M=Math.max(M,0),g===0&&_===0&&S===0&&M===0)return this;if(d){const w=this.channels,v=this.toCanvas(),T=this.width+g+_,E=this.height+S+M,F=l(T,E).getContext("2d");return F.drawImage(v,0,0,this.width,this.height,g,S,this.width,this.height),new f(F.getImageData(0,0,T,E).data,T,E,4).convert(w)}else{const w=this.toSharp().extend({left:g,right:_,top:S,bottom:M});return await c(w)}}async crop([g,_,S,M]){if(g=Math.max(g,0),_=Math.max(_,0),S=Math.min(S,this.width-1),M=Math.min(M,this.height-1),g===0&&_===0&&S===this.width-1&&M===this.height-1)return this;const w=S-g+1,v=M-_+1;if(d){const T=this.channels,E=this.toCanvas(),F=l(w,v).getContext("2d");return F.drawImage(E,g,_,w,v,0,0,w,v),new f(F.getImageData(0,0,w,v).data,w,v,4).convert(T)}else{const T=this.toSharp().extract({left:g,top:_,width:w,height:v});return await c(T)}}async center_crop(g,_){if(this.width===g&&this.height===_)return this;const S=(this.width-g)/2,M=(this.height-_)/2;if(d){const w=this.channels,v=this.toCanvas(),T=l(g,_).getContext("2d");let E=0,F=0,I=0,z=0;return S>=0?E=S:I=-S,M>=0?F=M:z=-M,T.drawImage(v,E,F,g,_,I,z,g,_),new f(T.getImageData(0,0,g,_).data,g,_,4).convert(w)}else{let w=this.toSharp();if(S>=0&&M>=0)w=w.extract({left:Math.floor(S),top:Math.floor(M),width:g,height:_});else if(S<=0&&M<=0){const v=Math.floor(-M),T=Math.floor(-S);w=w.extend({top:v,left:T,right:g-this.width-T,bottom:_-this.height-v})}else{let v=[0,0],T=0;M<0?(v[0]=Math.floor(-M),v[1]=_-this.height-v[0]):T=Math.floor(M);let E=[0,0],F=0;S<0?(E[0]=Math.floor(-S),E[1]=g-this.width-E[0]):F=Math.floor(S),w=w.extend({top:v[0],bottom:v[1],left:E[0],right:E[1]}).extract({left:F,top:T,width:g,height:_})}return await c(w)}}async toBlob(g="image/png",_=1){if(!d)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:g,quality:_})}toTensor(g="CHW"){let _=new o.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(g!=="HWC")if(g==="CHW")_=_.permute(2,0,1);else throw new Error(`Unsupported channel format: ${g}`);return _}toCanvas(){if(!d)throw new Error("toCanvas() is only supported in browser environments.");const g=this.clone().rgba(),_=l(g.width,g.height),S=new u(g.data,g.width,g.height);return _.getContext("2d").putImageData(S,0,0),_}split(){const{data:g,width:_,height:S,channels:M}=this,w=g.constructor,v=g.length/M,T=Array.from({length:M},()=>new w(v));for(let E=0;E<v;++E){const F=M*E;for(let I=0;I<M;++I)T[I][E]=g[F+I]}return T.map(E=>new f(E,_,S,1))}_update(g,_,S,M=null){return this.data=g,this.width=_,this.height=S,M!==null&&(this.channels=M),this}clone(){return new f(this.data.slice(),this.width,this.height,this.channels)}convert(g){if(this.channels===g)return this;switch(g){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(g){if(d){if(n.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const _=g.split(".").pop().toLowerCase(),S=p.get(_)??"image/png",M=await this.toBlob(S);(0,s.saveBlob)(g,M)}else{if(n.apis.IS_FS_AVAILABLE)return await this.toSharp().toFile(g);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(d)throw new Error("toSharp() is only supported in server-side environments.");return a(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const m=f.read.bind(f)},"./src/utils/maths.js":(i,e,t)=>{t.r(e),t.d(e,{FFT:()=>m,bankers_round:()=>_,cos_sim:()=>l,dot:()=>a,dynamic_time_warping:()=>S,interpolate_data:()=>s,log_softmax:()=>o,magnitude:()=>u,max:()=>d,medianFilter:()=>x,min:()=>c,permute_data:()=>r,round:()=>g,softmax:()=>n});function s(M,[w,v,T],[E,F],I="bilinear",z=!1){const G=F/T,L=E/v,Q=new M.constructor(E*F*w),q=v*T,J=E*F;for(let ee=0;ee<E;++ee)for(let se=0;se<F;++se){const fe=ee*F+se,ue=(se+.5)/G-.5,U=(ee+.5)/L-.5;let k=Math.floor(ue),j=Math.floor(U);const re=Math.min(k+1,T-1),we=Math.min(j+1,v-1);k=Math.max(k,0),j=Math.max(j,0);const de=ue-k,Pe=U-j,Xe=(1-de)*(1-Pe),et=de*(1-Pe),Me=(1-de)*Pe,X=de*Pe,oe=j*T,K=we*T,Ce=oe+k,Ee=oe+re,$e=K+k,Be=K+re;for(let Ve=0;Ve<w;++Ve){const We=Ve*q;Q[Ve*J+fe]=Xe*M[We+Ce]+et*M[We+Ee]+Me*M[We+$e]+X*M[We+Be]}}return Q}function r(M,w,v){const T=new Array(v.length),E=new Array(v.length);for(let z=v.length-1,G=1;z>=0;--z)E[z]=G,T[z]=w[v[z]],G*=T[z];const F=v.map((z,G)=>E[v.indexOf(G)]),I=new M.constructor(M.length);for(let z=0;z<M.length;++z){let G=0;for(let L=w.length-1,Q=z;L>=0;--L)G+=Q%w[L]*F[L],Q=Math.floor(Q/w[L]);I[G]=M[z]}return[I,T]}function n(M){const w=d(M)[0],v=M.map(F=>Math.exp(F-w)),T=v.reduce((F,I)=>F+I,0);return v.map(F=>F/T)}function o(M){const w=d(M)[0];let v=0;for(let F=0;F<M.length;++F)v+=Math.exp(M[F]-w);const T=Math.log(v);return M.map(F=>F-w-T)}function a(M,w){let v=0;for(let T=0;T<M.length;++T)v+=M[T]*w[T];return v}function l(M,w){const v=a(M,w),T=u(M),E=u(w);return v/(T*E)}function u(M){return Math.sqrt(M.reduce((w,v)=>w+v*v,0))}function c(M){if(M.length===0)throw Error("Array must not be empty");let w=M[0],v=0;for(let T=1;T<M.length;++T)M[T]<w&&(w=M[T],v=T);return[w,v]}function d(M){if(M.length===0)throw Error("Array must not be empty");let w=M[0],v=0;for(let T=1;T<M.length;++T)M[T]>w&&(w=M[T],v=T);return[w,v]}function h(M){return M>0&&(M&M-1)===0}class p{constructor(w){if(this.size=w|0,this.size<=1||!h(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=w<<1,this.table=new Float64Array(this.size*2);for(let T=0;T<this.table.length;T+=2){const E=Math.PI*T/this.size;this.table[T]=Math.cos(E),this.table[T+1]=-Math.sin(E)}let v=0;for(let T=1;this.size>T;T<<=1)++v;this._width=v%2===0?v-1:v,this._bitrev=new Int32Array(1<<this._width);for(let T=0;T<this._bitrev.length;++T){this._bitrev[T]=0;for(let E=0;E<this._width;E+=2){const F=this._width-E-2;this._bitrev[T]|=(T>>>E&3)<<F}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(w,v){const T=v||new Array(w.length>>>1);for(let E=0;E<w.length;E+=2)T[E>>>1]=w[E];return T}toComplexArray(w,v){const T=v||this.createComplexArray();for(let E=0;E<T.length;E+=2)T[E]=w[E>>>1],T[E+1]=0;return T}transform(w,v){if(w===v)throw new Error("Input and output buffers must be different");this._transform4(w,v,1)}realTransform(w,v){if(w===v)throw new Error("Input and output buffers must be different");this._realTransform4(w,v,1)}inverseTransform(w,v){if(w===v)throw new Error("Input and output buffers must be different");this._transform4(w,v,-1);for(let T=0;T<w.length;++T)w[T]/=this.size}_transform4(w,v,T){const E=this._csize;let I=1<<this._width,z=E/I<<1,G,L;const Q=this._bitrev;if(z===4)for(G=0,L=0;G<E;G+=z,++L){const J=Q[L];this._singleTransform2(v,w,G,J,I)}else for(G=0,L=0;G<E;G+=z,++L){const J=Q[L];this._singleTransform4(v,w,G,J,I,T)}const q=this.table;for(I>>=2;I>=2;I>>=2){z=E/I<<1;const J=z>>>2;for(G=0;G<E;G+=z){const ee=G+J-1;for(let se=G,fe=0;se<ee;se+=2,fe+=I){const ue=se,U=ue+J,k=U+J,j=k+J,re=w[ue],we=w[ue+1],de=w[U],Pe=w[U+1],Xe=w[k],et=w[k+1],Me=w[j],X=w[j+1],oe=q[fe],K=T*q[fe+1],Ce=de*oe-Pe*K,Ee=de*K+Pe*oe,$e=q[2*fe],Be=T*q[2*fe+1],Ve=Xe*$e-et*Be,We=Xe*Be+et*$e,Je=q[3*fe],it=T*q[3*fe+1],lt=Me*Je-X*it,Ue=Me*it+X*Je,rt=re+Ve,yt=we+We,Nt=re-Ve,bt=we-We,Ye=Ce+lt,tt=Ee+Ue,pt=T*(Ce-lt),ss=T*(Ee-Ue);w[ue]=rt+Ye,w[ue+1]=yt+tt,w[U]=Nt+ss,w[U+1]=bt-pt,w[k]=rt-Ye,w[k+1]=yt-tt,w[j]=Nt-ss,w[j+1]=bt+pt}}}}_singleTransform2(w,v,T,E,F){const I=w[E],z=w[E+1],G=w[E+F],L=w[E+F+1];v[T]=I+G,v[T+1]=z+L,v[T+2]=I-G,v[T+3]=z-L}_singleTransform4(w,v,T,E,F,I){const z=F*2,G=F*3,L=w[E],Q=w[E+1],q=w[E+F],J=w[E+F+1],ee=w[E+z],se=w[E+z+1],fe=w[E+G],ue=w[E+G+1],U=L+ee,k=Q+se,j=L-ee,re=Q-se,we=q+fe,de=J+ue,Pe=I*(q-fe),Xe=I*(J-ue);v[T]=U+we,v[T+1]=k+de,v[T+2]=j+Xe,v[T+3]=re-Pe,v[T+4]=U-we,v[T+5]=k-de,v[T+6]=j-Xe,v[T+7]=re+Pe}_realTransform4(w,v,T){const E=this._csize;let I=1<<this._width,z=E/I<<1,G,L;const Q=this._bitrev;if(z===4)for(G=0,L=0;G<E;G+=z,++L){const ee=Q[L];this._singleRealTransform2(v,w,G,ee>>>1,I>>>1)}else for(G=0,L=0;G<E;G+=z,++L){const ee=Q[L];this._singleRealTransform4(v,w,G,ee>>>1,I>>>1,T)}const q=this.table;for(I>>=2;I>=2;I>>=2){z=E/I<<1;const ee=z>>>1,se=ee>>>1,fe=se>>>1;for(G=0;G<E;G+=z)for(let ue=0,U=0;ue<=fe;ue+=2,U+=I){const k=G+ue,j=k+se,re=j+se,we=re+se,de=w[k],Pe=w[k+1],Xe=w[j],et=w[j+1],Me=w[re],X=w[re+1],oe=w[we],K=w[we+1],Ce=de,Ee=Pe,$e=q[U],Be=T*q[U+1],Ve=Xe*$e-et*Be,We=Xe*Be+et*$e,Je=q[2*U],it=T*q[2*U+1],lt=Me*Je-X*it,Ue=Me*it+X*Je,rt=q[3*U],yt=T*q[3*U+1],Nt=oe*rt-K*yt,bt=oe*yt+K*rt,Ye=Ce+lt,tt=Ee+Ue,pt=Ce-lt,ss=Ee-Ue,Zt=Ve+Nt,_s=We+bt,bi=T*(Ve-Nt),ti=T*(We-bt);if(w[k]=Ye+Zt,w[k+1]=tt+_s,w[j]=pt+ti,w[j+1]=ss-bi,ue===0){w[re]=Ye-Zt,w[re+1]=tt-_s;continue}if(ue===fe)continue;const $t=G+se-ue,Qr=G+ee-ue;w[$t]=pt-T*ti,w[$t+1]=-ss-T*bi,w[Qr]=Ye-T*Zt,w[Qr+1]=-tt+T*_s}}const J=E>>>1;for(let ee=2;ee<J;ee+=2)w[E-ee]=w[ee],w[E-ee+1]=-w[ee+1]}_singleRealTransform2(w,v,T,E,F){const I=w[E],z=w[E+F];v[T]=I+z,v[T+1]=0,v[T+2]=I-z,v[T+3]=0}_singleRealTransform4(w,v,T,E,F,I){const z=F*2,G=F*3,L=w[E],Q=w[E+F],q=w[E+z],J=w[E+G],ee=L+q,se=L-q,fe=Q+J,ue=I*(Q-J);v[T]=ee+fe,v[T+1]=0,v[T+2]=se,v[T+3]=-ue,v[T+4]=ee-fe,v[T+5]=0,v[T+6]=se,v[T+7]=ue}}class f{constructor(w){const v=2*(w-1),T=2*(2*w-1),E=2**Math.ceil(Math.log2(T));this.bufferSize=E,this._a=v;const F=new Float64Array(T),I=new Float64Array(E);this._chirpBuffer=new Float64Array(E),this._buffer1=new Float64Array(E),this._buffer2=new Float64Array(E),this._outBuffer1=new Float64Array(E),this._outBuffer2=new Float64Array(E);const z=-2*Math.PI/w,G=Math.cos(z),L=Math.sin(z);for(let Q=0;Q<T>>1;++Q){const q=(Q+1-w)**2/2,J=Math.sqrt(G**2+L**2)**q,ee=q*Math.atan2(L,G),se=2*Q;F[se]=J*Math.cos(ee),F[se+1]=J*Math.sin(ee),I[se]=F[se],I[se+1]=-F[se+1]}this._slicedChirpBuffer=F.subarray(v,T),this._f=new p(E>>1),this._f.transform(this._chirpBuffer,I)}_transform(w,v,T){const E=this._buffer1,F=this._buffer2,I=this._outBuffer1,z=this._outBuffer2,G=this._chirpBuffer,L=this._slicedChirpBuffer,Q=this._a;if(T)for(let q=0;q<L.length;q+=2){const J=q+1,ee=q>>1,se=v[ee];E[q]=se*L[q],E[J]=se*L[J]}else for(let q=0;q<L.length;q+=2){const J=q+1;E[q]=v[q]*L[q]-v[J]*L[J],E[J]=v[q]*L[J]+v[J]*L[q]}this._f.transform(I,E);for(let q=0;q<G.length;q+=2){const J=q+1;F[q]=I[q]*G[q]-I[J]*G[J],F[J]=I[q]*G[J]+I[J]*G[q]}this._f.inverseTransform(z,F);for(let q=0;q<z.length;q+=2){const J=z[q+Q],ee=z[q+Q+1],se=L[q],fe=L[q+1];w[q]=J*se-ee*fe,w[q+1]=J*fe+ee*se}}transform(w,v){this._transform(w,v,!1)}realTransform(w,v){this._transform(w,v,!0)}}class m{constructor(w){this.fft_length=w,this.isPowerOfTwo=h(w),this.isPowerOfTwo?(this.fft=new p(w),this.outputBufferSize=2*w):(this.fft=new f(w),this.outputBufferSize=this.fft.bufferSize)}realTransform(w,v){this.fft.realTransform(w,v)}transform(w,v){this.fft.transform(w,v)}}function x(M,w){if(w%2===0||w<=0)throw new Error("Window size must be a positive odd number");const v=new M.constructor(M.length),T=new M.constructor(w),E=Math.floor(w/2);for(let F=0;F<M.length;++F){let I=0;for(let z=-E;z<=E;++z){let G=F+z;G<0?G=Math.abs(G):G>=M.length&&(G=2*(M.length-1)-G),T[I++]=M[G]}T.sort(),v[F]=T[E]}return v}function g(M,w){const v=Math.pow(10,w);return Math.round(M*v)/v}function _(M){const w=Math.round(M);return Math.abs(M)%1===.5?w%2===0?w:w-1:w}function S(M){const w=M.length,v=M[0].length,T=[w+1,v+1],E=Array.from({length:T[0]},()=>Array(T[1]).fill(1/0));E[0][0]=0;const F=Array.from({length:T[0]},()=>Array(T[1]).fill(-1));for(let Q=1;Q<T[1];++Q)for(let q=1;q<T[0];++q){const J=E[q-1][Q-1],ee=E[q-1][Q],se=E[q][Q-1];let fe,ue;J<ee&&J<se?(fe=J,ue=0):ee<J&&ee<se?(fe=ee,ue=1):(fe=se,ue=2),E[q][Q]=M[q-1][Q-1]+fe,F[q][Q]=ue}for(let Q=0;Q<T[1];++Q)F[0][Q]=2;for(let Q=0;Q<T[0];++Q)F[Q][0]=1;let I=w,z=v,G=[],L=[];for(;I>0||z>0;)switch(G.push(I-1),L.push(z-1),F[I][z]){case 0:--I,--z;break;case 1:--I;break;case 2:--z;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${I}, ${z}]. Please file a bug report.`)}return G.reverse(),L.reverse(),[G,L]}},"./src/utils/tensor.js":(i,e,t)=>{t.r(e),t.d(e,{DataTypeMap:()=>o,Tensor:()=>a,cat:()=>v,full:()=>L,full_like:()=>Q,interpolate:()=>c,interpolate_4d:()=>d,layer_norm:()=>_,matmul:()=>h,mean:()=>I,mean_pooling:()=>g,ones:()=>q,ones_like:()=>J,permute:()=>u,quantize_embeddings:()=>ue,rand:()=>fe,rfft:()=>p,slice:()=>x,stack:()=>T,std_mean:()=>F,topk:()=>f,zeros:()=>ee,zeros_like:()=>se});var s=t("./src/utils/maths.js"),r=t("./src/backends/onnx.js"),n=t("./src/ops/registry.js");const o=Object.freeze({float32:Float32Array,float16:typeof Float16Array<"u"?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class a{constructor(...k){Z(this,"ort_tensor");return(0,r.isONNXTensor)(k[0])?this.ort_tensor=k[0]:this.ort_tensor=new r.Tensor(k[0],k[1],k[2]),new Proxy(this,{get:(j,re)=>{if(typeof re=="string"){let we=Number(re);if(Number.isInteger(we))return j._getitem(we)}return j[re]},set:(j,re,we)=>j[re]=we})}get dims(){return this.ort_tensor.dims}set dims(k){this.ort_tensor.dims=k}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[k,...j]=this.dims;if(j.length>0){const re=j.reduce((we,de)=>we*de);for(let we=0;we<k;++we)yield this._subarray(we,re,j)}else yield*this.data}_getitem(k){const[j,...re]=this.dims;if(k=w(k,j),re.length>0){const we=re.reduce((de,Pe)=>de*Pe);return this._subarray(k,we,re)}else return new a(this.type,[this.data[k]],re)}indexOf(k){const j=this.data;for(let re=0;re<j.length;++re)if(j[re]==k)return re;return-1}_subarray(k,j,re){const we=k*j,de=(k+1)*j,Pe="subarray"in this.data?this.data.subarray(we,de):this.data.slice(we,de);return new a(this.type,Pe,re)}item(){const k=this.data;if(k.length!==1)throw new Error(`a Tensor with ${k.length} elements cannot be converted to Scalar`);return k[0]}tolist(){return l(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const k=this.data;for(let j=0;j<k.length;++j)k[j]=1/(1+Math.exp(-k[j]));return this}map(k){return this.clone().map_(k)}map_(k){const j=this.data;for(let re=0;re<j.length;++re)j[re]=k(j[re],re,j);return this}mul(k){return this.clone().mul_(k)}mul_(k){const j=this.data;for(let re=0;re<j.length;++re)j[re]*=k;return this}div(k){return this.clone().div_(k)}div_(k){const j=this.data;for(let re=0;re<j.length;++re)j[re]/=k;return this}add(k){return this.clone().add_(k)}add_(k){const j=this.data;for(let re=0;re<j.length;++re)j[re]+=k;return this}sub(k){return this.clone().sub_(k)}sub_(k){const j=this.data;for(let re=0;re<j.length;++re)j[re]-=k;return this}clone(){return new a(this.type,this.data.slice(),this.dims.slice())}slice(...k){const j=[],re=[];for(let Me=0;Me<this.dims.length;++Me){let X=k[Me];if(X==null)re.push([0,this.dims[Me]]),j.push(this.dims[Me]);else if(typeof X=="number")X=w(X,this.dims[Me],Me),re.push([X,X+1]);else if(Array.isArray(X)&&X.length===2){let[oe,K]=X;if(oe=oe===null?0:w(oe,this.dims[Me],Me,!1),K=K===null?this.dims[Me]:w(K,this.dims[Me],Me,!1),oe>K)throw new Error(`Invalid slice: ${X}`);const Ce=[Math.max(oe,0),Math.min(K,this.dims[Me])];re.push(Ce),j.push(Ce[1]-Ce[0])}else throw new Error(`Invalid slice: ${X}`)}const we=re.map(([Me,X])=>X-Me),de=we.reduce((Me,X)=>Me*X),Pe=this.data,Xe=new Pe.constructor(de),et=this.stride();for(let Me=0;Me<de;++Me){let X=0;for(let oe=we.length-1,K=Me;oe>=0;--oe){const Ce=we[oe];X+=(K%Ce+re[oe][0])*et[oe],K=Math.floor(K/Ce)}Xe[Me]=Pe[X]}return new a(this.type,Xe,j)}permute(...k){return u(this,k)}transpose(...k){return this.permute(...k)}sum(k=null,j=!1){return this.norm(1,k,j)}norm(k="fro",j=null,re=!1){if(k==="fro")k=2;else if(typeof k=="string")throw Error(`Unsupported norm: ${k}`);const we=this.data,de=(Me,X)=>Me+X**k;if(j===null){const Me=we.reduce(de,0)**(1/k);return new a(this.type,[Me],[])}const[Pe,Xe,et]=E(de,this,j,re);if(k!==1)for(let Me=0;Me<Xe.length;++Me)Xe[Me]=Xe[Me]**(1/k);return new a(Pe,Xe,et)}normalize_(k=2,j=1){j=w(j,this.dims.length);const re=this.norm(k,j,!0),we=this.data,de=re.data;for(let Pe=0;Pe<we.length;++Pe){let Xe=0;for(let et=this.dims.length-1,Me=Pe,X=1;et>=0;--et){const oe=this.dims[et];if(et!==j){const K=Me%oe;Xe+=K*X,X*=this.dims[et]}Me=Math.floor(Me/oe)}we[Pe]/=de[Xe]}return this}normalize(k=2,j=1){return this.clone().normalize_(k,j)}stride(){return z(this.dims)}squeeze(k=null){return new a(this.type,this.data,S(this.dims,k))}squeeze_(k=null){return this.dims=S(this.dims,k),this}unsqueeze(k=null){return new a(this.type,this.data,M(this.dims,k))}unsqueeze_(k=null){return this.dims=M(this.dims,k),this}flatten_(k=0,j=-1){j=(j+this.dims.length)%this.dims.length;let re=this.dims.slice(0,k),we=this.dims.slice(k,j+1),de=this.dims.slice(j+1);return this.dims=[...re,we.reduce((Pe,Xe)=>Pe*Xe,1),...de],this}flatten(k=0,j=-1){return this.clone().flatten_(k,j)}view(...k){let j=-1;for(let we=0;we<k.length;++we)if(k[we]===-1){if(j!==-1)throw new Error("Only one dimension can be inferred");j=we}const re=this.data;if(j!==-1){const we=k.reduce((de,Pe,Xe)=>Xe!==j?de*Pe:de,1);k[j]=re.length/we}return new a(this.type,re,k)}neg_(){const k=this.data;for(let j=0;j<k.length;++j)k[j]=-k[j];return this}neg(){return this.clone().neg_()}gt(k){const j=new Uint8Array(this.data.length),re=this.data;for(let we=0;we<re.length;++we)j[we]=re[we]>k?1:0;return new a("bool",j,this.dims)}lt(k){const j=new Uint8Array(this.data.length),re=this.data;for(let we=0;we<re.length;++we)j[we]=re[we]<k?1:0;return new a("bool",j,this.dims)}clamp_(k,j){const re=this.data;for(let we=0;we<re.length;++we)re[we]=Math.min(Math.max(re[we],k),j);return this}clamp(k,j){return this.clone().clamp_(k,j)}round_(){const k=this.data;for(let j=0;j<k.length;++j)k[j]=Math.round(k[j]);return this}round(){return this.clone().round_()}mean(k=null,j=!1){return I(this,k,j)}min(k=null,j=!1){if(k===null){const Pe=(0,s.min)(this.data)[0];return new a(this.type,[Pe],[])}const[re,we,de]=E((Pe,Xe)=>Math.min(Pe,Xe),this,k,j,1/0);return new a(re,we,de)}max(k=null,j=!1){if(k===null){const Pe=(0,s.max)(this.data)[0];return new a(this.type,[Pe],[])}const[re,we,de]=E((Pe,Xe)=>Math.max(Pe,Xe),this,k,j,-1/0);return new a(re,we,de)}argmin(k=null,j=!1){if(k!==null)throw new Error("`dim !== null` not yet implemented.");const re=(0,s.min)(this.data)[1];return new a("int64",[BigInt(re)],[])}argmax(k=null,j=!1){if(k!==null)throw new Error("`dim !== null` not yet implemented.");const re=(0,s.max)(this.data)[1];return new a("int64",[BigInt(re)],[])}to(k){if(this.type===k)return this;if(!o.hasOwnProperty(k))throw new Error(`Unsupported type: ${k}`);let j;const re=["int64","uint64"].includes(this.type),we=["int64","uint64"].includes(k);return re&&!we?j=Number:!re&&we&&(j=BigInt),new a(k,o[k].from(this.data,j),this.dims)}}function l(U,k){const j=U.length,re=k.reduce((de,Pe)=>de*Pe);if(j!==re)throw Error(`cannot reshape array of size ${j} into shape (${k})`);let we=U;for(let de=k.length-1;de>=0;de--)we=we.reduce((Pe,Xe)=>{let et=Pe[Pe.length-1];return et.length<k[de]?et.push(Xe):Pe.push([Xe]),Pe},[[]]);return we[0]}function u(U,k){const[j,re]=(0,s.permute_data)(U.data,U.dims,k);return new a(U.type,j,re)}function c(U,[k,j],re="bilinear",we=!1){const de=U.dims.at(-3)??1,Pe=U.dims.at(-2),Xe=U.dims.at(-1);let et=(0,s.interpolate_data)(U.data,[de,Pe,Xe],[k,j],re,we);return new a(U.type,et,[de,k,j])}async function d(U,{size:k=null,mode:j="bilinear"}={}){if(U.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!k)throw new Error("`interpolate_4d` requires a `size` argument.");let re;if(k.length===2)re=[...U.dims.slice(0,2),...k];else if(k.length===3)re=[U.dims[0],...k];else if(k.length===4)re=k;else throw new Error("`size` must be of length 2, 3, or 4.");let we;if(j==="nearest")we=await n.TensorOpRegistry.nearest_interpolate_4d;else if(j==="bilinear")we=await n.TensorOpRegistry.bilinear_interpolate_4d;else if(j==="bicubic")we=await n.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${j}`);const de=new a("int64",new BigInt64Array(re.map(BigInt)),[re.length]);return await we({x:U,s:de})}async function h(U,k){return await(await n.TensorOpRegistry.matmul)({a:U,b:k})}async function p(U,k){return await(await n.TensorOpRegistry.rfft)({x:U,a:k})}async function f(U,k){const j=await n.TensorOpRegistry.top_k;return k==null?k=U.dims.at(-1):k=Math.min(k,U.dims.at(-1)),await j({x:U,k:new a("int64",[BigInt(k)],[1])})}const m=U=>new a("int64",U,[U.length]);async function x(U,k,j,re,we){return await(await n.TensorOpRegistry.slice)({x:U,s:m(k),e:m(j),a:m(re),t:m(we??new Array(re.length).fill(1))})}function g(U,k){const j=U.data,re=k.data,we=[U.dims[0],U.dims[2]],de=new j.constructor(we[0]*we[1]),[Pe,Xe,et]=U.dims;let Me=0;for(let X=0;X<Pe;++X){const oe=X*et*Xe;for(let K=0;K<et;++K){let Ce=0,Ee=0;const $e=X*Xe,Be=oe+K;for(let We=0;We<Xe;++We){const Je=Number(re[$e+We]);Ee+=Je,Ce+=j[Be+We*et]*Je}const Ve=Ce/Ee;de[Me++]=Ve}}return new a(U.type,de,we)}function _(U,k,{eps:j=1e-5}={}){if(U.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[re,we]=U.dims;if(k.length!==1&&k[0]!==we)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[de,Pe]=F(U,1,0,!0),Xe=de.data,et=Pe.data,Me=U.data,X=new Me.constructor(Me.length);for(let oe=0;oe<re;++oe){const K=oe*we;for(let Ce=0;Ce<we;++Ce){const Ee=K+Ce;X[Ee]=(Me[Ee]-et[oe])/(Xe[oe]+j)}}return new a(U.type,X,U.dims)}function S(U,k){return U=U.slice(),k===null?U=U.filter(j=>j!==1):typeof k=="number"?U[k]===1&&U.splice(k,1):Array.isArray(k)&&(U=U.filter((j,re)=>j!==1||!k.includes(re))),U}function M(U,k){return k=w(k,U.length+1),U=U.slice(),U.splice(k,0,1),U}function w(U,k,j=null,re=!0){if(U<-k||U>=k){if(re)throw new Error(`IndexError: index ${U} is out of bounds for dimension${j===null?"":" "+j} with size ${k}`);return U<-k?0:k}return U<0&&(U=(U%k+k)%k),U}function v(U,k=0){k=w(k,U[0].dims.length);const j=U[0].dims.slice();j[k]=U.reduce((Pe,Xe)=>Pe+Xe.dims[k],0);const re=j.reduce((Pe,Xe)=>Pe*Xe,1),we=new U[0].data.constructor(re),de=U[0].type;if(k===0){let Pe=0;for(const Xe of U){const et=Xe.data;we.set(et,Pe),Pe+=et.length}}else{let Pe=0;for(let Xe=0;Xe<U.length;++Xe){const{data:et,dims:Me}=U[Xe];for(let X=0;X<et.length;++X){let oe=0;for(let K=Me.length-1,Ce=X,Ee=1;K>=0;--K){const $e=Me[K];let Be=Ce%$e;K===k&&(Be+=Pe),oe+=Be*Ee,Ee*=j[K],Ce=Math.floor(Ce/$e)}we[oe]=et[X]}Pe+=Me[k]}}return new a(de,we,j)}function T(U,k=0){return v(U.map(j=>j.unsqueeze(k)),k)}function E(U,k,j=null,re=!1,we=null){const de=k.data,Pe=k.dims;j=w(j,Pe.length);const Xe=Pe.slice();Xe[j]=1;const et=new de.constructor(de.length/Pe[j]);we!==null&&et.fill(we);for(let Me=0;Me<de.length;++Me){let X=0;for(let oe=Pe.length-1,K=Me,Ce=1;oe>=0;--oe){const Ee=Pe[oe];if(oe!==j){const $e=K%Ee;X+=$e*Ce,Ce*=Xe[oe]}K=Math.floor(K/Ee)}et[X]=U(et[X],de[Me],Me,X)}return re||Xe.splice(j,1),[k.type,et,Xe]}function F(U,k=null,j=1,re=!1){const we=U.data,de=U.dims;if(k===null){const Ce=we.reduce((Ve,We)=>Ve+We,0)/we.length,Ee=Math.sqrt(we.reduce((Ve,We)=>Ve+(We-Ce)**2,0)/(we.length-j)),$e=new a(U.type,[Ce],[]);return[new a(U.type,[Ee],[]),$e]}k=w(k,de.length);const Pe=I(U,k,re),Xe=Pe.data,[et,Me,X]=E((K,Ce,Ee,$e)=>K+(Ce-Xe[$e])**2,U,k,re);for(let K=0;K<Me.length;++K)Me[K]=Math.sqrt(Me[K]/(de[k]-j));return[new a(et,Me,X),Pe]}function I(U,k=null,j=!1){const re=U.dims,we=U.data;if(k===null){const et=we.reduce((Me,X)=>Me+X,0);return new a(U.type,[et/we.length],[])}k=w(k,re.length);const[de,Pe,Xe]=E((et,Me)=>et+Me,U,k,j);if(re[k]!==1)for(let et=0;et<Pe.length;++et)Pe[et]/=re[k];return new a(de,Pe,Xe)}function z(U){const k=new Array(U.length);for(let j=U.length-1,re=1;j>=0;--j)k[j]=re,re*=U[j];return k}function G(U,k,j,re){const we=U.reduce((de,Pe)=>de*Pe,1);return new a(j,new re(we).fill(k),U)}function L(U,k){let j,re;if(typeof k=="number")j="float32",re=Float32Array;else if(typeof k=="bigint")j="int64",re=BigInt64Array;else if(typeof k=="boolean")j="bool",re=Uint8Array;else throw new Error(`Unsupported data type: ${typeof k}`);return G(U,k,j,re)}function Q(U,k){return L(U.dims,k)}function q(U){return G(U,1n,"int64",BigInt64Array)}function J(U){return q(U.dims)}function ee(U){return G(U,0n,"int64",BigInt64Array)}function se(U){return ee(U.dims)}function fe(U){const k=U.reduce((j,re)=>j*re,1);return new a("float32",Float32Array.from({length:k},()=>Math.random()),U)}function ue(U,k){if(U.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(U.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(k))throw new Error("The precision must be either 'binary' or 'ubinary'");const j=k==="binary",re=j?"int8":"uint8",we=j?Int8Array:Uint8Array,de=U.data,Pe=new we(de.length/8);for(let Xe=0;Xe<de.length;++Xe){const et=de[Xe]>0?1:0,Me=Math.floor(Xe/8),X=Xe%8;Pe[Me]|=et<<7-X,j&&X===0&&(Pe[Me]-=128)}return new a(re,Pe,[U.dims[0],U.dims[1]/8])}},"./src/utils/video.js":(i,e,t)=>{t.r(e),t.d(e,{RawVideo:()=>o,RawVideoFrame:()=>n,load_video:()=>a});var s=t("./src/utils/image.js"),r=t("./src/env.js");class n{constructor(u,c){this.image=u,this.timestamp=c}}class o{constructor(u,c){u.length>0&&u[0]instanceof s.RawImage&&(u=u.map((d,h)=>new n(d,(h+1)/(u.length+1)*c))),this.frames=u,this.duration=c}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function a(l,{num_frames:u=null,fps:c=null}={}){if(!r.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(u==null&&c==null)throw new Error("Either num_frames or fps must be provided.");const d=[],h=document.createElement("video");if(h.crossOrigin="anonymous",h.muted=!0,typeof l=="string")h.src=l;else if(l instanceof Blob)h.src=URL.createObjectURL(l);else if(l instanceof HTMLVideoElement)h.src=l.src;else throw new Error("Invalid URL or video element provided.");if(await new Promise(S=>h.onloadedmetadata=S),h.seekable.start(0)===h.seekable.end(0)){const M=await(await fetch(h.src)).blob();h.src=URL.createObjectURL(M),await new Promise(w=>h.onloadedmetadata=w)}const p=h.duration;let f,m;u!=null?(f=u,m=u===1?0:p/(u-1)):(m=1/c,f=Math.floor(p/m));let x=[];for(let S=0;S<f;++S)x.push(u===1?p/2:S*m);const g=document.createElement("canvas");g.width=h.videoWidth,g.height=h.videoHeight;const _=g.getContext("2d",{willReadFrequently:!0});for(const S of x){h.currentTime=S,await new Promise(T=>{h.onseeked=T}),_.drawImage(h,0,0,g.width,g.height);const M=_.getImageData(0,0,g.width,g.height),w=new s.RawImage(M.data,g.width,g.height,4),v=new n(w,S);d.push(v)}return h.remove(),new o(d,p)}}},FP={};function bs(i){var e=FP[i];if(e!==void 0)return e.exports;var t=FP[i]={exports:{}};return tV[i](t,t.exports,bs),t.exports}(()=>{var i=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__,e;bs.t=function(t,s){if(s&1&&(t=this(t)),s&8||typeof t=="object"&&t&&(s&4&&t.__esModule||s&16&&typeof t.then=="function"))return t;var r=Object.create(null);bs.r(r);var n={};e=e||[null,i({}),i([]),i(i)];for(var o=s&2&&t;typeof o=="object"&&!~e.indexOf(o);o=i(o))Object.getOwnPropertyNames(o).forEach(a=>n[a]=()=>t[a]);return n.default=()=>t,bs.d(r,n),r}})();bs.d=(i,e)=>{for(var t in e)bs.o(e,t)&&!bs.o(i,t)&&Object.defineProperty(i,t,{enumerable:!0,get:e[t]})};bs.o=(i,e)=>Object.prototype.hasOwnProperty.call(i,e);bs.r=i=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})};var b={};(()=>{/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/bs.r(b),bs.d(b,{ASTFeatureExtractor:()=>d.ASTFeatureExtractor,ASTForAudioClassification:()=>t.ASTForAudioClassification,ASTModel:()=>t.ASTModel,ASTPreTrainedModel:()=>t.ASTPreTrainedModel,AlbertForMaskedLM:()=>t.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>t.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>t.AlbertForSequenceClassification,AlbertModel:()=>t.AlbertModel,AlbertPreTrainedModel:()=>t.AlbertPreTrainedModel,AlbertTokenizer:()=>s.AlbertTokenizer,AudioClassificationPipeline:()=>e.AudioClassificationPipeline,AutoConfig:()=>r.AutoConfig,AutoFeatureExtractor:()=>h.AutoFeatureExtractor,AutoImageProcessor:()=>m.AutoImageProcessor,AutoModel:()=>t.AutoModel,AutoModelForAudioClassification:()=>t.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>t.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>t.AutoModelForAudioTextToText,AutoModelForCTC:()=>t.AutoModelForCTC,AutoModelForCausalLM:()=>t.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>t.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>t.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>t.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>t.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>t.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>t.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>t.AutoModelForImageTextToText,AutoModelForImageToImage:()=>t.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>t.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>t.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>t.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>t.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>t.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>t.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>t.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>t.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>t.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>t.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>t.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>t.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>t.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>t.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>t.AutoModelForVision2Seq,AutoModelForXVector:()=>t.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>t.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>_.AutoProcessor,AutoTokenizer:()=>s.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>e.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>e.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>t.BartForConditionalGeneration,BartForSequenceClassification:()=>t.BartForSequenceClassification,BartModel:()=>t.BartModel,BartPretrainedModel:()=>t.BartPretrainedModel,BartTokenizer:()=>s.BartTokenizer,BaseModelOutput:()=>t.BaseModelOutput,BaseStreamer:()=>S.BaseStreamer,BeitFeatureExtractor:()=>f.BeitFeatureExtractor,BeitForImageClassification:()=>t.BeitForImageClassification,BeitModel:()=>t.BeitModel,BeitPreTrainedModel:()=>t.BeitPreTrainedModel,BertForMaskedLM:()=>t.BertForMaskedLM,BertForQuestionAnswering:()=>t.BertForQuestionAnswering,BertForSequenceClassification:()=>t.BertForSequenceClassification,BertForTokenClassification:()=>t.BertForTokenClassification,BertModel:()=>t.BertModel,BertPreTrainedModel:()=>t.BertPreTrainedModel,BertTokenizer:()=>s.BertTokenizer,BitImageProcessor:()=>f.BitImageProcessor,BlenderbotForConditionalGeneration:()=>t.BlenderbotForConditionalGeneration,BlenderbotModel:()=>t.BlenderbotModel,BlenderbotPreTrainedModel:()=>t.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>t.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>t.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>t.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>s.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>s.BlenderbotTokenizer,BloomForCausalLM:()=>t.BloomForCausalLM,BloomModel:()=>t.BloomModel,BloomPreTrainedModel:()=>t.BloomPreTrainedModel,BloomTokenizer:()=>s.BloomTokenizer,CLIPFeatureExtractor:()=>f.CLIPFeatureExtractor,CLIPImageProcessor:()=>f.CLIPImageProcessor,CLIPModel:()=>t.CLIPModel,CLIPPreTrainedModel:()=>t.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>t.CLIPSegForImageSegmentation,CLIPSegModel:()=>t.CLIPSegModel,CLIPSegPreTrainedModel:()=>t.CLIPSegPreTrainedModel,CLIPTextModel:()=>t.CLIPTextModel,CLIPTextModelWithProjection:()=>t.CLIPTextModelWithProjection,CLIPTokenizer:()=>s.CLIPTokenizer,CLIPVisionModel:()=>t.CLIPVisionModel,CLIPVisionModelWithProjection:()=>t.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>t.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>t.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>t.CamembertForSequenceClassification,CamembertForTokenClassification:()=>t.CamembertForTokenClassification,CamembertModel:()=>t.CamembertModel,CamembertPreTrainedModel:()=>t.CamembertPreTrainedModel,CamembertTokenizer:()=>s.CamembertTokenizer,CausalLMOutput:()=>t.CausalLMOutput,CausalLMOutputWithPast:()=>t.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>f.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>t.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>t.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>t.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>d.ClapFeatureExtractor,ClapModel:()=>t.ClapModel,ClapPreTrainedModel:()=>t.ClapPreTrainedModel,ClapTextModelWithProjection:()=>t.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>w.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>t.CodeGenForCausalLM,CodeGenModel:()=>t.CodeGenModel,CodeGenPreTrainedModel:()=>t.CodeGenPreTrainedModel,CodeGenTokenizer:()=>s.CodeGenTokenizer,CodeLlamaTokenizer:()=>s.CodeLlamaTokenizer,CohereForCausalLM:()=>t.CohereForCausalLM,CohereModel:()=>t.CohereModel,CoherePreTrainedModel:()=>t.CoherePreTrainedModel,CohereTokenizer:()=>s.CohereTokenizer,ConvBertForMaskedLM:()=>t.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>t.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>t.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>t.ConvBertForTokenClassification,ConvBertModel:()=>t.ConvBertModel,ConvBertPreTrainedModel:()=>t.ConvBertPreTrainedModel,ConvBertTokenizer:()=>s.ConvBertTokenizer,ConvNextFeatureExtractor:()=>f.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>t.ConvNextForImageClassification,ConvNextImageProcessor:()=>f.ConvNextImageProcessor,ConvNextModel:()=>t.ConvNextModel,ConvNextPreTrainedModel:()=>t.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>t.ConvNextV2ForImageClassification,ConvNextV2Model:()=>t.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>t.ConvNextV2PreTrainedModel,DFineForObjectDetection:()=>t.DFineForObjectDetection,DFineModel:()=>t.DFineModel,DFinePreTrainedModel:()=>t.DFinePreTrainedModel,DPTFeatureExtractor:()=>f.DPTFeatureExtractor,DPTForDepthEstimation:()=>t.DPTForDepthEstimation,DPTImageProcessor:()=>f.DPTImageProcessor,DPTModel:()=>t.DPTModel,DPTPreTrainedModel:()=>t.DPTPreTrainedModel,DacDecoderModel:()=>t.DacDecoderModel,DacDecoderOutput:()=>t.DacDecoderOutput,DacEncoderModel:()=>t.DacEncoderModel,DacEncoderOutput:()=>t.DacEncoderOutput,DacFeatureExtractor:()=>d.DacFeatureExtractor,DacModel:()=>t.DacModel,DacPreTrainedModel:()=>t.DacPreTrainedModel,DataTypeMap:()=>l.DataTypeMap,DebertaForMaskedLM:()=>t.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>t.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>t.DebertaForSequenceClassification,DebertaForTokenClassification:()=>t.DebertaForTokenClassification,DebertaModel:()=>t.DebertaModel,DebertaPreTrainedModel:()=>t.DebertaPreTrainedModel,DebertaTokenizer:()=>s.DebertaTokenizer,DebertaV2ForMaskedLM:()=>t.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>t.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>t.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>t.DebertaV2ForTokenClassification,DebertaV2Model:()=>t.DebertaV2Model,DebertaV2PreTrainedModel:()=>t.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>s.DebertaV2Tokenizer,DecisionTransformerModel:()=>t.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>t.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>f.DeiTFeatureExtractor,DeiTForImageClassification:()=>t.DeiTForImageClassification,DeiTImageProcessor:()=>f.DeiTImageProcessor,DeiTModel:()=>t.DeiTModel,DeiTPreTrainedModel:()=>t.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>t.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>t.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>e.DepthEstimationPipeline,DepthProForDepthEstimation:()=>t.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>t.DepthProPreTrainedModel,DetrFeatureExtractor:()=>f.DetrFeatureExtractor,DetrForObjectDetection:()=>t.DetrForObjectDetection,DetrForSegmentation:()=>t.DetrForSegmentation,DetrImageProcessor:()=>f.DetrImageProcessor,DetrModel:()=>t.DetrModel,DetrObjectDetectionOutput:()=>t.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>t.DetrPreTrainedModel,DetrSegmentationOutput:()=>t.DetrSegmentationOutput,Dinov2ForImageClassification:()=>t.Dinov2ForImageClassification,Dinov2Model:()=>t.Dinov2Model,Dinov2PreTrainedModel:()=>t.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>t.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>t.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>t.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>t.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>t.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>t.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>t.DistilBertForTokenClassification,DistilBertModel:()=>t.DistilBertModel,DistilBertPreTrainedModel:()=>t.DistilBertPreTrainedModel,DistilBertTokenizer:()=>s.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>e.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>f.DonutFeatureExtractor,DonutImageProcessor:()=>f.DonutImageProcessor,DonutSwinModel:()=>t.DonutSwinModel,DonutSwinPreTrainedModel:()=>t.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>t.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>f.EfficientNetImageProcessor,EfficientNetModel:()=>t.EfficientNetModel,EfficientNetPreTrainedModel:()=>t.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>t.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>t.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>t.ElectraForSequenceClassification,ElectraForTokenClassification:()=>t.ElectraForTokenClassification,ElectraModel:()=>t.ElectraModel,ElectraPreTrainedModel:()=>t.ElectraPreTrainedModel,ElectraTokenizer:()=>s.ElectraTokenizer,EncodecFeatureExtractor:()=>d.EncodecFeatureExtractor,EosTokenCriteria:()=>M.EosTokenCriteria,EsmForMaskedLM:()=>t.EsmForMaskedLM,EsmForSequenceClassification:()=>t.EsmForSequenceClassification,EsmForTokenClassification:()=>t.EsmForTokenClassification,EsmModel:()=>t.EsmModel,EsmPreTrainedModel:()=>t.EsmPreTrainedModel,EsmTokenizer:()=>s.EsmTokenizer,ExaoneForCausalLM:()=>t.ExaoneForCausalLM,ExaoneModel:()=>t.ExaoneModel,ExaonePreTrainedModel:()=>t.ExaonePreTrainedModel,FFT:()=>u.FFT,FalconForCausalLM:()=>t.FalconForCausalLM,FalconModel:()=>t.FalconModel,FalconPreTrainedModel:()=>t.FalconPreTrainedModel,FalconTokenizer:()=>s.FalconTokenizer,FastViTForImageClassification:()=>t.FastViTForImageClassification,FastViTModel:()=>t.FastViTModel,FastViTPreTrainedModel:()=>t.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>e.FeatureExtractionPipeline,FeatureExtractor:()=>c.FeatureExtractor,FillMaskPipeline:()=>e.FillMaskPipeline,Florence2ForConditionalGeneration:()=>t.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>t.Florence2PreTrainedModel,Florence2Processor:()=>g.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>w.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>w.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>f.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>t.GLPNForDepthEstimation,GLPNModel:()=>t.GLPNModel,GLPNPreTrainedModel:()=>t.GLPNPreTrainedModel,GPT2LMHeadModel:()=>t.GPT2LMHeadModel,GPT2Model:()=>t.GPT2Model,GPT2PreTrainedModel:()=>t.GPT2PreTrainedModel,GPT2Tokenizer:()=>s.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>t.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>t.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>t.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>t.GPTJForCausalLM,GPTJModel:()=>t.GPTJModel,GPTJPreTrainedModel:()=>t.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>t.GPTNeoForCausalLM,GPTNeoModel:()=>t.GPTNeoModel,GPTNeoPreTrainedModel:()=>t.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>t.GPTNeoXForCausalLM,GPTNeoXModel:()=>t.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>t.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>s.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>t.Gemma2ForCausalLM,Gemma2Model:()=>t.Gemma2Model,Gemma2PreTrainedModel:()=>t.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>t.Gemma3ForCausalLM,Gemma3Model:()=>t.Gemma3Model,Gemma3PreTrainedModel:()=>t.Gemma3PreTrainedModel,Gemma3nAudioFeatureExtractor:()=>d.Gemma3nAudioFeatureExtractor,Gemma3nForConditionalGeneration:()=>t.Gemma3nForConditionalGeneration,Gemma3nPreTrainedModel:()=>t.Gemma3nPreTrainedModel,Gemma3nProcessor:()=>g.Gemma3nProcessor,GemmaForCausalLM:()=>t.GemmaForCausalLM,GemmaModel:()=>t.GemmaModel,GemmaPreTrainedModel:()=>t.GemmaPreTrainedModel,GemmaTokenizer:()=>s.GemmaTokenizer,GlmForCausalLM:()=>t.GlmForCausalLM,GlmModel:()=>t.GlmModel,GlmPreTrainedModel:()=>t.GlmPreTrainedModel,GraniteForCausalLM:()=>t.GraniteForCausalLM,GraniteModel:()=>t.GraniteModel,GranitePreTrainedModel:()=>t.GranitePreTrainedModel,Grok1Tokenizer:()=>s.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>t.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>f.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>t.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>g.GroundingDinoProcessor,GroupViTModel:()=>t.GroupViTModel,GroupViTPreTrainedModel:()=>t.GroupViTPreTrainedModel,HeliumForCausalLM:()=>t.HeliumForCausalLM,HeliumModel:()=>t.HeliumModel,HeliumPreTrainedModel:()=>t.HeliumPreTrainedModel,HerbertTokenizer:()=>s.HerbertTokenizer,HieraForImageClassification:()=>t.HieraForImageClassification,HieraModel:()=>t.HieraModel,HieraPreTrainedModel:()=>t.HieraPreTrainedModel,HubertForCTC:()=>t.HubertForCTC,HubertForSequenceClassification:()=>t.HubertForSequenceClassification,HubertModel:()=>t.HubertModel,HubertPreTrainedModel:()=>t.HubertPreTrainedModel,IJepaForImageClassification:()=>t.IJepaForImageClassification,IJepaModel:()=>t.IJepaModel,IJepaPreTrainedModel:()=>t.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>t.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>f.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>t.Idefics3PreTrainedModel,Idefics3Processor:()=>g.Idefics3Processor,ImageClassificationPipeline:()=>e.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>e.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>d.ImageFeatureExtractor,ImageMattingOutput:()=>t.ImageMattingOutput,ImageProcessor:()=>p.ImageProcessor,ImageSegmentationPipeline:()=>e.ImageSegmentationPipeline,ImageToImagePipeline:()=>e.ImageToImagePipeline,ImageToTextPipeline:()=>e.ImageToTextPipeline,InterruptableStoppingCriteria:()=>M.InterruptableStoppingCriteria,JAISLMHeadModel:()=>t.JAISLMHeadModel,JAISModel:()=>t.JAISModel,JAISPreTrainedModel:()=>t.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>f.JinaCLIPImageProcessor,JinaCLIPModel:()=>t.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>t.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>g.JinaCLIPProcessor,JinaCLIPTextModel:()=>t.JinaCLIPTextModel,JinaCLIPVisionModel:()=>t.JinaCLIPVisionModel,LiteWhisperForConditionalGeneration:()=>t.LiteWhisperForConditionalGeneration,LlamaForCausalLM:()=>t.LlamaForCausalLM,LlamaModel:()=>t.LlamaModel,LlamaPreTrainedModel:()=>t.LlamaPreTrainedModel,LlamaTokenizer:()=>s.LlamaTokenizer,LlavaForConditionalGeneration:()=>t.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>t.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>f.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>t.LlavaPreTrainedModel,LlavaProcessor:()=>g.LlavaProcessor,LlavaQwen2ForCausalLM:()=>t.LlavaQwen2ForCausalLM,LogitsProcessor:()=>w.LogitsProcessor,LogitsProcessorList:()=>w.LogitsProcessorList,LogitsWarper:()=>w.LogitsWarper,LongT5ForConditionalGeneration:()=>t.LongT5ForConditionalGeneration,LongT5Model:()=>t.LongT5Model,LongT5PreTrainedModel:()=>t.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>t.M2M100ForConditionalGeneration,M2M100Model:()=>t.M2M100Model,M2M100PreTrainedModel:()=>t.M2M100PreTrainedModel,M2M100Tokenizer:()=>s.M2M100Tokenizer,MBart50Tokenizer:()=>s.MBart50Tokenizer,MBartForCausalLM:()=>t.MBartForCausalLM,MBartForConditionalGeneration:()=>t.MBartForConditionalGeneration,MBartForSequenceClassification:()=>t.MBartForSequenceClassification,MBartModel:()=>t.MBartModel,MBartPreTrainedModel:()=>t.MBartPreTrainedModel,MBartTokenizer:()=>s.MBartTokenizer,MPNetForMaskedLM:()=>t.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>t.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>t.MPNetForSequenceClassification,MPNetForTokenClassification:()=>t.MPNetForTokenClassification,MPNetModel:()=>t.MPNetModel,MPNetPreTrainedModel:()=>t.MPNetPreTrainedModel,MPNetTokenizer:()=>s.MPNetTokenizer,MT5ForConditionalGeneration:()=>t.MT5ForConditionalGeneration,MT5Model:()=>t.MT5Model,MT5PreTrainedModel:()=>t.MT5PreTrainedModel,MarianMTModel:()=>t.MarianMTModel,MarianModel:()=>t.MarianModel,MarianPreTrainedModel:()=>t.MarianPreTrainedModel,MarianTokenizer:()=>s.MarianTokenizer,Mask2FormerImageProcessor:()=>f.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>f.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>t.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>f.MaskFormerImageProcessor,MaskFormerModel:()=>t.MaskFormerModel,MaskFormerPreTrainedModel:()=>t.MaskFormerPreTrainedModel,MaskedLMOutput:()=>t.MaskedLMOutput,MaxLengthCriteria:()=>M.MaxLengthCriteria,Metric3DForDepthEstimation:()=>t.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>t.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>t.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>t.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>t.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>t.MgpstrModelOutput,MgpstrPreTrainedModel:()=>t.MgpstrPreTrainedModel,MgpstrProcessor:()=>g.MgpstrProcessor,MgpstrTokenizer:()=>s.MgpstrTokenizer,MimiDecoderModel:()=>t.MimiDecoderModel,MimiDecoderOutput:()=>t.MimiDecoderOutput,MimiEncoderModel:()=>t.MimiEncoderModel,MimiEncoderOutput:()=>t.MimiEncoderOutput,MimiModel:()=>t.MimiModel,MimiPreTrainedModel:()=>t.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>w.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>w.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>t.MistralForCausalLM,MistralModel:()=>t.MistralModel,MistralPreTrainedModel:()=>t.MistralPreTrainedModel,MobileBertForMaskedLM:()=>t.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>t.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>t.MobileBertForSequenceClassification,MobileBertModel:()=>t.MobileBertModel,MobileBertPreTrainedModel:()=>t.MobileBertPreTrainedModel,MobileBertTokenizer:()=>s.MobileBertTokenizer,MobileLLMForCausalLM:()=>t.MobileLLMForCausalLM,MobileLLMModel:()=>t.MobileLLMModel,MobileLLMPreTrainedModel:()=>t.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>f.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>t.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>t.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>f.MobileNetV1ImageProcessor,MobileNetV1Model:()=>t.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>t.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>f.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>t.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>t.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>f.MobileNetV2ImageProcessor,MobileNetV2Model:()=>t.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>t.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>f.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>t.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>t.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>f.MobileNetV3ImageProcessor,MobileNetV3Model:()=>t.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>t.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>f.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>t.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>t.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>f.MobileNetV4ImageProcessor,MobileNetV4Model:()=>t.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>t.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>f.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>t.MobileViTForImageClassification,MobileViTImageProcessor:()=>f.MobileViTImageProcessor,MobileViTModel:()=>t.MobileViTModel,MobileViTPreTrainedModel:()=>t.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>t.MobileViTV2ForImageClassification,MobileViTV2Model:()=>t.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>t.MobileViTV2PreTrainedModel,ModelOutput:()=>t.ModelOutput,ModernBertForMaskedLM:()=>t.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>t.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>t.ModernBertForTokenClassification,ModernBertModel:()=>t.ModernBertModel,ModernBertPreTrainedModel:()=>t.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>t.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>d.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>t.MoonshineForConditionalGeneration,MoonshineModel:()=>t.MoonshineModel,MoonshinePreTrainedModel:()=>t.MoonshinePreTrainedModel,MoonshineProcessor:()=>g.MoonshineProcessor,MptForCausalLM:()=>t.MptForCausalLM,MptModel:()=>t.MptModel,MptPreTrainedModel:()=>t.MptPreTrainedModel,MultiModalityCausalLM:()=>t.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>t.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>t.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>t.MusicgenForConditionalGeneration,MusicgenModel:()=>t.MusicgenModel,MusicgenPreTrainedModel:()=>t.MusicgenPreTrainedModel,NeoBertForMaskedLM:()=>t.NeoBertForMaskedLM,NeoBertForQuestionAnswering:()=>t.NeoBertForQuestionAnswering,NeoBertForSequenceClassification:()=>t.NeoBertForSequenceClassification,NeoBertForTokenClassification:()=>t.NeoBertForTokenClassification,NeoBertModel:()=>t.NeoBertModel,NeoBertPreTrainedModel:()=>t.NeoBertPreTrainedModel,NllbTokenizer:()=>s.NllbTokenizer,NoBadWordsLogitsProcessor:()=>w.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>w.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>t.NomicBertModel,NomicBertPreTrainedModel:()=>t.NomicBertPreTrainedModel,NougatImageProcessor:()=>f.NougatImageProcessor,NougatTokenizer:()=>s.NougatTokenizer,OPTForCausalLM:()=>t.OPTForCausalLM,OPTModel:()=>t.OPTModel,OPTPreTrainedModel:()=>t.OPTPreTrainedModel,ObjectDetectionPipeline:()=>e.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>t.Olmo2ForCausalLM,Olmo2Model:()=>t.Olmo2Model,Olmo2PreTrainedModel:()=>t.Olmo2PreTrainedModel,OlmoForCausalLM:()=>t.OlmoForCausalLM,OlmoModel:()=>t.OlmoModel,OlmoPreTrainedModel:()=>t.OlmoPreTrainedModel,OpenELMForCausalLM:()=>t.OpenELMForCausalLM,OpenELMModel:()=>t.OpenELMModel,OpenELMPreTrainedModel:()=>t.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>f.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>t.OwlViTForObjectDetection,OwlViTImageProcessor:()=>f.OwlViTImageProcessor,OwlViTModel:()=>t.OwlViTModel,OwlViTPreTrainedModel:()=>t.OwlViTPreTrainedModel,OwlViTProcessor:()=>g.OwlViTProcessor,Owlv2ForObjectDetection:()=>t.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>f.Owlv2ImageProcessor,Owlv2Model:()=>t.Owlv2Model,Owlv2PreTrainedModel:()=>t.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>t.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>t.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>g.PaliGemmaProcessor,PatchTSMixerForPrediction:()=>t.PatchTSMixerForPrediction,PatchTSMixerModel:()=>t.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>t.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>t.PatchTSTForPrediction,PatchTSTModel:()=>t.PatchTSTModel,PatchTSTPreTrainedModel:()=>t.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>t.Phi3ForCausalLM,Phi3Model:()=>t.Phi3Model,Phi3PreTrainedModel:()=>t.Phi3PreTrainedModel,Phi3VForCausalLM:()=>t.Phi3VForCausalLM,Phi3VImageProcessor:()=>f.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>t.Phi3VPreTrainedModel,Phi3VProcessor:()=>g.Phi3VProcessor,PhiForCausalLM:()=>t.PhiForCausalLM,PhiModel:()=>t.PhiModel,PhiPreTrainedModel:()=>t.PhiPreTrainedModel,Pipeline:()=>e.Pipeline,PreTrainedModel:()=>t.PreTrainedModel,PreTrainedTokenizer:()=>s.PreTrainedTokenizer,PretrainedConfig:()=>r.PretrainedConfig,PretrainedMixin:()=>t.PretrainedMixin,Processor:()=>x.Processor,PvtForImageClassification:()=>t.PvtForImageClassification,PvtImageProcessor:()=>f.PvtImageProcessor,PvtModel:()=>t.PvtModel,PvtPreTrainedModel:()=>t.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>d.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>t.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>t.PyAnnoteModel,PyAnnotePreTrainedModel:()=>t.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>g.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>t.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>e.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>t.Qwen2ForCausalLM,Qwen2Model:()=>t.Qwen2Model,Qwen2PreTrainedModel:()=>t.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>s.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>t.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>f.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>t.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>g.Qwen2VLProcessor,Qwen3ForCausalLM:()=>t.Qwen3ForCausalLM,Qwen3Model:()=>t.Qwen3Model,Qwen3PreTrainedModel:()=>t.Qwen3PreTrainedModel,RFDetrForObjectDetection:()=>t.RFDetrForObjectDetection,RFDetrModel:()=>t.RFDetrModel,RFDetrObjectDetectionOutput:()=>t.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>t.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>t.RTDetrForObjectDetection,RTDetrImageProcessor:()=>f.RTDetrImageProcessor,RTDetrModel:()=>t.RTDetrModel,RTDetrObjectDetectionOutput:()=>t.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>t.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>t.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>t.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>t.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>t.RTDetrV2PreTrainedModel,RawAudio:()=>n.RawAudio,RawImage:()=>o.RawImage,RawVideo:()=>a.RawVideo,RawVideoFrame:()=>a.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>w.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>t.ResNetForImageClassification,ResNetModel:()=>t.ResNetModel,ResNetPreTrainedModel:()=>t.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>t.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>t.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>t.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>t.RoFormerForTokenClassification,RoFormerModel:()=>t.RoFormerModel,RoFormerPreTrainedModel:()=>t.RoFormerPreTrainedModel,RoFormerTokenizer:()=>s.RoFormerTokenizer,RobertaForMaskedLM:()=>t.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>t.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>t.RobertaForSequenceClassification,RobertaForTokenClassification:()=>t.RobertaForTokenClassification,RobertaModel:()=>t.RobertaModel,RobertaPreTrainedModel:()=>t.RobertaPreTrainedModel,RobertaTokenizer:()=>s.RobertaTokenizer,SamImageProcessor:()=>f.SamImageProcessor,SamImageSegmentationOutput:()=>t.SamImageSegmentationOutput,SamModel:()=>t.SamModel,SamPreTrainedModel:()=>t.SamPreTrainedModel,SamProcessor:()=>g.SamProcessor,SapiensForDepthEstimation:()=>t.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>t.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>t.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>t.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>d.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>f.SegformerFeatureExtractor,SegformerForImageClassification:()=>t.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>t.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>f.SegformerImageProcessor,SegformerModel:()=>t.SegformerModel,SegformerPreTrainedModel:()=>t.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>t.Seq2SeqLMOutput,SequenceClassifierOutput:()=>t.SequenceClassifierOutput,SiglipImageProcessor:()=>f.SiglipImageProcessor,SiglipModel:()=>t.SiglipModel,SiglipPreTrainedModel:()=>t.SiglipPreTrainedModel,SiglipTextModel:()=>t.SiglipTextModel,SiglipTokenizer:()=>s.SiglipTokenizer,SiglipVisionModel:()=>t.SiglipVisionModel,SmolVLMForConditionalGeneration:()=>t.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>f.SmolVLMImageProcessor,SmolVLMProcessor:()=>g.SmolVLMProcessor,SnacDecoderModel:()=>t.SnacDecoderModel,SnacEncoderModel:()=>t.SnacEncoderModel,SnacFeatureExtractor:()=>d.SnacFeatureExtractor,SnacModel:()=>t.SnacModel,SnacPreTrainedModel:()=>t.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>d.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>t.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>t.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>t.SpeechT5HifiGan,SpeechT5Model:()=>t.SpeechT5Model,SpeechT5PreTrainedModel:()=>t.SpeechT5PreTrainedModel,SpeechT5Processor:()=>g.SpeechT5Processor,SpeechT5Tokenizer:()=>s.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>t.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>t.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>t.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>t.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>t.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>s.SqueezeBertTokenizer,StableLmForCausalLM:()=>t.StableLmForCausalLM,StableLmModel:()=>t.StableLmModel,StableLmPreTrainedModel:()=>t.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>t.Starcoder2ForCausalLM,Starcoder2Model:()=>t.Starcoder2Model,Starcoder2PreTrainedModel:()=>t.Starcoder2PreTrainedModel,StoppingCriteria:()=>M.StoppingCriteria,StoppingCriteriaList:()=>M.StoppingCriteriaList,StyleTextToSpeech2Model:()=>t.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>t.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>e.SummarizationPipeline,SuppressTokensAtBeginLogitsProcessor:()=>w.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>t.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>f.Swin2SRImageProcessor,Swin2SRModel:()=>t.Swin2SRModel,Swin2SRPreTrainedModel:()=>t.Swin2SRPreTrainedModel,SwinForImageClassification:()=>t.SwinForImageClassification,SwinForSemanticSegmentation:()=>t.SwinForSemanticSegmentation,SwinModel:()=>t.SwinModel,SwinPreTrainedModel:()=>t.SwinPreTrainedModel,T5ForConditionalGeneration:()=>t.T5ForConditionalGeneration,T5Model:()=>t.T5Model,T5PreTrainedModel:()=>t.T5PreTrainedModel,T5Tokenizer:()=>s.T5Tokenizer,TableTransformerForObjectDetection:()=>t.TableTransformerForObjectDetection,TableTransformerModel:()=>t.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>t.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>t.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>w.TemperatureLogitsWarper,Tensor:()=>l.Tensor,Text2TextGenerationPipeline:()=>e.Text2TextGenerationPipeline,TextClassificationPipeline:()=>e.TextClassificationPipeline,TextGenerationPipeline:()=>e.TextGenerationPipeline,TextStreamer:()=>S.TextStreamer,TextToAudioPipeline:()=>e.TextToAudioPipeline,TokenClassificationPipeline:()=>e.TokenClassificationPipeline,TokenClassifierOutput:()=>t.TokenClassifierOutput,TokenizerModel:()=>s.TokenizerModel,TopKLogitsWarper:()=>w.TopKLogitsWarper,TopPLogitsWarper:()=>w.TopPLogitsWarper,TrOCRForCausalLM:()=>t.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>t.TrOCRPreTrainedModel,TranslationPipeline:()=>e.TranslationPipeline,UltravoxModel:()=>t.UltravoxModel,UltravoxPreTrainedModel:()=>t.UltravoxPreTrainedModel,UltravoxProcessor:()=>g.UltravoxProcessor,UniSpeechForCTC:()=>t.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>t.UniSpeechForSequenceClassification,UniSpeechModel:()=>t.UniSpeechModel,UniSpeechPreTrainedModel:()=>t.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>t.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>t.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>t.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>t.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>t.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>g.VLChatProcessor,VLMImageProcessor:()=>f.VLMImageProcessor,ViTFeatureExtractor:()=>f.ViTFeatureExtractor,ViTForImageClassification:()=>t.ViTForImageClassification,ViTImageProcessor:()=>f.ViTImageProcessor,ViTMAEModel:()=>t.ViTMAEModel,ViTMAEPreTrainedModel:()=>t.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>t.ViTMSNForImageClassification,ViTMSNModel:()=>t.ViTMSNModel,ViTMSNPreTrainedModel:()=>t.ViTMSNPreTrainedModel,ViTModel:()=>t.ViTModel,ViTPreTrainedModel:()=>t.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>t.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>t.VitMatteForImageMatting,VitMatteImageProcessor:()=>f.VitMatteImageProcessor,VitMattePreTrainedModel:()=>t.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>t.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>f.VitPoseImageProcessor,VitPosePreTrainedModel:()=>t.VitPosePreTrainedModel,VitsModel:()=>t.VitsModel,VitsModelOutput:()=>t.VitsModelOutput,VitsPreTrainedModel:()=>t.VitsPreTrainedModel,VitsTokenizer:()=>s.VitsTokenizer,Wav2Vec2BertForCTC:()=>t.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>t.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>t.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>t.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>s.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>d.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>t.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>t.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>t.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>t.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>t.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>g.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>g.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>t.WavLMForAudioFrameClassification,WavLMForCTC:()=>t.WavLMForCTC,WavLMForSequenceClassification:()=>t.WavLMForSequenceClassification,WavLMForXVector:()=>t.WavLMForXVector,WavLMModel:()=>t.WavLMModel,WavLMPreTrainedModel:()=>t.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>d.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>t.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>t.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>d.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>t.WhisperForConditionalGeneration,WhisperModel:()=>t.WhisperModel,WhisperPreTrainedModel:()=>t.WhisperPreTrainedModel,WhisperProcessor:()=>g.WhisperProcessor,WhisperTextStreamer:()=>S.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>w.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>s.WhisperTokenizer,XLMForQuestionAnswering:()=>t.XLMForQuestionAnswering,XLMForSequenceClassification:()=>t.XLMForSequenceClassification,XLMForTokenClassification:()=>t.XLMForTokenClassification,XLMModel:()=>t.XLMModel,XLMPreTrainedModel:()=>t.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>t.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>t.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>t.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>t.XLMRobertaForTokenClassification,XLMRobertaModel:()=>t.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>t.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>s.XLMRobertaTokenizer,XLMTokenizer:()=>s.XLMTokenizer,XLMWithLMHeadModel:()=>t.XLMWithLMHeadModel,XVectorOutput:()=>t.XVectorOutput,YolosFeatureExtractor:()=>f.YolosFeatureExtractor,YolosForObjectDetection:()=>t.YolosForObjectDetection,YolosImageProcessor:()=>f.YolosImageProcessor,YolosModel:()=>t.YolosModel,YolosObjectDetectionOutput:()=>t.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>t.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>e.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>e.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>e.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>e.ZeroShotObjectDetectionPipeline,bankers_round:()=>u.bankers_round,cat:()=>l.cat,cos_sim:()=>u.cos_sim,dot:()=>u.dot,dynamic_time_warping:()=>u.dynamic_time_warping,env:()=>i.env,full:()=>l.full,full_like:()=>l.full_like,getKeyValueShapes:()=>r.getKeyValueShapes,hamming:()=>n.hamming,hanning:()=>n.hanning,interpolate:()=>l.interpolate,interpolate_4d:()=>l.interpolate_4d,interpolate_data:()=>u.interpolate_data,is_chinese_char:()=>s.is_chinese_char,layer_norm:()=>l.layer_norm,load_image:()=>o.load_image,load_video:()=>a.load_video,log_softmax:()=>u.log_softmax,magnitude:()=>u.magnitude,matmul:()=>l.matmul,max:()=>u.max,mean:()=>l.mean,mean_pooling:()=>l.mean_pooling,medianFilter:()=>u.medianFilter,mel_filter_bank:()=>n.mel_filter_bank,min:()=>u.min,ones:()=>l.ones,ones_like:()=>l.ones_like,permute:()=>l.permute,permute_data:()=>u.permute_data,pipeline:()=>e.pipeline,quantize_embeddings:()=>l.quantize_embeddings,rand:()=>l.rand,read_audio:()=>n.read_audio,rfft:()=>l.rfft,round:()=>u.round,slice:()=>l.slice,softmax:()=>u.softmax,spectrogram:()=>n.spectrogram,stack:()=>l.stack,std_mean:()=>l.std_mean,topk:()=>l.topk,window_function:()=>n.window_function,zeros:()=>l.zeros,zeros_like:()=>l.zeros_like});var i=bs("./src/env.js"),e=bs("./src/pipelines.js"),t=bs("./src/models.js"),s=bs("./src/tokenizers.js"),r=bs("./src/configs.js"),n=bs("./src/utils/audio.js"),o=bs("./src/utils/image.js"),a=bs("./src/utils/video.js"),l=bs("./src/utils/tensor.js"),u=bs("./src/utils/maths.js"),c=bs("./src/base/feature_extraction_utils.js"),d=bs("./src/models/feature_extractors.js"),h=bs("./src/models/auto/feature_extraction_auto.js"),p=bs("./src/base/image_processors_utils.js"),f=bs("./src/models/image_processors.js"),m=bs("./src/models/auto/image_processing_auto.js"),x=bs("./src/base/processing_utils.js"),g=bs("./src/models/processors.js"),_=bs("./src/models/auto/processing_auto.js"),S=bs("./src/generation/streamers.js"),M=bs("./src/generation/stopping_criteria.js"),w=bs("./src/generation/logits_process.js")})();b.ASTFeatureExtractor;b.ASTForAudioClassification;b.ASTModel;b.ASTPreTrainedModel;b.AlbertForMaskedLM;b.AlbertForQuestionAnswering;b.AlbertForSequenceClassification;b.AlbertModel;b.AlbertPreTrainedModel;b.AlbertTokenizer;b.AudioClassificationPipeline;b.AutoConfig;b.AutoFeatureExtractor;b.AutoImageProcessor;b.AutoModel;b.AutoModelForAudioClassification;b.AutoModelForAudioFrameClassification;b.AutoModelForAudioTextToText;b.AutoModelForCTC;b.AutoModelForCausalLM;b.AutoModelForDepthEstimation;b.AutoModelForDocumentQuestionAnswering;b.AutoModelForImageClassification;b.AutoModelForImageFeatureExtraction;b.AutoModelForImageMatting;b.AutoModelForImageSegmentation;b.AutoModelForImageTextToText;b.AutoModelForImageToImage;b.AutoModelForMaskGeneration;b.AutoModelForMaskedLM;b.AutoModelForNormalEstimation;b.AutoModelForObjectDetection;b.AutoModelForPoseEstimation;b.AutoModelForQuestionAnswering;b.AutoModelForSemanticSegmentation;b.AutoModelForSeq2SeqLM;b.AutoModelForSequenceClassification;b.AutoModelForSpeechSeq2Seq;b.AutoModelForTextToSpectrogram;b.AutoModelForTextToWaveform;b.AutoModelForTokenClassification;b.AutoModelForUniversalSegmentation;b.AutoModelForVision2Seq;b.AutoModelForXVector;b.AutoModelForZeroShotObjectDetection;b.AutoProcessor;b.AutoTokenizer;b.AutomaticSpeechRecognitionPipeline;b.BackgroundRemovalPipeline;b.BartForConditionalGeneration;b.BartForSequenceClassification;b.BartModel;b.BartPretrainedModel;b.BartTokenizer;b.BaseModelOutput;b.BaseStreamer;b.BeitFeatureExtractor;b.BeitForImageClassification;b.BeitModel;b.BeitPreTrainedModel;b.BertForMaskedLM;b.BertForQuestionAnswering;b.BertForSequenceClassification;b.BertForTokenClassification;b.BertModel;b.BertPreTrainedModel;b.BertTokenizer;b.BitImageProcessor;b.BlenderbotForConditionalGeneration;b.BlenderbotModel;b.BlenderbotPreTrainedModel;b.BlenderbotSmallForConditionalGeneration;b.BlenderbotSmallModel;b.BlenderbotSmallPreTrainedModel;b.BlenderbotSmallTokenizer;b.BlenderbotTokenizer;b.BloomForCausalLM;b.BloomModel;b.BloomPreTrainedModel;b.BloomTokenizer;b.CLIPFeatureExtractor;b.CLIPImageProcessor;b.CLIPModel;b.CLIPPreTrainedModel;b.CLIPSegForImageSegmentation;b.CLIPSegModel;b.CLIPSegPreTrainedModel;b.CLIPTextModel;b.CLIPTextModelWithProjection;b.CLIPTokenizer;b.CLIPVisionModel;b.CLIPVisionModelWithProjection;b.CamembertForMaskedLM;b.CamembertForQuestionAnswering;b.CamembertForSequenceClassification;b.CamembertForTokenClassification;b.CamembertModel;b.CamembertPreTrainedModel;b.CamembertTokenizer;b.CausalLMOutput;b.CausalLMOutputWithPast;b.ChineseCLIPFeatureExtractor;b.ChineseCLIPModel;b.ChineseCLIPPreTrainedModel;b.ClapAudioModelWithProjection;b.ClapFeatureExtractor;b.ClapModel;b.ClapPreTrainedModel;b.ClapTextModelWithProjection;b.ClassifierFreeGuidanceLogitsProcessor;b.CodeGenForCausalLM;b.CodeGenModel;b.CodeGenPreTrainedModel;b.CodeGenTokenizer;b.CodeLlamaTokenizer;b.CohereForCausalLM;b.CohereModel;b.CoherePreTrainedModel;b.CohereTokenizer;b.ConvBertForMaskedLM;b.ConvBertForQuestionAnswering;b.ConvBertForSequenceClassification;b.ConvBertForTokenClassification;b.ConvBertModel;b.ConvBertPreTrainedModel;b.ConvBertTokenizer;b.ConvNextFeatureExtractor;b.ConvNextForImageClassification;b.ConvNextImageProcessor;b.ConvNextModel;b.ConvNextPreTrainedModel;b.ConvNextV2ForImageClassification;b.ConvNextV2Model;b.ConvNextV2PreTrainedModel;b.DFineForObjectDetection;b.DFineModel;b.DFinePreTrainedModel;b.DPTFeatureExtractor;b.DPTForDepthEstimation;b.DPTImageProcessor;b.DPTModel;b.DPTPreTrainedModel;b.DacDecoderModel;b.DacDecoderOutput;b.DacEncoderModel;b.DacEncoderOutput;b.DacFeatureExtractor;b.DacModel;b.DacPreTrainedModel;b.DataTypeMap;b.DebertaForMaskedLM;b.DebertaForQuestionAnswering;b.DebertaForSequenceClassification;b.DebertaForTokenClassification;b.DebertaModel;b.DebertaPreTrainedModel;b.DebertaTokenizer;b.DebertaV2ForMaskedLM;b.DebertaV2ForQuestionAnswering;b.DebertaV2ForSequenceClassification;b.DebertaV2ForTokenClassification;b.DebertaV2Model;b.DebertaV2PreTrainedModel;b.DebertaV2Tokenizer;b.DecisionTransformerModel;b.DecisionTransformerPreTrainedModel;b.DeiTFeatureExtractor;b.DeiTForImageClassification;b.DeiTImageProcessor;b.DeiTModel;b.DeiTPreTrainedModel;b.DepthAnythingForDepthEstimation;b.DepthAnythingPreTrainedModel;b.DepthEstimationPipeline;b.DepthProForDepthEstimation;b.DepthProPreTrainedModel;b.DetrFeatureExtractor;b.DetrForObjectDetection;b.DetrForSegmentation;b.DetrImageProcessor;b.DetrModel;b.DetrObjectDetectionOutput;b.DetrPreTrainedModel;b.DetrSegmentationOutput;b.Dinov2ForImageClassification;b.Dinov2Model;b.Dinov2PreTrainedModel;b.Dinov2WithRegistersForImageClassification;b.Dinov2WithRegistersModel;b.Dinov2WithRegistersPreTrainedModel;b.DistilBertForMaskedLM;b.DistilBertForQuestionAnswering;b.DistilBertForSequenceClassification;b.DistilBertForTokenClassification;b.DistilBertModel;b.DistilBertPreTrainedModel;b.DistilBertTokenizer;b.DocumentQuestionAnsweringPipeline;b.DonutFeatureExtractor;b.DonutImageProcessor;b.DonutSwinModel;b.DonutSwinPreTrainedModel;b.EfficientNetForImageClassification;b.EfficientNetImageProcessor;b.EfficientNetModel;b.EfficientNetPreTrainedModel;b.ElectraForMaskedLM;b.ElectraForQuestionAnswering;b.ElectraForSequenceClassification;b.ElectraForTokenClassification;b.ElectraModel;b.ElectraPreTrainedModel;b.ElectraTokenizer;b.EncodecFeatureExtractor;b.EosTokenCriteria;b.EsmForMaskedLM;b.EsmForSequenceClassification;b.EsmForTokenClassification;b.EsmModel;b.EsmPreTrainedModel;b.EsmTokenizer;b.ExaoneForCausalLM;b.ExaoneModel;b.ExaonePreTrainedModel;b.FFT;b.FalconForCausalLM;b.FalconModel;b.FalconPreTrainedModel;b.FalconTokenizer;b.FastViTForImageClassification;b.FastViTModel;b.FastViTPreTrainedModel;b.FeatureExtractionPipeline;b.FeatureExtractor;b.FillMaskPipeline;b.Florence2ForConditionalGeneration;b.Florence2PreTrainedModel;b.Florence2Processor;b.ForcedBOSTokenLogitsProcessor;b.ForcedEOSTokenLogitsProcessor;b.GLPNFeatureExtractor;b.GLPNForDepthEstimation;b.GLPNModel;b.GLPNPreTrainedModel;b.GPT2LMHeadModel;b.GPT2Model;b.GPT2PreTrainedModel;b.GPT2Tokenizer;b.GPTBigCodeForCausalLM;b.GPTBigCodeModel;b.GPTBigCodePreTrainedModel;b.GPTJForCausalLM;b.GPTJModel;b.GPTJPreTrainedModel;b.GPTNeoForCausalLM;b.GPTNeoModel;b.GPTNeoPreTrainedModel;b.GPTNeoXForCausalLM;b.GPTNeoXModel;b.GPTNeoXPreTrainedModel;b.GPTNeoXTokenizer;b.Gemma2ForCausalLM;b.Gemma2Model;b.Gemma2PreTrainedModel;b.Gemma3ForCausalLM;b.Gemma3Model;b.Gemma3PreTrainedModel;b.Gemma3nAudioFeatureExtractor;b.Gemma3nForConditionalGeneration;b.Gemma3nPreTrainedModel;b.Gemma3nProcessor;b.GemmaForCausalLM;b.GemmaModel;b.GemmaPreTrainedModel;b.GemmaTokenizer;b.GlmForCausalLM;b.GlmModel;b.GlmPreTrainedModel;b.GraniteForCausalLM;b.GraniteModel;b.GranitePreTrainedModel;b.Grok1Tokenizer;b.GroundingDinoForObjectDetection;b.GroundingDinoImageProcessor;b.GroundingDinoPreTrainedModel;b.GroundingDinoProcessor;b.GroupViTModel;b.GroupViTPreTrainedModel;b.HeliumForCausalLM;b.HeliumModel;b.HeliumPreTrainedModel;b.HerbertTokenizer;b.HieraForImageClassification;b.HieraModel;b.HieraPreTrainedModel;b.HubertForCTC;b.HubertForSequenceClassification;b.HubertModel;b.HubertPreTrainedModel;b.IJepaForImageClassification;b.IJepaModel;b.IJepaPreTrainedModel;b.Idefics3ForConditionalGeneration;b.Idefics3ImageProcessor;b.Idefics3PreTrainedModel;b.Idefics3Processor;b.ImageClassificationPipeline;b.ImageFeatureExtractionPipeline;b.ImageFeatureExtractor;b.ImageMattingOutput;b.ImageProcessor;b.ImageSegmentationPipeline;b.ImageToImagePipeline;b.ImageToTextPipeline;b.InterruptableStoppingCriteria;b.JAISLMHeadModel;b.JAISModel;b.JAISPreTrainedModel;b.JinaCLIPImageProcessor;b.JinaCLIPModel;b.JinaCLIPPreTrainedModel;b.JinaCLIPProcessor;b.JinaCLIPTextModel;b.JinaCLIPVisionModel;b.LiteWhisperForConditionalGeneration;b.LlamaForCausalLM;b.LlamaModel;b.LlamaPreTrainedModel;b.LlamaTokenizer;b.LlavaForConditionalGeneration;b.LlavaOnevisionForConditionalGeneration;b.LlavaOnevisionImageProcessor;b.LlavaPreTrainedModel;b.LlavaProcessor;b.LlavaQwen2ForCausalLM;b.LogitsProcessor;b.LogitsProcessorList;b.LogitsWarper;b.LongT5ForConditionalGeneration;b.LongT5Model;b.LongT5PreTrainedModel;b.M2M100ForConditionalGeneration;b.M2M100Model;b.M2M100PreTrainedModel;b.M2M100Tokenizer;b.MBart50Tokenizer;b.MBartForCausalLM;b.MBartForConditionalGeneration;b.MBartForSequenceClassification;b.MBartModel;b.MBartPreTrainedModel;b.MBartTokenizer;b.MPNetForMaskedLM;b.MPNetForQuestionAnswering;b.MPNetForSequenceClassification;b.MPNetForTokenClassification;b.MPNetModel;b.MPNetPreTrainedModel;b.MPNetTokenizer;b.MT5ForConditionalGeneration;b.MT5Model;b.MT5PreTrainedModel;b.MarianMTModel;b.MarianModel;b.MarianPreTrainedModel;b.MarianTokenizer;b.Mask2FormerImageProcessor;b.MaskFormerFeatureExtractor;b.MaskFormerForInstanceSegmentation;b.MaskFormerImageProcessor;b.MaskFormerModel;b.MaskFormerPreTrainedModel;b.MaskedLMOutput;b.MaxLengthCriteria;b.Metric3DForDepthEstimation;b.Metric3DPreTrainedModel;b.Metric3Dv2ForDepthEstimation;b.Metric3Dv2PreTrainedModel;b.MgpstrForSceneTextRecognition;b.MgpstrModelOutput;b.MgpstrPreTrainedModel;b.MgpstrProcessor;b.MgpstrTokenizer;b.MimiDecoderModel;b.MimiDecoderOutput;b.MimiEncoderModel;b.MimiEncoderOutput;b.MimiModel;b.MimiPreTrainedModel;b.MinLengthLogitsProcessor;b.MinNewTokensLengthLogitsProcessor;b.MistralForCausalLM;b.MistralModel;b.MistralPreTrainedModel;b.MobileBertForMaskedLM;b.MobileBertForQuestionAnswering;b.MobileBertForSequenceClassification;b.MobileBertModel;b.MobileBertPreTrainedModel;b.MobileBertTokenizer;b.MobileLLMForCausalLM;b.MobileLLMModel;b.MobileLLMPreTrainedModel;b.MobileNetV1FeatureExtractor;b.MobileNetV1ForImageClassification;b.MobileNetV1ForSemanticSegmentation;b.MobileNetV1ImageProcessor;b.MobileNetV1Model;b.MobileNetV1PreTrainedModel;b.MobileNetV2FeatureExtractor;b.MobileNetV2ForImageClassification;b.MobileNetV2ForSemanticSegmentation;b.MobileNetV2ImageProcessor;b.MobileNetV2Model;b.MobileNetV2PreTrainedModel;b.MobileNetV3FeatureExtractor;b.MobileNetV3ForImageClassification;b.MobileNetV3ForSemanticSegmentation;b.MobileNetV3ImageProcessor;b.MobileNetV3Model;b.MobileNetV3PreTrainedModel;b.MobileNetV4FeatureExtractor;b.MobileNetV4ForImageClassification;b.MobileNetV4ForSemanticSegmentation;b.MobileNetV4ImageProcessor;b.MobileNetV4Model;b.MobileNetV4PreTrainedModel;b.MobileViTFeatureExtractor;b.MobileViTForImageClassification;b.MobileViTImageProcessor;b.MobileViTModel;b.MobileViTPreTrainedModel;b.MobileViTV2ForImageClassification;b.MobileViTV2Model;b.MobileViTV2PreTrainedModel;b.ModelOutput;b.ModernBertForMaskedLM;b.ModernBertForSequenceClassification;b.ModernBertForTokenClassification;b.ModernBertModel;b.ModernBertPreTrainedModel;b.Moondream1ForConditionalGeneration;b.MoonshineFeatureExtractor;b.MoonshineForConditionalGeneration;b.MoonshineModel;b.MoonshinePreTrainedModel;b.MoonshineProcessor;b.MptForCausalLM;b.MptModel;b.MptPreTrainedModel;b.MultiModalityCausalLM;b.MultiModalityPreTrainedModel;b.MusicgenForCausalLM;b.MusicgenForConditionalGeneration;b.MusicgenModel;b.MusicgenPreTrainedModel;b.NeoBertForMaskedLM;b.NeoBertForQuestionAnswering;b.NeoBertForSequenceClassification;b.NeoBertForTokenClassification;b.NeoBertModel;b.NeoBertPreTrainedModel;b.NllbTokenizer;b.NoBadWordsLogitsProcessor;b.NoRepeatNGramLogitsProcessor;b.NomicBertModel;b.NomicBertPreTrainedModel;b.NougatImageProcessor;b.NougatTokenizer;b.OPTForCausalLM;b.OPTModel;b.OPTPreTrainedModel;b.ObjectDetectionPipeline;b.Olmo2ForCausalLM;b.Olmo2Model;b.Olmo2PreTrainedModel;b.OlmoForCausalLM;b.OlmoModel;b.OlmoPreTrainedModel;b.OpenELMForCausalLM;b.OpenELMModel;b.OpenELMPreTrainedModel;b.OwlViTFeatureExtractor;b.OwlViTForObjectDetection;b.OwlViTImageProcessor;b.OwlViTModel;b.OwlViTPreTrainedModel;b.OwlViTProcessor;b.Owlv2ForObjectDetection;b.Owlv2ImageProcessor;b.Owlv2Model;b.Owlv2PreTrainedModel;b.PaliGemmaForConditionalGeneration;b.PaliGemmaPreTrainedModel;b.PaliGemmaProcessor;b.PatchTSMixerForPrediction;b.PatchTSMixerModel;b.PatchTSMixerPreTrainedModel;b.PatchTSTForPrediction;b.PatchTSTModel;b.PatchTSTPreTrainedModel;b.Phi3ForCausalLM;b.Phi3Model;b.Phi3PreTrainedModel;b.Phi3VForCausalLM;b.Phi3VImageProcessor;b.Phi3VPreTrainedModel;b.Phi3VProcessor;b.PhiForCausalLM;b.PhiModel;b.PhiPreTrainedModel;b.Pipeline;b.PreTrainedModel;b.PreTrainedTokenizer;b.PretrainedConfig;b.PretrainedMixin;b.Processor;b.PvtForImageClassification;b.PvtImageProcessor;b.PvtModel;b.PvtPreTrainedModel;b.PyAnnoteFeatureExtractor;b.PyAnnoteForAudioFrameClassification;b.PyAnnoteModel;b.PyAnnotePreTrainedModel;b.PyAnnoteProcessor;b.QuestionAnsweringModelOutput;b.QuestionAnsweringPipeline;b.Qwen2ForCausalLM;b.Qwen2Model;b.Qwen2PreTrainedModel;b.Qwen2Tokenizer;b.Qwen2VLForConditionalGeneration;b.Qwen2VLImageProcessor;b.Qwen2VLPreTrainedModel;b.Qwen2VLProcessor;b.Qwen3ForCausalLM;b.Qwen3Model;b.Qwen3PreTrainedModel;b.RFDetrForObjectDetection;b.RFDetrModel;b.RFDetrObjectDetectionOutput;b.RFDetrPreTrainedModel;b.RTDetrForObjectDetection;b.RTDetrImageProcessor;b.RTDetrModel;b.RTDetrObjectDetectionOutput;b.RTDetrPreTrainedModel;b.RTDetrV2ForObjectDetection;b.RTDetrV2Model;b.RTDetrV2ObjectDetectionOutput;b.RTDetrV2PreTrainedModel;b.RawAudio;b.RawImage;b.RawVideo;b.RawVideoFrame;b.RepetitionPenaltyLogitsProcessor;b.ResNetForImageClassification;b.ResNetModel;b.ResNetPreTrainedModel;b.RoFormerForMaskedLM;b.RoFormerForQuestionAnswering;b.RoFormerForSequenceClassification;b.RoFormerForTokenClassification;b.RoFormerModel;b.RoFormerPreTrainedModel;b.RoFormerTokenizer;b.RobertaForMaskedLM;b.RobertaForQuestionAnswering;b.RobertaForSequenceClassification;b.RobertaForTokenClassification;b.RobertaModel;b.RobertaPreTrainedModel;b.RobertaTokenizer;b.SamImageProcessor;b.SamImageSegmentationOutput;b.SamModel;b.SamPreTrainedModel;b.SamProcessor;b.SapiensForDepthEstimation;b.SapiensForNormalEstimation;b.SapiensForSemanticSegmentation;b.SapiensPreTrainedModel;b.SeamlessM4TFeatureExtractor;b.SegformerFeatureExtractor;b.SegformerForImageClassification;b.SegformerForSemanticSegmentation;b.SegformerImageProcessor;b.SegformerModel;b.SegformerPreTrainedModel;b.Seq2SeqLMOutput;b.SequenceClassifierOutput;b.SiglipImageProcessor;b.SiglipModel;b.SiglipPreTrainedModel;b.SiglipTextModel;b.SiglipTokenizer;b.SiglipVisionModel;b.SmolVLMForConditionalGeneration;b.SmolVLMImageProcessor;b.SmolVLMProcessor;b.SnacDecoderModel;b.SnacEncoderModel;b.SnacFeatureExtractor;b.SnacModel;b.SnacPreTrainedModel;b.SpeechT5FeatureExtractor;b.SpeechT5ForSpeechToText;b.SpeechT5ForTextToSpeech;b.SpeechT5HifiGan;b.SpeechT5Model;b.SpeechT5PreTrainedModel;b.SpeechT5Processor;b.SpeechT5Tokenizer;b.SqueezeBertForMaskedLM;b.SqueezeBertForQuestionAnswering;b.SqueezeBertForSequenceClassification;b.SqueezeBertModel;b.SqueezeBertPreTrainedModel;b.SqueezeBertTokenizer;b.StableLmForCausalLM;b.StableLmModel;b.StableLmPreTrainedModel;b.Starcoder2ForCausalLM;b.Starcoder2Model;b.Starcoder2PreTrainedModel;b.StoppingCriteria;b.StoppingCriteriaList;b.StyleTextToSpeech2Model;b.StyleTextToSpeech2PreTrainedModel;b.SummarizationPipeline;b.SuppressTokensAtBeginLogitsProcessor;b.Swin2SRForImageSuperResolution;b.Swin2SRImageProcessor;b.Swin2SRModel;b.Swin2SRPreTrainedModel;b.SwinForImageClassification;b.SwinForSemanticSegmentation;b.SwinModel;b.SwinPreTrainedModel;b.T5ForConditionalGeneration;b.T5Model;b.T5PreTrainedModel;b.T5Tokenizer;b.TableTransformerForObjectDetection;b.TableTransformerModel;b.TableTransformerObjectDetectionOutput;b.TableTransformerPreTrainedModel;b.TemperatureLogitsWarper;b.Tensor;b.Text2TextGenerationPipeline;b.TextClassificationPipeline;b.TextGenerationPipeline;b.TextStreamer;b.TextToAudioPipeline;b.TokenClassificationPipeline;b.TokenClassifierOutput;b.TokenizerModel;b.TopKLogitsWarper;b.TopPLogitsWarper;b.TrOCRForCausalLM;b.TrOCRPreTrainedModel;b.TranslationPipeline;b.UltravoxModel;b.UltravoxPreTrainedModel;b.UltravoxProcessor;b.UniSpeechForCTC;b.UniSpeechForSequenceClassification;b.UniSpeechModel;b.UniSpeechPreTrainedModel;b.UniSpeechSatForAudioFrameClassification;b.UniSpeechSatForCTC;b.UniSpeechSatForSequenceClassification;b.UniSpeechSatModel;b.UniSpeechSatPreTrainedModel;b.VLChatProcessor;b.VLMImageProcessor;b.ViTFeatureExtractor;b.ViTForImageClassification;b.ViTImageProcessor;b.ViTMAEModel;b.ViTMAEPreTrainedModel;b.ViTMSNForImageClassification;b.ViTMSNModel;b.ViTMSNPreTrainedModel;b.ViTModel;b.ViTPreTrainedModel;b.VisionEncoderDecoderModel;b.VitMatteForImageMatting;b.VitMatteImageProcessor;b.VitMattePreTrainedModel;b.VitPoseForPoseEstimation;b.VitPoseImageProcessor;b.VitPosePreTrainedModel;b.VitsModel;b.VitsModelOutput;b.VitsPreTrainedModel;b.VitsTokenizer;b.Wav2Vec2BertForCTC;b.Wav2Vec2BertForSequenceClassification;b.Wav2Vec2BertModel;b.Wav2Vec2BertPreTrainedModel;b.Wav2Vec2CTCTokenizer;b.Wav2Vec2FeatureExtractor;b.Wav2Vec2ForAudioFrameClassification;b.Wav2Vec2ForCTC;b.Wav2Vec2ForSequenceClassification;b.Wav2Vec2Model;b.Wav2Vec2PreTrainedModel;b.Wav2Vec2Processor;b.Wav2Vec2ProcessorWithLM;b.WavLMForAudioFrameClassification;b.WavLMForCTC;b.WavLMForSequenceClassification;b.WavLMForXVector;b.WavLMModel;b.WavLMPreTrainedModel;b.WeSpeakerFeatureExtractor;b.WeSpeakerResNetModel;b.WeSpeakerResNetPreTrainedModel;b.WhisperFeatureExtractor;b.WhisperForConditionalGeneration;b.WhisperModel;b.WhisperPreTrainedModel;b.WhisperProcessor;b.WhisperTextStreamer;b.WhisperTimeStampLogitsProcessor;b.WhisperTokenizer;b.XLMForQuestionAnswering;b.XLMForSequenceClassification;b.XLMForTokenClassification;b.XLMModel;b.XLMPreTrainedModel;b.XLMRobertaForMaskedLM;b.XLMRobertaForQuestionAnswering;b.XLMRobertaForSequenceClassification;b.XLMRobertaForTokenClassification;b.XLMRobertaModel;b.XLMRobertaPreTrainedModel;b.XLMRobertaTokenizer;b.XLMTokenizer;b.XLMWithLMHeadModel;b.XVectorOutput;b.YolosFeatureExtractor;b.YolosForObjectDetection;b.YolosImageProcessor;b.YolosModel;b.YolosObjectDetectionOutput;b.YolosPreTrainedModel;b.ZeroShotAudioClassificationPipeline;b.ZeroShotClassificationPipeline;b.ZeroShotImageClassificationPipeline;b.ZeroShotObjectDetectionPipeline;b.bankers_round;b.cat;b.cos_sim;b.dot;b.dynamic_time_warping;b.env;b.full;b.full_like;b.getKeyValueShapes;b.hamming;b.hanning;b.interpolate;b.interpolate_4d;b.interpolate_data;b.is_chinese_char;b.layer_norm;b.load_image;b.load_video;b.log_softmax;b.magnitude;b.matmul;b.max;b.mean;b.mean_pooling;b.medianFilter;b.mel_filter_bank;b.min;b.ones;b.ones_like;b.permute;b.permute_data;var sV=b.pipeline;b.quantize_embeddings;b.rand;b.read_audio;b.rfft;b.round;b.slice;b.softmax;b.spectrogram;b.stack;b.std_mean;b.topk;b.window_function;b.zeros;b.zeros_like;/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.20.0
 * @author George Michael Brower
 * @license MIT
 */class po{constructor(e,t,s,r,n="div"){this.parent=e,this.object=t,this.property=s,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement(n),this.domElement.classList.add("controller"),this.domElement.classList.add(r),this.$name=document.createElement("div"),this.$name.classList.add("name"),po.nextNameID=po.nextNameID||0,this.$name.id=`lil-gui-name-${++po.nextNameID}`,this.$widget=document.createElement("div"),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.domElement.addEventListener("keydown",o=>o.stopPropagation()),this.domElement.addEventListener("keyup",o=>o.stopPropagation()),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(s)}name(e){return this._name=e,this.$name.textContent=e,this}onChange(e){return this._onChange=e,this}_callOnChange(){this.parent._callOnChange(this),this._onChange!==void 0&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),this._onFinishChange!==void 0&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(e=!0){return this.disable(!e)}disable(e=!0){return e===this._disabled?this:(this._disabled=e,this.domElement.classList.toggle("disabled",e),this.$disable.toggleAttribute("disabled",e),this)}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(e){const t=this.parent.add(this.object,this.property,e);return t.name(this._name),this.destroy(),t}min(e){return this}max(e){return this}step(e){return this}decimals(e){return this}listen(e=!0){return this._listening=e,this._listenCallbackID!==void 0&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const e=this.save();e!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=e}getValue(){return this.object[this.property]}setValue(e){return this.getValue()!==e&&(this.object[this.property]=e,this._callOnChange(),this.updateDisplay()),this}updateDisplay(){return this}load(e){return this.setValue(e),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class iV extends po{constructor(e,t,s){super(e,t,s,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",()=>{this.setValue(this.$input.checked),this._callOnFinishChange()}),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function Bx(i){let e,t;return(e=i.match(/(#|0x)?([a-f0-9]{6})/i))?t=e[2]:(e=i.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?t=parseInt(e[1]).toString(16).padStart(2,0)+parseInt(e[2]).toString(16).padStart(2,0)+parseInt(e[3]).toString(16).padStart(2,0):(e=i.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(t=e[1]+e[1]+e[2]+e[2]+e[3]+e[3]),t?"#"+t:!1}const rV={isPrimitive:!0,match:i=>typeof i=="string",fromHexString:Bx,toHexString:Bx},eh={isPrimitive:!0,match:i=>typeof i=="number",fromHexString:i=>parseInt(i.substring(1),16),toHexString:i=>"#"+i.toString(16).padStart(6,0)},nV={isPrimitive:!1,match:i=>Array.isArray(i),fromHexString(i,e,t=1){const s=eh.fromHexString(i);e[0]=(s>>16&255)/255*t,e[1]=(s>>8&255)/255*t,e[2]=(s&255)/255*t},toHexString([i,e,t],s=1){s=255/s;const r=i*s<<16^e*s<<8^t*s<<0;return eh.toHexString(r)}},oV={isPrimitive:!1,match:i=>Object(i)===i,fromHexString(i,e,t=1){const s=eh.fromHexString(i);e.r=(s>>16&255)/255*t,e.g=(s>>8&255)/255*t,e.b=(s&255)/255*t},toHexString({r:i,g:e,b:t},s=1){s=255/s;const r=i*s<<16^e*s<<8^t*s<<0;return eh.toHexString(r)}},aV=[rV,eh,nV,oV];function lV(i){return aV.find(e=>e.match(i))}class uV extends po{constructor(e,t,s,r){super(e,t,s,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=lV(this.initialValue),this._rgbScale=r,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",()=>{this._setValueFromHexString(this.$input.value)}),this.$input.addEventListener("blur",()=>{this._callOnFinishChange()}),this.$text.addEventListener("input",()=>{const n=Bx(this.$text.value);n&&this._setValueFromHexString(n)}),this.$text.addEventListener("focus",()=>{this._textFocused=!0,this.$text.select()}),this.$text.addEventListener("blur",()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()}),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(e){if(this._format.isPrimitive){const t=this._format.fromHexString(e);this.setValue(t)}else this._format.fromHexString(e,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(e){return this._setValueFromHexString(e),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class ly extends po{constructor(e,t,s){super(e,t,s,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",r=>{r.preventDefault(),this.getValue().call(this.object),this._callOnChange()}),this.$button.addEventListener("touchstart",()=>{},{passive:!0}),this.$disable=this.$button}}class cV extends po{constructor(e,t,s,r,n,o){super(e,t,s,"number"),this._initInput(),this.min(r),this.max(n);const a=o!==void 0;this.step(a?o:this._getImplicitStep(),a),this.updateDisplay()}decimals(e){return this._decimals=e,this.updateDisplay(),this}min(e){return this._min=e,this._onUpdateMinMax(),this}max(e){return this._max=e,this._onUpdateMinMax(),this}step(e,t=!0){return this._step=e,this._stepExplicit=t,this}updateDisplay(){const e=this.getValue();if(this._hasSlider){let t=(e-this._min)/(this._max-this._min);t=Math.max(0,Math.min(t,1)),this.$fill.style.width=t*100+"%"}return this._inputFocused||(this.$input.value=this._decimals===void 0?e:e.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),window.matchMedia("(pointer: coarse)").matches&&(this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any")),this.$widget.appendChild(this.$input),this.$disable=this.$input;const t=()=>{let _=parseFloat(this.$input.value);isNaN(_)||(this._stepExplicit&&(_=this._snap(_)),this.setValue(this._clamp(_)))},s=_=>{const S=parseFloat(this.$input.value);isNaN(S)||(this._snapClampSetValue(S+_),this.$input.value=this.getValue())},r=_=>{_.key==="Enter"&&this.$input.blur(),_.code==="ArrowUp"&&(_.preventDefault(),s(this._step*this._arrowKeyMultiplier(_))),_.code==="ArrowDown"&&(_.preventDefault(),s(this._step*this._arrowKeyMultiplier(_)*-1))},n=_=>{this._inputFocused&&(_.preventDefault(),s(this._step*this._normalizeMouseWheel(_)))};let o=!1,a,l,u,c,d;const h=5,p=_=>{a=_.clientX,l=u=_.clientY,o=!0,c=this.getValue(),d=0,window.addEventListener("mousemove",f),window.addEventListener("mouseup",m)},f=_=>{if(o){const S=_.clientX-a,M=_.clientY-l;Math.abs(M)>h?(_.preventDefault(),this.$input.blur(),o=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(S)>h&&m()}if(!o){const S=_.clientY-u;d-=S*this._step*this._arrowKeyMultiplier(_),c+d>this._max?d=this._max-c:c+d<this._min&&(d=this._min-c),this._snapClampSetValue(c+d)}u=_.clientY},m=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",f),window.removeEventListener("mouseup",m)},x=()=>{this._inputFocused=!0},g=()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()};this.$input.addEventListener("input",t),this.$input.addEventListener("keydown",r),this.$input.addEventListener("wheel",n,{passive:!1}),this.$input.addEventListener("mousedown",p),this.$input.addEventListener("focus",x),this.$input.addEventListener("blur",g)}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const e=(g,_,S,M,w)=>(g-_)/(S-_)*(w-M)+M,t=g=>{const _=this.$slider.getBoundingClientRect();let S=e(g,_.left,_.right,this._min,this._max);this._snapClampSetValue(S)},s=g=>{this._setDraggingStyle(!0),t(g.clientX),window.addEventListener("mousemove",r),window.addEventListener("mouseup",n)},r=g=>{t(g.clientX)},n=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",r),window.removeEventListener("mouseup",n)};let o=!1,a,l;const u=g=>{g.preventDefault(),this._setDraggingStyle(!0),t(g.touches[0].clientX),o=!1},c=g=>{g.touches.length>1||(this._hasScrollBar?(a=g.touches[0].clientX,l=g.touches[0].clientY,o=!0):u(g),window.addEventListener("touchmove",d,{passive:!1}),window.addEventListener("touchend",h))},d=g=>{if(o){const _=g.touches[0].clientX-a,S=g.touches[0].clientY-l;Math.abs(_)>Math.abs(S)?u(g):(window.removeEventListener("touchmove",d),window.removeEventListener("touchend",h))}else g.preventDefault(),t(g.touches[0].clientX)},h=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",d),window.removeEventListener("touchend",h)},p=this._callOnFinishChange.bind(this),f=400;let m;const x=g=>{if(Math.abs(g.deltaX)<Math.abs(g.deltaY)&&this._hasScrollBar)return;g.preventDefault();const S=this._normalizeMouseWheel(g)*this._step;this._snapClampSetValue(this.getValue()+S),this.$input.value=this.getValue(),clearTimeout(m),m=setTimeout(p,f)};this.$slider.addEventListener("mousedown",s),this.$slider.addEventListener("touchstart",c,{passive:!1}),this.$slider.addEventListener("wheel",x,{passive:!1})}_setDraggingStyle(e,t="horizontal"){this.$slider&&this.$slider.classList.toggle("active",e),document.body.classList.toggle("lil-gui-dragging",e),document.body.classList.toggle(`lil-gui-${t}`,e)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(e){let{deltaX:t,deltaY:s}=e;return Math.floor(e.deltaY)!==e.deltaY&&e.wheelDelta&&(t=0,s=-e.wheelDelta/120,s*=this._stepExplicit?1:10),t+-s}_arrowKeyMultiplier(e){let t=this._stepExplicit?1:10;return e.shiftKey?t*=10:e.altKey&&(t/=10),t}_snap(e){let t=0;return this._hasMin?t=this._min:this._hasMax&&(t=this._max),e-=t,e=Math.round(e/this._step)*this._step,e+=t,e=parseFloat(e.toPrecision(15)),e}_clamp(e){return e<this._min&&(e=this._min),e>this._max&&(e=this._max),e}_snapClampSetValue(e){this.setValue(this._clamp(this._snap(e)))}get _hasScrollBar(){const e=this.parent.root.$children;return e.scrollHeight>e.clientHeight}get _hasMin(){return this._min!==void 0}get _hasMax(){return this._max!==void 0}}class dV extends po{constructor(e,t,s,r){super(e,t,s,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$select.addEventListener("change",()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()}),this.$select.addEventListener("focus",()=>{this.$display.classList.add("focus")}),this.$select.addEventListener("blur",()=>{this.$display.classList.remove("focus")}),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.options(r)}options(e){return this._values=Array.isArray(e)?e:Object.values(e),this._names=Array.isArray(e)?e:Object.keys(e),this.$select.replaceChildren(),this._names.forEach(t=>{const s=document.createElement("option");s.textContent=t,this.$select.appendChild(s)}),this.updateDisplay(),this}updateDisplay(){const e=this.getValue(),t=this._values.indexOf(e);return this.$select.selectedIndex=t,this.$display.textContent=t===-1?e:this._names[t],this}}class hV extends po{constructor(e,t,s){super(e,t,s,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("spellcheck","false"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",()=>{this.setValue(this.$input.value)}),this.$input.addEventListener("keydown",r=>{r.code==="Enter"&&this.$input.blur()}),this.$input.addEventListener("blur",()=>{this._callOnFinishChange()}),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}var pV=`.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "↕";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  font-weight: 600;
  padding: 0 var(--padding);
  width: 100%;
  text-align: left;
  background: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "▾";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "▸";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "✓";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  border: none;
}
.lil-gui .controller button {
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
}
@media (hover: hover) {
  .lil-gui .controller button:hover {
    background: var(--hover-color);
  }
  .lil-gui .controller button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui .controller button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;function fV(i){const e=document.createElement("style");e.innerHTML=i;const t=document.querySelector("head link[rel=stylesheet], head style");t?document.head.insertBefore(e,t):document.head.appendChild(e)}let RP=!1;class o0{constructor({parent:e,autoPlace:t=e===void 0,container:s,width:r,title:n="Controls",closeFolders:o=!1,injectStyles:a=!0,touchStyles:l=!0}={}){if(this.parent=e,this.root=e?e.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("button"),this.$title.classList.add("title"),this.$title.setAttribute("aria-expanded",!0),this.$title.addEventListener("click",()=>this.openAnimated(this._closed)),this.$title.addEventListener("touchstart",()=>{},{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(n),this.parent){this.parent.children.push(this),this.parent.folders.push(this),this.parent.$children.appendChild(this.domElement);return}this.domElement.classList.add("root"),l&&this.domElement.classList.add("allow-touch-styles"),!RP&&a&&(fV(pV),RP=!0),s?s.appendChild(this.domElement):t&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),r&&this.domElement.style.setProperty("--width",r+"px"),this._closeFolders=o}add(e,t,s,r,n){if(Object(s)===s)return new dV(this,e,t,s);const o=e[t];switch(typeof o){case"number":return new cV(this,e,t,s,r,n);case"boolean":return new iV(this,e,t);case"string":return new hV(this,e,t);case"function":return new ly(this,e,t)}console.error(`gui.add failed
	property:`,t,`
	object:`,e,`
	value:`,o)}addColor(e,t,s=1){return new uV(this,e,t,s)}addFolder(e){const t=new o0({parent:this,title:e});return this.root._closeFolders&&t.close(),t}load(e,t=!0){return e.controllers&&this.controllers.forEach(s=>{s instanceof ly||s._name in e.controllers&&s.load(e.controllers[s._name])}),t&&e.folders&&this.folders.forEach(s=>{s._title in e.folders&&s.load(e.folders[s._title])}),this}save(e=!0){const t={controllers:{},folders:{}};return this.controllers.forEach(s=>{if(!(s instanceof ly)){if(s._name in t.controllers)throw new Error(`Cannot save GUI with duplicate property "${s._name}"`);t.controllers[s._name]=s.save()}}),e&&this.folders.forEach(s=>{if(s._title in t.folders)throw new Error(`Cannot save GUI with duplicate folder "${s._title}"`);t.folders[s._title]=s.save()}),t}open(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}_setClosed(e){this._closed!==e&&(this._closed=e,this._callOnOpenClose(this))}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame(()=>{const t=this.$children.clientHeight;this.$children.style.height=t+"px",this.domElement.classList.add("transition");const s=n=>{n.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",s))};this.$children.addEventListener("transitionend",s);const r=e?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!e),requestAnimationFrame(()=>{this.$children.style.height=r+"px"})}),this}title(e){return this._title=e,this.$title.textContent=e,this}reset(e=!0){return(e?this.controllersRecursive():this.controllers).forEach(s=>s.reset()),this}onChange(e){return this._onChange=e,this}_callOnChange(e){this.parent&&this.parent._callOnChange(e),this._onChange!==void 0&&this._onChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(e){this.parent&&this.parent._callOnFinishChange(e),this._onFinishChange!==void 0&&this._onFinishChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onOpenClose(e){return this._onOpenClose=e,this}_callOnOpenClose(e){this.parent&&this.parent._callOnOpenClose(e),this._onOpenClose!==void 0&&this._onOpenClose.call(this,e)}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach(e=>e.destroy())}controllersRecursive(){let e=Array.from(this.controllers);return this.folders.forEach(t=>{e=e.concat(t.controllersRecursive())}),e}foldersRecursive(){let e=Array.from(this.folders);return this.folders.forEach(t=>{e=e.concat(t.foldersRecursive())}),e}}var mV=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function gV(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var yD={exports:{}};(function(i,e){(function(t,s){i.exports=s()})(mV,function(){var t=function(){function s(p){return o.appendChild(p.dom),p}function r(p){for(var f=0;f<o.children.length;f++)o.children[f].style.display=f===p?"block":"none";n=p}var n=0,o=document.createElement("div");o.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",o.addEventListener("click",function(p){p.preventDefault(),r(++n%o.children.length)},!1);var a=(performance||Date).now(),l=a,u=0,c=s(new t.Panel("FPS","#0ff","#002")),d=s(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var h=s(new t.Panel("MB","#f08","#201"));return r(0),{REVISION:16,dom:o,addPanel:s,showPanel:r,begin:function(){a=(performance||Date).now()},end:function(){u++;var p=(performance||Date).now();if(d.update(p-a,200),p>l+1e3&&(c.update(1e3*u/(p-l),100),l=p,u=0,h)){var f=performance.memory;h.update(f.usedJSHeapSize/1048576,f.jsHeapSizeLimit/1048576)}return p},update:function(){a=this.end()},domElement:o,setMode:r}};return t.Panel=function(s,r,n){var o=1/0,a=0,l=Math.round,u=l(window.devicePixelRatio||1),c=80*u,d=48*u,h=3*u,p=2*u,f=3*u,m=15*u,x=74*u,g=30*u,_=document.createElement("canvas");_.width=c,_.height=d,_.style.cssText="width:80px;height:48px";var S=_.getContext("2d");return S.font="bold "+9*u+"px Helvetica,Arial,sans-serif",S.textBaseline="top",S.fillStyle=n,S.fillRect(0,0,c,d),S.fillStyle=r,S.fillText(s,h,p),S.fillRect(f,m,x,g),S.fillStyle=n,S.globalAlpha=.9,S.fillRect(f,m,x,g),{dom:_,update:function(M,w){o=Math.min(o,M),a=Math.max(a,M),S.fillStyle=n,S.globalAlpha=1,S.fillRect(0,0,c,m),S.fillStyle=r,S.fillText(l(M)+" "+s+" ("+l(o)+"-"+l(a)+")",h,p),S.drawImage(_,f+u,m,x-u,g,f,m,x-u,g),S.fillRect(f+x-u,m,u,g),S.fillStyle=n,S.globalAlpha=.9,S.fillRect(f+x-u,m,u,l((1-M/w)*g))}}},t})})(yD);var _V=yD.exports;const yV=gV(_V);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const hm="178",rc={ROTATE:0,DOLLY:1,PAN:2},Qu={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},xV=0,bV=1,wV=2,MV=0,TV=1,Tf=3,Wo=0,lr=1,Da=2,fc=0,Ho=1,Uf=2,Gf=3,jf=4,zd=5,Un=100,xD=101,bD=102,vV=103,SV=104,Aa=200,wD=201,MD=202,TD=203,Wf=204,Hf=205,vD=206,SD=207,ED=208,AD=209,CD=210,PD=0,ND=1,FD=2,qf=3,RD=4,ID=5,DD=6,kD=7,pm=0,EV=1,AV=2,nc=0,CV=1,PV=2,NV=3,FV=4,RV=6,IV=7,a0=300,th=301,Kf=302,l0=303,u0=304,Ox=306,mc=1e3,Ra=1001,gc=1002,yi=1003,LD=1004,sh=1005,wr=1006,$x=1007,qo=1008,DV=1008,xr=1009,Vd=1010,Ud=1011,Zu=1012,_r=1013,_i=1014,Kr=1015,Cr=1016,kV=1017,LV=1018,ka=1020,BD=35902,BV=1021,c0=1022,fn=1023,fo=1026,Ko=1027,d0=1028,h0=1029,Ol=1030,p0=1031,OV=1032,f0=1033,uy=33776,vf=33777,Sf=33778,Ef=33779,IP=35840,DP=35841,kP=35842,LP=35843,BP=36196,zx=37492,Vx=37496,Ux=37808,Gx=37809,jx=37810,Wx=37811,Hx=37812,qx=37813,Kx=37814,Xx=37815,Yx=37816,Qx=37817,Zx=37818,Jx=37819,eb=37820,tb=37821,cy=36492,$V=36283,OP=36284,$P=36285,zP=36286,$a=0,zV=1,ea="",jr="srgb",Ul="srgb-linear",Xf="linear",jt="srgb",VV=0,Nl=7680,UV=7681,GV=7682,jV=7683,WV=34055,HV=34056,qV=5386,KV=512,XV=513,YV=514,QV=515,ZV=516,JV=517,eU=518,sb=519,OD=512,m0=513,$D=514,zD=515,VD=516,UD=517,GD=518,jD=519,Yf=35044,Ju=35048,Pr=2e3,xo=2001;class oa{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){const s=this._listeners;return s===void 0?!1:s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){const s=this._listeners;if(s===void 0)return;const r=s[e];if(r!==void 0){const n=r.indexOf(t);n!==-1&&r.splice(n,1)}}dispatchEvent(e){const t=this._listeners;if(t===void 0)return;const s=t[e.type];if(s!==void 0){e.target=this;const r=s.slice(0);for(let n=0,o=r.length;n<o;n++)r[n].call(this,e);e.target=null}}}const rr=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let VP=1234567;const Gd=Math.PI/180,_c=180/Math.PI;function Xo(){const i=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(rr[i&255]+rr[i>>8&255]+rr[i>>16&255]+rr[i>>24&255]+"-"+rr[e&255]+rr[e>>8&255]+"-"+rr[e>>16&15|64]+rr[e>>24&255]+"-"+rr[t&63|128]+rr[t>>8&255]+"-"+rr[t>>16&255]+rr[t>>24&255]+rr[s&255]+rr[s>>8&255]+rr[s>>16&255]+rr[s>>24&255]).toLowerCase()}function es(i,e,t){return Math.max(e,Math.min(t,i))}function g0(i,e){return(i%e+e)%e}function tU(i,e,t,s,r){return s+(i-e)*(r-s)/(t-e)}function sU(i,e,t){return i!==e?(t-i)/(e-i):0}function jd(i,e,t){return(1-t)*i+t*e}function iU(i,e,t,s){return jd(i,e,1-Math.exp(-t*s))}function rU(i,e=1){return e-Math.abs(g0(i,e*2)-e)}function nU(i,e,t){return i<=e?0:i>=t?1:(i=(i-e)/(t-e),i*i*(3-2*i))}function oU(i,e,t){return i<=e?0:i>=t?1:(i=(i-e)/(t-e),i*i*i*(i*(i*6-15)+10))}function aU(i,e){return i+Math.floor(Math.random()*(e-i+1))}function lU(i,e){return i+Math.random()*(e-i)}function uU(i){return i*(.5-Math.random())}function cU(i){i!==void 0&&(VP=i);let e=VP+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function dU(i){return i*Gd}function hU(i){return i*_c}function pU(i){return(i&i-1)===0&&i!==0}function fU(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))}function mU(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function gU(i,e,t,s,r){const n=Math.cos,o=Math.sin,a=n(t/2),l=o(t/2),u=n((e+s)/2),c=o((e+s)/2),d=n((e-s)/2),h=o((e-s)/2),p=n((s-e)/2),f=o((s-e)/2);switch(r){case"XYX":i.set(a*c,l*d,l*h,a*u);break;case"YZY":i.set(l*h,a*c,l*d,a*u);break;case"ZXZ":i.set(l*d,l*h,a*c,a*u);break;case"XZX":i.set(a*c,l*f,l*p,a*u);break;case"YXY":i.set(l*p,a*c,l*f,a*u);break;case"ZYZ":i.set(l*f,l*p,a*c,a*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}function yr(i,e){switch(e.constructor){case Float32Array:return i;case Uint32Array:return i/4294967295;case Uint16Array:return i/65535;case Uint8Array:return i/255;case Int32Array:return Math.max(i/2147483647,-1);case Int16Array:return Math.max(i/32767,-1);case Int8Array:return Math.max(i/127,-1);default:throw new Error("Invalid component type.")}}function Qt(i,e){switch(e.constructor){case Float32Array:return i;case Uint32Array:return Math.round(i*4294967295);case Uint16Array:return Math.round(i*65535);case Uint8Array:return Math.round(i*255);case Int32Array:return Math.round(i*2147483647);case Int16Array:return Math.round(i*32767);case Int8Array:return Math.round(i*127);default:throw new Error("Invalid component type.")}}const _0={DEG2RAD:Gd,RAD2DEG:_c,generateUUID:Xo,clamp:es,euclideanModulo:g0,mapLinear:tU,inverseLerp:sU,lerp:jd,damp:iU,pingpong:rU,smoothstep:nU,smootherstep:oU,randInt:aU,randFloat:lU,randFloatSpread:uU,seededRandom:cU,degToRad:dU,radToDeg:hU,isPowerOfTwo:pU,ceilPowerOfTwo:fU,floorPowerOfTwo:mU,setQuaternionFromProperEuler:gU,normalize:Qt,denormalize:yr};class Dt{constructor(e=0,t=0){Dt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,r=e.elements;return this.x=r[0]*t+r[3]*s+r[6],this.y=r[1]*t+r[4]*s+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=es(this.x,e.x,t.x),this.y=es(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=es(this.x,e,t),this.y=es(this.y,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(es(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(es(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),r=Math.sin(t),n=this.x-e.x,o=this.y-e.y;return this.x=n*s-o*r+e.x,this.y=n*r+o*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class za{constructor(e=0,t=0,s=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=s,this._w=r}static slerpFlat(e,t,s,r,n,o,a){let l=s[r+0],u=s[r+1],c=s[r+2],d=s[r+3];const h=n[o+0],p=n[o+1],f=n[o+2],m=n[o+3];if(a===0){e[t+0]=l,e[t+1]=u,e[t+2]=c,e[t+3]=d;return}if(a===1){e[t+0]=h,e[t+1]=p,e[t+2]=f,e[t+3]=m;return}if(d!==m||l!==h||u!==p||c!==f){let x=1-a;const g=l*h+u*p+c*f+d*m,_=g>=0?1:-1,S=1-g*g;if(S>Number.EPSILON){const w=Math.sqrt(S),v=Math.atan2(w,g*_);x=Math.sin(x*v)/w,a=Math.sin(a*v)/w}const M=a*_;if(l=l*x+h*M,u=u*x+p*M,c=c*x+f*M,d=d*x+m*M,x===1-a){const w=1/Math.sqrt(l*l+u*u+c*c+d*d);l*=w,u*=w,c*=w,d*=w}}e[t]=l,e[t+1]=u,e[t+2]=c,e[t+3]=d}static multiplyQuaternionsFlat(e,t,s,r,n,o){const a=s[r],l=s[r+1],u=s[r+2],c=s[r+3],d=n[o],h=n[o+1],p=n[o+2],f=n[o+3];return e[t]=a*f+c*d+l*p-u*h,e[t+1]=l*f+c*h+u*d-a*p,e[t+2]=u*f+c*p+a*h-l*d,e[t+3]=c*f-a*d-l*h-u*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,r){return this._x=e,this._y=t,this._z=s,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const s=e._x,r=e._y,n=e._z,o=e._order,a=Math.cos,l=Math.sin,u=a(s/2),c=a(r/2),d=a(n/2),h=l(s/2),p=l(r/2),f=l(n/2);switch(o){case"XYZ":this._x=h*c*d+u*p*f,this._y=u*p*d-h*c*f,this._z=u*c*f+h*p*d,this._w=u*c*d-h*p*f;break;case"YXZ":this._x=h*c*d+u*p*f,this._y=u*p*d-h*c*f,this._z=u*c*f-h*p*d,this._w=u*c*d+h*p*f;break;case"ZXY":this._x=h*c*d-u*p*f,this._y=u*p*d+h*c*f,this._z=u*c*f+h*p*d,this._w=u*c*d-h*p*f;break;case"ZYX":this._x=h*c*d-u*p*f,this._y=u*p*d+h*c*f,this._z=u*c*f-h*p*d,this._w=u*c*d+h*p*f;break;case"YZX":this._x=h*c*d+u*p*f,this._y=u*p*d+h*c*f,this._z=u*c*f-h*p*d,this._w=u*c*d-h*p*f;break;case"XZY":this._x=h*c*d-u*p*f,this._y=u*p*d-h*c*f,this._z=u*c*f+h*p*d,this._w=u*c*d+h*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,r=Math.sin(s);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],r=t[4],n=t[8],o=t[1],a=t[5],l=t[9],u=t[2],c=t[6],d=t[10],h=s+a+d;if(h>0){const p=.5/Math.sqrt(h+1);this._w=.25/p,this._x=(c-l)*p,this._y=(n-u)*p,this._z=(o-r)*p}else if(s>a&&s>d){const p=2*Math.sqrt(1+s-a-d);this._w=(c-l)/p,this._x=.25*p,this._y=(r+o)/p,this._z=(n+u)/p}else if(a>d){const p=2*Math.sqrt(1+a-s-d);this._w=(n-u)/p,this._x=(r+o)/p,this._y=.25*p,this._z=(l+c)/p}else{const p=2*Math.sqrt(1+d-s-a);this._w=(o-r)/p,this._x=(n+u)/p,this._y=(l+c)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<1e-8?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(es(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const r=Math.min(1,t/s);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,r=e._y,n=e._z,o=e._w,a=t._x,l=t._y,u=t._z,c=t._w;return this._x=s*c+o*a+r*u-n*l,this._y=r*c+o*l+n*a-s*u,this._z=n*c+o*u+s*l-r*a,this._w=o*c-s*a-r*l-n*u,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const s=this._x,r=this._y,n=this._z,o=this._w;let a=o*e._w+s*e._x+r*e._y+n*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=s,this._y=r,this._z=n,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*s+t*this._x,this._y=p*r+t*this._y,this._z=p*n+t*this._z,this.normalize(),this}const u=Math.sqrt(l),c=Math.atan2(u,a),d=Math.sin((1-t)*c)/u,h=Math.sin(t*c)/u;return this._w=o*d+this._w*h,this._x=s*d+this._x*h,this._y=r*d+this._y*h,this._z=n*d+this._z*h,this._onChangeCallback(),this}slerpQuaternions(e,t,s){return this.copy(e).slerp(t,s)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),s=Math.random(),r=Math.sqrt(1-s),n=Math.sqrt(s);return this.set(r*Math.sin(e),r*Math.cos(e),n*Math.sin(t),n*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class xe{constructor(e=0,t=0,s=0){xe.prototype.isVector3=!0,this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(UP.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(UP.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,r=this.z,n=e.elements;return this.x=n[0]*t+n[3]*s+n[6]*r,this.y=n[1]*t+n[4]*s+n[7]*r,this.z=n[2]*t+n[5]*s+n[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,r=this.z,n=e.elements,o=1/(n[3]*t+n[7]*s+n[11]*r+n[15]);return this.x=(n[0]*t+n[4]*s+n[8]*r+n[12])*o,this.y=(n[1]*t+n[5]*s+n[9]*r+n[13])*o,this.z=(n[2]*t+n[6]*s+n[10]*r+n[14])*o,this}applyQuaternion(e){const t=this.x,s=this.y,r=this.z,n=e.x,o=e.y,a=e.z,l=e.w,u=2*(o*r-a*s),c=2*(a*t-n*r),d=2*(n*s-o*t);return this.x=t+l*u+o*d-a*c,this.y=s+l*c+a*u-n*d,this.z=r+l*d+n*c-o*u,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,r=this.z,n=e.elements;return this.x=n[0]*t+n[4]*s+n[8]*r,this.y=n[1]*t+n[5]*s+n[9]*r,this.z=n[2]*t+n[6]*s+n[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=es(this.x,e.x,t.x),this.y=es(this.y,e.y,t.y),this.z=es(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=es(this.x,e,t),this.y=es(this.y,e,t),this.z=es(this.z,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(es(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,r=e.y,n=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-n*a,this.y=n*o-s*l,this.z=s*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return dy.copy(this).projectOnVector(e),this.sub(dy)}reflect(e){return this.sub(dy.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(es(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,r=this.z-e.z;return t*t+s*s+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const r=Math.sin(t)*e;return this.x=r*Math.sin(s),this.y=Math.cos(t)*e,this.z=r*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,s=Math.sqrt(1-t*t);return this.x=s*Math.cos(e),this.y=t,this.z=s*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const dy=new xe,UP=new za;class kr{constructor(e,t,s,r,n,o,a,l,u){kr.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,s,r,n,o,a,l,u)}set(e,t,s,r,n,o,a,l,u){const c=this.elements;return c[0]=e,c[1]=r,c[2]=a,c[3]=t,c[4]=n,c[5]=l,c[6]=s,c[7]=o,c[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,r=t.elements,n=this.elements,o=s[0],a=s[3],l=s[6],u=s[1],c=s[4],d=s[7],h=s[2],p=s[5],f=s[8],m=r[0],x=r[3],g=r[6],_=r[1],S=r[4],M=r[7],w=r[2],v=r[5],T=r[8];return n[0]=o*m+a*_+l*w,n[3]=o*x+a*S+l*v,n[6]=o*g+a*M+l*T,n[1]=u*m+c*_+d*w,n[4]=u*x+c*S+d*v,n[7]=u*g+c*M+d*T,n[2]=h*m+p*_+f*w,n[5]=h*x+p*S+f*v,n[8]=h*g+p*M+f*T,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],r=e[2],n=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8];return t*o*c-t*a*u-s*n*c+s*a*l+r*n*u-r*o*l}invert(){const e=this.elements,t=e[0],s=e[1],r=e[2],n=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],d=c*o-a*u,h=a*l-c*n,p=u*n-o*l,f=t*d+s*h+r*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return e[0]=d*m,e[1]=(r*u-c*s)*m,e[2]=(a*s-r*o)*m,e[3]=h*m,e[4]=(c*t-r*l)*m,e[5]=(r*n-a*t)*m,e[6]=p*m,e[7]=(s*l-u*t)*m,e[8]=(o*t-s*n)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,r,n,o,a){const l=Math.cos(n),u=Math.sin(n);return this.set(s*l,s*u,-s*(l*o+u*a)+o+e,-r*u,r*l,-r*(-u*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(hy.makeScale(e,t)),this}rotate(e){return this.premultiply(hy.makeRotation(-e)),this}translate(e,t){return this.premultiply(hy.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,s=e.elements;for(let r=0;r<9;r++)if(t[r]!==s[r])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const hy=new kr;function WD(i){for(let e=i.length-1;e>=0;--e)if(i[e]>=65535)return!0;return!1}function ib(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}function _U(){const i=ib("canvas");return i.style.display="block",i}const GP={};function ta(i){i in GP||(GP[i]=!0,console.warn(i))}const jP=new kr().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),WP=new kr().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function yU(){const i={enabled:!0,workingColorSpace:Ul,spaces:{},convert:function(r,n,o){return this.enabled===!1||n===o||!n||!o||(this.spaces[n].transfer===jt&&(r.r=Yo(r.r),r.g=Yo(r.g),r.b=Yo(r.b)),this.spaces[n].primaries!==this.spaces[o].primaries&&(r.applyMatrix3(this.spaces[n].toXYZ),r.applyMatrix3(this.spaces[o].fromXYZ)),this.spaces[o].transfer===jt&&(r.r=oc(r.r),r.g=oc(r.g),r.b=oc(r.b))),r},workingToColorSpace:function(r,n){return this.convert(r,this.workingColorSpace,n)},colorSpaceToWorking:function(r,n){return this.convert(r,n,this.workingColorSpace)},getPrimaries:function(r){return this.spaces[r].primaries},getTransfer:function(r){return r===ea?Xf:this.spaces[r].transfer},getLuminanceCoefficients:function(r,n=this.workingColorSpace){return r.fromArray(this.spaces[n].luminanceCoefficients)},define:function(r){Object.assign(this.spaces,r)},_getMatrix:function(r,n,o){return r.copy(this.spaces[n].toXYZ).multiply(this.spaces[o].fromXYZ)},_getDrawingBufferColorSpace:function(r){return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(r=this.workingColorSpace){return this.spaces[r].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(r,n){return ta("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),i.workingToColorSpace(r,n)},toWorkingColorSpace:function(r,n){return ta("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),i.colorSpaceToWorking(r,n)}},e=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],s=[.3127,.329];return i.define({[Ul]:{primaries:e,whitePoint:s,transfer:Xf,toXYZ:jP,fromXYZ:WP,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:jr},outputColorSpaceConfig:{drawingBufferColorSpace:jr}},[jr]:{primaries:e,whitePoint:s,transfer:jt,toXYZ:jP,fromXYZ:WP,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:jr}}}),i}const Ls=yU();function Yo(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function oc(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}let Eu;class xU{static getDataURL(e,t="image/png"){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let s;if(e instanceof HTMLCanvasElement)s=e;else{Eu===void 0&&(Eu=ib("canvas")),Eu.width=e.width,Eu.height=e.height;const r=Eu.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),s=Eu}return s.toDataURL(t)}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=ib("canvas");t.width=e.width,t.height=e.height;const s=t.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const r=s.getImageData(0,0,e.width,e.height),n=r.data;for(let o=0;o<n.length;o++)n[o]=Yo(n[o]/255)*255;return s.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let s=0;s<t.length;s++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[s]=Math.floor(Yo(t[s]/255)*255):t[s]=Yo(t[s]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let bU=0;class y0{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:bU++}),this.uuid=Xo(),this.data=e,this.dataReady=!0,this.version=0}getSize(e){const t=this.data;return t instanceof HTMLVideoElement?e.set(t.videoWidth,t.videoHeight):t!==null?e.set(t.width,t.height,t.depth||0):e.set(0,0,0),e}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},r=this.data;if(r!==null){let n;if(Array.isArray(r)){n=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?n.push(py(r[o].image)):n.push(py(r[o]))}else n=py(r);s.url=n}return t||(e.images[this.uuid]=s),s}}function py(i){return typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&i instanceof ImageBitmap?xU.getDataURL(i):i.data?{data:Array.from(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let wU=0;const fy=new xe;class Yi extends oa{constructor(e=Yi.DEFAULT_IMAGE,t=Yi.DEFAULT_MAPPING,s=Ra,r=Ra,n=wr,o=qo,a=fn,l=xr,u=Yi.DEFAULT_ANISOTROPY,c=ea){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:wU++}),this.uuid=Xo(),this.name="",this.source=new y0(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=s,this.wrapT=r,this.magFilter=n,this.minFilter=o,this.anisotropy=u,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Dt(0,0),this.repeat=new Dt(1,1),this.center=new Dt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new kr,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=c,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(e&&e.depth&&e.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(fy).x}get height(){return this.source.getSize(fy).y}get depth(){return this.source.getSize(fy).z}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.isArrayTexture=e.isArrayTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}setValues(e){for(const t in e){const s=e[t];if(s===void 0){console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);continue}const r=this[t];if(r===void 0){console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);continue}r&&s&&r.isVector2&&s.isVector2||r&&s&&r.isVector3&&s.isVector3||r&&s&&r.isMatrix3&&s.isMatrix3?r.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==a0)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case mc:e.x=e.x-Math.floor(e.x);break;case Ra:e.x=e.x<0?0:1;break;case gc:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case mc:e.y=e.y-Math.floor(e.y);break;case Ra:e.y=e.y<0?0:1;break;case gc:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}Yi.DEFAULT_IMAGE=null;Yi.DEFAULT_MAPPING=a0;Yi.DEFAULT_ANISOTROPY=1;class ns{constructor(e=0,t=0,s=0,r=1){ns.prototype.isVector4=!0,this.x=e,this.y=t,this.z=s,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,r){return this.x=e,this.y=t,this.z=s,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,r=this.z,n=this.w,o=e.elements;return this.x=o[0]*t+o[4]*s+o[8]*r+o[12]*n,this.y=o[1]*t+o[5]*s+o[9]*r+o[13]*n,this.z=o[2]*t+o[6]*s+o[10]*r+o[14]*n,this.w=o[3]*t+o[7]*s+o[11]*r+o[15]*n,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,r,n;const l=e.elements,u=l[0],c=l[4],d=l[8],h=l[1],p=l[5],f=l[9],m=l[2],x=l[6],g=l[10];if(Math.abs(c-h)<.01&&Math.abs(d-m)<.01&&Math.abs(f-x)<.01){if(Math.abs(c+h)<.1&&Math.abs(d+m)<.1&&Math.abs(f+x)<.1&&Math.abs(u+p+g-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const S=(u+1)/2,M=(p+1)/2,w=(g+1)/2,v=(c+h)/4,T=(d+m)/4,E=(f+x)/4;return S>M&&S>w?S<.01?(s=0,r=.707106781,n=.707106781):(s=Math.sqrt(S),r=v/s,n=T/s):M>w?M<.01?(s=.707106781,r=0,n=.707106781):(r=Math.sqrt(M),s=v/r,n=E/r):w<.01?(s=.707106781,r=.707106781,n=0):(n=Math.sqrt(w),s=T/n,r=E/n),this.set(s,r,n,t),this}let _=Math.sqrt((x-f)*(x-f)+(d-m)*(d-m)+(h-c)*(h-c));return Math.abs(_)<.001&&(_=1),this.x=(x-f)/_,this.y=(d-m)/_,this.z=(h-c)/_,this.w=Math.acos((u+p+g-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=es(this.x,e.x,t.x),this.y=es(this.y,e.y,t.y),this.z=es(this.z,e.z,t.z),this.w=es(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=es(this.x,e,t),this.y=es(this.y,e,t),this.z=es(this.z,e,t),this.w=es(this.w,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(es(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class So extends oa{constructor(e=1,t=1,s={}){super(),s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:wr,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},s),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=s.depth,this.scissor=new ns(0,0,e,t),this.scissorTest=!1,this.viewport=new ns(0,0,e,t);const r={width:e,height:t,depth:s.depth},n=new Yi(r);this.textures=[];const o=s.count;for(let a=0;a<o;a++)this.textures[a]=n.clone(),this.textures[a].isRenderTargetTexture=!0,this.textures[a].renderTarget=this;this._setTextureOptions(s),this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.resolveDepthBuffer=s.resolveDepthBuffer,this.resolveStencilBuffer=s.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=s.depthTexture,this.samples=s.samples,this.multiview=s.multiview}_setTextureOptions(e={}){const t={minFilter:wr,generateMipmaps:!1,flipY:!1,internalFormat:null};e.mapping!==void 0&&(t.mapping=e.mapping),e.wrapS!==void 0&&(t.wrapS=e.wrapS),e.wrapT!==void 0&&(t.wrapT=e.wrapT),e.wrapR!==void 0&&(t.wrapR=e.wrapR),e.magFilter!==void 0&&(t.magFilter=e.magFilter),e.minFilter!==void 0&&(t.minFilter=e.minFilter),e.format!==void 0&&(t.format=e.format),e.type!==void 0&&(t.type=e.type),e.anisotropy!==void 0&&(t.anisotropy=e.anisotropy),e.colorSpace!==void 0&&(t.colorSpace=e.colorSpace),e.flipY!==void 0&&(t.flipY=e.flipY),e.generateMipmaps!==void 0&&(t.generateMipmaps=e.generateMipmaps),e.internalFormat!==void 0&&(t.internalFormat=e.internalFormat);for(let s=0;s<this.textures.length;s++)this.textures[s].setValues(t)}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,s=1){if(this.width!==e||this.height!==t||this.depth!==s){this.width=e,this.height=t,this.depth=s;for(let r=0,n=this.textures.length;r<n;r++)this.textures[r].image.width=e,this.textures[r].image.height=t,this.textures[r].image.depth=s,this.textures[r].isArrayTexture=this.textures[r].image.depth>1;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let t=0,s=e.textures.length;t<s;t++){this.textures[t]=e.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;const r=Object.assign({},e.textures[t].image);this.textures[t].source=new y0(r)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class MU extends So{constructor(e=1,t=1,s={}){super(e,t,s),this.isWebGLRenderTarget=!0}}class TU extends Yi{constructor(e=null,t=1,s=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:s,depth:r},this.magFilter=yi,this.minFilter=yi,this.wrapR=Ra,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class ph{constructor(e=new xe(1/0,1/0,1/0),t=new xe(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t+=3)this.expandByPoint(kn.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,s=e.count;t<s;t++)this.expandByPoint(kn.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=kn.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const n=s.getAttribute("position");if(t===!0&&n!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=n.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,kn):kn.fromBufferAttribute(n,o),kn.applyMatrix4(e.matrixWorld),this.expandByPoint(kn);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),Ip.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),Ip.copy(s.boundingBox)),Ip.applyMatrix4(e.matrixWorld),this.union(Ip)}const r=e.children;for(let n=0,o=r.length;n<o;n++)this.expandByObject(r[n],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,kn),kn.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(hd),Dp.subVectors(this.max,hd),Au.subVectors(e.a,hd),Cu.subVectors(e.b,hd),Pu.subVectors(e.c,hd),xa.subVectors(Cu,Au),ba.subVectors(Pu,Cu),yl.subVectors(Au,Pu);let t=[0,-xa.z,xa.y,0,-ba.z,ba.y,0,-yl.z,yl.y,xa.z,0,-xa.x,ba.z,0,-ba.x,yl.z,0,-yl.x,-xa.y,xa.x,0,-ba.y,ba.x,0,-yl.y,yl.x,0];return!my(t,Au,Cu,Pu,Dp)||(t=[1,0,0,0,1,0,0,0,1],!my(t,Au,Cu,Pu,Dp))?!1:(kp.crossVectors(xa,ba),t=[kp.x,kp.y,kp.z],my(t,Au,Cu,Pu,Dp))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,kn).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(kn).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Io[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Io[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Io[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Io[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Io[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Io[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Io[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Io[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Io),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(e){return this.min.fromArray(e.min),this.max.fromArray(e.max),this}}const Io=[new xe,new xe,new xe,new xe,new xe,new xe,new xe,new xe],kn=new xe,Ip=new ph,Au=new xe,Cu=new xe,Pu=new xe,xa=new xe,ba=new xe,yl=new xe,hd=new xe,Dp=new xe,kp=new xe,xl=new xe;function my(i,e,t,s,r){for(let n=0,o=i.length-3;n<=o;n+=3){xl.fromArray(i,n);const a=r.x*Math.abs(xl.x)+r.y*Math.abs(xl.y)+r.z*Math.abs(xl.z),l=e.dot(xl),u=t.dot(xl),c=s.dot(xl);if(Math.max(-Math.max(l,u,c),Math.min(l,u,c))>a)return!1}return!0}const vU=new ph,pd=new xe,gy=new xe;class fm{constructor(e=new xe,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):vU.setFromPoints(e).getCenter(s);let r=0;for(let n=0,o=e.length;n<o;n++)r=Math.max(r,s.distanceToSquared(e[n]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;pd.subVectors(e,this.center);const t=pd.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),r=(s-this.radius)*.5;this.center.addScaledVector(pd,r/s),this.radius+=r}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(gy.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(pd.copy(e.center).add(gy)),this.expandByPoint(pd.copy(e.center).sub(gy))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(e){return this.radius=e.radius,this.center.fromArray(e.center),this}}const Do=new xe,_y=new xe,Lp=new xe,wa=new xe,yy=new xe,Bp=new xe,xy=new xe;class HD{constructor(e=new xe,t=new xe(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Do)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Do.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Do.copy(this.origin).addScaledVector(this.direction,t),Do.distanceToSquared(e))}distanceSqToSegment(e,t,s,r){_y.copy(e).add(t).multiplyScalar(.5),Lp.copy(t).sub(e).normalize(),wa.copy(this.origin).sub(_y);const n=e.distanceTo(t)*.5,o=-this.direction.dot(Lp),a=wa.dot(this.direction),l=-wa.dot(Lp),u=wa.lengthSq(),c=Math.abs(1-o*o);let d,h,p,f;if(c>0)if(d=o*l-a,h=o*a-l,f=n*c,d>=0)if(h>=-f)if(h<=f){const m=1/c;d*=m,h*=m,p=d*(d+o*h+2*a)+h*(o*d+h+2*l)+u}else h=n,d=Math.max(0,-(o*h+a)),p=-d*d+h*(h+2*l)+u;else h=-n,d=Math.max(0,-(o*h+a)),p=-d*d+h*(h+2*l)+u;else h<=-f?(d=Math.max(0,-(-o*n+a)),h=d>0?-n:Math.min(Math.max(-n,-l),n),p=-d*d+h*(h+2*l)+u):h<=f?(d=0,h=Math.min(Math.max(-n,-l),n),p=h*(h+2*l)+u):(d=Math.max(0,-(o*n+a)),h=d>0?n:Math.min(Math.max(-n,-l),n),p=-d*d+h*(h+2*l)+u);else h=o>0?-n:n,d=Math.max(0,-(o*h+a)),p=-d*d+h*(h+2*l)+u;return s&&s.copy(this.origin).addScaledVector(this.direction,d),r&&r.copy(_y).addScaledVector(Lp,h),p}intersectSphere(e,t){Do.subVectors(e.center,this.origin);const s=Do.dot(this.direction),r=Do.dot(Do)-s*s,n=e.radius*e.radius;if(r>n)return null;const o=Math.sqrt(n-r),a=s-o,l=s+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return e.radius<0?!1:this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,r,n,o,a,l;const u=1/this.direction.x,c=1/this.direction.y,d=1/this.direction.z,h=this.origin;return u>=0?(s=(e.min.x-h.x)*u,r=(e.max.x-h.x)*u):(s=(e.max.x-h.x)*u,r=(e.min.x-h.x)*u),c>=0?(n=(e.min.y-h.y)*c,o=(e.max.y-h.y)*c):(n=(e.max.y-h.y)*c,o=(e.min.y-h.y)*c),s>o||n>r||((n>s||isNaN(s))&&(s=n),(o<r||isNaN(r))&&(r=o),d>=0?(a=(e.min.z-h.z)*d,l=(e.max.z-h.z)*d):(a=(e.max.z-h.z)*d,l=(e.min.z-h.z)*d),s>l||a>r)||((a>s||s!==s)&&(s=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(s>=0?s:r,t)}intersectsBox(e){return this.intersectBox(e,Do)!==null}intersectTriangle(e,t,s,r,n){yy.subVectors(t,e),Bp.subVectors(s,e),xy.crossVectors(yy,Bp);let o=this.direction.dot(xy),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;wa.subVectors(this.origin,e);const l=a*this.direction.dot(Bp.crossVectors(wa,Bp));if(l<0)return null;const u=a*this.direction.dot(yy.cross(wa));if(u<0||l+u>o)return null;const c=-a*wa.dot(xy);return c<0?null:this.at(c/o,n)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class cs{constructor(e,t,s,r,n,o,a,l,u,c,d,h,p,f,m,x){cs.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,s,r,n,o,a,l,u,c,d,h,p,f,m,x)}set(e,t,s,r,n,o,a,l,u,c,d,h,p,f,m,x){const g=this.elements;return g[0]=e,g[4]=t,g[8]=s,g[12]=r,g[1]=n,g[5]=o,g[9]=a,g[13]=l,g[2]=u,g[6]=c,g[10]=d,g[14]=h,g[3]=p,g[7]=f,g[11]=m,g[15]=x,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new cs().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,r=1/Nu.setFromMatrixColumn(e,0).length(),n=1/Nu.setFromMatrixColumn(e,1).length(),o=1/Nu.setFromMatrixColumn(e,2).length();return t[0]=s[0]*r,t[1]=s[1]*r,t[2]=s[2]*r,t[3]=0,t[4]=s[4]*n,t[5]=s[5]*n,t[6]=s[6]*n,t[7]=0,t[8]=s[8]*o,t[9]=s[9]*o,t[10]=s[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,s=e.x,r=e.y,n=e.z,o=Math.cos(s),a=Math.sin(s),l=Math.cos(r),u=Math.sin(r),c=Math.cos(n),d=Math.sin(n);if(e.order==="XYZ"){const h=o*c,p=o*d,f=a*c,m=a*d;t[0]=l*c,t[4]=-l*d,t[8]=u,t[1]=p+f*u,t[5]=h-m*u,t[9]=-a*l,t[2]=m-h*u,t[6]=f+p*u,t[10]=o*l}else if(e.order==="YXZ"){const h=l*c,p=l*d,f=u*c,m=u*d;t[0]=h+m*a,t[4]=f*a-p,t[8]=o*u,t[1]=o*d,t[5]=o*c,t[9]=-a,t[2]=p*a-f,t[6]=m+h*a,t[10]=o*l}else if(e.order==="ZXY"){const h=l*c,p=l*d,f=u*c,m=u*d;t[0]=h-m*a,t[4]=-o*d,t[8]=f+p*a,t[1]=p+f*a,t[5]=o*c,t[9]=m-h*a,t[2]=-o*u,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const h=o*c,p=o*d,f=a*c,m=a*d;t[0]=l*c,t[4]=f*u-p,t[8]=h*u+m,t[1]=l*d,t[5]=m*u+h,t[9]=p*u-f,t[2]=-u,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const h=o*l,p=o*u,f=a*l,m=a*u;t[0]=l*c,t[4]=m-h*d,t[8]=f*d+p,t[1]=d,t[5]=o*c,t[9]=-a*c,t[2]=-u*c,t[6]=p*d+f,t[10]=h-m*d}else if(e.order==="XZY"){const h=o*l,p=o*u,f=a*l,m=a*u;t[0]=l*c,t[4]=-d,t[8]=u*c,t[1]=h*d+m,t[5]=o*c,t[9]=p*d-f,t[2]=f*d-p,t[6]=a*c,t[10]=m*d+h}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(SU,e,EU)}lookAt(e,t,s){const r=this.elements;return $r.subVectors(e,t),$r.lengthSq()===0&&($r.z=1),$r.normalize(),Ma.crossVectors(s,$r),Ma.lengthSq()===0&&(Math.abs(s.z)===1?$r.x+=1e-4:$r.z+=1e-4,$r.normalize(),Ma.crossVectors(s,$r)),Ma.normalize(),Op.crossVectors($r,Ma),r[0]=Ma.x,r[4]=Op.x,r[8]=$r.x,r[1]=Ma.y,r[5]=Op.y,r[9]=$r.y,r[2]=Ma.z,r[6]=Op.z,r[10]=$r.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,r=t.elements,n=this.elements,o=s[0],a=s[4],l=s[8],u=s[12],c=s[1],d=s[5],h=s[9],p=s[13],f=s[2],m=s[6],x=s[10],g=s[14],_=s[3],S=s[7],M=s[11],w=s[15],v=r[0],T=r[4],E=r[8],F=r[12],I=r[1],z=r[5],G=r[9],L=r[13],Q=r[2],q=r[6],J=r[10],ee=r[14],se=r[3],fe=r[7],ue=r[11],U=r[15];return n[0]=o*v+a*I+l*Q+u*se,n[4]=o*T+a*z+l*q+u*fe,n[8]=o*E+a*G+l*J+u*ue,n[12]=o*F+a*L+l*ee+u*U,n[1]=c*v+d*I+h*Q+p*se,n[5]=c*T+d*z+h*q+p*fe,n[9]=c*E+d*G+h*J+p*ue,n[13]=c*F+d*L+h*ee+p*U,n[2]=f*v+m*I+x*Q+g*se,n[6]=f*T+m*z+x*q+g*fe,n[10]=f*E+m*G+x*J+g*ue,n[14]=f*F+m*L+x*ee+g*U,n[3]=_*v+S*I+M*Q+w*se,n[7]=_*T+S*z+M*q+w*fe,n[11]=_*E+S*G+M*J+w*ue,n[15]=_*F+S*L+M*ee+w*U,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],r=e[8],n=e[12],o=e[1],a=e[5],l=e[9],u=e[13],c=e[2],d=e[6],h=e[10],p=e[14],f=e[3],m=e[7],x=e[11],g=e[15];return f*(+n*l*d-r*u*d-n*a*h+s*u*h+r*a*p-s*l*p)+m*(+t*l*p-t*u*h+n*o*h-r*o*p+r*u*c-n*l*c)+x*(+t*u*d-t*a*p-n*o*d+s*o*p+n*a*c-s*u*c)+g*(-r*a*c-t*l*d+t*a*h+r*o*d-s*o*h+s*l*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],r=e[2],n=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],d=e[9],h=e[10],p=e[11],f=e[12],m=e[13],x=e[14],g=e[15],_=d*x*u-m*h*u+m*l*p-a*x*p-d*l*g+a*h*g,S=f*h*u-c*x*u-f*l*p+o*x*p+c*l*g-o*h*g,M=c*m*u-f*d*u+f*a*p-o*m*p-c*a*g+o*d*g,w=f*d*l-c*m*l-f*a*h+o*m*h+c*a*x-o*d*x,v=t*_+s*S+r*M+n*w;if(v===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/v;return e[0]=_*T,e[1]=(m*h*n-d*x*n-m*r*p+s*x*p+d*r*g-s*h*g)*T,e[2]=(a*x*n-m*l*n+m*r*u-s*x*u-a*r*g+s*l*g)*T,e[3]=(d*l*n-a*h*n-d*r*u+s*h*u+a*r*p-s*l*p)*T,e[4]=S*T,e[5]=(c*x*n-f*h*n+f*r*p-t*x*p-c*r*g+t*h*g)*T,e[6]=(f*l*n-o*x*n-f*r*u+t*x*u+o*r*g-t*l*g)*T,e[7]=(o*h*n-c*l*n+c*r*u-t*h*u-o*r*p+t*l*p)*T,e[8]=M*T,e[9]=(f*d*n-c*m*n-f*s*p+t*m*p+c*s*g-t*d*g)*T,e[10]=(o*m*n-f*a*n+f*s*u-t*m*u-o*s*g+t*a*g)*T,e[11]=(c*a*n-o*d*n-c*s*u+t*d*u+o*s*p-t*a*p)*T,e[12]=w*T,e[13]=(c*m*r-f*d*r+f*s*h-t*m*h-c*s*x+t*d*x)*T,e[14]=(f*a*r-o*m*r-f*s*l+t*m*l+o*s*x-t*a*x)*T,e[15]=(o*d*r-c*a*r+c*s*l-t*d*l-o*s*h+t*a*h)*T,this}scale(e){const t=this.elements,s=e.x,r=e.y,n=e.z;return t[0]*=s,t[4]*=r,t[8]*=n,t[1]*=s,t[5]*=r,t[9]*=n,t[2]*=s,t[6]*=r,t[10]*=n,t[3]*=s,t[7]*=r,t[11]*=n,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,r))}makeTranslation(e,t,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),r=Math.sin(t),n=1-s,o=e.x,a=e.y,l=e.z,u=n*o,c=n*a;return this.set(u*o+s,u*a-r*l,u*l+r*a,0,u*a+r*l,c*a+s,c*l-r*o,0,u*l-r*a,c*l+r*o,n*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,r,n,o){return this.set(1,s,n,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,s){const r=this.elements,n=t._x,o=t._y,a=t._z,l=t._w,u=n+n,c=o+o,d=a+a,h=n*u,p=n*c,f=n*d,m=o*c,x=o*d,g=a*d,_=l*u,S=l*c,M=l*d,w=s.x,v=s.y,T=s.z;return r[0]=(1-(m+g))*w,r[1]=(p+M)*w,r[2]=(f-S)*w,r[3]=0,r[4]=(p-M)*v,r[5]=(1-(h+g))*v,r[6]=(x+_)*v,r[7]=0,r[8]=(f+S)*T,r[9]=(x-_)*T,r[10]=(1-(h+m))*T,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,s){const r=this.elements;let n=Nu.set(r[0],r[1],r[2]).length();const o=Nu.set(r[4],r[5],r[6]).length(),a=Nu.set(r[8],r[9],r[10]).length();this.determinant()<0&&(n=-n),e.x=r[12],e.y=r[13],e.z=r[14],Ln.copy(this);const u=1/n,c=1/o,d=1/a;return Ln.elements[0]*=u,Ln.elements[1]*=u,Ln.elements[2]*=u,Ln.elements[4]*=c,Ln.elements[5]*=c,Ln.elements[6]*=c,Ln.elements[8]*=d,Ln.elements[9]*=d,Ln.elements[10]*=d,t.setFromRotationMatrix(Ln),s.x=n,s.y=o,s.z=a,this}makePerspective(e,t,s,r,n,o,a=Pr){const l=this.elements,u=2*n/(t-e),c=2*n/(s-r),d=(t+e)/(t-e),h=(s+r)/(s-r);let p,f;if(a===Pr)p=-(o+n)/(o-n),f=-2*o*n/(o-n);else if(a===xo)p=-o/(o-n),f=-o*n/(o-n);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=u,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=c,l[9]=h,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=f,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,s,r,n,o,a=Pr){const l=this.elements,u=1/(t-e),c=1/(s-r),d=1/(o-n),h=(t+e)*u,p=(s+r)*c;let f,m;if(a===Pr)f=(o+n)*d,m=-2*d;else if(a===xo)f=n*d,m=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*u,l[4]=0,l[8]=0,l[12]=-h,l[1]=0,l[5]=2*c,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=m,l[14]=-f,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let r=0;r<16;r++)if(t[r]!==s[r])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}const Nu=new xe,Ln=new cs,SU=new xe(0,0,0),EU=new xe(1,1,1),Ma=new xe,Op=new xe,$r=new xe,HP=new cs,qP=new za;class xn{constructor(e=0,t=0,s=0,r=xn.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=s,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,r=this._order){return this._x=e,this._y=t,this._z=s,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const r=e.elements,n=r[0],o=r[4],a=r[8],l=r[1],u=r[5],c=r[9],d=r[2],h=r[6],p=r[10];switch(t){case"XYZ":this._y=Math.asin(es(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-o,n)):(this._x=Math.atan2(h,u),this._z=0);break;case"YXZ":this._x=Math.asin(-es(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,u)):(this._y=Math.atan2(-d,n),this._z=0);break;case"ZXY":this._x=Math.asin(es(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-o,u)):(this._y=0,this._z=Math.atan2(l,n));break;case"ZYX":this._y=Math.asin(-es(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(h,p),this._z=Math.atan2(l,n)):(this._x=0,this._z=Math.atan2(-o,u));break;case"YZX":this._z=Math.asin(es(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-d,n)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-es(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(h,u),this._y=Math.atan2(a,n)):(this._x=Math.atan2(-c,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return HP.makeRotationFromQuaternion(e),this.setFromRotationMatrix(HP,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return qP.setFromEuler(this),this.setFromQuaternion(qP,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}xn.DEFAULT_ORDER="XYZ";class AU{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let CU=0;const KP=new xe,Fu=new za,ko=new cs,$p=new xe,fd=new xe,PU=new xe,NU=new za,XP=new xe(1,0,0),YP=new xe(0,1,0),QP=new xe(0,0,1),ZP={type:"added"},FU={type:"removed"},Ru={type:"childadded",child:null},by={type:"childremoved",child:null};class Fi extends oa{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:CU++}),this.uuid=Xo(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Fi.DEFAULT_UP.clone();const e=new xe,t=new xn,s=new za,r=new xe(1,1,1);function n(){s.setFromEuler(t,!1)}function o(){t.setFromQuaternion(s,void 0,!1)}t._onChange(n),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new cs},normalMatrix:{value:new kr}}),this.matrix=new cs,this.matrixWorld=new cs,this.matrixAutoUpdate=Fi.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Fi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new AU,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Fu.setFromAxisAngle(e,t),this.quaternion.multiply(Fu),this}rotateOnWorldAxis(e,t){return Fu.setFromAxisAngle(e,t),this.quaternion.premultiply(Fu),this}rotateX(e){return this.rotateOnAxis(XP,e)}rotateY(e){return this.rotateOnAxis(YP,e)}rotateZ(e){return this.rotateOnAxis(QP,e)}translateOnAxis(e,t){return KP.copy(e).applyQuaternion(this.quaternion),this.position.add(KP.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(XP,e)}translateY(e){return this.translateOnAxis(YP,e)}translateZ(e){return this.translateOnAxis(QP,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(ko.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?$p.copy(e):$p.set(e,t,s);const r=this.parent;this.updateWorldMatrix(!0,!1),fd.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ko.lookAt(fd,$p,this.up):ko.lookAt($p,fd,this.up),this.quaternion.setFromRotationMatrix(ko),r&&(ko.extractRotation(r.matrixWorld),Fu.setFromRotationMatrix(ko),this.quaternion.premultiply(Fu.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(ZP),Ru.child=e,this.dispatchEvent(Ru),Ru.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(FU),by.child=e,this.dispatchEvent(by),by.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),ko.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ko.multiply(e.parent.matrixWorld)),e.applyMatrix4(ko),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(ZP),Ru.child=e,this.dispatchEvent(Ru),Ru.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,r=this.children.length;s<r;s++){const o=this.children[s].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,s=[]){this[e]===t&&s.push(this);const r=this.children;for(let n=0,o=r.length;n<o;n++)r[n].getObjectsByProperty(e,t,s);return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(fd,e,PU),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(fd,NU,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].updateMatrixWorld(e)}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const r=this.children;for(let n=0,o=r.length;n<o;n++)r[n].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),r.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(r.type="BatchedMesh",r.perObjectFrustumCulled=this.perObjectFrustumCulled,r.sortObjects=this.sortObjects,r.drawRanges=this._drawRanges,r.reservedRanges=this._reservedRanges,r.geometryInfo=this._geometryInfo.map(a=>({...a,boundingBox:a.boundingBox?a.boundingBox.toJSON():void 0,boundingSphere:a.boundingSphere?a.boundingSphere.toJSON():void 0})),r.instanceInfo=this._instanceInfo.map(a=>({...a})),r.availableInstanceIds=this._availableInstanceIds.slice(),r.availableGeometryIds=this._availableGeometryIds.slice(),r.nextIndexStart=this._nextIndexStart,r.nextVertexStart=this._nextVertexStart,r.geometryCount=this._geometryCount,r.maxInstanceCount=this._maxInstanceCount,r.maxVertexCount=this._maxVertexCount,r.maxIndexCount=this._maxIndexCount,r.geometryInitialized=this._geometryInitialized,r.matricesTexture=this._matricesTexture.toJSON(e),r.indirectTexture=this._indirectTexture.toJSON(e),this._colorsTexture!==null&&(r.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(r.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(r.boundingBox=this.boundingBox.toJSON()));function n(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=n(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let u=0,c=l.length;u<c;u++){const d=l[u];n(e.shapes,d)}else n(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(n(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,u=this.material.length;l<u;l++)a.push(n(e.materials,this.material[l]));r.material=a}else r.material=n(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(n(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),u=o(e.textures),c=o(e.images),d=o(e.shapes),h=o(e.skeletons),p=o(e.animations),f=o(e.nodes);a.length>0&&(s.geometries=a),l.length>0&&(s.materials=l),u.length>0&&(s.textures=u),c.length>0&&(s.images=c),d.length>0&&(s.shapes=d),h.length>0&&(s.skeletons=h),p.length>0&&(s.animations=p),f.length>0&&(s.nodes=f)}return s.object=r,s;function o(a){const l=[];for(const u in a){const c=a[u];delete c.metadata,l.push(c)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const r=e.children[s];this.add(r.clone())}return this}}Fi.DEFAULT_UP=new xe(0,1,0);Fi.DEFAULT_MATRIX_AUTO_UPDATE=!0;Fi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Bn=new xe,Lo=new xe,wy=new xe,Bo=new xe,Iu=new xe,Du=new xe,JP=new xe,My=new xe,Ty=new xe,vy=new xe,Sy=new ns,Ey=new ns,Ay=new ns;class Gn{constructor(e=new xe,t=new xe,s=new xe){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,r){r.subVectors(s,t),Bn.subVectors(e,t),r.cross(Bn);const n=r.lengthSq();return n>0?r.multiplyScalar(1/Math.sqrt(n)):r.set(0,0,0)}static getBarycoord(e,t,s,r,n){Bn.subVectors(r,t),Lo.subVectors(s,t),wy.subVectors(e,t);const o=Bn.dot(Bn),a=Bn.dot(Lo),l=Bn.dot(wy),u=Lo.dot(Lo),c=Lo.dot(wy),d=o*u-a*a;if(d===0)return n.set(0,0,0),null;const h=1/d,p=(u*l-a*c)*h,f=(o*c-a*l)*h;return n.set(1-p-f,f,p)}static containsPoint(e,t,s,r){return this.getBarycoord(e,t,s,r,Bo)===null?!1:Bo.x>=0&&Bo.y>=0&&Bo.x+Bo.y<=1}static getInterpolation(e,t,s,r,n,o,a,l){return this.getBarycoord(e,t,s,r,Bo)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(n,Bo.x),l.addScaledVector(o,Bo.y),l.addScaledVector(a,Bo.z),l)}static getInterpolatedAttribute(e,t,s,r,n,o){return Sy.setScalar(0),Ey.setScalar(0),Ay.setScalar(0),Sy.fromBufferAttribute(e,t),Ey.fromBufferAttribute(e,s),Ay.fromBufferAttribute(e,r),o.setScalar(0),o.addScaledVector(Sy,n.x),o.addScaledVector(Ey,n.y),o.addScaledVector(Ay,n.z),o}static isFrontFacing(e,t,s,r){return Bn.subVectors(s,t),Lo.subVectors(e,t),Bn.cross(Lo).dot(r)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,r){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,s,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Bn.subVectors(this.c,this.b),Lo.subVectors(this.a,this.b),Bn.cross(Lo).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Gn.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Gn.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,s,r,n){return Gn.getInterpolation(e,this.a,this.b,this.c,t,s,r,n)}containsPoint(e){return Gn.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Gn.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,r=this.b,n=this.c;let o,a;Iu.subVectors(r,s),Du.subVectors(n,s),My.subVectors(e,s);const l=Iu.dot(My),u=Du.dot(My);if(l<=0&&u<=0)return t.copy(s);Ty.subVectors(e,r);const c=Iu.dot(Ty),d=Du.dot(Ty);if(c>=0&&d<=c)return t.copy(r);const h=l*d-c*u;if(h<=0&&l>=0&&c<=0)return o=l/(l-c),t.copy(s).addScaledVector(Iu,o);vy.subVectors(e,n);const p=Iu.dot(vy),f=Du.dot(vy);if(f>=0&&p<=f)return t.copy(n);const m=p*u-l*f;if(m<=0&&u>=0&&f<=0)return a=u/(u-f),t.copy(s).addScaledVector(Du,a);const x=c*f-p*d;if(x<=0&&d-c>=0&&p-f>=0)return JP.subVectors(n,r),a=(d-c)/(d-c+(p-f)),t.copy(r).addScaledVector(JP,a);const g=1/(x+m+h);return o=m*g,a=h*g,t.copy(s).addScaledVector(Iu,o).addScaledVector(Du,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const qD={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ta={h:0,s:0,l:0},zp={h:0,s:0,l:0};function Cy(i,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?i+(e-i)*6*t:t<1/2?e:t<2/3?i+(e-i)*6*(2/3-t):i}class gs{constructor(e,t,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,s)}set(e,t,s){if(t===void 0&&s===void 0){const r=e;r&&r.isColor?this.copy(r):typeof r=="number"?this.setHex(r):typeof r=="string"&&this.setStyle(r)}else this.setRGB(e,t,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=jr){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Ls.colorSpaceToWorking(this,t),this}setRGB(e,t,s,r=Ls.workingColorSpace){return this.r=e,this.g=t,this.b=s,Ls.colorSpaceToWorking(this,r),this}setHSL(e,t,s,r=Ls.workingColorSpace){if(e=g0(e,1),t=es(t,0,1),s=es(s,0,1),t===0)this.r=this.g=this.b=s;else{const n=s<=.5?s*(1+t):s+t-s*t,o=2*s-n;this.r=Cy(o,n,e+1/3),this.g=Cy(o,n,e),this.b=Cy(o,n,e-1/3)}return Ls.colorSpaceToWorking(this,r),this}setStyle(e,t=jr){function s(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^(\w+)\(([^\)]*)\)/.exec(e)){let n;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(n=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(n[4]),this.setRGB(Math.min(255,parseInt(n[1],10))/255,Math.min(255,parseInt(n[2],10))/255,Math.min(255,parseInt(n[3],10))/255,t);if(n=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(n[4]),this.setRGB(Math.min(100,parseInt(n[1],10))/100,Math.min(100,parseInt(n[2],10))/100,Math.min(100,parseInt(n[3],10))/100,t);break;case"hsl":case"hsla":if(n=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(n[4]),this.setHSL(parseFloat(n[1])/360,parseFloat(n[2])/100,parseFloat(n[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const n=r[1],o=n.length;if(o===3)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(n,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=jr){const s=qD[e.toLowerCase()];return s!==void 0?this.setHex(s,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Yo(e.r),this.g=Yo(e.g),this.b=Yo(e.b),this}copyLinearToSRGB(e){return this.r=oc(e.r),this.g=oc(e.g),this.b=oc(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=jr){return Ls.workingToColorSpace(nr.copy(this),e),Math.round(es(nr.r*255,0,255))*65536+Math.round(es(nr.g*255,0,255))*256+Math.round(es(nr.b*255,0,255))}getHexString(e=jr){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Ls.workingColorSpace){Ls.workingToColorSpace(nr.copy(this),t);const s=nr.r,r=nr.g,n=nr.b,o=Math.max(s,r,n),a=Math.min(s,r,n);let l,u;const c=(a+o)/2;if(a===o)l=0,u=0;else{const d=o-a;switch(u=c<=.5?d/(o+a):d/(2-o-a),o){case s:l=(r-n)/d+(r<n?6:0);break;case r:l=(n-s)/d+2;break;case n:l=(s-r)/d+4;break}l/=6}return e.h=l,e.s=u,e.l=c,e}getRGB(e,t=Ls.workingColorSpace){return Ls.workingToColorSpace(nr.copy(this),t),e.r=nr.r,e.g=nr.g,e.b=nr.b,e}getStyle(e=jr){Ls.workingToColorSpace(nr.copy(this),e);const t=nr.r,s=nr.g,r=nr.b;return e!==jr?`color(${e} ${t.toFixed(3)} ${s.toFixed(3)} ${r.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(s*255)},${Math.round(r*255)})`}offsetHSL(e,t,s){return this.getHSL(Ta),this.setHSL(Ta.h+e,Ta.s+t,Ta.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(Ta),e.getHSL(zp);const s=jd(Ta.h,zp.h,t),r=jd(Ta.s,zp.s,t),n=jd(Ta.l,zp.l,t);return this.setHSL(s,r,n),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,s=this.g,r=this.b,n=e.elements;return this.r=n[0]*t+n[3]*s+n[6]*r,this.g=n[1]*t+n[4]*s+n[7]*r,this.b=n[2]*t+n[5]*s+n[8]*r,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const nr=new gs;gs.NAMES=qD;let RU=0;class Rr extends oa{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:RU++}),this.uuid=Xo(),this.name="",this.type="Material",this.blending=Ho,this.side=Wo,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Wf,this.blendDst=Hf,this.blendEquation=Un,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new gs(0,0,0),this.blendAlpha=0,this.depthFunc=qf,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=sb,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Nl,this.stencilZFail=Nl,this.stencilZPass=Nl,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const r=this[t];if(r===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}r&&r.isColor?r.set(s):r&&r.isVector3&&s&&s.isVector3?r.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(s.dispersion=this.dispersion),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==Ho&&(s.blending=this.blending),this.side!==Wo&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==Wf&&(s.blendSrc=this.blendSrc),this.blendDst!==Hf&&(s.blendDst=this.blendDst),this.blendEquation!==Un&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==qf&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==sb&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Nl&&(s.stencilFail=this.stencilFail),this.stencilZFail!==Nl&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==Nl&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function r(n){const o=[];for(const a in n){const l=n[a];delete l.metadata,o.push(l)}return o}if(t){const n=r(e.textures),o=r(e.images);n.length>0&&(s.textures=n),o.length>0&&(s.images=o)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const r=t.length;s=new Array(r);for(let n=0;n!==r;++n)s[n]=t[n].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class co extends Rr{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new gs(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xn,this.combine=pm,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Go=IU();function IU(){const i=new ArrayBuffer(4),e=new Float32Array(i),t=new Uint32Array(i),s=new Uint32Array(512),r=new Uint32Array(512);for(let l=0;l<256;++l){const u=l-127;u<-27?(s[l]=0,s[l|256]=32768,r[l]=24,r[l|256]=24):u<-14?(s[l]=1024>>-u-14,s[l|256]=1024>>-u-14|32768,r[l]=-u-1,r[l|256]=-u-1):u<=15?(s[l]=u+15<<10,s[l|256]=u+15<<10|32768,r[l]=13,r[l|256]=13):u<128?(s[l]=31744,s[l|256]=64512,r[l]=24,r[l|256]=24):(s[l]=31744,s[l|256]=64512,r[l]=13,r[l|256]=13)}const n=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let u=l<<13,c=0;for(;!(u&8388608);)u<<=1,c-=8388608;u&=-8388609,c+=947912704,n[l]=u|c}for(let l=1024;l<2048;++l)n[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:s,shiftTable:r,mantissaTable:n,exponentTable:o,offsetTable:a}}function zr(i){Math.abs(i)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),i=es(i,-65504,65504),Go.floatView[0]=i;const e=Go.uint32View[0],t=e>>23&511;return Go.baseTable[t]+((e&8388607)>>Go.shiftTable[t])}function Vp(i){const e=i>>10;return Go.uint32View[0]=Go.mantissaTable[Go.offsetTable[e]+(i&1023)]+Go.exponentTable[e],Go.floatView[0]}const Ai=new xe,Up=new Dt;let DU=0;class Yr{constructor(e,t,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:DU++}),this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s,this.usage=Yf,this.updateRanges=[],this.gpuType=Kr,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let r=0,n=this.itemSize;r<n;r++)this.array[e+r]=t.array[s+r];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)Up.fromBufferAttribute(this,t),Up.applyMatrix3(e),this.setXY(t,Up.x,Up.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)Ai.fromBufferAttribute(this,t),Ai.applyMatrix3(e),this.setXYZ(t,Ai.x,Ai.y,Ai.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)Ai.fromBufferAttribute(this,t),Ai.applyMatrix4(e),this.setXYZ(t,Ai.x,Ai.y,Ai.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Ai.fromBufferAttribute(this,t),Ai.applyNormalMatrix(e),this.setXYZ(t,Ai.x,Ai.y,Ai.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Ai.fromBufferAttribute(this,t),Ai.transformDirection(e),this.setXYZ(t,Ai.x,Ai.y,Ai.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let s=this.array[e*this.itemSize+t];return this.normalized&&(s=yr(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Qt(s,this.array)),this.array[e*this.itemSize+t]=s,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=yr(t,this.array)),t}setX(e,t){return this.normalized&&(t=Qt(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=yr(t,this.array)),t}setY(e,t){return this.normalized&&(t=Qt(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=yr(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Qt(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=yr(t,this.array)),t}setW(e,t){return this.normalized&&(t=Qt(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array)),this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,r){return e*=this.itemSize,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array),r=Qt(r,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=r,this}setXYZW(e,t,s,r,n){return e*=this.itemSize,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array),r=Qt(r,this.array),n=Qt(n,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=r,this.array[e+3]=n,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Yf&&(e.usage=this.usage),e}}class KD extends Yr{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class XD extends Yr{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class YD extends Yr{constructor(e,t,s){super(new Uint16Array(e),t,s),this.isFloat16BufferAttribute=!0}getX(e){let t=Vp(this.array[e*this.itemSize]);return this.normalized&&(t=yr(t,this.array)),t}setX(e,t){return this.normalized&&(t=Qt(t,this.array)),this.array[e*this.itemSize]=zr(t),this}getY(e){let t=Vp(this.array[e*this.itemSize+1]);return this.normalized&&(t=yr(t,this.array)),t}setY(e,t){return this.normalized&&(t=Qt(t,this.array)),this.array[e*this.itemSize+1]=zr(t),this}getZ(e){let t=Vp(this.array[e*this.itemSize+2]);return this.normalized&&(t=yr(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Qt(t,this.array)),this.array[e*this.itemSize+2]=zr(t),this}getW(e){let t=Vp(this.array[e*this.itemSize+3]);return this.normalized&&(t=yr(t,this.array)),t}setW(e,t){return this.normalized&&(t=Qt(t,this.array)),this.array[e*this.itemSize+3]=zr(t),this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array)),this.array[e+0]=zr(t),this.array[e+1]=zr(s),this}setXYZ(e,t,s,r){return e*=this.itemSize,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array),r=Qt(r,this.array)),this.array[e+0]=zr(t),this.array[e+1]=zr(s),this.array[e+2]=zr(r),this}setXYZW(e,t,s,r,n){return e*=this.itemSize,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array),r=Qt(r,this.array),n=Qt(n,this.array)),this.array[e+0]=zr(t),this.array[e+1]=zr(s),this.array[e+2]=zr(r),this.array[e+3]=zr(n),this}}class br extends Yr{constructor(e,t,s){super(new Float32Array(e),t,s)}}let kU=0;const an=new cs,Py=new Fi,ku=new xe,Vr=new ph,md=new ph,Hi=new xe;class aa extends oa{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:kU++}),this.uuid=Xo(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(WD(e)?XD:KD)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const n=new kr().getNormalMatrix(e);s.applyNormalMatrix(n),s.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return an.makeRotationFromQuaternion(e),this.applyMatrix4(an),this}rotateX(e){return an.makeRotationX(e),this.applyMatrix4(an),this}rotateY(e){return an.makeRotationY(e),this.applyMatrix4(an),this}rotateZ(e){return an.makeRotationZ(e),this.applyMatrix4(an),this}translate(e,t,s){return an.makeTranslation(e,t,s),this.applyMatrix4(an),this}scale(e,t,s){return an.makeScale(e,t,s),this.applyMatrix4(an),this}lookAt(e){return Py.lookAt(e),Py.updateMatrix(),this.applyMatrix4(Py.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ku).negate(),this.translate(ku.x,ku.y,ku.z),this}setFromPoints(e){const t=this.getAttribute("position");if(t===void 0){const s=[];for(let r=0,n=e.length;r<n;r++){const o=e[r];s.push(o.x,o.y,o.z||0)}this.setAttribute("position",new br(s,3))}else{const s=Math.min(e.length,t.count);for(let r=0;r<s;r++){const n=e[r];t.setXYZ(r,n.x,n.y,n.z||0)}e.length>t.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ph);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new xe(-1/0,-1/0,-1/0),new xe(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,r=t.length;s<r;s++){const n=t[s];Vr.setFromBufferAttribute(n),this.morphTargetsRelative?(Hi.addVectors(this.boundingBox.min,Vr.min),this.boundingBox.expandByPoint(Hi),Hi.addVectors(this.boundingBox.max,Vr.max),this.boundingBox.expandByPoint(Hi)):(this.boundingBox.expandByPoint(Vr.min),this.boundingBox.expandByPoint(Vr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new fm);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new xe,1/0);return}if(e){const s=this.boundingSphere.center;if(Vr.setFromBufferAttribute(e),t)for(let n=0,o=t.length;n<o;n++){const a=t[n];md.setFromBufferAttribute(a),this.morphTargetsRelative?(Hi.addVectors(Vr.min,md.min),Vr.expandByPoint(Hi),Hi.addVectors(Vr.max,md.max),Vr.expandByPoint(Hi)):(Vr.expandByPoint(md.min),Vr.expandByPoint(md.max))}Vr.getCenter(s);let r=0;for(let n=0,o=e.count;n<o;n++)Hi.fromBufferAttribute(e,n),r=Math.max(r,s.distanceToSquared(Hi));if(t)for(let n=0,o=t.length;n<o;n++){const a=t[n],l=this.morphTargetsRelative;for(let u=0,c=a.count;u<c;u++)Hi.fromBufferAttribute(a,u),l&&(ku.fromBufferAttribute(e,u),Hi.add(ku)),r=Math.max(r,s.distanceToSquared(Hi))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=t.position,r=t.normal,n=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Yr(new Float32Array(4*s.count),4));const o=this.getAttribute("tangent"),a=[],l=[];for(let E=0;E<s.count;E++)a[E]=new xe,l[E]=new xe;const u=new xe,c=new xe,d=new xe,h=new Dt,p=new Dt,f=new Dt,m=new xe,x=new xe;function g(E,F,I){u.fromBufferAttribute(s,E),c.fromBufferAttribute(s,F),d.fromBufferAttribute(s,I),h.fromBufferAttribute(n,E),p.fromBufferAttribute(n,F),f.fromBufferAttribute(n,I),c.sub(u),d.sub(u),p.sub(h),f.sub(h);const z=1/(p.x*f.y-f.x*p.y);isFinite(z)&&(m.copy(c).multiplyScalar(f.y).addScaledVector(d,-p.y).multiplyScalar(z),x.copy(d).multiplyScalar(p.x).addScaledVector(c,-f.x).multiplyScalar(z),a[E].add(m),a[F].add(m),a[I].add(m),l[E].add(x),l[F].add(x),l[I].add(x))}let _=this.groups;_.length===0&&(_=[{start:0,count:e.count}]);for(let E=0,F=_.length;E<F;++E){const I=_[E],z=I.start,G=I.count;for(let L=z,Q=z+G;L<Q;L+=3)g(e.getX(L+0),e.getX(L+1),e.getX(L+2))}const S=new xe,M=new xe,w=new xe,v=new xe;function T(E){w.fromBufferAttribute(r,E),v.copy(w);const F=a[E];S.copy(F),S.sub(w.multiplyScalar(w.dot(F))).normalize(),M.crossVectors(v,F);const z=M.dot(l[E])<0?-1:1;o.setXYZW(E,S.x,S.y,S.z,z)}for(let E=0,F=_.length;E<F;++E){const I=_[E],z=I.start,G=I.count;for(let L=z,Q=z+G;L<Q;L+=3)T(e.getX(L+0)),T(e.getX(L+1)),T(e.getX(L+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Yr(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let h=0,p=s.count;h<p;h++)s.setXYZ(h,0,0,0);const r=new xe,n=new xe,o=new xe,a=new xe,l=new xe,u=new xe,c=new xe,d=new xe;if(e)for(let h=0,p=e.count;h<p;h+=3){const f=e.getX(h+0),m=e.getX(h+1),x=e.getX(h+2);r.fromBufferAttribute(t,f),n.fromBufferAttribute(t,m),o.fromBufferAttribute(t,x),c.subVectors(o,n),d.subVectors(r,n),c.cross(d),a.fromBufferAttribute(s,f),l.fromBufferAttribute(s,m),u.fromBufferAttribute(s,x),a.add(c),l.add(c),u.add(c),s.setXYZ(f,a.x,a.y,a.z),s.setXYZ(m,l.x,l.y,l.z),s.setXYZ(x,u.x,u.y,u.z)}else for(let h=0,p=t.count;h<p;h+=3)r.fromBufferAttribute(t,h+0),n.fromBufferAttribute(t,h+1),o.fromBufferAttribute(t,h+2),c.subVectors(o,n),d.subVectors(r,n),c.cross(d),s.setXYZ(h+0,c.x,c.y,c.z),s.setXYZ(h+1,c.x,c.y,c.z),s.setXYZ(h+2,c.x,c.y,c.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)Hi.fromBufferAttribute(e,t),Hi.normalize(),e.setXYZ(t,Hi.x,Hi.y,Hi.z)}toNonIndexed(){function e(a,l){const u=a.array,c=a.itemSize,d=a.normalized,h=new u.constructor(l.length*c);let p=0,f=0;for(let m=0,x=l.length;m<x;m++){a.isInterleavedBufferAttribute?p=l[m]*a.data.stride+a.offset:p=l[m]*c;for(let g=0;g<c;g++)h[f++]=u[p++]}return new Yr(h,c,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new aa,s=this.index.array,r=this.attributes;for(const a in r){const l=r[a],u=e(l,s);t.setAttribute(a,u)}const n=this.morphAttributes;for(const a in n){const l=[],u=n[a];for(let c=0,d=u.length;c<d;c++){const h=u[c],p=e(h,s);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const u=o[a];t.addGroup(u.start,u.count,u.materialIndex)}return t}toJSON(){const e={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const u in l)l[u]!==void 0&&(e[u]=l[u]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const u=s[l];e.data.attributes[l]=u.toJSON(e.data)}const r={};let n=!1;for(const l in this.morphAttributes){const u=this.morphAttributes[l],c=[];for(let d=0,h=u.length;d<h;d++){const p=u[d];c.push(p.toJSON(e.data))}c.length>0&&(r[l]=c,n=!0)}n&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere=a.toJSON()),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone());const r=e.attributes;for(const u in r){const c=r[u];this.setAttribute(u,c.clone(t))}const n=e.morphAttributes;for(const u in n){const c=[],d=n[u];for(let h=0,p=d.length;h<p;h++)c.push(d[h].clone(t));this.morphAttributes[u]=c}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let u=0,c=o.length;u<c;u++){const d=o[u];this.addGroup(d.start,d.count,d.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const e2=new cs,bl=new HD,Gp=new fm,t2=new xe,jp=new xe,Wp=new xe,Hp=new xe,Ny=new xe,qp=new xe,s2=new xe,Kp=new xe;class bn extends Fi{constructor(e=new aa,t=new co){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,o=r.length;n<o;n++){const a=r[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}getVertexPosition(e,t){const s=this.geometry,r=s.attributes.position,n=s.morphAttributes.position,o=s.morphTargetsRelative;t.fromBufferAttribute(r,e);const a=this.morphTargetInfluences;if(n&&a){qp.set(0,0,0);for(let l=0,u=n.length;l<u;l++){const c=a[l],d=n[l];c!==0&&(Ny.fromBufferAttribute(d,e),o?qp.addScaledVector(Ny,c):qp.addScaledVector(Ny.sub(t),c))}t.add(qp)}return t}raycast(e,t){const s=this.geometry,r=this.material,n=this.matrixWorld;r!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),Gp.copy(s.boundingSphere),Gp.applyMatrix4(n),bl.copy(e.ray).recast(e.near),!(Gp.containsPoint(bl.origin)===!1&&(bl.intersectSphere(Gp,t2)===null||bl.origin.distanceToSquared(t2)>(e.far-e.near)**2))&&(e2.copy(n).invert(),bl.copy(e.ray).applyMatrix4(e2),!(s.boundingBox!==null&&bl.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,t,bl)))}_computeIntersections(e,t,s){let r;const n=this.geometry,o=this.material,a=n.index,l=n.attributes.position,u=n.attributes.uv,c=n.attributes.uv1,d=n.attributes.normal,h=n.groups,p=n.drawRange;if(a!==null)if(Array.isArray(o))for(let f=0,m=h.length;f<m;f++){const x=h[f],g=o[x.materialIndex],_=Math.max(x.start,p.start),S=Math.min(a.count,Math.min(x.start+x.count,p.start+p.count));for(let M=_,w=S;M<w;M+=3){const v=a.getX(M),T=a.getX(M+1),E=a.getX(M+2);r=Xp(this,g,e,s,u,c,d,v,T,E),r&&(r.faceIndex=Math.floor(M/3),r.face.materialIndex=x.materialIndex,t.push(r))}}else{const f=Math.max(0,p.start),m=Math.min(a.count,p.start+p.count);for(let x=f,g=m;x<g;x+=3){const _=a.getX(x),S=a.getX(x+1),M=a.getX(x+2);r=Xp(this,o,e,s,u,c,d,_,S,M),r&&(r.faceIndex=Math.floor(x/3),t.push(r))}}else if(l!==void 0)if(Array.isArray(o))for(let f=0,m=h.length;f<m;f++){const x=h[f],g=o[x.materialIndex],_=Math.max(x.start,p.start),S=Math.min(l.count,Math.min(x.start+x.count,p.start+p.count));for(let M=_,w=S;M<w;M+=3){const v=M,T=M+1,E=M+2;r=Xp(this,g,e,s,u,c,d,v,T,E),r&&(r.faceIndex=Math.floor(M/3),r.face.materialIndex=x.materialIndex,t.push(r))}}else{const f=Math.max(0,p.start),m=Math.min(l.count,p.start+p.count);for(let x=f,g=m;x<g;x+=3){const _=x,S=x+1,M=x+2;r=Xp(this,o,e,s,u,c,d,_,S,M),r&&(r.faceIndex=Math.floor(x/3),t.push(r))}}}}function LU(i,e,t,s,r,n,o,a){let l;if(e.side===lr?l=s.intersectTriangle(o,n,r,!0,a):l=s.intersectTriangle(r,n,o,e.side===Wo,a),l===null)return null;Kp.copy(a),Kp.applyMatrix4(i.matrixWorld);const u=t.ray.origin.distanceTo(Kp);return u<t.near||u>t.far?null:{distance:u,point:Kp.clone(),object:i}}function Xp(i,e,t,s,r,n,o,a,l,u){i.getVertexPosition(a,jp),i.getVertexPosition(l,Wp),i.getVertexPosition(u,Hp);const c=LU(i,e,t,s,jp,Wp,Hp,s2);if(c){const d=new xe;Gn.getBarycoord(s2,jp,Wp,Hp,d),r&&(c.uv=Gn.getInterpolatedAttribute(r,a,l,u,d,new Dt)),n&&(c.uv1=Gn.getInterpolatedAttribute(n,a,l,u,d,new Dt)),o&&(c.normal=Gn.getInterpolatedAttribute(o,a,l,u,d,new xe),c.normal.dot(s.direction)>0&&c.normal.multiplyScalar(-1));const h={a,b:l,c:u,normal:new xe,materialIndex:0};Gn.getNormal(jp,Wp,Hp,h.normal),c.face=h,c.barycoord=d}return c}class fh extends aa{constructor(e=1,t=1,s=1,r=1,n=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:r,heightSegments:n,depthSegments:o};const a=this;r=Math.floor(r),n=Math.floor(n),o=Math.floor(o);const l=[],u=[],c=[],d=[];let h=0,p=0;f("z","y","x",-1,-1,s,t,e,o,n,0),f("z","y","x",1,-1,s,t,-e,o,n,1),f("x","z","y",1,1,e,s,t,r,o,2),f("x","z","y",1,-1,e,s,-t,r,o,3),f("x","y","z",1,-1,e,t,s,r,n,4),f("x","y","z",-1,-1,e,t,-s,r,n,5),this.setIndex(l),this.setAttribute("position",new br(u,3)),this.setAttribute("normal",new br(c,3)),this.setAttribute("uv",new br(d,2));function f(m,x,g,_,S,M,w,v,T,E,F){const I=M/T,z=w/E,G=M/2,L=w/2,Q=v/2,q=T+1,J=E+1;let ee=0,se=0;const fe=new xe;for(let ue=0;ue<J;ue++){const U=ue*z-L;for(let k=0;k<q;k++){const j=k*I-G;fe[m]=j*_,fe[x]=U*S,fe[g]=Q,u.push(fe.x,fe.y,fe.z),fe[m]=0,fe[x]=0,fe[g]=v>0?1:-1,c.push(fe.x,fe.y,fe.z),d.push(k/T),d.push(1-ue/E),ee+=1}}for(let ue=0;ue<E;ue++)for(let U=0;U<T;U++){const k=h+U+q*ue,j=h+U+q*(ue+1),re=h+(U+1)+q*(ue+1),we=h+(U+1)+q*ue;l.push(k,j,we),l.push(j,re,we),se+=6}a.addGroup(p,se,F),p+=se,h+=ee}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new fh(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function QD(i){const e={};for(const t in i){e[t]={};for(const s in i[t]){const r=i[t][s];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][s]=null):e[t][s]=r.clone():Array.isArray(r)?e[t][s]=r.slice():e[t][s]=r}}return e}function BU(i){const e=[];for(let t=0;t<i.length;t++)e.push(i[t].clone());return e}var OU=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,$U=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class zU extends Rr{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=OU,this.fragmentShader=$U,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=QD(e.uniforms),this.uniformsGroups=BU(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const s={};for(const r in this.extensions)this.extensions[r]===!0&&(s[r]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}class x0 extends Fi{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new cs,this.projectionMatrix=new cs,this.projectionMatrixInverse=new cs,this.coordinateSystem=Pr}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const va=new xe,i2=new Dt,r2=new Dt;class Ar extends x0{constructor(e=50,t=1,s=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=_c*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Gd*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return _c*2*Math.atan(Math.tan(Gd*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,s){va.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(va.x,va.y).multiplyScalar(-e/va.z),va.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(va.x,va.y).multiplyScalar(-e/va.z)}getViewSize(e,t){return this.getViewBounds(e,i2,r2),t.subVectors(r2,i2)}setViewOffset(e,t,s,r,n,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=r,this.view.width=n,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Gd*.5*this.fov)/this.zoom,s=2*t,r=this.aspect*s,n=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,u=o.fullHeight;n+=o.offsetX*r/l,t-=o.offsetY*s/u,r*=o.width/l,s*=o.height/u}const a=this.filmOffset;a!==0&&(n+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(n,n+r,t,t-s,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Lu=-90,Bu=1;class ZD extends Fi{constructor(e,t,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const r=new Ar(Lu,Bu,e,t);r.layers=this.layers,this.add(r);const n=new Ar(Lu,Bu,e,t);n.layers=this.layers,this.add(n);const o=new Ar(Lu,Bu,e,t);o.layers=this.layers,this.add(o);const a=new Ar(Lu,Bu,e,t);a.layers=this.layers,this.add(a);const l=new Ar(Lu,Bu,e,t);l.layers=this.layers,this.add(l);const u=new Ar(Lu,Bu,e,t);u.layers=this.layers,this.add(u)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[s,r,n,o,a,l]=t;for(const u of t)this.remove(u);if(e===Pr)s.up.set(0,1,0),s.lookAt(1,0,0),r.up.set(0,1,0),r.lookAt(-1,0,0),n.up.set(0,0,-1),n.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===xo)s.up.set(0,-1,0),s.lookAt(-1,0,0),r.up.set(0,-1,0),r.lookAt(1,0,0),n.up.set(0,0,1),n.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const u of t)this.add(u),u.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:r}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[n,o,a,l,u,c]=this.children,d=e.getRenderTarget(),h=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),f=e.xr.enabled;e.xr.enabled=!1;const m=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,r),e.render(t,n),e.setRenderTarget(s,1,r),e.render(t,o),e.setRenderTarget(s,2,r),e.render(t,a),e.setRenderTarget(s,3,r),e.render(t,l),e.setRenderTarget(s,4,r),e.render(t,u),s.texture.generateMipmaps=m,e.setRenderTarget(s,5,r),e.render(t,c),e.setRenderTarget(d,h,p),e.xr.enabled=f,s.texture.needsPMREMUpdate=!0}}class mm extends Yi{constructor(e=[],t=th,s,r,n,o,a,l,u,c){super(e,t,s,r,n,o,a,l,u,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class VU extends MU{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},r=[s,s,s,s,s,s];this.texture=new mm(r),this._setTextureOptions(t),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new fh(5,5,5),n=new zU({name:"CubemapFromEquirect",uniforms:QD(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:lr,blending:fc});n.uniforms.tEquirect.value=t;const o=new bn(r,n),a=t.minFilter;return t.minFilter===qo&&(t.minFilter=wr),new ZD(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t=!0,s=!0,r=!0){const n=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,s,r);e.setRenderTarget(n)}}class Yp extends Fi{constructor(){super(),this.isGroup=!0,this.type="Group"}}const UU={type:"move"};class GU{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Yp,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Yp,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new xe,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new xe),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Yp,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new xe,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new xe),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const s of e.hand.values())this._getHandJoint(t,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let r=null,n=null,o=null;const a=this._targetRay,l=this._grip,u=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(u&&e.hand){o=!0;for(const m of e.hand.values()){const x=t.getJointPose(m,s),g=this._getHandJoint(u,m);x!==null&&(g.matrix.fromArray(x.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.matrixWorldNeedsUpdate=!0,g.jointRadius=x.radius),g.visible=x!==null}const c=u.joints["index-finger-tip"],d=u.joints["thumb-tip"],h=c.position.distanceTo(d.position),p=.02,f=.005;u.inputState.pinching&&h>p+f?(u.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!u.inputState.pinching&&h<=p-f&&(u.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(n=t.getPose(e.gripSpace,s),n!==null&&(l.matrix.fromArray(n.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,n.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(n.linearVelocity)):l.hasLinearVelocity=!1,n.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(n.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(r=t.getPose(e.targetRaySpace,s),r===null&&n!==null&&(r=n),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(UU)))}return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=n!==null),u!==null&&(u.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const s=new Yp;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[t.jointName]=s,e.add(s)}return e.joints[t.jointName]}}class mh extends Fi{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new xn,this.environmentIntensity=1,this.environmentRotation=new xn,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}class JD{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Yf,this.updateRanges=[],this.version=0,this.uuid=Xo()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,s){e*=this.stride,s*=t.stride;for(let r=0,n=this.stride;r<n;r++)this.array[e+r]=t.array[s+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Xo()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(t,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Xo()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const mr=new xe;class b0{constructor(e,t,s,r=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=s,this.normalized=r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,s=this.data.count;t<s;t++)mr.fromBufferAttribute(this,t),mr.applyMatrix4(e),this.setXYZ(t,mr.x,mr.y,mr.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)mr.fromBufferAttribute(this,t),mr.applyNormalMatrix(e),this.setXYZ(t,mr.x,mr.y,mr.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)mr.fromBufferAttribute(this,t),mr.transformDirection(e),this.setXYZ(t,mr.x,mr.y,mr.z);return this}getComponent(e,t){let s=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(s=yr(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Qt(s,this.array)),this.data.array[e*this.data.stride+this.offset+t]=s,this}setX(e,t){return this.normalized&&(t=Qt(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Qt(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Qt(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Qt(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=yr(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=yr(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=yr(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=yr(t,this.array)),t}setXY(e,t,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this}setXYZ(e,t,s,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array),r=Qt(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=r,this}setXYZW(e,t,s,r,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=Qt(t,this.array),s=Qt(s,this.array),r=Qt(r,this.array),n=Qt(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=r,this.data.array[e+3]=n,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const r=s*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)t.push(this.data.array[r+n])}return new Yr(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new b0(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const r=s*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)t.push(this.data.array[r+n])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class jU extends Rr{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new gs(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}class WU extends Yi{constructor(e=null,t=1,s=1,r,n,o,a,l,u=yi,c=yi,d,h){super(null,o,a,l,u,c,r,n,d,h),this.isDataTexture=!0,this.image={data:e,width:t,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ac extends Yr{constructor(e,t,s,r=1){super(e,t,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Fy=new xe,HU=new xe,qU=new kr;class $o{constructor(e=new xe(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,r){return this.normal.set(e,t,s),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const r=Fy.subVectors(s,t).cross(HU.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const s=e.delta(Fy),r=this.normal.dot(s);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const n=-(e.start.dot(this.normal)+this.constant)/r;return n<0||n>1?null:t.copy(e.start).addScaledVector(s,n)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||qU.getNormalMatrix(e),r=this.coplanarPoint(Fy).applyMatrix4(e),n=this.normal.applyMatrix3(s).normalize();return this.constant=-r.dot(n),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const wl=new fm,KU=new Dt(.5,.5),Qp=new xe;class w0{constructor(e=new $o,t=new $o,s=new $o,r=new $o,n=new $o,o=new $o){this.planes=[e,t,s,r,n,o]}set(e,t,s,r,n,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(s),a[3].copy(r),a[4].copy(n),a[5].copy(o),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,t=Pr){const s=this.planes,r=e.elements,n=r[0],o=r[1],a=r[2],l=r[3],u=r[4],c=r[5],d=r[6],h=r[7],p=r[8],f=r[9],m=r[10],x=r[11],g=r[12],_=r[13],S=r[14],M=r[15];if(s[0].setComponents(l-n,h-u,x-p,M-g).normalize(),s[1].setComponents(l+n,h+u,x+p,M+g).normalize(),s[2].setComponents(l+o,h+c,x+f,M+_).normalize(),s[3].setComponents(l-o,h-c,x-f,M-_).normalize(),s[4].setComponents(l-a,h-d,x-m,M-S).normalize(),t===Pr)s[5].setComponents(l+a,h+d,x+m,M+S).normalize();else if(t===xo)s[5].setComponents(a,d,m,S).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),wl.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),wl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(wl)}intersectsSprite(e){wl.center.set(0,0,0);const t=KU.distanceTo(e.center);return wl.radius=.7071067811865476+t,wl.applyMatrix4(e.matrixWorld),this.intersectsSphere(wl)}intersectsSphere(e){const t=this.planes,s=e.center,r=-e.radius;for(let n=0;n<6;n++)if(t[n].distanceToPoint(s)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const r=t[s];if(Qp.x=r.normal.x>0?e.max.x:e.min.x,Qp.y=r.normal.y>0?e.max.y:e.min.y,Qp.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(Qp)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}const no=new cs,oo=new w0;class M0{constructor(){this.coordinateSystem=Pr}intersectsObject(e,t){if(!t.isArrayCamera||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const r=t.cameras[s];if(no.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),oo.setFromProjectionMatrix(no,this.coordinateSystem),oo.intersectsObject(e))return!0}return!1}intersectsSprite(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const r=t.cameras[s];if(no.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),oo.setFromProjectionMatrix(no,this.coordinateSystem),oo.intersectsSprite(e))return!0}return!1}intersectsSphere(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const r=t.cameras[s];if(no.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),oo.setFromProjectionMatrix(no,this.coordinateSystem),oo.intersectsSphere(e))return!0}return!1}intersectsBox(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const r=t.cameras[s];if(no.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),oo.setFromProjectionMatrix(no,this.coordinateSystem),oo.intersectsBox(e))return!0}return!1}containsPoint(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const r=t.cameras[s];if(no.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),oo.setFromProjectionMatrix(no,this.coordinateSystem),oo.containsPoint(e))return!0}return!1}clone(){return new M0}}class ek extends Rr{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new gs(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}class XU extends Rr{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new gs(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}class tk extends Yi{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=yi,this.minFilter=yi,this.generateMipmaps=!1,this.needsUpdate=!0}}class YU extends Yi{constructor(e,t,s,r,n,o,a,l,u){super(e,t,s,r,n,o,a,l,u),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Hn extends Yi{constructor(e,t,s=_i,r,n,o,a=yi,l=yi,u,c=fo,d=1){if(c!==fo&&c!==Ko)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");const h={width:e,height:t,depth:d};super(h,r,n,o,a,l,c,s,u),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new y0(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class T0 extends aa{constructor(e=1,t=1,s=1,r=32,n=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:s,radialSegments:r,heightSegments:n,openEnded:o,thetaStart:a,thetaLength:l};const u=this;r=Math.floor(r),n=Math.floor(n);const c=[],d=[],h=[],p=[];let f=0;const m=[],x=s/2;let g=0;_(),o===!1&&(e>0&&S(!0),t>0&&S(!1)),this.setIndex(c),this.setAttribute("position",new br(d,3)),this.setAttribute("normal",new br(h,3)),this.setAttribute("uv",new br(p,2));function _(){const M=new xe,w=new xe;let v=0;const T=(t-e)/s;for(let E=0;E<=n;E++){const F=[],I=E/n,z=I*(t-e)+e;for(let G=0;G<=r;G++){const L=G/r,Q=L*l+a,q=Math.sin(Q),J=Math.cos(Q);w.x=z*q,w.y=-I*s+x,w.z=z*J,d.push(w.x,w.y,w.z),M.set(q,T,J).normalize(),h.push(M.x,M.y,M.z),p.push(L,1-I),F.push(f++)}m.push(F)}for(let E=0;E<r;E++)for(let F=0;F<n;F++){const I=m[F][E],z=m[F+1][E],G=m[F+1][E+1],L=m[F][E+1];(e>0||F!==0)&&(c.push(I,z,L),v+=3),(t>0||F!==n-1)&&(c.push(z,G,L),v+=3)}u.addGroup(g,v,0),g+=v}function S(M){const w=f,v=new Dt,T=new xe;let E=0;const F=M===!0?e:t,I=M===!0?1:-1;for(let G=1;G<=r;G++)d.push(0,x*I,0),h.push(0,I,0),p.push(.5,.5),f++;const z=f;for(let G=0;G<=r;G++){const Q=G/r*l+a,q=Math.cos(Q),J=Math.sin(Q);T.x=F*J,T.y=x*I,T.z=F*q,d.push(T.x,T.y,T.z),h.push(0,I,0),v.x=q*.5+.5,v.y=J*.5*I+.5,p.push(v.x,v.y),f++}for(let G=0;G<r;G++){const L=w+G,Q=z+G;M===!0?c.push(Q,Q+1,L):c.push(Q+1,Q,L),E+=3}u.addGroup(g,E,M===!0?1:2),g+=E}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new T0(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class yc extends aa{constructor(e=1,t=1,s=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:r};const n=e/2,o=t/2,a=Math.floor(s),l=Math.floor(r),u=a+1,c=l+1,d=e/a,h=t/l,p=[],f=[],m=[],x=[];for(let g=0;g<c;g++){const _=g*h-o;for(let S=0;S<u;S++){const M=S*d-n;f.push(M,-_,0),m.push(0,0,1),x.push(S/a),x.push(1-g/l)}}for(let g=0;g<l;g++)for(let _=0;_<a;_++){const S=_+u*g,M=_+u*(g+1),w=_+1+u*(g+1),v=_+1+u*g;p.push(S,M,v),p.push(M,w,v)}this.setIndex(p),this.setAttribute("position",new br(f,3)),this.setAttribute("normal",new br(m,3)),this.setAttribute("uv",new br(x,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new yc(e.width,e.height,e.widthSegments,e.heightSegments)}}class v0 extends aa{constructor(e=1,t=32,s=16,r=0,n=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:s,phiStart:r,phiLength:n,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),s=Math.max(2,Math.floor(s));const l=Math.min(o+a,Math.PI);let u=0;const c=[],d=new xe,h=new xe,p=[],f=[],m=[],x=[];for(let g=0;g<=s;g++){const _=[],S=g/s;let M=0;g===0&&o===0?M=.5/t:g===s&&l===Math.PI&&(M=-.5/t);for(let w=0;w<=t;w++){const v=w/t;d.x=-e*Math.cos(r+v*n)*Math.sin(o+S*a),d.y=e*Math.cos(o+S*a),d.z=e*Math.sin(r+v*n)*Math.sin(o+S*a),f.push(d.x,d.y,d.z),h.copy(d).normalize(),m.push(h.x,h.y,h.z),x.push(v+M,1-S),_.push(u++)}c.push(_)}for(let g=0;g<s;g++)for(let _=0;_<t;_++){const S=c[g][_+1],M=c[g][_],w=c[g+1][_],v=c[g+1][_+1];(g!==0||o>0)&&p.push(S,M,v),(g!==s-1||l<Math.PI)&&p.push(M,w,v)}this.setIndex(p),this.setAttribute("position",new br(f,3)),this.setAttribute("normal",new br(m,3)),this.setAttribute("uv",new br(x,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new v0(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class QU extends Rr{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new gs(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class sk extends Rr{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new gs(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new gs(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$a,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xn,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class ZU extends sk{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Dt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return es(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new gs(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new gs(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new gs(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class JU extends Rr{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new gs(16777215),this.specular=new gs(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new gs(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$a,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xn,this.combine=pm,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class e4 extends Rr{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new gs(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new gs(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$a,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class t4 extends Rr{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$a,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class s4 extends Rr{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new gs(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new gs(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$a,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xn,this.combine=pm,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class i4 extends Rr{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new gs(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$a,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class r4 extends ek{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}class eu extends Fi{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new gs(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}class n4 extends eu{constructor(e,t,s){super(e,s),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Fi.DEFAULT_UP),this.updateMatrix(),this.groundColor=new gs(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const Ry=new cs,n2=new xe,o2=new xe;class S0{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Dt(512,512),this.mapType=xr,this.map=null,this.mapPass=null,this.matrix=new cs,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new w0,this._frameExtents=new Dt(1,1),this._viewportCount=1,this._viewports=[new ns(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;n2.setFromMatrixPosition(e.matrixWorld),t.position.copy(n2),o2.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(o2),t.updateMatrixWorld(),Ry.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ry),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(Ry)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.autoUpdate=e.autoUpdate,this.needsUpdate=e.needsUpdate,this.normalBias=e.normalBias,this.blurSamples=e.blurSamples,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class o4 extends S0{constructor(){super(new Ar(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(e){const t=this.camera,s=_c*2*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height*this.aspect,n=e.distance||t.far;(s!==t.fov||r!==t.aspect||n!==t.far)&&(t.fov=s,t.aspect=r,t.far=n,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class E0 extends eu{constructor(e,t,s=0,r=Math.PI/3,n=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Fi.DEFAULT_UP),this.updateMatrix(),this.target=new Fi,this.distance=s,this.angle=r,this.penumbra=n,this.decay=o,this.map=null,this.shadow=new o4}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const a2=new cs,gd=new xe,Iy=new xe;class a4 extends S0{constructor(){super(new Ar(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Dt(4,2),this._viewportCount=6,this._viewports=[new ns(2,1,1,1),new ns(0,1,1,1),new ns(3,1,1,1),new ns(1,1,1,1),new ns(3,0,1,1),new ns(1,0,1,1)],this._cubeDirections=[new xe(1,0,0),new xe(-1,0,0),new xe(0,0,1),new xe(0,0,-1),new xe(0,1,0),new xe(0,-1,0)],this._cubeUps=[new xe(0,1,0),new xe(0,1,0),new xe(0,1,0),new xe(0,1,0),new xe(0,0,1),new xe(0,0,-1)]}updateMatrices(e,t=0){const s=this.camera,r=this.matrix,n=e.distance||s.far;n!==s.far&&(s.far=n,s.updateProjectionMatrix()),gd.setFromMatrixPosition(e.matrixWorld),s.position.copy(gd),Iy.copy(s.position),Iy.add(this._cubeDirections[t]),s.up.copy(this._cubeUps[t]),s.lookAt(Iy),s.updateMatrixWorld(),r.makeTranslation(-gd.x,-gd.y,-gd.z),a2.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(a2)}}class l4 extends eu{constructor(e,t,s=0,r=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=r,this.shadow=new a4}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class gm extends x0{constructor(e=-1,t=1,s=1,r=-1,n=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=r,this.near=n,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,r,n,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=r,this.view.width=n,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let n=s-e,o=s+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const u=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;n+=u*this.view.offsetX,o=n+u*this.view.width,a-=c*this.view.offsetY,l=a-c*this.view.height}this.projectionMatrix.makeOrthographic(n,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class u4 extends S0{constructor(){super(new gm(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class c4 extends eu{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Fi.DEFAULT_UP),this.updateMatrix(),this.target=new Fi,this.shadow=new u4}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class d4 extends eu{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class h4 extends eu{constructor(e,t,s=10,r=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=s,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class p4{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new xe)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const s=e.x,r=e.y,n=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*n),t.addScaledVector(o[3],.488603*s),t.addScaledVector(o[4],1.092548*(s*r)),t.addScaledVector(o[5],1.092548*(r*n)),t.addScaledVector(o[6],.315392*(3*n*n-1)),t.addScaledVector(o[7],1.092548*(s*n)),t.addScaledVector(o[8],.546274*(s*s-r*r)),t}getIrradianceAt(e,t){const s=e.x,r=e.y,n=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*r),t.addScaledVector(o[2],2*.511664*n),t.addScaledVector(o[3],2*.511664*s),t.addScaledVector(o[4],2*.429043*s*r),t.addScaledVector(o[5],2*.429043*r*n),t.addScaledVector(o[6],.743125*n*n-.247708),t.addScaledVector(o[7],2*.429043*s*n),t.addScaledVector(o[8],.429043*(s*s-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(e.coefficients[s],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let s=0;s<9;s++)this.coefficients[s].lerp(e.coefficients[s],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const s=this.coefficients;for(let r=0;r<9;r++)s[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const s=this.coefficients;for(let r=0;r<9;r++)s[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const s=e.x,r=e.y,n=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*n,t[3]=.488603*s,t[4]=1.092548*s*r,t[5]=1.092548*r*n,t[6]=.315392*(3*n*n-1),t[7]=1.092548*s*n,t[8]=.546274*(s*s-r*r)}}class f4 extends eu{constructor(e=new p4,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class m4 extends Ar{constructor(e=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=e}}class g4 extends JD{constructor(e,t,s=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class l2{constructor(e=1,t=0,s=0){this.radius=e,this.phi=t,this.theta=s}set(e,t,s){return this.radius=e,this.phi=t,this.theta=s,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=es(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+t*t+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,s),this.phi=Math.acos(es(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class _m{constructor(e,t,s,r){_m.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,t,s,r)}identity(){return this.set(1,0,0,1),this}fromArray(e,t=0){for(let s=0;s<4;s++)this.elements[s]=e[s+t];return this}set(e,t,s,r){const n=this.elements;return n[0]=e,n[2]=t,n[1]=s,n[3]=r,this}}class _4 extends oa{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(e){if(e===void 0){console.warn("THREE.Controls: connect() now requires an element.");return}this.domElement!==null&&this.disconnect(),this.domElement=e}disconnect(){}dispose(){}update(){}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:hm}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=hm);const u2={type:"change"},A0={type:"start"},ik={type:"end"},Zp=new HD,c2=new $o,y4=Math.cos(70*_0.DEG2RAD),zi=new xe,Sr=2*Math.PI,Bs={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},Dy=1e-6;class x4 extends _4{constructor(e,t=null){super(e,t),this.state=Bs.NONE,this.target=new xe,this.cursor=new xe,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.keyRotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:rc.ROTATE,MIDDLE:rc.DOLLY,RIGHT:rc.PAN},this.touches={ONE:Qu.ROTATE,TWO:Qu.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new xe,this._lastQuaternion=new za,this._lastTargetPosition=new xe,this._quat=new za().setFromUnitVectors(e.up,new xe(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new l2,this._sphericalDelta=new l2,this._scale=1,this._panOffset=new xe,this._rotateStart=new Dt,this._rotateEnd=new Dt,this._rotateDelta=new Dt,this._panStart=new Dt,this._panEnd=new Dt,this._panDelta=new Dt,this._dollyStart=new Dt,this._dollyEnd=new Dt,this._dollyDelta=new Dt,this._dollyDirection=new xe,this._mouse=new Dt,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=w4.bind(this),this._onPointerDown=b4.bind(this),this._onPointerUp=M4.bind(this),this._onContextMenu=P4.bind(this),this._onMouseWheel=S4.bind(this),this._onKeyDown=E4.bind(this),this._onTouchStart=A4.bind(this),this._onTouchMove=C4.bind(this),this._onMouseDown=T4.bind(this),this._onMouseMove=v4.bind(this),this._interceptControlDown=N4.bind(this),this._interceptControlUp=F4.bind(this),this.domElement!==null&&this.connect(this.domElement),this.update()}connect(e){super.connect(e),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(e){e.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=e}stopListenToKeyEvents(){this._domElementKeyEvents!==null&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(u2),this.update(),this.state=Bs.NONE}update(e=null){const t=this.object.position;zi.copy(t).sub(this.target),zi.applyQuaternion(this._quat),this._spherical.setFromVector3(zi),this.autoRotate&&this.state===Bs.NONE&&this._rotateLeft(this._getAutoRotationAngle(e)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let s=this.minAzimuthAngle,r=this.maxAzimuthAngle;isFinite(s)&&isFinite(r)&&(s<-Math.PI?s+=Sr:s>Math.PI&&(s-=Sr),r<-Math.PI?r+=Sr:r>Math.PI&&(r-=Sr),s<=r?this._spherical.theta=Math.max(s,Math.min(r,this._spherical.theta)):this._spherical.theta=this._spherical.theta>(s+r)/2?Math.max(s,this._spherical.theta):Math.min(r,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),this.enableDamping===!0?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let n=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const o=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),n=o!=this._spherical.radius}if(zi.setFromSpherical(this._spherical),zi.applyQuaternion(this._quatInverse),t.copy(this.target).add(zi),this.object.lookAt(this.target),this.enableDamping===!0?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let o=null;if(this.object.isPerspectiveCamera){const a=zi.length();o=this._clampDistance(a*this._scale);const l=a-o;this.object.position.addScaledVector(this._dollyDirection,l),this.object.updateMatrixWorld(),n=!!l}else if(this.object.isOrthographicCamera){const a=new xe(this._mouse.x,this._mouse.y,0);a.unproject(this.object);const l=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),n=l!==this.object.zoom;const u=new xe(this._mouse.x,this._mouse.y,0);u.unproject(this.object),this.object.position.sub(u).add(a),this.object.updateMatrixWorld(),o=zi.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;o!==null&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position):(Zp.origin.copy(this.object.position),Zp.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(Zp.direction))<y4?this.object.lookAt(this.target):(c2.setFromNormalAndCoplanarPoint(this.object.up,this.target),Zp.intersectPlane(c2,this.target))))}else if(this.object.isOrthographicCamera){const o=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),o!==this.object.zoom&&(this.object.updateProjectionMatrix(),n=!0)}return this._scale=1,this._performCursorZoom=!1,n||this._lastPosition.distanceToSquared(this.object.position)>Dy||8*(1-this._lastQuaternion.dot(this.object.quaternion))>Dy||this._lastTargetPosition.distanceToSquared(this.target)>Dy?(this.dispatchEvent(u2),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0):!1}_getAutoRotationAngle(e){return e!==null?Sr/60*this.autoRotateSpeed*e:Sr/60/60*this.autoRotateSpeed}_getZoomScale(e){const t=Math.abs(e*.01);return Math.pow(.95,this.zoomSpeed*t)}_rotateLeft(e){this._sphericalDelta.theta-=e}_rotateUp(e){this._sphericalDelta.phi-=e}_panLeft(e,t){zi.setFromMatrixColumn(t,0),zi.multiplyScalar(-e),this._panOffset.add(zi)}_panUp(e,t){this.screenSpacePanning===!0?zi.setFromMatrixColumn(t,1):(zi.setFromMatrixColumn(t,0),zi.crossVectors(this.object.up,zi)),zi.multiplyScalar(e),this._panOffset.add(zi)}_pan(e,t){const s=this.domElement;if(this.object.isPerspectiveCamera){const r=this.object.position;zi.copy(r).sub(this.target);let n=zi.length();n*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*e*n/s.clientHeight,this.object.matrix),this._panUp(2*t*n/s.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(e*(this.object.right-this.object.left)/this.object.zoom/s.clientWidth,this.object.matrix),this._panUp(t*(this.object.top-this.object.bottom)/this.object.zoom/s.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(e,t){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const s=this.domElement.getBoundingClientRect(),r=e-s.left,n=t-s.top,o=s.width,a=s.height;this._mouse.x=r/o*2-1,this._mouse.y=-(n/a)*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(e){return Math.max(this.minDistance,Math.min(this.maxDistance,e))}_handleMouseDownRotate(e){this._rotateStart.set(e.clientX,e.clientY)}_handleMouseDownDolly(e){this._updateZoomParameters(e.clientX,e.clientX),this._dollyStart.set(e.clientX,e.clientY)}_handleMouseDownPan(e){this._panStart.set(e.clientX,e.clientY)}_handleMouseMoveRotate(e){this._rotateEnd.set(e.clientX,e.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(Sr*this._rotateDelta.x/t.clientHeight),this._rotateUp(Sr*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(e){this._dollyEnd.set(e.clientX,e.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(e){this._panEnd.set(e.clientX,e.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(e){this._updateZoomParameters(e.clientX,e.clientY),e.deltaY<0?this._dollyIn(this._getZoomScale(e.deltaY)):e.deltaY>0&&this._dollyOut(this._getZoomScale(e.deltaY)),this.update()}_handleKeyDown(e){let t=!1;switch(e.code){case this.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(Sr*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,this.keyPanSpeed),t=!0;break;case this.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(-Sr*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,-this.keyPanSpeed),t=!0;break;case this.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(Sr*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(this.keyPanSpeed,0),t=!0;break;case this.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(-Sr*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(-this.keyPanSpeed,0),t=!0;break}t&&(e.preventDefault(),this.update())}_handleTouchStartRotate(e){if(this._pointers.length===1)this._rotateStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),s=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);this._rotateStart.set(s,r)}}_handleTouchStartPan(e){if(this._pointers.length===1)this._panStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),s=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);this._panStart.set(s,r)}}_handleTouchStartDolly(e){const t=this._getSecondPointerPosition(e),s=e.pageX-t.x,r=e.pageY-t.y,n=Math.sqrt(s*s+r*r);this._dollyStart.set(0,n)}_handleTouchStartDollyPan(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enablePan&&this._handleTouchStartPan(e)}_handleTouchStartDollyRotate(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enableRotate&&this._handleTouchStartRotate(e)}_handleTouchMoveRotate(e){if(this._pointers.length==1)this._rotateEnd.set(e.pageX,e.pageY);else{const s=this._getSecondPointerPosition(e),r=.5*(e.pageX+s.x),n=.5*(e.pageY+s.y);this._rotateEnd.set(r,n)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(Sr*this._rotateDelta.x/t.clientHeight),this._rotateUp(Sr*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(e){if(this._pointers.length===1)this._panEnd.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),s=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);this._panEnd.set(s,r)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(e){const t=this._getSecondPointerPosition(e),s=e.pageX-t.x,r=e.pageY-t.y,n=Math.sqrt(s*s+r*r);this._dollyEnd.set(0,n),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const o=(e.pageX+t.x)*.5,a=(e.pageY+t.y)*.5;this._updateZoomParameters(o,a)}_handleTouchMoveDollyPan(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enablePan&&this._handleTouchMovePan(e)}_handleTouchMoveDollyRotate(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enableRotate&&this._handleTouchMoveRotate(e)}_addPointer(e){this._pointers.push(e.pointerId)}_removePointer(e){delete this._pointerPositions[e.pointerId];for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId){this._pointers.splice(t,1);return}}_isTrackingPointer(e){for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId)return!0;return!1}_trackPointer(e){let t=this._pointerPositions[e.pointerId];t===void 0&&(t=new Dt,this._pointerPositions[e.pointerId]=t),t.set(e.pageX,e.pageY)}_getSecondPointerPosition(e){const t=e.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[t]}_customWheelEvent(e){const t=e.deltaMode,s={clientX:e.clientX,clientY:e.clientY,deltaY:e.deltaY};switch(t){case 1:s.deltaY*=16;break;case 2:s.deltaY*=100;break}return e.ctrlKey&&!this._controlActive&&(s.deltaY*=10),s}}function b4(i){this.enabled!==!1&&(this._pointers.length===0&&(this.domElement.setPointerCapture(i.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),!this._isTrackingPointer(i)&&(this._addPointer(i),i.pointerType==="touch"?this._onTouchStart(i):this._onMouseDown(i)))}function w4(i){this.enabled!==!1&&(i.pointerType==="touch"?this._onTouchMove(i):this._onMouseMove(i))}function M4(i){switch(this._removePointer(i),this._pointers.length){case 0:this.domElement.releasePointerCapture(i.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(ik),this.state=Bs.NONE;break;case 1:const e=this._pointers[0],t=this._pointerPositions[e];this._onTouchStart({pointerId:e,pageX:t.x,pageY:t.y});break}}function T4(i){let e;switch(i.button){case 0:e=this.mouseButtons.LEFT;break;case 1:e=this.mouseButtons.MIDDLE;break;case 2:e=this.mouseButtons.RIGHT;break;default:e=-1}switch(e){case rc.DOLLY:if(this.enableZoom===!1)return;this._handleMouseDownDolly(i),this.state=Bs.DOLLY;break;case rc.ROTATE:if(i.ctrlKey||i.metaKey||i.shiftKey){if(this.enablePan===!1)return;this._handleMouseDownPan(i),this.state=Bs.PAN}else{if(this.enableRotate===!1)return;this._handleMouseDownRotate(i),this.state=Bs.ROTATE}break;case rc.PAN:if(i.ctrlKey||i.metaKey||i.shiftKey){if(this.enableRotate===!1)return;this._handleMouseDownRotate(i),this.state=Bs.ROTATE}else{if(this.enablePan===!1)return;this._handleMouseDownPan(i),this.state=Bs.PAN}break;default:this.state=Bs.NONE}this.state!==Bs.NONE&&this.dispatchEvent(A0)}function v4(i){switch(this.state){case Bs.ROTATE:if(this.enableRotate===!1)return;this._handleMouseMoveRotate(i);break;case Bs.DOLLY:if(this.enableZoom===!1)return;this._handleMouseMoveDolly(i);break;case Bs.PAN:if(this.enablePan===!1)return;this._handleMouseMovePan(i);break}}function S4(i){this.enabled===!1||this.enableZoom===!1||this.state!==Bs.NONE||(i.preventDefault(),this.dispatchEvent(A0),this._handleMouseWheel(this._customWheelEvent(i)),this.dispatchEvent(ik))}function E4(i){this.enabled!==!1&&this._handleKeyDown(i)}function A4(i){switch(this._trackPointer(i),this._pointers.length){case 1:switch(this.touches.ONE){case Qu.ROTATE:if(this.enableRotate===!1)return;this._handleTouchStartRotate(i),this.state=Bs.TOUCH_ROTATE;break;case Qu.PAN:if(this.enablePan===!1)return;this._handleTouchStartPan(i),this.state=Bs.TOUCH_PAN;break;default:this.state=Bs.NONE}break;case 2:switch(this.touches.TWO){case Qu.DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchStartDollyPan(i),this.state=Bs.TOUCH_DOLLY_PAN;break;case Qu.DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchStartDollyRotate(i),this.state=Bs.TOUCH_DOLLY_ROTATE;break;default:this.state=Bs.NONE}break;default:this.state=Bs.NONE}this.state!==Bs.NONE&&this.dispatchEvent(A0)}function C4(i){switch(this._trackPointer(i),this.state){case Bs.TOUCH_ROTATE:if(this.enableRotate===!1)return;this._handleTouchMoveRotate(i),this.update();break;case Bs.TOUCH_PAN:if(this.enablePan===!1)return;this._handleTouchMovePan(i),this.update();break;case Bs.TOUCH_DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchMoveDollyPan(i),this.update();break;case Bs.TOUCH_DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchMoveDollyRotate(i),this.update();break;default:this.state=Bs.NONE}}function P4(i){this.enabled!==!1&&i.preventDefault()}function N4(i){i.key==="Control"&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function F4(i){i.key==="Control"&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const R4=["alphaMap","alphaTest","anisotropy","anisotropyMap","anisotropyRotation","aoMap","aoMapIntensity","attenuationColor","attenuationDistance","bumpMap","clearcoat","clearcoatMap","clearcoatNormalMap","clearcoatNormalScale","clearcoatRoughness","color","dispersion","displacementMap","emissive","emissiveIntensity","emissiveMap","envMap","envMapIntensity","gradientMap","ior","iridescence","iridescenceIOR","iridescenceMap","iridescenceThicknessMap","lightMap","lightMapIntensity","map","matcap","metalness","metalnessMap","normalMap","normalScale","opacity","roughness","roughnessMap","sheen","sheenColor","sheenColorMap","sheenRoughnessMap","shininess","specular","specularColor","specularColorMap","specularIntensity","specularIntensityMap","specularMap","thickness","transmission","transmissionMap"];class I4{constructor(e){this.renderObjects=new WeakMap,this.hasNode=this.containsNode(e),this.hasAnimation=e.object.isSkinnedMesh===!0,this.refreshUniforms=R4,this.renderId=0}firstInitialization(e){return this.renderObjects.has(e)===!1?(this.getRenderObjectData(e),!0):!1}needsVelocity(e){const t=e.getMRT();return t!==null&&t.has("velocity")}getRenderObjectData(e){let t=this.renderObjects.get(e);if(t===void 0){const{geometry:s,material:r,object:n}=e;if(t={material:this.getMaterialData(r),geometry:{id:s.id,attributes:this.getAttributesData(s.attributes),indexVersion:s.index?s.index.version:null,drawRange:{start:s.drawRange.start,count:s.drawRange.count}},worldMatrix:n.matrixWorld.clone()},n.center&&(t.center=n.center.clone()),n.morphTargetInfluences&&(t.morphTargetInfluences=n.morphTargetInfluences.slice()),e.bundle!==null&&(t.version=e.bundle.version),t.material.transmission>0){const{width:o,height:a}=e.context;t.bufferWidth=o,t.bufferHeight=a}this.renderObjects.set(e,t)}return t}getAttributesData(e){const t={};for(const s in e){const r=e[s];t[s]={version:r.version}}return t}containsNode(e){const t=e.material;for(const s in t)if(t[s]&&t[s].isNode)return!0;return e.renderer.overrideNodes.modelViewMatrix!==null||e.renderer.overrideNodes.modelNormalViewMatrix!==null}getMaterialData(e){const t={};for(const s of this.refreshUniforms){const r=e[s];r!=null&&(typeof r=="object"&&r.clone!==void 0?r.isTexture===!0?t[s]={id:r.id,version:r.version}:t[s]=r.clone():t[s]=r)}return t}equals(e){const{object:t,material:s,geometry:r}=e,n=this.getRenderObjectData(e);if(n.worldMatrix.equals(t.matrixWorld)!==!0)return n.worldMatrix.copy(t.matrixWorld),!1;const o=n.material;for(const m in o){const x=o[m],g=s[m];if(x.equals!==void 0){if(x.equals(g)===!1)return x.copy(g),!1}else if(g.isTexture===!0){if(x.id!==g.id||x.version!==g.version)return x.id=g.id,x.version=g.version,!1}else if(x!==g)return o[m]=g,!1}if(o.transmission>0){const{width:m,height:x}=e.context;if(n.bufferWidth!==m||n.bufferHeight!==x)return n.bufferWidth=m,n.bufferHeight=x,!1}const a=n.geometry,l=r.attributes,u=a.attributes,c=Object.keys(u),d=Object.keys(l);if(a.id!==r.id)return a.id=r.id,!1;if(c.length!==d.length)return n.geometry.attributes=this.getAttributesData(l),!1;for(const m of c){const x=u[m],g=l[m];if(g===void 0)return delete u[m],!1;if(x.version!==g.version)return x.version=g.version,!1}const h=r.index,p=a.indexVersion,f=h?h.version:null;if(p!==f)return a.indexVersion=f,!1;if(a.drawRange.start!==r.drawRange.start||a.drawRange.count!==r.drawRange.count)return a.drawRange.start=r.drawRange.start,a.drawRange.count=r.drawRange.count,!1;if(n.morphTargetInfluences){let m=!1;for(let x=0;x<n.morphTargetInfluences.length;x++)n.morphTargetInfluences[x]!==t.morphTargetInfluences[x]&&(m=!0);if(m)return!0}return n.center&&n.center.equals(t.center)===!1?(n.center.copy(t.center),!0):(e.bundle!==null&&(n.version=e.bundle.version),!0)}needsRefresh(e,t){if(this.hasNode||this.hasAnimation||this.firstInitialization(e)||this.needsVelocity(t.renderer))return!0;const{renderId:s}=t;if(this.renderId!==s)return this.renderId=s,!0;const r=e.object.static===!0,n=e.bundle!==null&&e.bundle.static===!0&&this.getRenderObjectData(e).version===e.bundle.version;return r||n?!1:this.equals(e)!==!0}}function ih(i,e=0){let t=3735928559^e,s=1103547991^e;if(i instanceof Array)for(let r=0,n;r<i.length;r++)n=i[r],t=Math.imul(t^n,2654435761),s=Math.imul(s^n,1597334677);else for(let r=0,n;r<i.length;r++)n=i.charCodeAt(r),t=Math.imul(t^n,2654435761),s=Math.imul(s^n,1597334677);return t=Math.imul(t^t>>>16,2246822507),t^=Math.imul(s^s>>>13,3266489909),s=Math.imul(s^s>>>16,2246822507),s^=Math.imul(t^t>>>13,3266489909),4294967296*(2097151&s)+(t>>>0)}const rk=i=>ih(i),ym=i=>ih(i),Qf=(...i)=>ih(i);function nk(i,e=!1){const t=[];i.isNode===!0&&(t.push(i.id),i=i.getSelf());for(const{property:s,childNode:r}of Zf(i))t.push(ih(s.slice(0,-4)),r.getCacheKey(e));return ih(t)}function*Zf(i,e=!1){for(const t in i){if(t.startsWith("_")===!0)continue;const s=i[t];if(Array.isArray(s)===!0)for(let r=0;r<s.length;r++){const n=s[r];n&&(n.isNode===!0||e&&typeof n.toJSON=="function")&&(yield{property:t,index:r,childNode:n})}else if(s&&s.isNode===!0)yield{property:t,childNode:s};else if(typeof s=="object")for(const r in s){const n=s[r];n&&(n.isNode===!0||e&&typeof n.toJSON=="function")&&(yield{property:t,index:r,childNode:n})}}}const D4=new Map([[1,"float"],[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),d2=new WeakMap;function ok(i){return D4.get(i)}function Jf(i){if(/[iu]?vec\d/.test(i))return i.startsWith("ivec")?Int32Array:i.startsWith("uvec")?Uint32Array:Float32Array;if(/mat\d/.test(i)||/float/.test(i))return Float32Array;if(/uint/.test(i))return Uint32Array;if(/int/.test(i))return Int32Array;throw new Error(`THREE.NodeUtils: Unsupported type: ${i}`)}function ak(i){if(/float|int|uint/.test(i))return 1;if(/vec2/.test(i))return 2;if(/vec3/.test(i))return 3;if(/vec4/.test(i)||/mat2/.test(i))return 4;if(/mat3/.test(i))return 9;if(/mat4/.test(i))return 16;console.error("THREE.TSL: Unsupported type:",i)}function k4(i){if(/float|int|uint/.test(i))return 1;if(/vec2/.test(i))return 2;if(/vec3/.test(i))return 3;if(/vec4/.test(i)||/mat2/.test(i))return 4;if(/mat3/.test(i))return 12;if(/mat4/.test(i))return 16;console.error("THREE.TSL: Unsupported type:",i)}function L4(i){if(/float|int|uint/.test(i))return 4;if(/vec2/.test(i))return 8;if(/vec3/.test(i)||/vec4/.test(i))return 16;if(/mat2/.test(i))return 8;if(/mat3/.test(i))return 48;if(/mat4/.test(i))return 64;console.error("THREE.TSL: Unsupported type:",i)}function Ia(i){if(i==null)return null;const e=typeof i;return i.isNode===!0?"node":e==="number"?"float":e==="boolean"?"bool":e==="string"?"string":e==="function"?"shader":i.isVector2===!0?"vec2":i.isVector3===!0?"vec3":i.isVector4===!0?"vec4":i.isMatrix2===!0?"mat2":i.isMatrix3===!0?"mat3":i.isMatrix4===!0?"mat4":i.isColor===!0?"color":i instanceof ArrayBuffer?"ArrayBuffer":null}function lk(i,...e){const t=i?i.slice(-4):void 0;return e.length===1&&(t==="vec2"?e=[e[0],e[0]]:t==="vec3"?e=[e[0],e[0],e[0]]:t==="vec4"&&(e=[e[0],e[0],e[0],e[0]])),i==="color"?new gs(...e):t==="vec2"?new Dt(...e):t==="vec3"?new xe(...e):t==="vec4"?new ns(...e):t==="mat2"?new _m(...e):t==="mat3"?new kr(...e):t==="mat4"?new cs(...e):i==="bool"?e[0]||!1:i==="float"||i==="int"||i==="uint"?e[0]||0:i==="string"?e[0]||"":i==="ArrayBuffer"?dk(e[0]):null}function uk(i){let e=d2.get(i);return e===void 0&&(e={},d2.set(i,e)),e}function ck(i){let e="";const t=new Uint8Array(i);for(let s=0;s<t.length;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function dk(i){return Uint8Array.from(atob(i),e=>e.charCodeAt(0)).buffer}const Ld={VERTEX:"vertex",FRAGMENT:"fragment"},Kt={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},B4={BOOLEAN:"bool",INTEGER:"int",FLOAT:"float",VECTOR2:"vec2",VECTOR3:"vec3",VECTOR4:"vec4",MATRIX2:"mat2",MATRIX3:"mat3",MATRIX4:"mat4"},ar={READ_ONLY:"readOnly",WRITE_ONLY:"writeOnly",READ_WRITE:"readWrite"},hk=["fragment","vertex"],rb=["setup","analyze","generate"],nb=[...hk,"compute"],tu=["x","y","z","w"],O4={analyze:"setup",generate:"analyze"};let $4=0;class Ft extends oa{static get type(){return"Node"}constructor(e=null){super(),this.nodeType=e,this.updateType=Kt.NONE,this.updateBeforeType=Kt.NONE,this.updateAfterType=Kt.NONE,this.uuid=_0.generateUUID(),this.version=0,this.global=!1,this.parents=!1,this.isNode=!0,this._cacheKey=null,this._cacheKeyVersion=0,Object.defineProperty(this,"id",{value:$4++})}set needsUpdate(e){e===!0&&this.version++}get type(){return this.constructor.type}onUpdate(e,t){return this.updateType=t,this.update=e.bind(this.getSelf()),this}onFrameUpdate(e){return this.onUpdate(e,Kt.FRAME)}onRenderUpdate(e){return this.onUpdate(e,Kt.RENDER)}onObjectUpdate(e){return this.onUpdate(e,Kt.OBJECT)}onReference(e){return this.updateReference=e.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return this.global}*getChildren(){for(const{childNode:e}of Zf(this))yield e}dispose(){this.dispatchEvent({type:"dispose"})}traverse(e){e(this);for(const t of this.getChildren())t.traverse(e)}getCacheKey(e=!1){return e=e||this.version!==this._cacheKeyVersion,(e===!0||this._cacheKey===null)&&(this._cacheKey=Qf(nk(this,e),this.customCacheKey()),this._cacheKeyVersion=this.version),this._cacheKey}customCacheKey(){return 0}getScope(){return this}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getUpdateAfterType(){return this.updateAfterType}getElementType(e){const t=this.getNodeType(e);return e.getElementType(t)}getMemberType(){return"void"}getNodeType(e){const t=e.getNodeProperties(this);return t.outputNode?t.outputNode.getNodeType(e):this.nodeType}getShared(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}setup(e){const t=e.getNodeProperties(this);let s=0;for(const r of this.getChildren())t["node"+s++]=r;return t.outputNode||null}analyze(e,t=null){const s=e.increaseUsage(this);if(this.parents===!0){const r=e.getDataFromNode(this,"any");r.stages=r.stages||{},r.stages[e.shaderStage]=r.stages[e.shaderStage]||[],r.stages[e.shaderStage].push(t)}if(s===1){const r=e.getNodeProperties(this);for(const n of Object.values(r))n&&n.isNode===!0&&n.build(e,this)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&s.isNode===!0)return s.build(e,t)}updateBefore(){console.warn("Abstract function.")}updateAfter(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(e,t=null){const s=this.getShared(e);if(this!==s)return s.build(e,t);const r=e.getDataFromNode(this);r.buildStages=r.buildStages||{},r.buildStages[e.buildStage]=!0;const n=O4[e.buildStage];if(n&&r.buildStages[n]!==!0){const l=e.getBuildStage();e.setBuildStage(n),this.build(e),e.setBuildStage(l)}e.addNode(this),e.addChain(this);let o=null;const a=e.getBuildStage();if(a==="setup"){this.updateReference(e);const l=e.getNodeProperties(this);if(l.initialized!==!0){l.initialized=!0,l.outputNode=this.setup(e)||l.outputNode||null;for(const u of Object.values(l))if(u&&u.isNode===!0){if(u.parents===!0){const c=e.getNodeProperties(u);c.parents=c.parents||[],c.parents.push(this)}u.build(e)}}o=l.outputNode}else if(a==="analyze")this.analyze(e,t);else if(a==="generate")if(this.generate.length===1){const u=this.getNodeType(e),c=e.getDataFromNode(this);o=c.snippet,o===void 0?c.generated===void 0?(c.generated=!0,o=this.generate(e)||"",c.snippet=o):(console.warn("THREE.Node: Recursion detected.",this),o="/* Recursion detected. */"):c.flowCodes!==void 0&&e.context.nodeBlock!==void 0&&e.addFlowCodeHierarchy(this,e.context.nodeBlock),o=e.format(o,u,t)}else o=this.generate(e,t)||"";return e.removeChain(this),e.addSequentialNode(this),o}getSerializeChildren(){return Zf(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:r,index:n,childNode:o}of t)n!==void 0?(s[r]===void 0&&(s[r]=Number.isInteger(n)?[]:{}),s[r][n]=o.toJSON(e.meta).uuid):s[r]=o.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(e.inputNodes!==void 0){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const r=[];for(const n of e.inputNodes[s])r.push(t[n]);this[s]=r}else if(typeof e.inputNodes[s]=="object"){const r={};for(const n in e.inputNodes[s]){const o=e.inputNodes[s][n];r[n]=t[o]}this[s]=r}else{const r=e.inputNodes[s];this[s]=t[r]}}}toJSON(e){const{uuid:t,type:s}=this,r=e===void 0||typeof e=="string";r&&(e={textures:{},images:{},nodes:{}});let n=e.nodes[t];n===void 0&&(n={uuid:t,type:s,meta:e,metadata:{version:4.7,type:"Node",generator:"Node.toJSON"}},r!==!0&&(e.nodes[n.uuid]=n),this.serialize(n),delete n.meta);function o(a){const l=[];for(const u in a){const c=a[u];delete c.metadata,l.push(c)}return l}if(r){const a=o(e.textures),l=o(e.images),u=o(e.nodes);a.length>0&&(n.textures=a),l.length>0&&(n.images=l),u.length>0&&(n.nodes=u)}return n}}class su extends Ft{static get type(){return"ArrayElementNode"}constructor(e,t){super(),this.node=e,this.indexNode=t,this.isArrayElementNode=!0}getNodeType(e){return this.node.getElementType(e)}generate(e){const t=this.indexNode.getNodeType(e),s=this.node.build(e),r=this.indexNode.build(e,!e.isVector(t)&&e.isInteger(t)?t:"uint");return`${s}[ ${r} ]`}}class pk extends Ft{static get type(){return"ConvertNode"}constructor(e,t){super(),this.node=e,this.convertTo=t}getNodeType(e){const t=this.node.getNodeType(e);let s=null;for(const r of this.convertTo.split("|"))(s===null||e.getTypeLength(t)===e.getTypeLength(r))&&(s=r);return s}serialize(e){super.serialize(e),e.convertTo=this.convertTo}deserialize(e){super.deserialize(e),this.convertTo=e.convertTo}generate(e,t){const s=this.node,r=this.getNodeType(e),n=s.build(e,r);return e.format(n,r,t)}}class Ii extends Ft{static get type(){return"TempNode"}constructor(e=null){super(e),this.isTempNode=!0}hasDependencies(e){return e.getDataFromNode(this).usageCount>1}build(e,t){if(e.getBuildStage()==="generate"){const r=e.getVectorType(this.getNodeType(e,t)),n=e.getDataFromNode(this);if(n.propertyName!==void 0)return e.format(n.propertyName,r,t);if(r!=="void"&&t!=="void"&&this.hasDependencies(e)){const o=super.build(e,r),a=e.getVarFromNode(this,null,r),l=e.getPropertyName(a);return e.addLineFlowCode(`${l} = ${o}`,this),n.snippet=o,n.propertyName=l,e.format(n.propertyName,r,t)}}return super.build(e,t)}}class z4 extends Ii{static get type(){return"JoinNode"}constructor(e=[],t=null){super(t),this.nodes=e}getNodeType(e){return this.nodeType!==null?e.getVectorType(this.nodeType):e.getTypeFromLength(this.nodes.reduce((t,s)=>t+e.getTypeLength(s.getNodeType(e)),0))}generate(e,t){const s=this.getNodeType(e),r=e.getTypeLength(s),n=this.nodes,o=e.getComponentType(s),a=[];let l=0;for(const c of n){if(l>=r){console.error(`THREE.TSL: Length of parameters exceeds maximum length of function '${s}()' type.`);break}let d=c.getNodeType(e),h=e.getTypeLength(d),p;l+h>r&&(console.error(`THREE.TSL: Length of '${s}()' data exceeds maximum length of output type.`),h=r-l,d=e.getTypeFromLength(h)),l+=h,p=c.build(e,d);const f=e.getComponentType(d);f!==o&&(p=e.format(p,f,o)),a.push(p)}const u=`${e.getType(s)}( ${a.join(", ")} )`;return e.format(u,s,t)}}const V4=tu.join("");class ob extends Ft{static get type(){return"SplitNode"}constructor(e,t="x"){super(),this.node=e,this.components=t,this.isSplitNode=!0}getVectorLength(){let e=this.components.length;for(const t of this.components)e=Math.max(tu.indexOf(t)+1,e);return e}getComponentType(e){return e.getComponentType(this.node.getNodeType(e))}getNodeType(e){return e.getTypeFromLength(this.components.length,this.getComponentType(e))}generate(e,t){const s=this.node,r=e.getTypeLength(s.getNodeType(e));let n=null;if(r>1){let o=null;this.getVectorLength()>=r&&(o=e.getTypeFromLength(this.getVectorLength(),this.getComponentType(e)));const l=s.build(e,o);this.components.length===r&&this.components===V4.slice(0,this.components.length)?n=e.format(l,o,t):n=e.format(`${l}.${this.components}`,this.getNodeType(e),t)}else n=s.build(e,t);return n}serialize(e){super.serialize(e),e.components=this.components}deserialize(e){super.deserialize(e),this.components=e.components}}class U4 extends Ii{static get type(){return"SetNode"}constructor(e,t,s){super(),this.sourceNode=e,this.components=t,this.targetNode=s}getNodeType(e){return this.sourceNode.getNodeType(e)}generate(e){const{sourceNode:t,components:s,targetNode:r}=this,n=this.getNodeType(e),o=e.getComponentType(r.getNodeType(e)),a=e.getTypeFromLength(s.length,o),l=r.build(e,a),u=t.build(e,n),c=e.getTypeLength(n),d=[];for(let h=0;h<c;h++){const p=tu[h];p===s[0]?(d.push(l),h+=s.length-1):d.push(u+"."+p)}return`${e.getType(n)}( ${d.join(", ")} )`}}class G4 extends Ii{static get type(){return"FlipNode"}constructor(e,t){super(),this.sourceNode=e,this.components=t}getNodeType(e){return this.sourceNode.getNodeType(e)}generate(e){const{components:t,sourceNode:s}=this,r=this.getNodeType(e),n=s.build(e),o=e.getVarFromNode(this),a=e.getPropertyName(o);e.addLineFlowCode(a+" = "+n,this);const l=e.getTypeLength(r),u=[];let c=0;for(let d=0;d<l;d++){const h=tu[d];h===t[c]?(u.push("1.0 - "+(a+"."+h)),c++):u.push(a+"."+h)}return`${e.getType(r)}( ${u.join(", ")} )`}}class C0 extends Ft{static get type(){return"InputNode"}constructor(e,t=null){super(t),this.isInputNode=!0,this.value=e,this.precision=null}getNodeType(){return this.nodeType===null?Ia(this.value):this.nodeType}getInputType(e){return this.getNodeType(e)}setPrecision(e){return this.precision=e,this}serialize(e){super.serialize(e),e.value=this.value,this.value&&this.value.toArray&&(e.value=this.value.toArray()),e.valueType=Ia(this.value),e.nodeType=this.nodeType,e.valueType==="ArrayBuffer"&&(e.value=ck(e.value)),e.precision=this.precision}deserialize(e){super.deserialize(e),this.nodeType=e.nodeType,this.value=Array.isArray(e.value)?lk(e.valueType,...e.value):e.value,this.precision=e.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(e.value))}generate(){console.warn("Abstract function.")}}const h2=/float|u?int/;class Yn extends C0{static get type(){return"ConstNode"}constructor(e,t=null){super(e,t),this.isConstNode=!0}generateConst(e){return e.generateConst(this.getNodeType(e),this.value)}generate(e,t){const s=this.getNodeType(e);return h2.test(s)&&h2.test(t)?e.generateConst(t,this.value):e.format(this.generateConst(e),s,t)}}class j4 extends Ft{static get type(){return"MemberNode"}constructor(e,t){super(),this.node=e,this.property=t,this.isMemberNode=!0}getNodeType(e){return this.node.getMemberType(e,this.property)}generate(e){return this.node.build(e)+"."+this.property}}let Yl=null;const ec=new Map;function Le(i,e){if(ec.has(i)){console.warn(`THREE.TSL: Redefinition of method chaining '${i}'.`);return}if(typeof e!="function")throw new Error(`THREE.TSL: Node element ${i} is not a function`);ec.set(i,e)}const fk=i=>i.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),p2=i=>fk(i).split("").sort().join(""),mk={setup(i,e){const t=e.shift();return i(gh(t),...e)},get(i,e,t){if(typeof e=="string"&&i[e]===void 0){if(i.isStackNode!==!0&&e==="assign")return(...s)=>(Yl.assign(t,...s),t);if(ec.has(e)){const s=ec.get(e);return i.isStackNode?(...r)=>t.add(s(...r)):(...r)=>s(t,...r)}else{if(e==="self")return i;if(e.endsWith("Assign")&&ec.has(e.slice(0,e.length-6))){const s=ec.get(e.slice(0,e.length-6));return i.isStackNode?(...r)=>t.assign(r[0],s(...r)):(...r)=>t.assign(s(t,...r))}else{if(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0)return e=fk(e),De(new ob(t,e));if(/^set[XYZWRGBASTPQ]{1,4}$/.test(e)===!0)return e=p2(e.slice(3).toLowerCase()),s=>De(new U4(i,e,De(s)));if(/^flip[XYZWRGBASTPQ]{1,4}$/.test(e)===!0)return e=p2(e.slice(4).toLowerCase()),()=>De(new G4(De(i),e));if(e==="width"||e==="height"||e==="depth")return e==="width"?e="x":e==="height"?e="y":e==="depth"&&(e="z"),De(new ob(i,e));if(/^\d+$/.test(e)===!0)return De(new su(t,new Yn(Number(e),"uint")));if(/^get$/.test(e)===!0)return s=>De(new j4(t,s))}}}return Reflect.get(i,e,t)},set(i,e,t,s){return typeof e=="string"&&i[e]===void 0&&(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0||e==="width"||e==="height"||e==="depth"||/^\d+$/.test(e)===!0)?(s[e].assign(t),!0):Reflect.set(i,e,t,s)}},ky=new WeakMap,f2=new WeakMap,W4=function(i,e=null){const t=Ia(i);if(t==="node"){let s=ky.get(i);return s===void 0&&(s=new Proxy(i,mk),ky.set(i,s),ky.set(s,s)),s}else{if(e===null&&(t==="float"||t==="boolean")||t&&t!=="shader"&&t!=="string")return De(ab(i,e));if(t==="shader")return i.isFn?i:ge(i)}return i},H4=function(i,e=null){for(const t in i)i[t]=De(i[t],e);return i},q4=function(i,e=null){const t=i.length;for(let s=0;s<t;s++)i[s]=De(i[s],e);return i},K4=function(i,e=null,t=null,s=null){const r=c=>De(s!==null?Object.assign(c,s):c);let n,o=e,a,l;function u(c){let d;return o?d=/[a-z]/i.test(o)?o+"()":o:d=i.type,a!==void 0&&c.length<a?(console.error(`THREE.TSL: "${d}" parameter length is less than minimum required.`),c.concat(new Array(a-c.length).fill(0))):l!==void 0&&c.length>l?(console.error(`THREE.TSL: "${d}" parameter length exceeds limit.`),c.slice(0,l)):c}return e===null?n=(...c)=>r(new i(...Gl(u(c)))):t!==null?(t=De(t),n=(...c)=>r(new i(e,...Gl(u(c)),t))):n=(...c)=>r(new i(e,...Gl(u(c)))),n.setParameterLength=(...c)=>(c.length===1?a=l=c[0]:c.length===2&&([a,l]=c),n),n.setName=c=>(o=c,n),n},X4=function(i,...e){return De(new i(...Gl(e)))};class Y4 extends Ft{constructor(e,t){super(),this.shaderNode=e,this.inputNodes=t,this.isShaderCallNodeInternal=!0}getNodeType(e){return this.shaderNode.nodeType||this.getOutputNode(e).getNodeType(e)}getMemberType(e,t){return this.getOutputNode(e).getMemberType(e,t)}call(e){const{shaderNode:t,inputNodes:s}=this,r=e.getNodeProperties(t),n=e.getClosestSubBuild(t.subBuilds)||"",o=n||"default";if(r[o])return r[o];const a=e.subBuildFn;e.subBuildFn=n;let l=null;if(t.layout){let u=f2.get(e.constructor);u===void 0&&(u=new WeakMap,f2.set(e.constructor,u));let c=u.get(t);c===void 0&&(c=De(e.buildFunctionNode(t)),u.set(t,c)),e.addInclude(c),l=De(c.call(s))}else{const u=t.jsFunc,c=s!==null||u.length>1?u(s||[],e):u(e);l=De(c)}return e.subBuildFn=a,t.once&&(r[o]=l),l}setupOutput(e){return e.addStack(),e.stack.outputNode=this.call(e),e.removeStack()}getOutputNode(e){const t=e.getNodeProperties(this),s=e.getSubBuildOutput(this);return t[s]=t[s]||this.setupOutput(e),t[s].subBuild=e.getClosestSubBuild(this),t[s]}build(e,t=null){let s=null;const r=e.getBuildStage(),n=e.getNodeProperties(this),o=e.getSubBuildOutput(this),a=this.getOutputNode(e);if(r==="setup"){const l=e.getSubBuildProperty("initialized",this);if(n[l]!==!0&&(n[l]=!0,n[o]=this.getOutputNode(e),n[o].build(e),this.shaderNode.subBuilds))for(const u of e.chaining){const c=e.getDataFromNode(u,"any");c.subBuilds=c.subBuilds||new Set;for(const d of this.shaderNode.subBuilds)c.subBuilds.add(d)}s=n[o]}else r==="analyze"?a.build(e,t):r==="generate"&&(s=a.build(e,t)||"");return s}}class Q4 extends Ft{constructor(e,t){super(t),this.jsFunc=e,this.layout=null,this.global=!0,this.once=!1}setLayout(e){return this.layout=e,this}call(e=null){return gh(e),De(new Y4(this,e))}setup(){return this.call()}}const Z4=[!1,!0],J4=[0,1,2,3],eG=[-1,-2],gk=[.5,1.5,1/3,1e-6,1e6,Math.PI,Math.PI*2,1/Math.PI,2/Math.PI,1/(Math.PI*2),Math.PI/2],P0=new Map;for(const i of Z4)P0.set(i,new Yn(i));const N0=new Map;for(const i of J4)N0.set(i,new Yn(i,"uint"));const F0=new Map([...N0].map(i=>new Yn(i.value,"int")));for(const i of eG)F0.set(i,new Yn(i,"int"));const xm=new Map([...F0].map(i=>new Yn(i.value)));for(const i of gk)xm.set(i,new Yn(i));for(const i of gk)xm.set(-i,new Yn(-i));const bm={bool:P0,uint:N0,ints:F0,float:xm},m2=new Map([...P0,...xm]),ab=(i,e)=>m2.has(i)?m2.get(i):i.isNode===!0?i:new Yn(i,e),Di=function(i,e=null){return(...t)=>{if((t.length===0||!["bool","float","int","uint"].includes(i)&&t.every(r=>typeof r!="object"))&&(t=[lk(i,...t)]),t.length===1&&e!==null&&e.has(t[0]))return De(e.get(t[0]));if(t.length===1){const r=ab(t[0],i);return r.nodeType===i?De(r):De(new pk(r,i))}const s=t.map(r=>ab(r));return De(new z4(s,i))}},rh=i=>typeof i=="object"&&i!==null?i.value:i,_k=i=>i!=null?i.nodeType||i.convertTo||(typeof i=="string"?i:null):null;function tc(i,e){return new Proxy(new Q4(i,e),mk)}const De=(i,e=null)=>W4(i,e),gh=(i,e=null)=>new H4(i,e),Gl=(i,e=null)=>new q4(i,e),ze=(...i)=>new K4(...i),ot=(...i)=>new X4(...i);let tG=0;const ge=(i,e=null)=>{let t=null;e!==null&&(typeof e=="object"?t=e.return:(typeof e=="string"?t=e:console.error("THREE.TSL: Invalid layout type."),e=null));const s=new tc(i,t),r=(...n)=>{let o;gh(n),n[0]&&(n[0].isNode||Object.getPrototypeOf(n[0])!==Object.prototype)?o=[...n]:o=n[0];const l=s.call(o);return t==="void"&&l.toStack(),l};if(r.shaderNode=s,r.id=s.id,r.isFn=!0,r.getNodeType=(...n)=>s.getNodeType(...n),r.getCacheKey=(...n)=>s.getCacheKey(...n),r.setLayout=n=>(s.setLayout(n),r),r.once=(n=null)=>(s.once=!0,s.subBuilds=n,r),e!==null){if(typeof e.inputs!="object"){const n={name:"fn"+tG++,type:t,inputs:[]};for(const o in e)o!=="return"&&n.inputs.push({name:o,type:e[o]});e=n}r.setLayout(e)}return r},nh=i=>{Yl=i},R0=()=>Yl,Ht=(...i)=>Yl.If(...i),sG=(...i)=>Yl.Switch(...i);function wm(i){return Yl&&Yl.add(i),i}Le("toStack",wm);const yk=new Di("color"),Y=new Di("float",bm.float),ne=new Di("int",bm.ints),ht=new Di("uint",bm.uint),bo=new Di("bool",bm.bool),Ge=new Di("vec2"),Vi=new Di("ivec2"),xk=new Di("uvec2"),bk=new Di("bvec2"),pe=new Di("vec3"),wk=new Di("ivec3"),Sc=new Di("uvec3"),I0=new Di("bvec3"),St=new Di("vec4"),Mk=new Di("ivec4"),Tk=new Di("uvec4"),vk=new Di("bvec4"),Mm=new Di("mat2"),cr=new Di("mat3"),jl=new Di("mat4"),iG=(i="")=>De(new Yn(i,"string")),rG=i=>De(new Yn(i,"ArrayBuffer"));Le("toColor",yk);Le("toFloat",Y);Le("toInt",ne);Le("toUint",ht);Le("toBool",bo);Le("toVec2",Ge);Le("toIVec2",Vi);Le("toUVec2",xk);Le("toBVec2",bk);Le("toVec3",pe);Le("toIVec3",wk);Le("toUVec3",Sc);Le("toBVec3",I0);Le("toVec4",St);Le("toIVec4",Mk);Le("toUVec4",Tk);Le("toBVec4",vk);Le("toMat2",Mm);Le("toMat3",cr);Le("toMat4",jl);const Sk=ze(su).setParameterLength(2),Ek=(i,e)=>De(new pk(De(i),e)),nG=(i,e)=>De(new ob(De(i),e));Le("element",Sk);Le("convert",Ek);const oG=i=>(console.warn("THREE.TSL: append() has been renamed to Stack()."),wm(i));Le("append",i=>(console.warn("THREE.TSL: .append() has been renamed to .toStack()."),wm(i)));class Ps extends Ft{static get type(){return"PropertyNode"}constructor(e,t=null,s=!1){super(e),this.name=t,this.varying=s,this.isPropertyNode=!0,this.global=!0}getHash(e){return this.name||super.getHash(e)}generate(e){let t;return this.varying===!0?(t=e.getVaryingFromNode(this,this.name),t.needsInterpolation=!0):t=e.getVarFromNode(this,this.name),e.getPropertyName(t)}}const Qo=(i,e)=>De(new Ps(i,e)),oh=(i,e)=>De(new Ps(i,e,!0)),ws=ot(Ps,"vec4","DiffuseColor"),lb=ot(Ps,"vec3","EmissiveColor"),ho=ot(Ps,"float","Roughness"),ah=ot(Ps,"float","Metalness"),em=ot(Ps,"float","Clearcoat"),lh=ot(Ps,"float","ClearcoatRoughness"),$l=ot(Ps,"vec3","Sheen"),Tm=ot(Ps,"float","SheenRoughness"),vm=ot(Ps,"float","Iridescence"),D0=ot(Ps,"float","IridescenceIOR"),k0=ot(Ps,"float","IridescenceThickness"),tm=ot(Ps,"float","AlphaT"),Ca=ot(Ps,"float","Anisotropy"),Wd=ot(Ps,"vec3","AnisotropyT"),Wl=ot(Ps,"vec3","AnisotropyB"),Er=ot(Ps,"color","SpecularColor"),uh=ot(Ps,"float","SpecularF90"),sm=ot(Ps,"float","Shininess"),lc=ot(Ps,"vec4","Output"),Af=ot(Ps,"float","dashSize"),ub=ot(Ps,"float","gapSize"),aG=ot(Ps,"float","pointWidth"),Hd=ot(Ps,"float","IOR"),im=ot(Ps,"float","Transmission"),L0=ot(Ps,"float","Thickness"),B0=ot(Ps,"float","AttenuationDistance"),O0=ot(Ps,"color","AttenuationColor"),$0=ot(Ps,"float","Dispersion");class Ak extends Ft{static get type(){return"UniformGroupNode"}constructor(e,t=!1,s=1){super("string"),this.name=e,this.shared=t,this.order=s,this.isUniformGroup=!0}serialize(e){super.serialize(e),e.name=this.name,e.version=this.version,e.shared=this.shared}deserialize(e){super.deserialize(e),this.name=e.name,this.version=e.version,this.shared=e.shared}}const Ck=i=>new Ak(i),Sm=(i,e=0)=>new Ak(i,!0,e),Pk=Sm("frame"),Rt=Sm("render"),z0=Ck("object");class _h extends C0{static get type(){return"UniformNode"}constructor(e,t=null){super(e,t),this.isUniformNode=!0,this.name="",this.groupNode=z0}label(e){return this.name=e,this}setGroup(e){return this.groupNode=e,this}getGroup(){return this.groupNode}getUniformHash(e){return this.getHash(e)}onUpdate(e,t){const s=this.getSelf();return e=e.bind(s),super.onUpdate(r=>{const n=e(r,s);n!==void 0&&(this.value=n)},t)}generate(e,t){const s=this.getNodeType(e),r=this.getUniformHash(e);let n=e.getNodeFromHash(r);n===void 0&&(e.setHashNode(this,r),n=this);const o=n.getInputType(e),a=e.getUniformFromNode(n,o,e.shaderStage,this.name||e.context.label),l=e.getPropertyName(a);return e.context.label!==void 0&&delete e.context.label,e.format(l,s,t)}}const Et=(i,e)=>{const t=_k(e||i),s=i&&i.isNode===!0?i.node&&i.node.value||i.value:i;return De(new _h(s,t))};class g2 extends Ii{static get type(){return"ArrayNode"}constructor(e,t,s=null){super(e),this.count=t,this.values=s,this.isArrayNode=!0}getNodeType(e){return this.nodeType===null&&(this.nodeType=this.values[0].getNodeType(e)),this.nodeType}getElementType(e){return this.getNodeType(e)}generate(e){const t=this.getNodeType(e);return e.generateArray(t,this.count,this.values)}}const Nk=(...i)=>{let e;if(i.length===1){const t=i[0];e=new g2(null,t.length,t)}else{const t=i[0],s=i[1];e=new g2(t,s)}return De(e)};Le("toArray",(i,e)=>Nk(Array(e).fill(i)));class lG extends Ii{static get type(){return"AssignNode"}constructor(e,t){super(),this.targetNode=e,this.sourceNode=t,this.isAssignNode=!0}hasDependencies(){return!1}getNodeType(e,t){return t!=="void"?this.targetNode.getNodeType(e):"void"}needsSplitAssign(e){const{targetNode:t}=this;if(e.isAvailable("swizzleAssign")===!1&&t.isSplitNode&&t.components.length>1){const s=e.getTypeLength(t.node.getNodeType(e));return tu.join("").slice(0,s)!==t.components}return!1}setup(e){const{targetNode:t,sourceNode:s}=this,r=e.getNodeProperties(this);r.sourceNode=s,r.targetNode=t.context({assign:!0})}generate(e,t){const{targetNode:s,sourceNode:r}=e.getNodeProperties(this),n=this.needsSplitAssign(e),o=s.getNodeType(e),a=s.build(e),l=r.build(e,o),u=r.getNodeType(e),c=e.getDataFromNode(this);let d;if(c.initialized===!0)t!=="void"&&(d=a);else if(n){const h=e.getVarFromNode(this,null,o),p=e.getPropertyName(h);e.addLineFlowCode(`${p} = ${l}`,this);const f=s.node,x=f.node.context({assign:!0}).build(e);for(let g=0;g<f.components.length;g++){const _=f.components[g];e.addLineFlowCode(`${x}.${_} = ${p}[ ${g} ]`,this)}t!=="void"&&(d=a)}else d=`${a} = ${l}`,(t==="void"||u==="void")&&(e.addLineFlowCode(d,this),t!=="void"&&(d=a));return c.initialized=!0,e.format(d,o,t)}}const Fk=ze(lG).setParameterLength(2);Le("assign",Fk);class uG extends Ii{static get type(){return"FunctionCallNode"}constructor(e=null,t={}){super(),this.functionNode=e,this.parameters=t}setParameters(e){return this.parameters=e,this}getParameters(){return this.parameters}getNodeType(e){return this.functionNode.getNodeType(e)}generate(e){const t=[],s=this.functionNode,r=s.getInputs(e),n=this.parameters,o=(l,u)=>{const c=u.type,d=c==="pointer";let h;return d?h="&"+l.build(e):h=l.build(e,c),h};if(Array.isArray(n)){if(n.length>r.length)console.error("THREE.TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'."),n.length=r.length;else if(n.length<r.length)for(console.error("THREE.TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'.");n.length<r.length;)n.push(Y(0));for(let l=0;l<n.length;l++)t.push(o(n[l],r[l]))}else for(const l of r){const u=n[l.name];u!==void 0?t.push(o(u,l)):(console.error(`THREE.TSL: Input '${l.name}' not found in 'Fn()'.`),t.push(o(Y(0),l)))}return`${s.build(e,"property")}( ${t.join(", ")} )`}}const Rk=(i,...e)=>(e=e.length>1||e[0]&&e[0].isNode===!0?Gl(e):gh(e[0]),De(new uG(De(i),e)));Le("call",Rk);const cG={"==":"equal","!=":"notEqual","<":"lessThan",">":"greaterThan","<=":"lessThanEqual",">=":"greaterThanEqual","%":"mod"};class ei extends Ii{static get type(){return"OperatorNode"}constructor(e,t,s,...r){if(super(),r.length>0){let n=new ei(e,t,s);for(let o=0;o<r.length-1;o++)n=new ei(e,n,r[o]);t=n,s=r[r.length-1]}this.op=e,this.aNode=t,this.bNode=s,this.isOperatorNode=!0}getOperatorMethod(e,t){return e.getMethod(cG[this.op],t)}getNodeType(e){const t=this.op,s=this.aNode,r=this.bNode,n=s.getNodeType(e),o=r?r.getNodeType(e):null;if(n==="void"||o==="void")return"void";if(t==="%")return n;if(t==="~"||t==="&"||t==="|"||t==="^"||t===">>"||t==="<<")return e.getIntegerType(n);if(t==="!"||t==="&&"||t==="||"||t==="^^")return"bool";if(t==="=="||t==="!="||t==="<"||t===">"||t==="<="||t===">="){const a=Math.max(e.getTypeLength(n),e.getTypeLength(o));return a>1?`bvec${a}`:"bool"}else{if(e.isMatrix(n)){if(o==="float")return n;if(e.isVector(o))return e.getVectorFromMatrix(n);if(e.isMatrix(o))return n}else if(e.isMatrix(o)){if(n==="float")return o;if(e.isVector(n))return e.getVectorFromMatrix(o)}return e.getTypeLength(o)>e.getTypeLength(n)?o:n}}generate(e,t){const s=this.op,{aNode:r,bNode:n}=this,o=this.getNodeType(e);let a=null,l=null;o!=="void"?(a=r.getNodeType(e),l=n?n.getNodeType(e):null,s==="<"||s===">"||s==="<="||s===">="||s==="=="||s==="!="?e.isVector(a)?l=a:e.isVector(l)?a=l:a!==l&&(a=l="float"):s===">>"||s==="<<"?(a=o,l=e.changeComponentType(l,"uint")):s==="%"?(a=o,l=e.isInteger(a)&&e.isInteger(l)?l:a):e.isMatrix(a)?l==="float"?l="float":e.isVector(l)?l=e.getVectorFromMatrix(a):e.isMatrix(l)||(a=l=o):e.isMatrix(l)?a==="float"?a="float":e.isVector(a)?a=e.getVectorFromMatrix(l):a=l=o:a=l=o):a=l=o;const u=r.build(e,a),c=n?n.build(e,l):null,d=e.getFunctionOperator(s);if(t!=="void"){const h=e.renderer.coordinateSystem===Pr;if(s==="=="||s==="!="||s==="<"||s===">"||s==="<="||s===">=")return h?e.isVector(a)?e.format(`${this.getOperatorMethod(e,t)}( ${u}, ${c} )`,o,t):e.format(`( ${u} ${s} ${c} )`,o,t):e.format(`( ${u} ${s} ${c} )`,o,t);if(s==="%")return e.isInteger(l)?e.format(`( ${u} % ${c} )`,o,t):e.format(`${this.getOperatorMethod(e,o)}( ${u}, ${c} )`,o,t);if(s==="!"||s==="~")return e.format(`(${s}${u})`,a,t);if(d)return e.format(`${d}( ${u}, ${c} )`,o,t);if(e.isMatrix(a)&&l==="float")return e.format(`( ${c} ${s} ${u} )`,o,t);if(a==="float"&&e.isMatrix(l))return e.format(`${u} ${s} ${c}`,o,t);{let p=`( ${u} ${s} ${c} )`;return!h&&o==="bool"&&e.isVector(a)&&e.isVector(l)&&(p=`all${p}`),e.format(p,o,t)}}else if(a!=="void")return d?e.format(`${d}( ${u}, ${c} )`,o,t):e.isMatrix(a)&&l==="float"?e.format(`${c} ${s} ${u}`,o,t):e.format(`${u} ${s} ${c}`,o,t)}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}const Ri=ze(ei,"+").setParameterLength(2,1/0).setName("add"),us=ze(ei,"-").setParameterLength(2,1/0).setName("sub"),Wt=ze(ei,"*").setParameterLength(2,1/0).setName("mul"),wn=ze(ei,"/").setParameterLength(2,1/0).setName("div"),Em=ze(ei,"%").setParameterLength(2).setName("mod"),V0=ze(ei,"==").setParameterLength(2).setName("equal"),Ik=ze(ei,"!=").setParameterLength(2).setName("notEqual"),Dk=ze(ei,"<").setParameterLength(2).setName("lessThan"),U0=ze(ei,">").setParameterLength(2).setName("greaterThan"),kk=ze(ei,"<=").setParameterLength(2).setName("lessThanEqual"),Lk=ze(ei,">=").setParameterLength(2).setName("greaterThanEqual"),Bk=ze(ei,"&&").setParameterLength(2,1/0).setName("and"),Ok=ze(ei,"||").setParameterLength(2,1/0).setName("or"),$k=ze(ei,"!").setParameterLength(1).setName("not"),zk=ze(ei,"^^").setParameterLength(2).setName("xor"),Vk=ze(ei,"&").setParameterLength(2).setName("bitAnd"),Uk=ze(ei,"~").setParameterLength(2).setName("bitNot"),Gk=ze(ei,"|").setParameterLength(2).setName("bitOr"),jk=ze(ei,"^").setParameterLength(2).setName("bitXor"),Wk=ze(ei,"<<").setParameterLength(2).setName("shiftLeft"),Hk=ze(ei,">>").setParameterLength(2).setName("shiftRight"),qk=ge(([i])=>(i.addAssign(1),i)),Kk=ge(([i])=>(i.subAssign(1),i)),Xk=ge(([i])=>{const e=ne(i).toConst();return i.addAssign(1),e}),Yk=ge(([i])=>{const e=ne(i).toConst();return i.subAssign(1),e});Le("add",Ri);Le("sub",us);Le("mul",Wt);Le("div",wn);Le("mod",Em);Le("equal",V0);Le("notEqual",Ik);Le("lessThan",Dk);Le("greaterThan",U0);Le("lessThanEqual",kk);Le("greaterThanEqual",Lk);Le("and",Bk);Le("or",Ok);Le("not",$k);Le("xor",zk);Le("bitAnd",Vk);Le("bitNot",Uk);Le("bitOr",Gk);Le("bitXor",jk);Le("shiftLeft",Wk);Le("shiftRight",Hk);Le("incrementBefore",qk);Le("decrementBefore",Kk);Le("increment",Xk);Le("decrement",Yk);const Qk=(i,e)=>(console.warn('THREE.TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.'),Em(ne(i),ne(e)));Le("modInt",Qk);class be extends Ii{static get type(){return"MathNode"}constructor(e,t,s=null,r=null){if(super(),(e===be.MAX||e===be.MIN)&&arguments.length>3){let n=new be(e,t,s);for(let o=2;o<arguments.length-1;o++)n=new be(e,n,arguments[o]);t=n,s=arguments[arguments.length-1],r=null}this.method=e,this.aNode=t,this.bNode=s,this.cNode=r,this.isMathNode=!0}getInputType(e){const t=this.aNode.getNodeType(e),s=this.bNode?this.bNode.getNodeType(e):null,r=this.cNode?this.cNode.getNodeType(e):null,n=e.isMatrix(t)?0:e.getTypeLength(t),o=e.isMatrix(s)?0:e.getTypeLength(s),a=e.isMatrix(r)?0:e.getTypeLength(r);return n>o&&n>a?t:o>a?s:a>n?r:t}getNodeType(e){const t=this.method;return t===be.LENGTH||t===be.DISTANCE||t===be.DOT?"float":t===be.CROSS?"vec3":t===be.ALL||t===be.ANY?"bool":t===be.EQUALS?e.changeComponentType(this.aNode.getNodeType(e),"bool"):this.getInputType(e)}setup(e){const{aNode:t,bNode:s,method:r}=this;let n=null;if(r===be.ONE_MINUS)n=us(1,t);else if(r===be.RECIPROCAL)n=wn(1,t);else if(r===be.DIFFERENCE)n=Us(us(t,s));else if(r===be.TRANSFORM_DIRECTION){let o=t,a=s;e.isMatrix(o.getNodeType(e))?a=St(pe(a),0):o=St(pe(o),0);const l=Wt(o,a).xyz;n=sa(l)}return n!==null?n:super.setup(e)}generate(e,t){if(e.getNodeProperties(this).outputNode)return super.generate(e,t);let r=this.method;const n=this.getNodeType(e),o=this.getInputType(e),a=this.aNode,l=this.bNode,u=this.cNode,c=e.renderer.coordinateSystem;if(r===be.NEGATE)return e.format("( - "+a.build(e,o)+" )",n,t);{const d=[];return r===be.CROSS?d.push(a.build(e,n),l.build(e,n)):c===Pr&&r===be.STEP?d.push(a.build(e,e.getTypeLength(a.getNodeType(e))===1?"float":o),l.build(e,o)):c===Pr&&(r===be.MIN||r===be.MAX)?d.push(a.build(e,o),l.build(e,e.getTypeLength(l.getNodeType(e))===1?"float":o)):r===be.REFRACT?d.push(a.build(e,o),l.build(e,o),u.build(e,"float")):r===be.MIX?d.push(a.build(e,o),l.build(e,o),u.build(e,e.getTypeLength(u.getNodeType(e))===1?"float":o)):(c===xo&&r===be.ATAN&&l!==null&&(r="atan2"),e.shaderStage!=="fragment"&&(r===be.DFDX||r===be.DFDY)&&(console.warn(`THREE.TSL: '${r}' is not supported in the ${e.shaderStage} stage.`),r="/*"+r+"*/"),d.push(a.build(e,o)),l!==null&&d.push(l.build(e,o)),u!==null&&d.push(u.build(e,o))),e.format(`${e.getMethod(r,n)}( ${d.join(", ")} )`,n,t)}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}be.ALL="all";be.ANY="any";be.RADIANS="radians";be.DEGREES="degrees";be.EXP="exp";be.EXP2="exp2";be.LOG="log";be.LOG2="log2";be.SQRT="sqrt";be.INVERSE_SQRT="inversesqrt";be.FLOOR="floor";be.CEIL="ceil";be.NORMALIZE="normalize";be.FRACT="fract";be.SIN="sin";be.COS="cos";be.TAN="tan";be.ASIN="asin";be.ACOS="acos";be.ATAN="atan";be.ABS="abs";be.SIGN="sign";be.LENGTH="length";be.NEGATE="negate";be.ONE_MINUS="oneMinus";be.DFDX="dFdx";be.DFDY="dFdy";be.ROUND="round";be.RECIPROCAL="reciprocal";be.TRUNC="trunc";be.FWIDTH="fwidth";be.TRANSPOSE="transpose";be.BITCAST="bitcast";be.EQUALS="equals";be.MIN="min";be.MAX="max";be.STEP="step";be.REFLECT="reflect";be.DISTANCE="distance";be.DIFFERENCE="difference";be.DOT="dot";be.CROSS="cross";be.POW="pow";be.TRANSFORM_DIRECTION="transformDirection";be.MIX="mix";be.CLAMP="clamp";be.REFRACT="refract";be.SMOOTHSTEP="smoothstep";be.FACEFORWARD="faceforward";const Zk=Y(1e-6),dG=Y(1e6),rm=Y(Math.PI),hG=Y(Math.PI*2),Jk=ze(be,be.ALL).setParameterLength(1),eL=ze(be,be.ANY).setParameterLength(1),tL=ze(be,be.RADIANS).setParameterLength(1),sL=ze(be,be.DEGREES).setParameterLength(1),G0=ze(be,be.EXP).setParameterLength(1),xc=ze(be,be.EXP2).setParameterLength(1),Am=ze(be,be.LOG).setParameterLength(1),mo=ze(be,be.LOG2).setParameterLength(1),Eo=ze(be,be.SQRT).setParameterLength(1),j0=ze(be,be.INVERSE_SQRT).setParameterLength(1),go=ze(be,be.FLOOR).setParameterLength(1),Cm=ze(be,be.CEIL).setParameterLength(1),sa=ze(be,be.NORMALIZE).setParameterLength(1),la=ze(be,be.FRACT).setParameterLength(1),qr=ze(be,be.SIN).setParameterLength(1),zo=ze(be,be.COS).setParameterLength(1),iL=ze(be,be.TAN).setParameterLength(1),rL=ze(be,be.ASIN).setParameterLength(1),W0=ze(be,be.ACOS).setParameterLength(1),H0=ze(be,be.ATAN).setParameterLength(1,2),Us=ze(be,be.ABS).setParameterLength(1),ch=ze(be,be.SIGN).setParameterLength(1),_o=ze(be,be.LENGTH).setParameterLength(1),nL=ze(be,be.NEGATE).setParameterLength(1),oL=ze(be,be.ONE_MINUS).setParameterLength(1),q0=ze(be,be.DFDX).setParameterLength(1),K0=ze(be,be.DFDY).setParameterLength(1),aL=ze(be,be.ROUND).setParameterLength(1),lL=ze(be,be.RECIPROCAL).setParameterLength(1),X0=ze(be,be.TRUNC).setParameterLength(1),uL=ze(be,be.FWIDTH).setParameterLength(1),cL=ze(be,be.TRANSPOSE).setParameterLength(1),pG=ze(be,be.BITCAST).setParameterLength(2),dL=(i,e)=>(console.warn('THREE.TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"'),V0(i,e)),Ir=ze(be,be.MIN).setParameterLength(2,1/0),ni=ze(be,be.MAX).setParameterLength(2,1/0),Pm=ze(be,be.STEP).setParameterLength(2),hL=ze(be,be.REFLECT).setParameterLength(2),pL=ze(be,be.DISTANCE).setParameterLength(2),fL=ze(be,be.DIFFERENCE).setParameterLength(2),Ua=ze(be,be.DOT).setParameterLength(2),Nm=ze(be,be.CROSS).setParameterLength(2),jn=ze(be,be.POW).setParameterLength(2),Y0=ze(be,be.POW,2).setParameterLength(1),mL=ze(be,be.POW,3).setParameterLength(1),gL=ze(be,be.POW,4).setParameterLength(1),_L=ze(be,be.TRANSFORM_DIRECTION).setParameterLength(2),yL=i=>Wt(ch(i),jn(Us(i),1/3)),Q0=i=>Ua(i,i),Cs=ze(be,be.MIX).setParameterLength(3),wo=(i,e=0,t=1)=>De(new be(be.CLAMP,De(i),De(e),De(t))),Z0=i=>wo(i),J0=ze(be,be.REFRACT).setParameterLength(3),Mo=ze(be,be.SMOOTHSTEP).setParameterLength(3),ew=ze(be,be.FACEFORWARD).setParameterLength(3),xL=ge(([i])=>{const s=43758.5453,r=Ua(i.xy,Ge(12.9898,78.233)),n=Em(r,rm);return la(qr(n).mul(s))}),bL=(i,e,t)=>Cs(e,t,i),wL=(i,e,t)=>Mo(e,t,i),ML=(i,e)=>Pm(e,i),TL=(i,e)=>(console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.'),H0(i,e)),fG=ew,mG=j0;Le("all",Jk);Le("any",eL);Le("equals",dL);Le("radians",tL);Le("degrees",sL);Le("exp",G0);Le("exp2",xc);Le("log",Am);Le("log2",mo);Le("sqrt",Eo);Le("inverseSqrt",j0);Le("floor",go);Le("ceil",Cm);Le("normalize",sa);Le("fract",la);Le("sin",qr);Le("cos",zo);Le("tan",iL);Le("asin",rL);Le("acos",W0);Le("atan",H0);Le("abs",Us);Le("sign",ch);Le("length",_o);Le("lengthSq",Q0);Le("negate",nL);Le("oneMinus",oL);Le("dFdx",q0);Le("dFdy",K0);Le("round",aL);Le("reciprocal",lL);Le("trunc",X0);Le("fwidth",uL);Le("atan2",TL);Le("min",Ir);Le("max",ni);Le("step",ML);Le("reflect",hL);Le("distance",pL);Le("dot",Ua);Le("cross",Nm);Le("pow",jn);Le("pow2",Y0);Le("pow3",mL);Le("pow4",gL);Le("transformDirection",_L);Le("mix",bL);Le("clamp",wo);Le("refract",J0);Le("smoothstep",wL);Le("faceForward",ew);Le("difference",fL);Le("saturate",Z0);Le("cbrt",yL);Le("transpose",cL);Le("rand",xL);class gG extends Ft{static get type(){return"ConditionalNode"}constructor(e,t,s=null){super(),this.condNode=e,this.ifNode=t,this.elseNode=s}getNodeType(e){const{ifNode:t,elseNode:s}=e.getNodeProperties(this);if(t===void 0)return this.setup(e),this.getNodeType(e);const r=t.getNodeType(e);if(s!==null){const n=s.getNodeType(e);if(e.getTypeLength(n)>e.getTypeLength(r))return n}return r}setup(e){const t=this.condNode.cache(),s=this.ifNode.cache(),r=this.elseNode?this.elseNode.cache():null,n=e.context.nodeBlock;e.getDataFromNode(s).parentNodeBlock=n,r!==null&&(e.getDataFromNode(r).parentNodeBlock=n);const o=e.getNodeProperties(this);o.condNode=t,o.ifNode=s.context({nodeBlock:s}),o.elseNode=r?r.context({nodeBlock:r}):null}generate(e,t){const s=this.getNodeType(e),r=e.getDataFromNode(this);if(r.nodeProperty!==void 0)return r.nodeProperty;const{condNode:n,ifNode:o,elseNode:a}=e.getNodeProperties(this),l=e.currentFunctionNode,u=t!=="void",c=u?Qo(s).build(e):"";r.nodeProperty=c;const d=n.build(e,"bool");e.addFlowCode(`
${e.tab}if ( ${d} ) {

`).addFlowTab();let h=o.build(e,s);if(h&&(u?h=c+" = "+h+";":(h="return "+h+";",l===null&&(console.warn("THREE.TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values."),h="// "+h))),e.removeFlowTab().addFlowCode(e.tab+"	"+h+`

`+e.tab+"}"),a!==null){e.addFlowCode(` else {

`).addFlowTab();let p=a.build(e,s);p&&(u?p=c+" = "+p+";":(p="return "+p+";",l===null&&(console.warn("THREE.TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values."),p="// "+p))),e.removeFlowTab().addFlowCode(e.tab+"	"+p+`

`+e.tab+`}

`)}else e.addFlowCode(`

`);return e.format(c,s,t)}}const Xi=ze(gG).setParameterLength(2,3);Le("select",Xi);class vL extends Ft{static get type(){return"ContextNode"}constructor(e,t={}){super(),this.isContextNode=!0,this.node=e,this.value=t}getScope(){return this.node.getScope()}getNodeType(e){return this.node.getNodeType(e)}analyze(e){const t=e.getContext();e.setContext({...e.context,...this.value}),this.node.build(e),e.setContext(t)}setup(e){const t=e.getContext();e.setContext({...e.context,...this.value}),this.node.build(e),e.setContext(t)}generate(e,t){const s=e.getContext();e.setContext({...e.context,...this.value});const r=this.node.build(e,t);return e.setContext(s),r}}const Fm=ze(vL).setParameterLength(1,2),SL=(i,e)=>Fm(i,{label:e});Le("context",Fm);Le("label",SL);class Cf extends Ft{static get type(){return"VarNode"}constructor(e,t=null,s=!1){super(),this.node=e,this.name=t,this.global=!0,this.isVarNode=!0,this.readOnly=s,this.parents=!0}getMemberType(e,t){return this.node.getMemberType(e,t)}getElementType(e){return this.node.getElementType(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{node:t,name:s,readOnly:r}=this,{renderer:n}=e,o=n.backend.isWebGPUBackend===!0;let a=!1,l=!1;r&&(a=e.isDeterministic(t),l=o?r:a);const u=e.getVectorType(this.getNodeType(e)),c=t.build(e,u),d=e.getVarFromNode(this,s,u,void 0,l),h=e.getPropertyName(d);let p=h;if(l)if(o)p=a?`const ${h}`:`let ${h}`;else{const f=e.getArrayCount(t);p=`const ${e.getVar(d.type,h,f)}`}return e.addLineFlowCode(`${p} = ${c}`,this),h}}const tw=ze(Cf),EL=(i,e=null)=>tw(i,e).toStack(),AL=(i,e=null)=>tw(i,e,!0).toStack();Le("toVar",EL);Le("toConst",AL);const CL=i=>(console.warn('TSL: "temp( node )" is deprecated. Use "Var( node )" or "node.toVar()" instead.'),tw(i));Le("temp",CL);class _G extends Ft{static get type(){return"SubBuild"}constructor(e,t,s=null){super(s),this.node=e,this.name=t,this.isSubBuildNode=!0}getNodeType(e){if(this.nodeType!==null)return this.nodeType;e.addSubBuild(this.name);const t=this.node.getNodeType(e);return e.removeSubBuild(),t}build(e,...t){e.addSubBuild(this.name);const s=this.node.build(e,...t);return e.removeSubBuild(),s}}const uc=(i,e,t=null)=>De(new _G(De(i),e,t));class yG extends Ft{static get type(){return"VaryingNode"}constructor(e,t=null){super(),this.node=e,this.name=t,this.isVaryingNode=!0,this.interpolationType=null,this.interpolationSampling=null,this.global=!0}setInterpolation(e,t=null){return this.interpolationType=e,this.interpolationSampling=t,this}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}setupVarying(e){const t=e.getNodeProperties(this);let s=t.varying;if(s===void 0){const r=this.name,n=this.getNodeType(e),o=this.interpolationType,a=this.interpolationSampling;t.varying=s=e.getVaryingFromNode(this,r,n,o,a),t.node=uc(this.node,"VERTEX")}return s.needsInterpolation||(s.needsInterpolation=e.shaderStage==="fragment"),s}setup(e){this.setupVarying(e),e.flowNodeFromShaderStage(Ld.VERTEX,this.node)}analyze(e){this.setupVarying(e),e.flowNodeFromShaderStage(Ld.VERTEX,this.node)}generate(e){const t=e.getSubBuildProperty("property",e.currentStack),s=e.getNodeProperties(this),r=this.setupVarying(e);if(s[t]===void 0){const n=this.getNodeType(e),o=e.getPropertyName(r,Ld.VERTEX);e.flowNodeFromShaderStage(Ld.VERTEX,s.node,n,o),s[t]=o}return e.getPropertyName(r)}}const Ao=ze(yG).setParameterLength(1,2),PL=i=>Ao(i);Le("toVarying",Ao);Le("toVertexStage",PL);Le("varying",(...i)=>(console.warn("THREE.TSL: .varying() has been renamed to .toVarying()."),Ao(...i)));Le("vertexStage",(...i)=>(console.warn("THREE.TSL: .vertexStage() has been renamed to .toVertexStage()."),Ao(...i)));const NL=ge(([i])=>{const e=i.mul(.9478672986).add(.0521327014).pow(2.4),t=i.mul(.0773993808),s=i.lessThanEqual(.04045);return Cs(e,t,s)}).setLayout({name:"sRGBTransferEOTF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),FL=ge(([i])=>{const e=i.pow(.41666).mul(1.055).sub(.055),t=i.mul(12.92),s=i.lessThanEqual(.0031308);return Cs(e,t,s)}).setLayout({name:"sRGBTransferOETF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),sw="WorkingColorSpace",xG="OutputColorSpace";class iw extends Ii{static get type(){return"ColorSpaceNode"}constructor(e,t,s){super("vec4"),this.colorNode=e,this.source=t,this.target=s}resolveColorSpace(e,t){return t===sw?Ls.workingColorSpace:t===xG?e.context.outputColorSpace||e.renderer.outputColorSpace:t}setup(e){const{colorNode:t}=this,s=this.resolveColorSpace(e,this.source),r=this.resolveColorSpace(e,this.target);let n=t;return Ls.enabled===!1||s===r||!s||!r||(Ls.getTransfer(s)===jt&&(n=St(NL(n.rgb),n.a)),Ls.getPrimaries(s)!==Ls.getPrimaries(r)&&(n=St(cr(Ls._getMatrix(new kr,s,r)).mul(n.rgb),n.a)),Ls.getTransfer(r)===jt&&(n=St(FL(n.rgb),n.a))),n}}const RL=(i,e)=>De(new iw(De(i),sw,e)),Rm=(i,e)=>De(new iw(De(i),e,sw)),bG=(i,e,t)=>De(new iw(De(i),e,t));Le("workingToColorSpace",RL);Le("colorSpaceToWorking",Rm);let wG=class extends su{static get type(){return"ReferenceElementNode"}constructor(e,t){super(e,t),this.referenceNode=e,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(e){const t=super.generate(e),s=this.referenceNode.getNodeType(),r=this.getNodeType();return e.format(t,s,r)}};class IL extends Ft{static get type(){return"ReferenceBaseNode"}constructor(e,t,s=null,r=null){super(),this.property=e,this.uniformType=t,this.object=s,this.count=r,this.properties=e.split("."),this.reference=s,this.node=null,this.group=null,this.updateType=Kt.OBJECT}setGroup(e){return this.group=e,this}element(e){return De(new wG(this,De(e)))}setNodeType(e){const t=Et(null,e).getSelf();this.group!==null&&t.setGroup(this.group),this.node=t}getNodeType(e){return this.node===null&&(this.updateReference(e),this.updateValue()),this.node.getNodeType(e)}getValueFromReference(e=this.reference){const{properties:t}=this;let s=e[t[0]];for(let r=1;r<t.length;r++)s=s[t[r]];return s}updateReference(e){return this.reference=this.object!==null?this.object:e.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){this.node===null&&this.setNodeType(this.uniformType);const e=this.getValueFromReference();Array.isArray(e)?this.node.array=e:this.node.value=e}}const MG=(i,e,t)=>De(new IL(i,e,t));class TG extends IL{static get type(){return"RendererReferenceNode"}constructor(e,t,s=null){super(e,t,s),this.renderer=s,this.setGroup(Rt)}updateReference(e){return this.reference=this.renderer!==null?this.renderer:e.renderer,this.reference}}const DL=(i,e,t=null)=>De(new TG(i,e,t));class vG extends Ii{static get type(){return"ToneMappingNode"}constructor(e,t=LL,s=null){super("vec3"),this.toneMapping=e,this.exposureNode=t,this.colorNode=s}customCacheKey(){return Qf(this.toneMapping)}setup(e){const t=this.colorNode||e.context.color,s=this.toneMapping;if(s===nc)return t;let r=null;const n=e.renderer.library.getToneMappingFunction(s);return n!==null?r=St(n(t.rgb,this.exposureNode),t.a):(console.error("ToneMappingNode: Unsupported Tone Mapping configuration.",s),r=t),r}}const kL=(i,e,t)=>De(new vG(i,De(e),De(t))),LL=DL("toneMappingExposure","float");Le("toneMapping",(i,e,t)=>kL(e,t,i));class SG extends C0{static get type(){return"BufferAttributeNode"}constructor(e,t=null,s=0,r=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferStride=s,this.bufferOffset=r,this.usage=Yf,this.instanced=!1,this.attribute=null,this.global=!0,e&&e.isBufferAttribute===!0&&(this.attribute=e,this.usage=e.usage,this.instanced=e.isInstancedBufferAttribute)}getHash(e){if(this.bufferStride===0&&this.bufferOffset===0){let t=e.globalCache.getData(this.value);return t===void 0&&(t={node:this},e.globalCache.setData(this.value,t)),t.node.uuid}return this.uuid}getNodeType(e){return this.bufferType===null&&(this.bufferType=e.getTypeFromAttribute(this.attribute)),this.bufferType}setup(e){if(this.attribute!==null)return;const t=this.getNodeType(e),s=this.value,r=e.getTypeLength(t),n=this.bufferStride||r,o=this.bufferOffset,a=s.isInterleavedBuffer===!0?s:new JD(s,n),l=new b0(a,r,o);a.setUsage(this.usage),this.attribute=l,this.attribute.isInstancedBufferAttribute=this.instanced}generate(e){const t=this.getNodeType(e),s=e.getBufferAttributeFromNode(this,t),r=e.getPropertyName(s);let n=null;return e.shaderStage==="vertex"||e.shaderStage==="compute"?(this.name=r,n=r):n=Ao(this).build(e,t),n}getInputType(){return"bufferAttribute"}setUsage(e){return this.usage=e,this.attribute&&this.attribute.isBufferAttribute===!0&&(this.attribute.usage=e),this}setInstanced(e){return this.instanced=e,this}}const yh=(i,e=null,t=0,s=0)=>De(new SG(i,e,t,s)),BL=(i,e=null,t=0,s=0)=>yh(i,e,t,s).setUsage(Ju),nm=(i,e=null,t=0,s=0)=>yh(i,e,t,s).setInstanced(!0),cb=(i,e=null,t=0,s=0)=>BL(i,e,t,s).setInstanced(!0);Le("toAttribute",i=>yh(i.value));class EG extends Ft{static get type(){return"ComputeNode"}constructor(e,t,s=[64]){super("void"),this.isComputeNode=!0,this.computeNode=e,this.count=t,this.workgroupSize=s,this.dispatchCount=0,this.version=1,this.name="",this.updateBeforeType=Kt.OBJECT,this.onInitFunction=null,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}label(e){return this.name=e,this}updateDispatchCount(){const{count:e,workgroupSize:t}=this;let s=t[0];for(let r=1;r<t.length;r++)s*=t[r];this.dispatchCount=Math.ceil(e/s)}onInit(e){return this.onInitFunction=e,this}updateBefore({renderer:e}){e.compute(this)}setup(e){const t=this.computeNode.build(e);if(t){const s=e.getNodeProperties(this);s.outputComputeNode=t.outputNode,t.outputNode=null}return t}generate(e,t){const{shaderStage:s}=e;if(s==="compute"){const r=this.computeNode.build(e,"void");r!==""&&e.addLineFlowCode(r,this)}else{const n=e.getNodeProperties(this).outputComputeNode;if(n)return n.build(e,t)}}}const OL=(i,e,t)=>De(new EG(De(i),e,t));Le("compute",OL);class AG extends Ft{static get type(){return"CacheNode"}constructor(e,t=!0){super(),this.node=e,this.parent=t,this.isCacheNode=!0}getNodeType(e){const t=e.getCache(),s=e.getCacheFromNode(this,this.parent);e.setCache(s);const r=this.node.getNodeType(e);return e.setCache(t),r}build(e,...t){const s=e.getCache(),r=e.getCacheFromNode(this,this.parent);e.setCache(r);const n=this.node.build(e,...t);return e.setCache(s),n}}const qd=(i,e)=>De(new AG(De(i),e));Le("cache",qd);class CG extends Ft{static get type(){return"BypassNode"}constructor(e,t){super(),this.isBypassNode=!0,this.outputNode=e,this.callNode=t}getNodeType(e){return this.outputNode.getNodeType(e)}generate(e){const t=this.callNode.build(e,"void");return t!==""&&e.addLineFlowCode(t,this),this.outputNode.build(e)}}const $L=ze(CG).setParameterLength(2);Le("bypass",$L);class zL extends Ft{static get type(){return"RemapNode"}constructor(e,t,s,r=Y(0),n=Y(1)){super(),this.node=e,this.inLowNode=t,this.inHighNode=s,this.outLowNode=r,this.outHighNode=n,this.doClamp=!0}setup(){const{node:e,inLowNode:t,inHighNode:s,outLowNode:r,outHighNode:n,doClamp:o}=this;let a=e.sub(t).div(s.sub(t));return o===!0&&(a=a.clamp()),a.mul(n.sub(r)).add(r)}}const VL=ze(zL,null,null,{doClamp:!1}).setParameterLength(3,5),UL=ze(zL).setParameterLength(3,5);Le("remap",VL);Le("remapClamp",UL);class Pf extends Ft{static get type(){return"ExpressionNode"}constructor(e="",t="void"){super(t),this.snippet=e}generate(e,t){const s=this.getNodeType(e),r=this.snippet;if(s==="void")e.addLineFlowCode(r,this);else return e.format(r,s,t)}}const ia=ze(Pf).setParameterLength(1,2),GL=i=>(i?Xi(i,ia("discard")):ia("discard")).toStack(),PG=()=>ia("return").toStack();Le("discard",GL);class NG extends Ii{static get type(){return"RenderOutputNode"}constructor(e,t,s){super("vec4"),this.colorNode=e,this.toneMapping=t,this.outputColorSpace=s,this.isRenderOutputNode=!0}setup({context:e}){let t=this.colorNode||e.color;const s=(this.toneMapping!==null?this.toneMapping:e.toneMapping)||nc,r=(this.outputColorSpace!==null?this.outputColorSpace:e.outputColorSpace)||ea;return s!==nc&&(t=t.toneMapping(s)),r!==ea&&r!==Ls.workingColorSpace&&(t=t.workingToColorSpace(r)),t}}const jL=(i,e=null,t=null)=>De(new NG(De(i),e,t));Le("renderOutput",jL);class FG extends Ii{static get type(){return"DebugNode"}constructor(e,t=null){super(),this.node=e,this.callback=t}getNodeType(e){return this.node.getNodeType(e)}setup(e){return this.node.build(e)}analyze(e){return this.node.build(e)}generate(e){const t=this.callback,s=this.node.build(e),r="--- TSL debug - "+e.shaderStage+" shader ---",n="-".repeat(r.length);let o="";return o+="// #"+r+`#
`,o+=e.flow.code.replace(/^\t/mg,"")+`
`,o+="/* ... */ "+s+` /* ... */
`,o+="// #"+n+`#
`,t!==null?t(e,o):console.log(o),s}}const WL=(i,e=null)=>De(new FG(De(i),e));Le("debug",WL);function RG(i){console.warn("THREE.TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add",i)}class HL extends Ft{static get type(){return"AttributeNode"}constructor(e,t=null){super(t),this.global=!0,this._attributeName=e}getHash(e){return this.getAttributeName(e)}getNodeType(e){let t=this.nodeType;if(t===null){const s=this.getAttributeName(e);if(e.hasGeometryAttribute(s)){const r=e.geometry.getAttribute(s);t=e.getTypeFromAttribute(r)}else t="float"}return t}setAttributeName(e){return this._attributeName=e,this}getAttributeName(){return this._attributeName}generate(e){const t=this.getAttributeName(e),s=this.getNodeType(e);if(e.hasGeometryAttribute(t)===!0){const n=e.geometry.getAttribute(t),o=e.getTypeFromAttribute(n),a=e.getAttribute(t,o);return e.shaderStage==="vertex"?e.format(a.name,o,s):Ao(this).build(e,s)}else return console.warn(`AttributeNode: Vertex attribute "${t}" not found on geometry.`),e.generateConst(s)}serialize(e){super.serialize(e),e.global=this.global,e._attributeName=this._attributeName}deserialize(e){super.deserialize(e),this.global=e.global,this._attributeName=e._attributeName}}const ra=(i,e=null)=>De(new HL(i,e)),qs=(i=0)=>ra("uv"+(i>0?i:""),"vec2");class IG extends Ft{static get type(){return"TextureSizeNode"}constructor(e,t=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=e,this.levelNode=t}generate(e,t){const s=this.textureNode.build(e,"property"),r=this.levelNode===null?"0":this.levelNode.build(e,"int");return e.format(`${e.getMethod("textureDimensions")}( ${s}, ${r} )`,this.getNodeType(e),t)}}const La=ze(IG).setParameterLength(1,2);class DG extends _h{static get type(){return"MaxMipLevelNode"}constructor(e){super(0),this._textureNode=e,this.updateType=Kt.FRAME}get textureNode(){return this._textureNode}get texture(){return this._textureNode.value}update(){const e=this.texture,t=e.images,s=t&&t.length>0?t[0]&&t[0].image||t[0]:e.image;if(s&&s.width!==void 0){const{width:r,height:n}=s;this.value=Math.log2(Math.max(r,n))}}}const rw=ze(DG).setParameterLength(1),nw=new Yi;class To extends _h{static get type(){return"TextureNode"}constructor(e=nw,t=null,s=null,r=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=s,this.biasNode=r,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=Kt.NONE,this.referenceNode=null,this._value=e,this._matrixUniform=null,this.setUpdateMatrix(t===null)}set value(e){this.referenceNode?this.referenceNode.value=e:this._value=e}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return this.value.isDepthTexture===!0?"float":this.value.type===_i?"uvec4":this.value.type===_r?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return qs(this.value.channel)}updateReference(){return this.value}getTransformedUV(e){return this._matrixUniform===null&&(this._matrixUniform=Et(this.value.matrix)),this._matrixUniform.mul(pe(e,1)).xy}setUpdateMatrix(e){return this.updateMatrix=e,this.updateType=e?Kt.OBJECT:Kt.NONE,this}setupUV(e,t){const s=this.value;return e.isFlipY()&&(s.image instanceof ImageBitmap&&s.flipY===!0||s.isRenderTargetTexture===!0||s.isFramebufferTexture===!0||s.isDepthTexture===!0)&&(this.sampler?t=t.flipY():t=t.setY(ne(La(this,this.levelNode).y).sub(t.y).sub(1))),t}setup(e){const t=e.getNodeProperties(this);t.referenceNode=this.referenceNode;const s=this.value;if(!s||s.isTexture!==!0)throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");let r=this.uvNode;(r===null||e.context.forceUVContext===!0)&&e.context.getUV&&(r=e.context.getUV(this,e)),r||(r=this.getDefaultUV()),this.updateMatrix===!0&&(r=this.getTransformedUV(r)),r=this.setupUV(e,r);let n=this.levelNode;n===null&&e.context.getTextureLevel&&(n=e.context.getTextureLevel(this)),t.uvNode=r,t.levelNode=n,t.biasNode=this.biasNode,t.compareNode=this.compareNode,t.gradNode=this.gradNode,t.depthNode=this.depthNode}generateUV(e,t){return t.build(e,this.sampler===!0?"vec2":"ivec2")}generateSnippet(e,t,s,r,n,o,a,l){const u=this.value;let c;return r?c=e.generateTextureLevel(u,t,s,r,o):n?c=e.generateTextureBias(u,t,s,n,o):l?c=e.generateTextureGrad(u,t,s,l,o):a?c=e.generateTextureCompare(u,t,s,a,o):this.sampler===!1?c=e.generateTextureLoad(u,t,s,o):c=e.generateTexture(u,t,s,o),c}generate(e,t){const s=this.value,r=e.getNodeProperties(this),n=super.generate(e,"property");if(/^sampler/.test(t))return n+"_sampler";if(e.isReference(t))return n;{const o=e.getDataFromNode(this);let a=o.propertyName;if(a===void 0){const{uvNode:c,levelNode:d,biasNode:h,compareNode:p,depthNode:f,gradNode:m}=r,x=this.generateUV(e,c),g=d?d.build(e,"float"):null,_=h?h.build(e,"float"):null,S=f?f.build(e,"int"):null,M=p?p.build(e,"float"):null,w=m?[m[0].build(e,"vec2"),m[1].build(e,"vec2")]:null,v=e.getVarFromNode(this);a=e.getPropertyName(v);const T=this.generateSnippet(e,n,x,g,_,S,M,w);e.addLineFlowCode(`${a} = ${T}`,this),o.snippet=T,o.propertyName=a}let l=a;const u=this.getNodeType(e);return e.needsToWorkingColorSpace(s)&&(l=Rm(ia(l,u),s.colorSpace).setup(e).build(e,u)),e.format(l,u,t)}}setSampler(e){return this.sampler=e,this}getSampler(){return this.sampler}uv(e){return console.warn("THREE.TextureNode: .uv() has been renamed. Use .sample() instead."),this.sample(e)}sample(e){const t=this.clone();return t.uvNode=De(e),t.referenceNode=this.getSelf(),De(t)}blur(e){const t=this.clone();t.biasNode=De(e).mul(rw(t)),t.referenceNode=this.getSelf();const s=t.value;return t.generateMipmaps===!1&&(s&&s.generateMipmaps===!1||s.minFilter===yi||s.magFilter===yi)&&(console.warn("THREE.TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture."),t.biasNode=null),De(t)}level(e){const t=this.clone();return t.levelNode=De(e),t.referenceNode=this.getSelf(),De(t)}size(e){return La(this,e)}bias(e){const t=this.clone();return t.biasNode=De(e),t.referenceNode=this.getSelf(),De(t)}compare(e){const t=this.clone();return t.compareNode=De(e),t.referenceNode=this.getSelf(),De(t)}grad(e,t){const s=this.clone();return s.gradNode=[De(e),De(t)],s.referenceNode=this.getSelf(),De(s)}depth(e){const t=this.clone();return t.depthNode=De(e),t.referenceNode=this.getSelf(),De(t)}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid,e.sampler=this.sampler,e.updateMatrix=this.updateMatrix,e.updateType=this.updateType}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value],this.sampler=e.sampler,this.updateMatrix=e.updateMatrix,this.updateType=e.updateType}update(){const e=this.value,t=this._matrixUniform;t!==null&&(t.value=e.matrix),e.matrixAutoUpdate===!0&&e.updateMatrix()}clone(){const e=new this.constructor(this.value,this.uvNode,this.levelNode,this.biasNode);return e.sampler=this.sampler,e.depthNode=this.depthNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e}}const kG=ze(To).setParameterLength(1,4).setName("texture"),ts=(i=nw,e=null,t=null,s=null)=>{let r;return i&&i.isTextureNode===!0?(r=De(i.clone()),r.referenceNode=i.getSelf(),e!==null&&(r.uvNode=De(e)),t!==null&&(r.levelNode=De(t)),s!==null&&(r.biasNode=De(s))):r=kG(i,e,t,s),r},LG=(i=nw)=>ts(i),ci=(...i)=>ts(...i).setSampler(!1),BG=i=>(i.isNode===!0?i:ts(i)).convert("sampler"),OG=i=>(i.isNode===!0?i:ts(i)).convert("samplerComparison");class ow extends _h{static get type(){return"BufferNode"}constructor(e,t,s=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferCount=s}getElementType(e){return this.getNodeType(e)}getInputType(){return"buffer"}}const xh=(i,e,t)=>De(new ow(i,e,t));class $G extends su{static get type(){return"UniformArrayElementNode"}constructor(e,t){super(e,t),this.isArrayBufferElementNode=!0}generate(e){const t=super.generate(e),s=this.getNodeType(),r=this.node.getPaddedType();return e.format(t,r,s)}}class zG extends ow{static get type(){return"UniformArrayNode"}constructor(e,t=null){super(null),this.array=e,this.elementType=t===null?Ia(e[0]):t,this.paddedType=this.getPaddedType(),this.updateType=Kt.RENDER,this.isArrayBufferNode=!0}getNodeType(){return this.paddedType}getElementType(){return this.elementType}getPaddedType(){const e=this.elementType;let t="vec4";return e==="mat2"?t="mat2":/mat/.test(e)===!0?t="mat4":e.charAt(0)==="i"?t="ivec4":e.charAt(0)==="u"&&(t="uvec4"),t}update(){const{array:e,value:t}=this,s=this.elementType;if(s==="float"||s==="int"||s==="uint")for(let r=0;r<e.length;r++){const n=r*4;t[n]=e[r]}else if(s==="color")for(let r=0;r<e.length;r++){const n=r*4,o=e[r];t[n]=o.r,t[n+1]=o.g,t[n+2]=o.b||0}else if(s==="mat2")for(let r=0;r<e.length;r++){const n=r*4,o=e[r];t[n]=o.elements[0],t[n+1]=o.elements[1],t[n+2]=o.elements[2],t[n+3]=o.elements[3]}else if(s==="mat3")for(let r=0;r<e.length;r++){const n=r*16,o=e[r];t[n]=o.elements[0],t[n+1]=o.elements[1],t[n+2]=o.elements[2],t[n+4]=o.elements[3],t[n+5]=o.elements[4],t[n+6]=o.elements[5],t[n+8]=o.elements[6],t[n+9]=o.elements[7],t[n+10]=o.elements[8],t[n+15]=1}else if(s==="mat4")for(let r=0;r<e.length;r++){const n=r*16,o=e[r];for(let a=0;a<o.elements.length;a++)t[n+a]=o.elements[a]}else for(let r=0;r<e.length;r++){const n=r*4,o=e[r];t[n]=o.x,t[n+1]=o.y,t[n+2]=o.z||0,t[n+3]=o.w||0}}setup(e){const t=this.array.length,s=this.elementType;let r=Float32Array;const n=this.paddedType,o=e.getTypeLength(n);return s.charAt(0)==="i"&&(r=Int32Array),s.charAt(0)==="u"&&(r=Uint32Array),this.value=new r(t*o),this.bufferCount=t,this.bufferType=n,super.setup(e)}element(e){return De(new $G(this,De(e)))}}const pn=(i,e)=>De(new zG(i,e));class VG extends Ft{constructor(e){super("float"),this.name=e,this.isBuiltinNode=!0}generate(){return this.name}}const bh=ze(VG).setParameterLength(1),Im=Et(0,"uint").label("u_cameraIndex").setGroup(Sm("cameraIndex")).toVarying("v_cameraIndex"),Pa=Et("float").label("cameraNear").setGroup(Rt).onRenderUpdate(({camera:i})=>i.near),Na=Et("float").label("cameraFar").setGroup(Rt).onRenderUpdate(({camera:i})=>i.far),iu=ge(({camera:i})=>{let e;if(i.isArrayCamera&&i.cameras.length>0){const t=[];for(const r of i.cameras)t.push(r.projectionMatrix);e=pn(t).setGroup(Rt).label("cameraProjectionMatrices").element(i.isMultiViewCamera?bh("gl_ViewID_OVR"):Im).toVar("cameraProjectionMatrix")}else e=Et("mat4").label("cameraProjectionMatrix").setGroup(Rt).onRenderUpdate(({camera:t})=>t.projectionMatrix);return e}).once()(),UG=ge(({camera:i})=>{let e;if(i.isArrayCamera&&i.cameras.length>0){const t=[];for(const r of i.cameras)t.push(r.projectionMatrixInverse);e=pn(t).setGroup(Rt).label("cameraProjectionMatricesInverse").element(i.isMultiViewCamera?bh("gl_ViewID_OVR"):Im).toVar("cameraProjectionMatrixInverse")}else e=Et("mat4").label("cameraProjectionMatrixInverse").setGroup(Rt).onRenderUpdate(({camera:t})=>t.projectionMatrixInverse);return e}).once()(),Tn=ge(({camera:i})=>{let e;if(i.isArrayCamera&&i.cameras.length>0){const t=[];for(const r of i.cameras)t.push(r.matrixWorldInverse);e=pn(t).setGroup(Rt).label("cameraViewMatrices").element(i.isMultiViewCamera?bh("gl_ViewID_OVR"):Im).toVar("cameraViewMatrix")}else e=Et("mat4").label("cameraViewMatrix").setGroup(Rt).onRenderUpdate(({camera:t})=>t.matrixWorldInverse);return e}).once()(),GG=Et("mat4").label("cameraWorldMatrix").setGroup(Rt).onRenderUpdate(({camera:i})=>i.matrixWorld),jG=Et("mat3").label("cameraNormalMatrix").setGroup(Rt).onRenderUpdate(({camera:i})=>i.normalMatrix),qL=Et(new xe).label("cameraPosition").setGroup(Rt).onRenderUpdate(({camera:i},e)=>e.value.setFromMatrixPosition(i.matrixWorld)),_2=new fm;class rs extends Ft{static get type(){return"Object3DNode"}constructor(e,t=null){super(),this.scope=e,this.object3d=t,this.updateType=Kt.OBJECT,this.uniformNode=new _h(null)}getNodeType(){const e=this.scope;if(e===rs.WORLD_MATRIX)return"mat4";if(e===rs.POSITION||e===rs.VIEW_POSITION||e===rs.DIRECTION||e===rs.SCALE)return"vec3";if(e===rs.RADIUS)return"float"}update(e){const t=this.object3d,s=this.uniformNode,r=this.scope;if(r===rs.WORLD_MATRIX)s.value=t.matrixWorld;else if(r===rs.POSITION)s.value=s.value||new xe,s.value.setFromMatrixPosition(t.matrixWorld);else if(r===rs.SCALE)s.value=s.value||new xe,s.value.setFromMatrixScale(t.matrixWorld);else if(r===rs.DIRECTION)s.value=s.value||new xe,t.getWorldDirection(s.value);else if(r===rs.VIEW_POSITION){const n=e.camera;s.value=s.value||new xe,s.value.setFromMatrixPosition(t.matrixWorld),s.value.applyMatrix4(n.matrixWorldInverse)}else if(r===rs.RADIUS){const n=e.object.geometry;n.boundingSphere===null&&n.computeBoundingSphere(),_2.copy(n.boundingSphere).applyMatrix4(t.matrixWorld),s.value=_2.radius}}generate(e){const t=this.scope;return t===rs.WORLD_MATRIX?this.uniformNode.nodeType="mat4":t===rs.POSITION||t===rs.VIEW_POSITION||t===rs.DIRECTION||t===rs.SCALE?this.uniformNode.nodeType="vec3":t===rs.RADIUS&&(this.uniformNode.nodeType="float"),this.uniformNode.build(e)}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}rs.WORLD_MATRIX="worldMatrix";rs.POSITION="position";rs.SCALE="scale";rs.VIEW_POSITION="viewPosition";rs.DIRECTION="direction";rs.RADIUS="radius";const WG=ze(rs,rs.DIRECTION).setParameterLength(1),HG=ze(rs,rs.WORLD_MATRIX).setParameterLength(1),KL=ze(rs,rs.POSITION).setParameterLength(1),qG=ze(rs,rs.SCALE).setParameterLength(1),KG=ze(rs,rs.VIEW_POSITION).setParameterLength(1),XG=ze(rs,rs.RADIUS).setParameterLength(1);class Mn extends rs{static get type(){return"ModelNode"}constructor(e){super(e)}update(e){this.object3d=e.object,super.update(e)}}const YG=ot(Mn,Mn.DIRECTION),mn=ot(Mn,Mn.WORLD_MATRIX),QG=ot(Mn,Mn.POSITION),ZG=ot(Mn,Mn.SCALE),JG=ot(Mn,Mn.VIEW_POSITION),ej=ot(Mn,Mn.RADIUS),XL=Et(new kr).onObjectUpdate(({object:i},e)=>e.value.getNormalMatrix(i.matrixWorld)),tj=Et(new cs).onObjectUpdate(({object:i},e)=>e.value.copy(i.matrixWorld).invert()),ru=ge(i=>i.renderer.overrideNodes.modelViewMatrix||YL).once()().toVar("modelViewMatrix"),YL=Tn.mul(mn),db=ge(i=>(i.context.isHighPrecisionModelViewMatrix=!0,Et("mat4").onObjectUpdate(({object:e,camera:t})=>e.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse,e.matrixWorld)))).once()().toVar("highpModelViewMatrix"),hb=ge(i=>{const e=i.context.isHighPrecisionModelViewMatrix;return Et("mat3").onObjectUpdate(({object:t,camera:s})=>(e!==!0&&t.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix)))}).once()().toVar("highpModelNormalViewMatrix"),wh=ra("position","vec3"),di=wh.toVarying("positionLocal"),om=wh.toVarying("positionPrevious"),Zo=ge(i=>mn.mul(di).xyz.toVarying(i.getSubBuildProperty("v_positionWorld")),"vec3").once(["POSITION"])(),aw=ge(()=>di.transformDirection(mn).toVarying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"),"vec3").once(["POSITION"])(),hi=ge(i=>i.context.setupPositionView().toVarying("v_positionView"),"vec3").once(["POSITION"])(),Ks=hi.negate().toVarying("v_positionViewDirection").normalize().toVar("positionViewDirection");class sj extends Ft{static get type(){return"FrontFacingNode"}constructor(){super("bool"),this.isFrontFacingNode=!0}generate(e){if(e.shaderStage!=="fragment")return"true";const{renderer:t,material:s}=e;return t.coordinateSystem===Pr&&s.side===lr?"false":e.getFrontFacing()}}const QL=ot(sj),lw=Y(QL).mul(2).sub(1),Ec=ge(([i],{material:e})=>{const t=e.side;return t===lr?i=i.mul(-1):t===Da&&(i=i.mul(lw)),i}),Dm=ra("normal","vec3"),Dr=ge(i=>i.geometry.hasAttribute("normal")===!1?(console.warn('THREE.TSL: Vertex attribute "normal" not found on geometry.'),pe(0,1,0)):Dm,"vec3").once()().toVar("normalLocal"),ZL=hi.dFdx().cross(hi.dFdy()).normalize().toVar("normalFlat"),bc=ge(i=>{let e;return i.material.flatShading===!0?e=ZL:e=uw(Dr).toVarying("v_normalViewGeometry").normalize(),e},"vec3").once()().toVar("normalViewGeometry"),JL=ge(i=>{let e=bc.transformDirection(Tn);return i.material.flatShading!==!0&&(e=e.toVarying("v_normalWorldGeometry")),e.normalize().toVar("normalWorldGeometry")},"vec3").once()(),Fs=ge(({subBuildFn:i,material:e,context:t})=>{let s;return i==="NORMAL"||i==="VERTEX"?(s=bc,e.flatShading!==!0&&(s=Ec(s))):s=t.setupNormal().context({getUV:null}),s},"vec3").once(["NORMAL","VERTEX"])().toVar("normalView"),Ga=Fs.transformDirection(Tn).toVar("normalWorld"),zl=ge(({subBuildFn:i,context:e})=>{let t;return i==="NORMAL"||i==="VERTEX"?t=Fs:t=e.setupClearcoatNormal().context({getUV:null}),t},"vec3").once(["NORMAL","VERTEX"])().toVar("clearcoatNormalView"),eB=ge(([i,e=mn])=>{const t=cr(e),s=i.div(pe(t[0].dot(t[0]),t[1].dot(t[1]),t[2].dot(t[2])));return t.mul(s).xyz}),uw=ge(([i],e)=>{const t=e.renderer.overrideNodes.modelNormalViewMatrix;if(t!==null)return t.transformDirection(i);const s=XL.mul(i);return Tn.transformDirection(s)}),ij=ge(()=>(console.warn('THREE.TSL: "transformedNormalView" is deprecated. Use "normalView" instead.'),Fs)).once(["NORMAL","VERTEX"])(),rj=ge(()=>(console.warn('THREE.TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.'),Ga)).once(["NORMAL","VERTEX"])(),nj=ge(()=>(console.warn('THREE.TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.'),zl)).once(["NORMAL","VERTEX"])(),y2=new xn,Ly=new cs,tB=Et(0).onReference(({material:i})=>i).onObjectUpdate(({material:i})=>i.refractionRatio),Nf=Et(1).onReference(({material:i})=>i).onObjectUpdate(function({material:i,scene:e}){return i.envMap?i.envMapIntensity:e.environmentIntensity}),cw=Et(new cs).onReference(function(i){return i.material}).onObjectUpdate(function({material:i,scene:e}){const t=e.environment!==null&&i.envMap===null?e.environmentRotation:i.envMapRotation;return t?(y2.copy(t),Ly.makeRotationFromEuler(y2)):Ly.identity(),Ly}),sB=Ks.negate().reflect(Fs),iB=Ks.negate().refract(Fs,tB),rB=sB.transformDirection(Tn).toVar("reflectVector"),nB=iB.transformDirection(Tn).toVar("reflectVector"),oB=new mm;class oj extends To{static get type(){return"CubeTextureNode"}constructor(e,t=null,s=null,r=null){super(e,t,s,r),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){const e=this.value;return e.mapping===th?rB:e.mapping===Kf?nB:(console.error('THREE.CubeTextureNode: Mapping "%s" not supported.',e.mapping),pe(0,0,0))}setUpdateMatrix(){}setupUV(e,t){const s=this.value;return(e.renderer.coordinateSystem===xo||!s.isRenderTargetTexture)&&(t=pe(t.x.negate(),t.yz)),cw.mul(t)}generateUV(e,t){return t.build(e,"vec3")}}const dw=ze(oj).setParameterLength(1,4).setName("cubeTexture"),wc=(i=oB,e=null,t=null,s=null)=>{let r;return i&&i.isCubeTextureNode===!0?(r=De(i.clone()),r.referenceNode=i.getSelf(),e!==null&&(r.uvNode=De(e)),t!==null&&(r.levelNode=De(t)),s!==null&&(r.biasNode=De(s))):r=dw(i,e,t,s),r},aj=(i=oB)=>dw(i);class lj extends su{static get type(){return"ReferenceElementNode"}constructor(e,t){super(e,t),this.referenceNode=e,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(e){const t=super.generate(e),s=this.referenceNode.getNodeType(),r=this.getNodeType();return e.format(t,s,r)}}class km extends Ft{static get type(){return"ReferenceNode"}constructor(e,t,s=null,r=null){super(),this.property=e,this.uniformType=t,this.object=s,this.count=r,this.properties=e.split("."),this.reference=s,this.node=null,this.group=null,this.name=null,this.updateType=Kt.OBJECT}element(e){return De(new lj(this,De(e)))}setGroup(e){return this.group=e,this}label(e){return this.name=e,this}setNodeType(e){let t=null;this.count!==null?t=xh(null,e,this.count):Array.isArray(this.getValueFromReference())?t=pn(null,e):e==="texture"?t=ts(null):e==="cubeTexture"?t=wc(null):t=Et(null,e),this.group!==null&&t.setGroup(this.group),this.name!==null&&t.label(this.name),this.node=t.getSelf()}getNodeType(e){return this.node===null&&(this.updateReference(e),this.updateValue()),this.node.getNodeType(e)}getValueFromReference(e=this.reference){const{properties:t}=this;let s=e[t[0]];for(let r=1;r<t.length;r++)s=s[t[r]];return s}updateReference(e){return this.reference=this.object!==null?this.object:e.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){this.node===null&&this.setNodeType(this.uniformType);const e=this.getValueFromReference();Array.isArray(e)?this.node.array=e:this.node.value=e}}const Os=(i,e,t)=>De(new km(i,e,t)),pb=(i,e,t,s)=>De(new km(i,e,s,t));class uj extends km{static get type(){return"MaterialReferenceNode"}constructor(e,t,s=null){super(e,t,s),this.material=s,this.isMaterialReferenceNode=!0}updateReference(e){return this.reference=this.material!==null?this.material:e.material,this.reference}}const jo=(i,e,t=null)=>De(new uj(i,e,t)),aB=qs(),cj=hi.dFdx(),dj=hi.dFdy(),lB=aB.dFdx(),uB=aB.dFdy(),cB=Fs,dB=dj.cross(cB),hB=cB.cross(cj),fb=dB.mul(lB.x).add(hB.mul(uB.x)),mb=dB.mul(lB.y).add(hB.mul(uB.y)),x2=fb.dot(fb).max(mb.dot(mb)),pB=x2.equal(0).select(0,x2.inverseSqrt()),hj=fb.mul(pB).toVar("tangentViewFrame"),pj=mb.mul(pB).toVar("bitangentViewFrame"),Lm=ge(i=>(i.geometry.hasAttribute("tangent")===!1&&i.geometry.computeTangents(),ra("tangent","vec4")))(),Mh=Lm.xyz.toVar("tangentLocal"),Bm=ge(({subBuildFn:i,geometry:e,material:t})=>{let s;return i==="VERTEX"||e.hasAttribute("tangent")?s=ru.mul(St(Mh,0)).xyz.toVarying("v_tangentView").normalize():s=hj,t.flatShading!==!0&&(s=Ec(s)),s},"vec3").once(["NORMAL","VERTEX"])().toVar("tangentView"),fB=Bm.transformDirection(Tn).toVarying("v_tangentWorld").normalize().toVar("tangentWorld"),Om=ge(([i,e],{subBuildFn:t,material:s})=>{let r=i.mul(Lm.w).xyz;return t==="NORMAL"&&s.flatShading!==!0&&(r=r.toVarying(e)),r}).once(["NORMAL"]),fj=Om(Dm.cross(Lm),"v_bitangentGeometry").normalize().toVar("bitangentGeometry"),mj=Om(Dr.cross(Mh),"v_bitangentLocal").normalize().toVar("bitangentLocal"),mB=ge(({subBuildFn:i,geometry:e,material:t})=>{let s;return i==="VERTEX"||e.hasAttribute("tangent")?s=Om(Fs.cross(Bm),"v_bitangentView").normalize():s=pj,t.flatShading!==!0&&(s=Ec(s)),s},"vec3").once(["NORMAL","VERTEX"])().toVar("bitangentView"),gj=Om(Ga.cross(fB),"v_bitangentWorld").normalize().toVar("bitangentWorld"),Vl=cr(Bm,mB,Fs).toVar("TBNViewMatrix"),gB=Ks.mul(Vl),_j=(i,e)=>i.sub(gB.mul(e)),_B=ge(()=>{let i=Wl.cross(Ks);return i=i.cross(Wl).normalize(),i=Cs(i,Fs,Ca.mul(ho.oneMinus()).oneMinus().pow2().pow2()).normalize(),i}).once()();class yj extends Ii{static get type(){return"NormalMapNode"}constructor(e,t=null){super("vec3"),this.node=e,this.scaleNode=t,this.normalMapType=$a}setup({material:e}){const{normalMapType:t,scaleNode:s}=this;let r=this.node.mul(2).sub(1);if(s!==null){let o=s;e.flatShading===!0&&(o=Ec(o)),r=pe(r.xy.mul(o),r.z)}let n=null;return t===zV?n=uw(r):t===$a?n=Vl.mul(r).normalize():(console.error(`THREE.NodeMaterial: Unsupported normal map type: ${t}`),n=Fs),n}}const gb=ze(yj).setParameterLength(1,2),xj=ge(({textureNode:i,bumpScale:e})=>{const t=r=>i.cache().context({getUV:n=>r(n.uvNode||qs()),forceUVContext:!0}),s=Y(t(r=>r));return Ge(Y(t(r=>r.add(r.dFdx()))).sub(s),Y(t(r=>r.add(r.dFdy()))).sub(s)).mul(e)}),bj=ge(i=>{const{surf_pos:e,surf_norm:t,dHdxy:s}=i,r=e.dFdx().normalize(),n=e.dFdy().normalize(),o=t,a=n.cross(o),l=o.cross(r),u=r.dot(a).mul(lw),c=u.sign().mul(s.x.mul(a).add(s.y.mul(l)));return u.abs().mul(t).sub(c).normalize()});class wj extends Ii{static get type(){return"BumpMapNode"}constructor(e,t=null){super("vec3"),this.textureNode=e,this.scaleNode=t}setup(){const e=this.scaleNode!==null?this.scaleNode:1,t=xj({textureNode:this.textureNode,bumpScale:e});return bj({surf_pos:hi,surf_norm:Fs,dHdxy:t})}}const yB=ze(wj).setParameterLength(1,2),b2=new Map;class ke extends Ft{static get type(){return"MaterialNode"}constructor(e){super(),this.scope=e}getCache(e,t){let s=b2.get(e);return s===void 0&&(s=jo(e,t),b2.set(e,s)),s}getFloat(e){return this.getCache(e,"float")}getColor(e){return this.getCache(e,"color")}getTexture(e){return this.getCache(e==="map"?"map":e+"Map","texture")}setup(e){const t=e.context.material,s=this.scope;let r=null;if(s===ke.COLOR){const n=t.color!==void 0?this.getColor(s):pe();t.map&&t.map.isTexture===!0?r=n.mul(this.getTexture("map")):r=n}else if(s===ke.OPACITY){const n=this.getFloat(s);t.alphaMap&&t.alphaMap.isTexture===!0?r=n.mul(this.getTexture("alpha")):r=n}else if(s===ke.SPECULAR_STRENGTH)t.specularMap&&t.specularMap.isTexture===!0?r=this.getTexture("specular").r:r=Y(1);else if(s===ke.SPECULAR_INTENSITY){const n=this.getFloat(s);t.specularIntensityMap&&t.specularIntensityMap.isTexture===!0?r=n.mul(this.getTexture(s).a):r=n}else if(s===ke.SPECULAR_COLOR){const n=this.getColor(s);t.specularColorMap&&t.specularColorMap.isTexture===!0?r=n.mul(this.getTexture(s).rgb):r=n}else if(s===ke.ROUGHNESS){const n=this.getFloat(s);t.roughnessMap&&t.roughnessMap.isTexture===!0?r=n.mul(this.getTexture(s).g):r=n}else if(s===ke.METALNESS){const n=this.getFloat(s);t.metalnessMap&&t.metalnessMap.isTexture===!0?r=n.mul(this.getTexture(s).b):r=n}else if(s===ke.EMISSIVE){const n=this.getFloat("emissiveIntensity"),o=this.getColor(s).mul(n);t.emissiveMap&&t.emissiveMap.isTexture===!0?r=o.mul(this.getTexture(s)):r=o}else if(s===ke.NORMAL)t.normalMap?(r=gb(this.getTexture("normal"),this.getCache("normalScale","vec2")),r.normalMapType=t.normalMapType):t.bumpMap?r=yB(this.getTexture("bump").r,this.getFloat("bumpScale")):r=Fs;else if(s===ke.CLEARCOAT){const n=this.getFloat(s);t.clearcoatMap&&t.clearcoatMap.isTexture===!0?r=n.mul(this.getTexture(s).r):r=n}else if(s===ke.CLEARCOAT_ROUGHNESS){const n=this.getFloat(s);t.clearcoatRoughnessMap&&t.clearcoatRoughnessMap.isTexture===!0?r=n.mul(this.getTexture(s).r):r=n}else if(s===ke.CLEARCOAT_NORMAL)t.clearcoatNormalMap?r=gb(this.getTexture(s),this.getCache(s+"Scale","vec2")):r=Fs;else if(s===ke.SHEEN){const n=this.getColor("sheenColor").mul(this.getFloat("sheen"));t.sheenColorMap&&t.sheenColorMap.isTexture===!0?r=n.mul(this.getTexture("sheenColor").rgb):r=n}else if(s===ke.SHEEN_ROUGHNESS){const n=this.getFloat(s);t.sheenRoughnessMap&&t.sheenRoughnessMap.isTexture===!0?r=n.mul(this.getTexture(s).a):r=n,r=r.clamp(.07,1)}else if(s===ke.ANISOTROPY)if(t.anisotropyMap&&t.anisotropyMap.isTexture===!0){const n=this.getTexture(s);r=Mm(qu.x,qu.y,qu.y.negate(),qu.x).mul(n.rg.mul(2).sub(Ge(1)).normalize().mul(n.b))}else r=qu;else if(s===ke.IRIDESCENCE_THICKNESS){const n=Os("1","float",t.iridescenceThicknessRange);if(t.iridescenceThicknessMap){const o=Os("0","float",t.iridescenceThicknessRange);r=n.sub(o).mul(this.getTexture(s).g).add(o)}else r=n}else if(s===ke.TRANSMISSION){const n=this.getFloat(s);t.transmissionMap?r=n.mul(this.getTexture(s).r):r=n}else if(s===ke.THICKNESS){const n=this.getFloat(s);t.thicknessMap?r=n.mul(this.getTexture(s).g):r=n}else if(s===ke.IOR)r=this.getFloat(s);else if(s===ke.LIGHT_MAP)r=this.getTexture(s).rgb.mul(this.getFloat("lightMapIntensity"));else if(s===ke.AO)r=this.getTexture(s).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);else if(s===ke.LINE_DASH_OFFSET)r=t.dashOffset?this.getFloat(s):Y(0);else{const n=this.getNodeType(e);r=this.getCache(s,n)}return r}}ke.ALPHA_TEST="alphaTest";ke.COLOR="color";ke.OPACITY="opacity";ke.SHININESS="shininess";ke.SPECULAR="specular";ke.SPECULAR_STRENGTH="specularStrength";ke.SPECULAR_INTENSITY="specularIntensity";ke.SPECULAR_COLOR="specularColor";ke.REFLECTIVITY="reflectivity";ke.ROUGHNESS="roughness";ke.METALNESS="metalness";ke.NORMAL="normal";ke.CLEARCOAT="clearcoat";ke.CLEARCOAT_ROUGHNESS="clearcoatRoughness";ke.CLEARCOAT_NORMAL="clearcoatNormal";ke.EMISSIVE="emissive";ke.ROTATION="rotation";ke.SHEEN="sheen";ke.SHEEN_ROUGHNESS="sheenRoughness";ke.ANISOTROPY="anisotropy";ke.IRIDESCENCE="iridescence";ke.IRIDESCENCE_IOR="iridescenceIOR";ke.IRIDESCENCE_THICKNESS="iridescenceThickness";ke.IOR="ior";ke.TRANSMISSION="transmission";ke.THICKNESS="thickness";ke.ATTENUATION_DISTANCE="attenuationDistance";ke.ATTENUATION_COLOR="attenuationColor";ke.LINE_SCALE="scale";ke.LINE_DASH_SIZE="dashSize";ke.LINE_GAP_SIZE="gapSize";ke.LINE_WIDTH="linewidth";ke.LINE_DASH_OFFSET="dashOffset";ke.POINT_SIZE="size";ke.DISPERSION="dispersion";ke.LIGHT_MAP="light";ke.AO="ao";const xB=ot(ke,ke.ALPHA_TEST),bB=ot(ke,ke.COLOR),wB=ot(ke,ke.SHININESS),MB=ot(ke,ke.EMISSIVE),hw=ot(ke,ke.OPACITY),TB=ot(ke,ke.SPECULAR),_b=ot(ke,ke.SPECULAR_INTENSITY),vB=ot(ke,ke.SPECULAR_COLOR),Kd=ot(ke,ke.SPECULAR_STRENGTH),Ff=ot(ke,ke.REFLECTIVITY),SB=ot(ke,ke.ROUGHNESS),EB=ot(ke,ke.METALNESS),AB=ot(ke,ke.NORMAL),CB=ot(ke,ke.CLEARCOAT),PB=ot(ke,ke.CLEARCOAT_ROUGHNESS),NB=ot(ke,ke.CLEARCOAT_NORMAL),FB=ot(ke,ke.ROTATION),RB=ot(ke,ke.SHEEN),IB=ot(ke,ke.SHEEN_ROUGHNESS),DB=ot(ke,ke.ANISOTROPY),kB=ot(ke,ke.IRIDESCENCE),LB=ot(ke,ke.IRIDESCENCE_IOR),BB=ot(ke,ke.IRIDESCENCE_THICKNESS),OB=ot(ke,ke.TRANSMISSION),$B=ot(ke,ke.THICKNESS),zB=ot(ke,ke.IOR),VB=ot(ke,ke.ATTENUATION_DISTANCE),UB=ot(ke,ke.ATTENUATION_COLOR),GB=ot(ke,ke.LINE_SCALE),jB=ot(ke,ke.LINE_DASH_SIZE),WB=ot(ke,ke.LINE_GAP_SIZE),Mj=ot(ke,ke.LINE_WIDTH),HB=ot(ke,ke.LINE_DASH_OFFSET),qB=ot(ke,ke.POINT_SIZE),KB=ot(ke,ke.DISPERSION),pw=ot(ke,ke.LIGHT_MAP),XB=ot(ke,ke.AO),qu=Et(new Dt).onReference(function(i){return i.material}).onRenderUpdate(function({material:i}){this.value.set(i.anisotropy*Math.cos(i.anisotropyRotation),i.anisotropy*Math.sin(i.anisotropyRotation))}),fw=ge(i=>i.context.setupModelViewProjection(),"vec4").once()().toVarying("v_modelViewProjection");class Xs extends Ft{static get type(){return"IndexNode"}constructor(e){super("uint"),this.scope=e,this.isIndexNode=!0}generate(e){const t=this.getNodeType(e),s=this.scope;let r;if(s===Xs.VERTEX)r=e.getVertexIndex();else if(s===Xs.INSTANCE)r=e.getInstanceIndex();else if(s===Xs.DRAW)r=e.getDrawIndex();else if(s===Xs.INVOCATION_LOCAL)r=e.getInvocationLocalIndex();else if(s===Xs.INVOCATION_SUBGROUP)r=e.getInvocationSubgroupIndex();else if(s===Xs.SUBGROUP)r=e.getSubgroupIndex();else throw new Error("THREE.IndexNode: Unknown scope: "+s);let n;return e.shaderStage==="vertex"||e.shaderStage==="compute"?n=r:n=Ao(this).build(e,t),n}}Xs.VERTEX="vertex";Xs.INSTANCE="instance";Xs.SUBGROUP="subgroup";Xs.INVOCATION_LOCAL="invocationLocal";Xs.INVOCATION_SUBGROUP="invocationSubgroup";Xs.DRAW="draw";const YB=ot(Xs,Xs.VERTEX),Ba=ot(Xs,Xs.INSTANCE),Tj=ot(Xs,Xs.SUBGROUP),vj=ot(Xs,Xs.INVOCATION_SUBGROUP),Sj=ot(Xs,Xs.INVOCATION_LOCAL),QB=ot(Xs,Xs.DRAW);class ZB extends Ft{static get type(){return"InstanceNode"}constructor(e,t,s=null){super("void"),this.count=e,this.instanceMatrix=t,this.instanceColor=s,this.instanceMatrixNode=null,this.instanceColorNode=null,this.updateType=Kt.FRAME,this.buffer=null,this.bufferColor=null}setup(e){const{count:t,instanceMatrix:s,instanceColor:r}=this;let{instanceMatrixNode:n,instanceColorNode:o}=this;if(n===null){if(t<=1e3)n=xh(s.array,"mat4",Math.max(t,1)).element(Ba);else{const l=new g4(s.array,16,1);this.buffer=l;const u=s.usage===Ju?cb:nm,c=[u(l,"vec4",16,0),u(l,"vec4",16,4),u(l,"vec4",16,8),u(l,"vec4",16,12)];n=jl(...c)}this.instanceMatrixNode=n}if(r&&o===null){const l=new ac(r.array,3),u=r.usage===Ju?cb:nm;this.bufferColor=l,o=pe(u(l,"vec3",3,0)),this.instanceColorNode=o}const a=n.mul(di).xyz;if(di.assign(a),e.hasGeometryAttribute("normal")){const l=eB(Dr,n);Dr.assign(l)}this.instanceColorNode!==null&&oh("vec3","vInstanceColor").assign(this.instanceColorNode)}update(){this.instanceMatrix.usage!==Ju&&this.buffer!==null&&this.instanceMatrix.version!==this.buffer.version&&(this.buffer.version=this.instanceMatrix.version),this.instanceColor&&this.instanceColor.usage!==Ju&&this.bufferColor!==null&&this.instanceColor.version!==this.bufferColor.version&&(this.bufferColor.version=this.instanceColor.version)}}const Ej=ze(ZB).setParameterLength(2,3);class Aj extends ZB{static get type(){return"InstancedMeshNode"}constructor(e){const{count:t,instanceMatrix:s,instanceColor:r}=e;super(t,s,r),this.instancedMesh=e}}const JB=ze(Aj).setParameterLength(1);class Cj extends Ft{static get type(){return"BatchNode"}constructor(e){super("void"),this.batchMesh=e,this.batchingIdNode=null}setup(e){this.batchingIdNode===null&&(e.getDrawIndex()===null?this.batchingIdNode=Ba:this.batchingIdNode=QB);const s=ge(([f])=>{const m=ne(La(ci(this.batchMesh._indirectTexture),0).x),x=ne(f).mod(m),g=ne(f).div(m);return ci(this.batchMesh._indirectTexture,Vi(x,g)).x}).setLayout({name:"getIndirectIndex",type:"uint",inputs:[{name:"id",type:"int"}]})(ne(this.batchingIdNode)),r=this.batchMesh._matricesTexture,n=ne(La(ci(r),0).x),o=Y(s).mul(4).toInt().toVar(),a=o.mod(n),l=o.div(n),u=jl(ci(r,Vi(a,l)),ci(r,Vi(a.add(1),l)),ci(r,Vi(a.add(2),l)),ci(r,Vi(a.add(3),l))),c=this.batchMesh._colorsTexture;if(c!==null){const m=ge(([x])=>{const g=ne(La(ci(c),0).x),_=x,S=_.mod(g),M=_.div(g);return ci(c,Vi(S,M)).rgb}).setLayout({name:"getBatchingColor",type:"vec3",inputs:[{name:"id",type:"int"}]})(s);oh("vec3","vBatchColor").assign(m)}const d=cr(u);di.assign(u.mul(di));const h=Dr.div(pe(d[0].dot(d[0]),d[1].dot(d[1]),d[2].dot(d[2]))),p=d.mul(h).xyz;Dr.assign(p),e.hasGeometryAttribute("tangent")&&Mh.mulAssign(d)}}const eO=ze(Cj).setParameterLength(1);class Pj extends su{static get type(){return"StorageArrayElementNode"}constructor(e,t){super(e,t),this.isStorageArrayElementNode=!0}set storageBufferNode(e){this.node=e}get storageBufferNode(){return this.node}getMemberType(e,t){const s=this.storageBufferNode.structTypeNode;return s?s.getMemberType(e,t):"void"}setup(e){return e.isAvailable("storageBuffer")===!1&&this.node.isPBO===!0&&e.setupPBO(this.node),super.setup(e)}generate(e,t){let s;const r=e.context.assign;if(e.isAvailable("storageBuffer")===!1?this.node.isPBO===!0&&r!==!0&&(this.node.value.isInstancedBufferAttribute||e.shaderStage!=="compute")?s=e.generatePBO(this):s=this.node.build(e):s=super.generate(e),r!==!0){const n=this.getNodeType(e);s=e.format(s,n,t)}return s}}const Nj=ze(Pj).setParameterLength(2);class Fj extends ow{static get type(){return"StorageBufferNode"}constructor(e,t=null,s=0){let r,n=null;t&&t.isStruct?(r="struct",n=t.layout,(e.isStorageBufferAttribute||e.isStorageInstancedBufferAttribute)&&(s=e.count)):t===null&&(e.isStorageBufferAttribute||e.isStorageInstancedBufferAttribute)?(r=ok(e.itemSize),s=e.count):r=t,super(e,r,s),this.isStorageBufferNode=!0,this.structTypeNode=n,this.access=ar.READ_WRITE,this.isAtomic=!1,this.isPBO=!1,this._attribute=null,this._varying=null,this.global=!0,e.isStorageBufferAttribute!==!0&&e.isStorageInstancedBufferAttribute!==!0&&(e.isInstancedBufferAttribute?e.isStorageInstancedBufferAttribute=!0:e.isStorageBufferAttribute=!0)}getHash(e){if(this.bufferCount===0){let t=e.globalCache.getData(this.value);return t===void 0&&(t={node:this},e.globalCache.setData(this.value,t)),t.node.uuid}return this.uuid}getInputType(){return this.value.isIndirectStorageBufferAttribute?"indirectStorageBuffer":"storageBuffer"}element(e){return Nj(this,e)}setPBO(e){return this.isPBO=e,this}getPBO(){return this.isPBO}setAccess(e){return this.access=e,this}toReadOnly(){return this.setAccess(ar.READ_ONLY)}setAtomic(e){return this.isAtomic=e,this}toAtomic(){return this.setAtomic(!0)}getAttributeData(){return this._attribute===null&&(this._attribute=yh(this.value),this._varying=Ao(this._attribute)),{attribute:this._attribute,varying:this._varying}}getNodeType(e){if(this.structTypeNode!==null)return this.structTypeNode.getNodeType(e);if(e.isAvailable("storageBuffer")||e.isAvailable("indirectStorageBuffer"))return super.getNodeType(e);const{attribute:t}=this.getAttributeData();return t.getNodeType(e)}getMemberType(e,t){return this.structTypeNode!==null?this.structTypeNode.getMemberType(e,t):"void"}generate(e){if(this.structTypeNode!==null&&this.structTypeNode.build(e),e.isAvailable("storageBuffer")||e.isAvailable("indirectStorageBuffer"))return super.generate(e);const{attribute:t,varying:s}=this.getAttributeData(),r=s.build(e);return e.registerTransform(r,t),r}}const Hl=(i,e=null,t=0)=>De(new Fj(i,e,t)),Rj=(i,e,t)=>(console.warn('THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.'),Hl(i,e,t).setPBO(!0)),w2=new WeakMap;class tO extends Ft{static get type(){return"SkinningNode"}constructor(e){super("void"),this.skinnedMesh=e,this.updateType=Kt.OBJECT,this.skinIndexNode=ra("skinIndex","uvec4"),this.skinWeightNode=ra("skinWeight","vec4"),this.bindMatrixNode=Os("bindMatrix","mat4"),this.bindMatrixInverseNode=Os("bindMatrixInverse","mat4"),this.boneMatricesNode=pb("skeleton.boneMatrices","mat4",e.skeleton.bones.length),this.positionNode=di,this.toPositionNode=di,this.previousBoneMatricesNode=null}getSkinnedPosition(e=this.boneMatricesNode,t=this.positionNode){const{skinIndexNode:s,skinWeightNode:r,bindMatrixNode:n,bindMatrixInverseNode:o}=this,a=e.element(s.x),l=e.element(s.y),u=e.element(s.z),c=e.element(s.w),d=n.mul(t),h=Ri(a.mul(r.x).mul(d),l.mul(r.y).mul(d),u.mul(r.z).mul(d),c.mul(r.w).mul(d));return o.mul(h).xyz}getSkinnedNormal(e=this.boneMatricesNode,t=Dr){const{skinIndexNode:s,skinWeightNode:r,bindMatrixNode:n,bindMatrixInverseNode:o}=this,a=e.element(s.x),l=e.element(s.y),u=e.element(s.z),c=e.element(s.w);let d=Ri(r.x.mul(a),r.y.mul(l),r.z.mul(u),r.w.mul(c));return d=o.mul(d).mul(n),d.transformDirection(t).xyz}getPreviousSkinnedPosition(e){const t=e.object;return this.previousBoneMatricesNode===null&&(t.skeleton.previousBoneMatrices=new Float32Array(t.skeleton.boneMatrices),this.previousBoneMatricesNode=pb("skeleton.previousBoneMatrices","mat4",t.skeleton.bones.length)),this.getSkinnedPosition(this.previousBoneMatricesNode,om)}needsPreviousBoneMatrices(e){const t=e.renderer.getMRT();return t&&t.has("velocity")||uk(e.object).useVelocity===!0}setup(e){this.needsPreviousBoneMatrices(e)&&om.assign(this.getPreviousSkinnedPosition(e));const t=this.getSkinnedPosition();if(this.toPositionNode&&this.toPositionNode.assign(t),e.hasGeometryAttribute("normal")){const s=this.getSkinnedNormal();Dr.assign(s),e.hasGeometryAttribute("tangent")&&Mh.assign(s)}return t}generate(e,t){if(t!=="void")return super.generate(e,t)}update(e){const t=e.object&&e.object.skeleton?e.object.skeleton:this.skinnedMesh.skeleton;w2.get(t)!==e.frameId&&(w2.set(t,e.frameId),this.previousBoneMatricesNode!==null&&t.previousBoneMatrices.set(t.boneMatrices),t.update())}}const sO=i=>De(new tO(i)),Ij=(i,e=null)=>{const t=new tO(i);return t.positionNode=Hl(new ac(i.geometry.getAttribute("position").array,3),"vec3").setPBO(!0).toReadOnly().element(Ba).toVar(),t.skinIndexNode=Hl(new ac(new Uint32Array(i.geometry.getAttribute("skinIndex").array),4),"uvec4").setPBO(!0).toReadOnly().element(Ba).toVar(),t.skinWeightNode=Hl(new ac(i.geometry.getAttribute("skinWeight").array,4),"vec4").setPBO(!0).toReadOnly().element(Ba).toVar(),t.bindMatrixNode=Et(i.bindMatrix,"mat4"),t.bindMatrixInverseNode=Et(i.bindMatrixInverse,"mat4"),t.boneMatricesNode=xh(i.skeleton.boneMatrices,"mat4",i.skeleton.bones.length),t.toPositionNode=e,De(t)};class Dj extends Ft{static get type(){return"LoopNode"}constructor(e=[]){super(),this.params=e}getVarName(e){return String.fromCharCode(105+e)}getProperties(e){const t=e.getNodeProperties(this);if(t.stackNode!==void 0)return t;const s={};for(let o=0,a=this.params.length-1;o<a;o++){const l=this.params[o],u=l.isNode!==!0&&l.name||this.getVarName(o),c=l.isNode!==!0&&l.type||"int";s[u]=ia(u,c)}const r=e.addStack();t.returnsNode=this.params[this.params.length-1](s,e),t.stackNode=r;const n=this.params[0];return n.isNode!==!0&&typeof n.update=="function"&&(t.updateNode=ge(this.params[0].update)(s)),e.removeStack(),t}getNodeType(e){const{returnsNode:t}=this.getProperties(e);return t?t.getNodeType(e):"void"}setup(e){this.getProperties(e)}generate(e){const t=this.getProperties(e),s=this.params,r=t.stackNode;for(let a=0,l=s.length-1;a<l;a++){const u=s[a];let c=!1,d=null,h=null,p=null,f=null,m=null,x=null;u.isNode?u.getNodeType(e)==="bool"?(c=!0,f="bool",h=u.build(e,f)):(f="int",p=this.getVarName(a),d="0",h=u.build(e,f),m="<"):(f=u.type||"int",p=u.name||this.getVarName(a),d=u.start,h=u.end,m=u.condition,x=u.update,typeof d=="number"?d=e.generateConst(f,d):d&&d.isNode&&(d=d.build(e,f)),typeof h=="number"?h=e.generateConst(f,h):h&&h.isNode&&(h=h.build(e,f)),d!==void 0&&h===void 0?(d=d+" - 1",h="0",m=">="):h!==void 0&&d===void 0&&(d="0",m="<"),m===void 0&&(Number(d)>Number(h)?m=">=":m="<"));let g;if(c)g=`while ( ${h} )`;else{const _={start:d,end:h},S=_.start,M=_.end;let w;const v=()=>m.includes("<")?"+=":"-=";if(x!=null)switch(typeof x){case"function":w=e.flowStagesNode(t.updateNode,"void").code.replace(/\t|;/g,"");break;case"number":w=p+" "+v()+" "+e.generateConst(f,x);break;case"string":w=p+" "+x;break;default:x.isNode?w=p+" "+v()+" "+x.build(e):(console.error("THREE.TSL: 'Loop( { update: ... } )' is not a function, string or number."),w="break /* invalid update */")}else f==="int"||f==="uint"?x=m.includes("<")?"++":"--":x=v()+" 1.",w=p+" "+x;const T=e.getVar(f,p)+" = "+S,E=p+" "+m+" "+M;g=`for ( ${T}; ${E}; ${w} )`}e.addFlowCode((a===0?`
`:"")+e.tab+g+` {

`).addFlowTab()}const n=r.build(e,"void"),o=t.returnsNode?t.returnsNode.build(e):"";e.removeFlowTab().addFlowCode(`
`+e.tab+n);for(let a=0,l=this.params.length-1;a<l;a++)e.addFlowCode((a===0?"":e.tab)+`}

`).removeFlowTab();return e.addFlowTab(),o}}const Rs=(...i)=>De(new Dj(Gl(i,"int"))).toStack(),kj=()=>ia("continue").toStack(),iO=()=>ia("break").toStack(),By=new WeakMap,Ur=new ns,M2=ge(({bufferMap:i,influence:e,stride:t,width:s,depth:r,offset:n})=>{const o=ne(YB).mul(t).add(n),a=o.div(s),l=o.sub(a.mul(s));return ci(i,Vi(l,a)).depth(r).xyz.mul(e)});function Lj(i){const e=i.morphAttributes.position!==void 0,t=i.morphAttributes.normal!==void 0,s=i.morphAttributes.color!==void 0,r=i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color,n=r!==void 0?r.length:0;let o=By.get(i);if(o===void 0||o.count!==n){let g=function(){m.dispose(),By.delete(i),i.removeEventListener("dispose",g)};o!==void 0&&o.texture.dispose();const a=i.morphAttributes.position||[],l=i.morphAttributes.normal||[],u=i.morphAttributes.color||[];let c=0;e===!0&&(c=1),t===!0&&(c=2),s===!0&&(c=3);let d=i.attributes.position.count*c,h=1;const p=4096;d>p&&(h=Math.ceil(d/p),d=p);const f=new Float32Array(d*h*4*n),m=new TU(f,d,h,n);m.type=Kr,m.needsUpdate=!0;const x=c*4;for(let _=0;_<n;_++){const S=a[_],M=l[_],w=u[_],v=d*h*4*_;for(let T=0;T<S.count;T++){const E=T*x;e===!0&&(Ur.fromBufferAttribute(S,T),f[v+E+0]=Ur.x,f[v+E+1]=Ur.y,f[v+E+2]=Ur.z,f[v+E+3]=0),t===!0&&(Ur.fromBufferAttribute(M,T),f[v+E+4]=Ur.x,f[v+E+5]=Ur.y,f[v+E+6]=Ur.z,f[v+E+7]=0),s===!0&&(Ur.fromBufferAttribute(w,T),f[v+E+8]=Ur.x,f[v+E+9]=Ur.y,f[v+E+10]=Ur.z,f[v+E+11]=w.itemSize===4?Ur.w:1)}}o={count:n,texture:m,stride:c,size:new Dt(d,h)},By.set(i,o),i.addEventListener("dispose",g)}return o}class Bj extends Ft{static get type(){return"MorphNode"}constructor(e){super("void"),this.mesh=e,this.morphBaseInfluence=Et(1),this.updateType=Kt.OBJECT}setup(e){const{geometry:t}=e,s=t.morphAttributes.position!==void 0,r=t.hasAttribute("normal")&&t.morphAttributes.normal!==void 0,n=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,o=n!==void 0?n.length:0,{texture:a,stride:l,size:u}=Lj(t);s===!0&&di.mulAssign(this.morphBaseInfluence),r===!0&&Dr.mulAssign(this.morphBaseInfluence);const c=ne(u.width);Rs(o,({i:d})=>{const h=Y(0).toVar();this.mesh.count>1&&this.mesh.morphTexture!==null&&this.mesh.morphTexture!==void 0?h.assign(ci(this.mesh.morphTexture,Vi(ne(d).add(1),ne(Ba))).r):h.assign(Os("morphTargetInfluences","float").element(d).toVar()),Ht(h.notEqual(0),()=>{s===!0&&di.addAssign(M2({bufferMap:a,influence:h,stride:l,width:c,depth:d,offset:ne(0)})),r===!0&&Dr.addAssign(M2({bufferMap:a,influence:h,stride:l,width:c,depth:d,offset:ne(1)}))})})}update(){const e=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?e.value=1:e.value=1-this.mesh.morphTargetInfluences.reduce((t,s)=>t+s,0)}}const rO=ze(Bj).setParameterLength(1);class Ac extends Ft{static get type(){return"LightingNode"}constructor(){super("vec3"),this.isLightingNode=!0}}class Oj extends Ac{static get type(){return"AONode"}constructor(e=null){super(),this.aoNode=e}setup(e){e.context.ambientOcclusion.mulAssign(this.aoNode)}}class $j extends vL{static get type(){return"LightingContextNode"}constructor(e,t=null,s=null,r=null){super(e),this.lightingModel=t,this.backdropNode=s,this.backdropAlphaNode=r,this._value=null}getContext(){const{backdropNode:e,backdropAlphaNode:t}=this,s=pe().toVar("directDiffuse"),r=pe().toVar("directSpecular"),n=pe().toVar("indirectDiffuse"),o=pe().toVar("indirectSpecular"),a={directDiffuse:s,directSpecular:r,indirectDiffuse:n,indirectSpecular:o};return{radiance:pe().toVar("radiance"),irradiance:pe().toVar("irradiance"),iblIrradiance:pe().toVar("iblIrradiance"),ambientOcclusion:Y(1).toVar("ambientOcclusion"),reflectedLight:a,backdrop:e,backdropAlpha:t}}setup(e){return this.value=this._value||(this._value=this.getContext()),this.value.lightingModel=this.lightingModel||e.context.lightingModel,super.setup(e)}}const nO=ze($j);class zj extends Ac{static get type(){return"IrradianceNode"}constructor(e){super(),this.node=e}setup(e){e.context.irradiance.addAssign(this.node)}}let _d,yd;class Ni extends Ft{static get type(){return"ScreenNode"}constructor(e){super(),this.scope=e,this.isViewportNode=!0}getNodeType(){return this.scope===Ni.VIEWPORT?"vec4":"vec2"}getUpdateType(){let e=Kt.NONE;return(this.scope===Ni.SIZE||this.scope===Ni.VIEWPORT)&&(e=Kt.RENDER),this.updateType=e,e}update({renderer:e}){const t=e.getRenderTarget();this.scope===Ni.VIEWPORT?t!==null?yd.copy(t.viewport):(e.getViewport(yd),yd.multiplyScalar(e.getPixelRatio())):t!==null?(_d.width=t.width,_d.height=t.height):e.getDrawingBufferSize(_d)}setup(){const e=this.scope;let t=null;return e===Ni.SIZE?t=Et(_d||(_d=new Dt)):e===Ni.VIEWPORT?t=Et(yd||(yd=new ns)):t=Ge(Th.div(dh)),t}generate(e){if(this.scope===Ni.COORDINATE){let t=e.getFragCoord();if(e.isFlipY()){const s=e.getNodeProperties(dh).outputNode.build(e);t=`${e.getType("vec2")}( ${t}.x, ${s}.y - ${t}.y )`}return t}return super.generate(e)}}Ni.COORDINATE="coordinate";Ni.VIEWPORT="viewport";Ni.SIZE="size";Ni.UV="uv";const Jo=ot(Ni,Ni.UV),dh=ot(Ni,Ni.SIZE),Th=ot(Ni,Ni.COORDINATE),cc=ot(Ni,Ni.VIEWPORT),oO=cc.zw,aO=Th.sub(cc.xy),Vj=aO.div(oO),Uj=ge(()=>(console.warn('THREE.TSL: "viewportResolution" is deprecated. Use "screenSize" instead.'),dh),"vec2").once()(),xd=new Dt;class $m extends To{static get type(){return"ViewportTextureNode"}constructor(e=Jo,t=null,s=null){s===null&&(s=new tk,s.minFilter=qo),super(s,e,t),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=Kt.FRAME}updateBefore(e){const t=e.renderer;t.getDrawingBufferSize(xd);const s=this.value;(s.image.width!==xd.width||s.image.height!==xd.height)&&(s.image.width=xd.width,s.image.height=xd.height,s.needsUpdate=!0);const r=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,t.copyFramebufferToTexture(s),s.generateMipmaps=r}clone(){const e=new this.constructor(this.uvNode,this.levelNode,this.value);return e.generateMipmaps=this.generateMipmaps,e}}const Gj=ze($m).setParameterLength(0,3),mw=ze($m,null,null,{generateMipmaps:!0}).setParameterLength(0,3);let Oy=null;class jj extends $m{static get type(){return"ViewportDepthTextureNode"}constructor(e=Jo,t=null){Oy===null&&(Oy=new Hn),super(e,t,Oy)}}const gw=ze(jj).setParameterLength(0,2);class Nr extends Ft{static get type(){return"ViewportDepthNode"}constructor(e,t=null){super("float"),this.scope=e,this.valueNode=t,this.isViewportDepthNode=!0}generate(e){const{scope:t}=this;return t===Nr.DEPTH_BASE?e.getFragDepth():super.generate(e)}setup({camera:e}){const{scope:t}=this,s=this.valueNode;let r=null;if(t===Nr.DEPTH_BASE)s!==null&&(r=uO().assign(s));else if(t===Nr.DEPTH)e.isPerspectiveCamera?r=lO(hi.z,Pa,Na):r=dc(hi.z,Pa,Na);else if(t===Nr.LINEAR_DEPTH)if(s!==null)if(e.isPerspectiveCamera){const n=_w(s,Pa,Na);r=dc(n,Pa,Na)}else r=s;else r=dc(hi.z,Pa,Na);return r}}Nr.DEPTH_BASE="depthBase";Nr.DEPTH="depth";Nr.LINEAR_DEPTH="linearDepth";const dc=(i,e,t)=>i.add(e).div(e.sub(t)),Wj=(i,e,t)=>e.sub(t).mul(i).sub(e),lO=(i,e,t)=>e.add(i).mul(t).div(t.sub(e).mul(i)),_w=(i,e,t)=>e.mul(t).div(t.sub(e).mul(i).sub(t)),yw=(i,e,t)=>{e=e.max(1e-6).toVar();const s=mo(i.negate().div(e)),r=mo(t.div(e));return s.div(r)},Hj=(i,e,t)=>{const s=i.mul(Am(t.div(e)));return Y(Math.E).pow(s).mul(e).negate()},uO=ze(Nr,Nr.DEPTH_BASE),xw=ot(Nr,Nr.DEPTH),am=ze(Nr,Nr.LINEAR_DEPTH).setParameterLength(0,1),qj=am(gw());xw.assign=i=>uO(i);class yn extends Ft{static get type(){return"ClippingNode"}constructor(e=yn.DEFAULT){super(),this.scope=e}setup(e){super.setup(e);const t=e.clippingContext,{intersectionPlanes:s,unionPlanes:r}=t;return this.hardwareClipping=e.material.hardwareClipping,this.scope===yn.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(s,r):this.scope===yn.HARDWARE?this.setupHardwareClipping(r,e):this.setupDefault(s,r)}setupAlphaToCoverage(e,t){return ge(()=>{const s=Y().toVar("distanceToPlane"),r=Y().toVar("distanceToGradient"),n=Y(1).toVar("clipOpacity"),o=t.length;if(this.hardwareClipping===!1&&o>0){const l=pn(t);Rs(o,({i:u})=>{const c=l.element(u);s.assign(hi.dot(c.xyz).negate().add(c.w)),r.assign(s.fwidth().div(2)),n.mulAssign(Mo(r.negate(),r,s))})}const a=e.length;if(a>0){const l=pn(e),u=Y(1).toVar("intersectionClipOpacity");Rs(a,({i:c})=>{const d=l.element(c);s.assign(hi.dot(d.xyz).negate().add(d.w)),r.assign(s.fwidth().div(2)),u.mulAssign(Mo(r.negate(),r,s).oneMinus())}),n.mulAssign(u.oneMinus())}ws.a.mulAssign(n),ws.a.equal(0).discard()})()}setupDefault(e,t){return ge(()=>{const s=t.length;if(this.hardwareClipping===!1&&s>0){const n=pn(t);Rs(s,({i:o})=>{const a=n.element(o);hi.dot(a.xyz).greaterThan(a.w).discard()})}const r=e.length;if(r>0){const n=pn(e),o=bo(!0).toVar("clipped");Rs(r,({i:a})=>{const l=n.element(a);o.assign(hi.dot(l.xyz).greaterThan(l.w).and(o))}),o.discard()}})()}setupHardwareClipping(e,t){const s=e.length;return t.enableHardwareClipping(s),ge(()=>{const r=pn(e),n=bh(t.getClipDistance());Rs(s,({i:o})=>{const a=r.element(o),l=hi.dot(a.xyz).sub(a.w).negate();n.element(o).assign(l)})})()}}yn.ALPHA_TO_COVERAGE="alphaToCoverage";yn.DEFAULT="default";yn.HARDWARE="hardware";const Kj=()=>De(new yn),Xj=()=>De(new yn(yn.ALPHA_TO_COVERAGE)),Yj=()=>De(new yn(yn.HARDWARE)),Qj=.05,T2=ge(([i])=>la(Wt(1e4,qr(Wt(17,i.x).add(Wt(.1,i.y)))).mul(Ri(.1,Us(qr(Wt(13,i.y).add(i.x))))))),v2=ge(([i])=>T2(Ge(T2(i.xy),i.z))),Zj=ge(([i])=>{const e=ni(_o(q0(i.xyz)),_o(K0(i.xyz))),t=Y(1).div(Y(Qj).mul(e)).toVar("pixScale"),s=Ge(xc(go(mo(t))),xc(Cm(mo(t)))),r=Ge(v2(go(s.x.mul(i.xyz))),v2(go(s.y.mul(i.xyz)))),n=la(mo(t)),o=Ri(Wt(n.oneMinus(),r.x),Wt(n,r.y)),a=Ir(n,n.oneMinus()),l=pe(o.mul(o).div(Wt(2,a).mul(us(1,a))),o.sub(Wt(.5,a)).div(us(1,a)),us(1,us(1,o).mul(us(1,o)).div(Wt(2,a).mul(us(1,a))))),u=o.lessThan(a.oneMinus()).select(o.lessThan(a).select(l.x,l.y),l.z);return wo(u,1e-6,1)}).setLayout({name:"getAlphaHashThreshold",type:"float",inputs:[{name:"position",type:"vec3"}]});class Jj extends HL{static get type(){return"VertexColorNode"}constructor(e){super(null,"vec4"),this.isVertexColorNode=!0,this.index=e}getAttributeName(){const e=this.index;return"color"+(e>0?e:"")}generate(e){const t=this.getAttributeName(e),s=e.hasGeometryAttribute(t);let r;return s===!0?r=super.generate(e):r=e.generateConst(this.nodeType,new ns(1,1,1,1)),r}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}const cO=(i=0)=>De(new Jj(i)),dO=ge(([i,e])=>Ir(1,i.oneMinus().div(e)).oneMinus()).setLayout({name:"blendBurn",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),hO=ge(([i,e])=>Ir(i.div(e.oneMinus()),1)).setLayout({name:"blendDodge",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),pO=ge(([i,e])=>i.oneMinus().mul(e.oneMinus()).oneMinus()).setLayout({name:"blendScreen",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),fO=ge(([i,e])=>Cs(i.mul(2).mul(e),i.oneMinus().mul(2).mul(e.oneMinus()).oneMinus(),Pm(.5,i))).setLayout({name:"blendOverlay",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),eW=ge(([i,e])=>{const t=e.a.add(i.a.mul(e.a.oneMinus()));return St(e.rgb.mul(e.a).add(i.rgb.mul(i.a).mul(e.a.oneMinus())).div(t),t)}).setLayout({name:"blendColor",type:"vec4",inputs:[{name:"base",type:"vec4"},{name:"blend",type:"vec4"}]}),mO=ge(([i])=>St(i.rgb.mul(i.a),i.a),{color:"vec4",return:"vec4"}),tW=ge(([i])=>(Ht(i.a.equal(0),()=>St(0)),St(i.rgb.div(i.a),i.a)),{color:"vec4",return:"vec4"}),sW=(...i)=>(console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.'),dO(i)),iW=(...i)=>(console.warn('THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.'),hO(i)),rW=(...i)=>(console.warn('THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.'),pO(i)),nW=(...i)=>(console.warn('THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.'),fO(i));class pi extends Rr{static get type(){return"NodeMaterial"}get type(){return this.constructor.type}set type(e){}constructor(){super(),this.isNodeMaterial=!0,this.fog=!0,this.lights=!1,this.hardwareClipping=!1,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.maskNode=null,this.positionNode=null,this.geometryNode=null,this.depthNode=null,this.receivedShadowPositionNode=null,this.castShadowPositionNode=null,this.receivedShadowNode=null,this.castShadowNode=null,this.outputNode=null,this.mrtNode=null,this.fragmentNode=null,this.vertexNode=null,Object.defineProperty(this,"shadowPositionNode",{get:()=>this.receivedShadowPositionNode,set:e=>{console.warn('THREE.NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".'),this.receivedShadowPositionNode=e}})}customProgramCacheKey(){return this.type+nk(this)}build(e){this.setup(e)}setupObserver(e){return new I4(e)}setup(e){e.context.setupNormal=()=>uc(this.setupNormal(e),"NORMAL","vec3"),e.context.setupPositionView=()=>this.setupPositionView(e),e.context.setupModelViewProjection=()=>this.setupModelViewProjection(e);const t=e.renderer,s=t.getRenderTarget();e.addStack();const r=uc(this.setupVertex(e),"VERTEX"),n=this.vertexNode||r;e.stack.outputNode=n,this.setupHardwareClipping(e),this.geometryNode!==null&&(e.stack.outputNode=e.stack.outputNode.bypass(this.geometryNode)),e.addFlow("vertex",e.removeStack()),e.addStack();let o;const a=this.setupClipping(e);if((this.depthWrite===!0||this.depthTest===!0)&&(s!==null?s.depthBuffer===!0&&this.setupDepth(e):t.depth===!0&&this.setupDepth(e)),this.fragmentNode===null){this.setupDiffuseColor(e),this.setupVariants(e);const l=this.setupLighting(e);a!==null&&e.stack.add(a);const u=St(l,ws.a).max(0);o=this.setupOutput(e,u),lc.assign(o);const c=this.outputNode!==null;if(c&&(o=this.outputNode),s!==null){const d=t.getMRT(),h=this.mrtNode;d!==null?(c&&lc.assign(o),o=d,h!==null&&(o=d.merge(h))):h!==null&&(o=h)}}else{let l=this.fragmentNode;l.isOutputStructNode!==!0&&(l=St(l)),o=this.setupOutput(e,l)}e.stack.outputNode=o,e.addFlow("fragment",e.removeStack()),e.observer=this.setupObserver(e)}setupClipping(e){if(e.clippingContext===null)return null;const{unionPlanes:t,intersectionPlanes:s}=e.clippingContext;let r=null;if(t.length>0||s.length>0){const n=e.renderer.samples;this.alphaToCoverage&&n>1?r=Xj():e.stack.add(Kj())}return r}setupHardwareClipping(e){if(this.hardwareClipping=!1,e.clippingContext===null)return;const t=e.clippingContext.unionPlanes.length;t>0&&t<=8&&e.isAvailable("clipDistance")&&(e.stack.add(Yj()),this.hardwareClipping=!0)}setupDepth(e){const{renderer:t,camera:s}=e;let r=this.depthNode;if(r===null){const n=t.getMRT();n&&n.has("depth")?r=n.get("depth"):t.logarithmicDepthBuffer===!0&&(s.isPerspectiveCamera?r=yw(hi.z,Pa,Na):r=dc(hi.z,Pa,Na))}r!==null&&xw.assign(r).toStack()}setupPositionView(){return ru.mul(di).xyz}setupModelViewProjection(){return iu.mul(hi)}setupVertex(e){return e.addStack(),this.setupPosition(e),e.context.vertex=e.removeStack(),fw}setupPosition(e){const{object:t,geometry:s}=e;if((s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color)&&rO(t).toStack(),t.isSkinnedMesh===!0&&sO(t).toStack(),this.displacementMap){const r=jo("displacementMap","texture"),n=jo("displacementScale","float"),o=jo("displacementBias","float");di.addAssign(Dr.normalize().mul(r.x.mul(n).add(o)))}return t.isBatchedMesh&&eO(t).toStack(),t.isInstancedMesh&&t.instanceMatrix&&t.instanceMatrix.isInstancedBufferAttribute===!0&&JB(t).toStack(),this.positionNode!==null&&di.assign(uc(this.positionNode,"POSITION","vec3")),di}setupDiffuseColor({object:e,geometry:t}){this.maskNode!==null&&bo(this.maskNode).not().discard();let s=this.colorNode?St(this.colorNode):bB;this.vertexColors===!0&&t.hasAttribute("color")&&(s=s.mul(cO())),e.instanceColor&&(s=oh("vec3","vInstanceColor").mul(s)),e.isBatchedMesh&&e._colorsTexture&&(s=oh("vec3","vBatchColor").mul(s)),ws.assign(s);const r=this.opacityNode?Y(this.opacityNode):hw;ws.a.assign(ws.a.mul(r));let n=null;(this.alphaTestNode!==null||this.alphaTest>0)&&(n=this.alphaTestNode!==null?Y(this.alphaTestNode):xB,ws.a.lessThanEqual(n).discard()),this.alphaHash===!0&&ws.a.lessThan(Zj(di)).discard(),this.transparent===!1&&this.blending===Ho&&this.alphaToCoverage===!1?ws.a.assign(1):n===null&&ws.a.lessThanEqual(0).discard()}setupVariants(){}setupOutgoingLight(){return this.lights===!0?pe(0):ws.rgb}setupNormal(){return this.normalNode?pe(this.normalNode):AB}setupEnvironment(){let e=null;return this.envNode?e=this.envNode:this.envMap&&(e=this.envMap.isCubeTexture?jo("envMap","cubeTexture"):jo("envMap","texture")),e}setupLightMap(e){let t=null;return e.material.lightMap&&(t=new zj(pw)),t}setupLights(e){const t=[],s=this.setupEnvironment(e);s&&s.isLightingNode&&t.push(s);const r=this.setupLightMap(e);if(r&&r.isLightingNode&&t.push(r),this.aoNode!==null||e.material.aoMap){const o=this.aoNode!==null?this.aoNode:XB;t.push(new Oj(o))}let n=this.lightsNode||e.lightsNode;return t.length>0&&(n=e.renderer.lighting.createNode([...n.getLights(),...t])),n}setupLightingModel(){}setupLighting(e){const{material:t}=e,{backdropNode:s,backdropAlphaNode:r,emissiveNode:n}=this,a=this.lights===!0||this.lightsNode!==null?this.setupLights(e):null;let l=this.setupOutgoingLight(e);if(a&&a.getScope().hasLights){const u=this.setupLightingModel(e)||null;l=nO(a,u,s,r)}else s!==null&&(l=pe(r!==null?Cs(l,s,r):s));return(n&&n.isNode===!0||t.emissive&&t.emissive.isColor===!0)&&(lb.assign(pe(n||MB)),l=l.add(lb)),l}setupFog(e,t){const s=e.fogNode;return s&&(lc.assign(t),t=St(s)),t}setupPremultipliedAlpha(e,t){return mO(t)}setupOutput(e,t){return this.fog===!0&&(t=this.setupFog(e,t)),this.premultipliedAlpha===!0&&(t=this.setupPremultipliedAlpha(e,t)),t}setDefaultValues(e){for(const s in e){const r=e[s];this[s]===void 0&&(this[s]=r,r&&r.clone&&(this[s]=r.clone()))}const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const s in t)Object.getOwnPropertyDescriptor(this.constructor.prototype,s)===void 0&&t[s].get!==void 0&&Object.defineProperty(this.constructor.prototype,s,t[s])}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{},nodes:{}});const s=Rr.prototype.toJSON.call(this,e),r=Zf(this);s.inputNodes={};for(const{property:o,childNode:a}of r)s.inputNodes[o]=a.toJSON(e).uuid;function n(o){const a=[];for(const l in o){const u=o[l];delete u.metadata,a.push(u)}return a}if(t){const o=n(e.textures),a=n(e.images),l=n(e.nodes);o.length>0&&(s.textures=o),a.length>0&&(s.images=a),l.length>0&&(s.nodes=l)}return s}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.maskNode=e.maskNode,this.positionNode=e.positionNode,this.geometryNode=e.geometryNode,this.depthNode=e.depthNode,this.receivedShadowPositionNode=e.receivedShadowPositionNode,this.castShadowPositionNode=e.castShadowPositionNode,this.receivedShadowNode=e.receivedShadowNode,this.castShadowNode=e.castShadowNode,this.outputNode=e.outputNode,this.mrtNode=e.mrtNode,this.fragmentNode=e.fragmentNode,this.vertexNode=e.vertexNode,super.copy(e)}}const oW=new ek;class aW extends pi{static get type(){return"LineBasicNodeMaterial"}constructor(e){super(),this.isLineBasicNodeMaterial=!0,this.setDefaultValues(oW),this.setValues(e)}}const lW=new r4;class uW extends pi{static get type(){return"LineDashedNodeMaterial"}constructor(e){super(),this.isLineDashedNodeMaterial=!0,this.setDefaultValues(lW),this.dashOffset=0,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setupVariants(){const e=this.offsetNode?Y(this.offsetNode):HB,t=this.dashScaleNode?Y(this.dashScaleNode):GB,s=this.dashSizeNode?Y(this.dashSizeNode):jB,r=this.gapSizeNode?Y(this.gapSizeNode):WB;Af.assign(s),ub.assign(r);const n=Ao(ra("lineDistance").mul(t));(e?n.add(e):n).mod(Af.add(ub)).greaterThan(Af).discard()}}let $y=null;class cW extends $m{static get type(){return"ViewportSharedTextureNode"}constructor(e=Jo,t=null){$y===null&&($y=new tk),super(e,t,$y)}updateReference(){return this}}const dW=ze(cW).setParameterLength(0,2),gO=i=>De(i).mul(.5).add(.5),hW=i=>De(i).mul(2).sub(1),pW=new t4;class fW extends pi{static get type(){return"MeshNormalNodeMaterial"}constructor(e){super(),this.isMeshNormalNodeMaterial=!0,this.setDefaultValues(pW),this.setValues(e)}setupDiffuseColor(){const e=this.opacityNode?Y(this.opacityNode):hw;ws.assign(Rm(St(gO(Fs),e),jr))}}const bw=ge(([i=aw])=>{const e=i.z.atan(i.x).mul(1/(Math.PI*2)).add(.5),t=i.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return Ge(e,t)});class _O extends VU{constructor(e=1,t={}){super(e,t),this.isCubeRenderTarget=!0}fromEquirectangularTexture(e,t){const s=t.minFilter,r=t.generateMipmaps;t.generateMipmaps=!0,this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n=new fh(5,5,5),o=bw(aw),a=new pi;a.colorNode=ts(t,o,0),a.side=lr,a.blending=fc;const l=new bn(n,a),u=new mh;u.add(l),t.minFilter===qo&&(t.minFilter=wr);const c=new ZD(1,10,this),d=e.getMRT();return e.setMRT(null),c.update(e,u),e.setMRT(d),t.minFilter=s,t.currentGenerateMipmaps=r,l.geometry.dispose(),l.material.dispose(),this}}const Xd=new WeakMap;class mW extends Ii{static get type(){return"CubeMapNode"}constructor(e){super("vec3"),this.envNode=e,this._cubeTexture=null,this._cubeTextureNode=wc(null);const t=new mm;t.isRenderTargetTexture=!0,this._defaultTexture=t,this.updateBeforeType=Kt.RENDER}updateBefore(e){const{renderer:t,material:s}=e,r=this.envNode;if(r.isTextureNode||r.isMaterialReferenceNode){const n=r.isTextureNode?r.value:s[r.property];if(n&&n.isTexture){const o=n.mapping;if(o===l0||o===u0){if(Xd.has(n)){const a=Xd.get(n);S2(a,n.mapping),this._cubeTexture=a}else{const a=n.image;if(gW(a)){const l=new _O(a.height);l.fromEquirectangularTexture(t,n),S2(l.texture,n.mapping),this._cubeTexture=l.texture,Xd.set(n,l.texture),n.addEventListener("dispose",yO)}else this._cubeTexture=this._defaultTexture}this._cubeTextureNode.value=this._cubeTexture}else this._cubeTextureNode=this.envNode}}}setup(e){return this.updateBefore(e),this._cubeTextureNode}}function gW(i){return i==null?!1:i.height>0}function yO(i){const e=i.target;e.removeEventListener("dispose",yO);const t=Xd.get(e);t!==void 0&&(Xd.delete(e),t.dispose())}function S2(i,e){e===l0?i.mapping=th:e===u0&&(i.mapping=Kf)}const xO=ze(mW).setParameterLength(1);class ww extends Ac{static get type(){return"BasicEnvironmentNode"}constructor(e=null){super(),this.envNode=e}setup(e){e.context.environment=xO(this.envNode)}}class _W extends Ac{static get type(){return"BasicLightMapNode"}constructor(e=null){super(),this.lightMapNode=e}setup(e){const t=Y(1/Math.PI);e.context.irradianceLightMap=this.lightMapNode.mul(t)}}class zm{start(e){e.lightsNode.setupLights(e,e.lightsNode.getLightNodes(e)),this.indirect(e)}finish(){}direct(){}directRectArea(){}indirect(){}ambientOcclusion(){}}class bO extends zm{constructor(){super()}indirect({context:e}){const t=e.ambientOcclusion,s=e.reflectedLight,r=e.irradianceLightMap;s.indirectDiffuse.assign(St(0)),r?s.indirectDiffuse.addAssign(r):s.indirectDiffuse.addAssign(St(1,1,1,0)),s.indirectDiffuse.mulAssign(t),s.indirectDiffuse.mulAssign(ws.rgb)}finish(e){const{material:t,context:s}=e,r=s.outgoingLight,n=e.context.environment;if(n)switch(t.combine){case pm:r.rgb.assign(Cs(r.rgb,r.rgb.mul(n.rgb),Kd.mul(Ff)));break;case EV:r.rgb.assign(Cs(r.rgb,n.rgb,Kd.mul(Ff)));break;case AV:r.rgb.addAssign(n.rgb.mul(Kd.mul(Ff)));break;default:console.warn("THREE.BasicLightingModel: Unsupported .combine value:",t.combine);break}}}const yW=new co;class wO extends pi{static get type(){return"MeshBasicNodeMaterial"}constructor(e){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!0,this.setDefaultValues(yW),this.setValues(e)}setupNormal(){return Ec(bc)}setupEnvironment(e){const t=super.setupEnvironment(e);return t?new ww(t):null}setupLightMap(e){let t=null;return e.material.lightMap&&(t=new _W(pw)),t}setupOutgoingLight(){return ws.rgb}setupLightingModel(){return new bO}}const Mc=ge(({f0:i,f90:e,dotVH:t})=>{const s=t.mul(-5.55473).sub(6.98316).mul(t).exp2();return i.mul(s.oneMinus()).add(e.mul(s))}),Ql=ge(i=>i.diffuseColor.mul(1/Math.PI)),xW=()=>Y(.25),bW=ge(({dotNH:i})=>sm.mul(Y(.5)).add(1).mul(Y(1/Math.PI)).mul(i.pow(sm))),wW=ge(({lightDirection:i})=>{const e=i.add(Ks).normalize(),t=Fs.dot(e).clamp(),s=Ks.dot(e).clamp(),r=Mc({f0:Er,f90:1,dotVH:s}),n=xW(),o=bW({dotNH:t});return r.mul(n).mul(o)});class MO extends bO{constructor(e=!0){super(),this.specular=e}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const n=Fs.dot(e).clamp().mul(t);s.directDiffuse.addAssign(n.mul(Ql({diffuseColor:ws.rgb}))),this.specular===!0&&s.directSpecular.addAssign(n.mul(wW({lightDirection:e})).mul(Kd))}indirect(e){const{ambientOcclusion:t,irradiance:s,reflectedLight:r}=e.context;r.indirectDiffuse.addAssign(s.mul(Ql({diffuseColor:ws}))),r.indirectDiffuse.mulAssign(t)}}const MW=new s4;class TW extends pi{static get type(){return"MeshLambertNodeMaterial"}constructor(e){super(),this.isMeshLambertNodeMaterial=!0,this.lights=!0,this.setDefaultValues(MW),this.setValues(e)}setupEnvironment(e){const t=super.setupEnvironment(e);return t?new ww(t):null}setupLightingModel(){return new MO(!1)}}const vW=new JU;class SW extends pi{static get type(){return"MeshPhongNodeMaterial"}constructor(e){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(vW),this.setValues(e)}setupEnvironment(e){const t=super.setupEnvironment(e);return t?new ww(t):null}setupLightingModel(){return new MO}setupVariants(){const e=(this.shininessNode?Y(this.shininessNode):wB).max(1e-4);sm.assign(e);const t=this.specularNode||TB;Er.assign(t)}copy(e){return this.shininessNode=e.shininessNode,this.specularNode=e.specularNode,super.copy(e)}}const TO=ge(i=>{if(i.geometry.hasAttribute("normal")===!1)return Y(0);const e=bc.dFdx().abs().max(bc.dFdy().abs());return e.x.max(e.y).max(e.z)}),Mw=ge(i=>{const{roughness:e}=i,t=TO();let s=e.max(.0525);return s=s.add(t),s=s.min(1),s}),vO=ge(({alpha:i,dotNL:e,dotNV:t})=>{const s=i.pow2(),r=e.mul(s.add(s.oneMinus().mul(t.pow2())).sqrt()),n=t.mul(s.add(s.oneMinus().mul(e.pow2())).sqrt());return wn(.5,r.add(n).max(Zk))}).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),EW=ge(({alphaT:i,alphaB:e,dotTV:t,dotBV:s,dotTL:r,dotBL:n,dotNV:o,dotNL:a})=>{const l=a.mul(pe(i.mul(t),e.mul(s),o).length()),u=o.mul(pe(i.mul(r),e.mul(n),a).length());return wn(.5,l.add(u)).saturate()}).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),SO=ge(({alpha:i,dotNH:e})=>{const t=i.pow2(),s=e.pow2().mul(t.oneMinus()).oneMinus();return t.div(s.pow2()).mul(1/Math.PI)}).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),AW=Y(1/Math.PI),CW=ge(({alphaT:i,alphaB:e,dotNH:t,dotTH:s,dotBH:r})=>{const n=i.mul(e),o=pe(e.mul(s),i.mul(r),n.mul(t)),a=o.dot(o),l=n.div(a);return AW.mul(n.mul(l.pow2()))}).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),yb=ge(({lightDirection:i,f0:e,f90:t,roughness:s,f:r,normalView:n=Fs,USE_IRIDESCENCE:o,USE_ANISOTROPY:a})=>{const l=s.pow2(),u=i.add(Ks).normalize(),c=n.dot(i).clamp(),d=n.dot(Ks).clamp(),h=n.dot(u).clamp(),p=Ks.dot(u).clamp();let f=Mc({f0:e,f90:t,dotVH:p}),m,x;if(rh(o)&&(f=vm.mix(f,r)),rh(a)){const g=Wd.dot(i),_=Wd.dot(Ks),S=Wd.dot(u),M=Wl.dot(i),w=Wl.dot(Ks),v=Wl.dot(u);m=EW({alphaT:tm,alphaB:l,dotTV:_,dotBV:w,dotTL:g,dotBL:M,dotNV:d,dotNL:c}),x=CW({alphaT:tm,alphaB:l,dotNH:h,dotTH:S,dotBH:v})}else m=vO({alpha:l,dotNL:c,dotNV:d}),x=SO({alpha:l,dotNH:h});return f.mul(m).mul(x)}),Tw=ge(({roughness:i,dotNV:e})=>{const t=St(-1,-.0275,-.572,.022),s=St(1,.0425,1.04,-.04),r=i.mul(t).add(s),n=r.x.mul(r.x).min(e.mul(-9.28).exp2()).mul(r.x).add(r.y);return Ge(-1.04,1.04).mul(n).add(r.zw)}).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),EO=ge(i=>{const{dotNV:e,specularColor:t,specularF90:s,roughness:r}=i,n=Tw({dotNV:e,roughness:r});return t.mul(n.x).add(s.mul(n.y))}),AO=ge(({f:i,f90:e,dotVH:t})=>{const s=t.oneMinus().saturate(),r=s.mul(s),n=s.mul(r,r).clamp(0,.9999);return i.sub(pe(e).mul(n)).div(n.oneMinus())}).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),PW=ge(({roughness:i,dotNH:e})=>{const t=i.pow2(),s=Y(1).div(t),n=e.pow2().oneMinus().max(.0078125);return Y(2).add(s).mul(n.pow(s.mul(.5))).div(2*Math.PI)}).setLayout({name:"D_Charlie",type:"float",inputs:[{name:"roughness",type:"float"},{name:"dotNH",type:"float"}]}),NW=ge(({dotNV:i,dotNL:e})=>Y(1).div(Y(4).mul(e.add(i).sub(e.mul(i))))).setLayout({name:"V_Neubelt",type:"float",inputs:[{name:"dotNV",type:"float"},{name:"dotNL",type:"float"}]}),FW=ge(({lightDirection:i})=>{const e=i.add(Ks).normalize(),t=Fs.dot(i).clamp(),s=Fs.dot(Ks).clamp(),r=Fs.dot(e).clamp(),n=PW({roughness:Tm,dotNH:r}),o=NW({dotNV:s,dotNL:t});return $l.mul(n).mul(o)}),RW=ge(({N:i,V:e,roughness:t})=>{const n=.0078125,o=i.dot(e).saturate(),a=Ge(t,o.oneMinus().sqrt());return a.assign(a.mul(.984375).add(n)),a}).setLayout({name:"LTC_Uv",type:"vec2",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"roughness",type:"float"}]}),IW=ge(({f:i})=>{const e=i.length();return ni(e.mul(e).add(i.z).div(e.add(1)),0)}).setLayout({name:"LTC_ClippedSphereFormFactor",type:"float",inputs:[{name:"f",type:"vec3"}]}),Jp=ge(({v1:i,v2:e})=>{const t=i.dot(e),s=t.abs().toVar(),r=s.mul(.0145206).add(.4965155).mul(s).add(.8543985).toVar(),n=s.add(4.1616724).mul(s).add(3.417594).toVar(),o=r.div(n),a=t.greaterThan(0).select(o,ni(t.mul(t).oneMinus(),1e-7).inverseSqrt().mul(.5).sub(o));return i.cross(e).mul(a)}).setLayout({name:"LTC_EdgeVectorFormFactor",type:"vec3",inputs:[{name:"v1",type:"vec3"},{name:"v2",type:"vec3"}]}),E2=ge(({N:i,V:e,P:t,mInv:s,p0:r,p1:n,p2:o,p3:a})=>{const l=n.sub(r).toVar(),u=a.sub(r).toVar(),c=l.cross(u),d=pe().toVar();return Ht(c.dot(t.sub(r)).greaterThanEqual(0),()=>{const h=e.sub(i.mul(e.dot(i))).normalize(),p=i.cross(h).negate(),f=s.mul(cr(h,p,i).transpose()).toVar(),m=f.mul(r.sub(t)).normalize().toVar(),x=f.mul(n.sub(t)).normalize().toVar(),g=f.mul(o.sub(t)).normalize().toVar(),_=f.mul(a.sub(t)).normalize().toVar(),S=pe(0).toVar();S.addAssign(Jp({v1:m,v2:x})),S.addAssign(Jp({v1:x,v2:g})),S.addAssign(Jp({v1:g,v2:_})),S.addAssign(Jp({v1:_,v2:m})),d.assign(pe(IW({f:S})))}),d}).setLayout({name:"LTC_Evaluate",type:"vec3",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"P",type:"vec3"},{name:"mInv",type:"mat3"},{name:"p0",type:"vec3"},{name:"p1",type:"vec3"},{name:"p2",type:"vec3"},{name:"p3",type:"vec3"}]}),Vm=1/6,CO=i=>Wt(Vm,Wt(i,Wt(i,i.negate().add(3)).sub(3)).add(1)),xb=i=>Wt(Vm,Wt(i,Wt(i,Wt(3,i).sub(6))).add(4)),PO=i=>Wt(Vm,Wt(i,Wt(i,Wt(-3,i).add(3)).add(3)).add(1)),bb=i=>Wt(Vm,jn(i,3)),A2=i=>CO(i).add(xb(i)),C2=i=>PO(i).add(bb(i)),P2=i=>Ri(-1,xb(i).div(CO(i).add(xb(i)))),N2=i=>Ri(1,bb(i).div(PO(i).add(bb(i)))),F2=(i,e,t)=>{const s=i.uvNode,r=Wt(s,e.zw).add(.5),n=go(r),o=la(r),a=A2(o.x),l=C2(o.x),u=P2(o.x),c=N2(o.x),d=P2(o.y),h=N2(o.y),p=Ge(n.x.add(u),n.y.add(d)).sub(.5).mul(e.xy),f=Ge(n.x.add(c),n.y.add(d)).sub(.5).mul(e.xy),m=Ge(n.x.add(u),n.y.add(h)).sub(.5).mul(e.xy),x=Ge(n.x.add(c),n.y.add(h)).sub(.5).mul(e.xy),g=A2(o.y).mul(Ri(a.mul(i.sample(p).level(t)),l.mul(i.sample(f).level(t)))),_=C2(o.y).mul(Ri(a.mul(i.sample(m).level(t)),l.mul(i.sample(x).level(t))));return g.add(_)},vw=ge(([i,e])=>{const t=Ge(i.size(ne(e))),s=Ge(i.size(ne(e.add(1)))),r=wn(1,t),n=wn(1,s),o=F2(i,St(r,t),go(e)),a=F2(i,St(n,s),Cm(e));return la(e).mix(o,a)}),DW=ge(([i,e])=>{const t=e.mul(rw(i));return vw(i,t)}),R2=ge(([i,e,t,s,r])=>{const n=pe(J0(e.negate(),sa(i),wn(1,s))),o=pe(_o(r[0].xyz),_o(r[1].xyz),_o(r[2].xyz));return sa(n).mul(t.mul(o))}).setLayout({name:"getVolumeTransmissionRay",type:"vec3",inputs:[{name:"n",type:"vec3"},{name:"v",type:"vec3"},{name:"thickness",type:"float"},{name:"ior",type:"float"},{name:"modelMatrix",type:"mat4"}]}),kW=ge(([i,e])=>i.mul(wo(e.mul(2).sub(2),0,1))).setLayout({name:"applyIorToRoughness",type:"float",inputs:[{name:"roughness",type:"float"},{name:"ior",type:"float"}]}),LW=mw(),BW=mw(),I2=ge(([i,e,t],{material:s})=>{const n=(s.side===lr?LW:BW).sample(i),o=mo(dh.x).mul(kW(e,t));return vw(n,o)}),D2=ge(([i,e,t])=>(Ht(t.notEqual(0),()=>{const s=Am(e).negate().div(t);return G0(s.negate().mul(i))}),pe(1))).setLayout({name:"volumeAttenuation",type:"vec3",inputs:[{name:"transmissionDistance",type:"float"},{name:"attenuationColor",type:"vec3"},{name:"attenuationDistance",type:"float"}]}),OW=ge(([i,e,t,s,r,n,o,a,l,u,c,d,h,p,f])=>{let m,x;if(f){m=St().toVar(),x=pe().toVar();const w=c.sub(1).mul(f.mul(.025)),v=pe(c.sub(w),c,c.add(w));Rs({start:0,end:3},({i:T})=>{const E=v.element(T),F=R2(i,e,d,E,a),I=o.add(F),z=u.mul(l.mul(St(I,1))),G=Ge(z.xy.div(z.w)).toVar();G.addAssign(1),G.divAssign(2),G.assign(Ge(G.x,G.y.oneMinus()));const L=I2(G,t,E);m.element(T).assign(L.element(T)),m.a.addAssign(L.a),x.element(T).assign(s.element(T).mul(D2(_o(F),h,p).element(T)))}),m.a.divAssign(3)}else{const w=R2(i,e,d,c,a),v=o.add(w),T=u.mul(l.mul(St(v,1))),E=Ge(T.xy.div(T.w)).toVar();E.addAssign(1),E.divAssign(2),E.assign(Ge(E.x,E.y.oneMinus())),m=I2(E,t,c),x=s.mul(D2(_o(w),h,p))}const g=x.rgb.mul(m.rgb),_=i.dot(e).clamp(),S=pe(EO({dotNV:_,specularColor:r,specularF90:n,roughness:t})),M=x.r.add(x.g,x.b).div(3);return St(S.oneMinus().mul(g),m.a.oneMinus().mul(M).oneMinus())}),$W=cr(3.2404542,-.969266,.0556434,-1.5371385,1.8760108,-.2040259,-.4985314,.041556,1.0572252),zW=i=>{const e=i.sqrt();return pe(1).add(e).div(pe(1).sub(e))},k2=(i,e)=>i.sub(e).div(i.add(e)).pow2(),VW=(i,e)=>{const t=i.mul(2*Math.PI*1e-9),s=pe(54856e-17,44201e-17,52481e-17),r=pe(1681e3,1795300,2208400),n=pe(43278e5,93046e5,66121e5),o=Y(9747e-17*Math.sqrt(2*Math.PI*45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());let a=s.mul(n.mul(2*Math.PI).sqrt()).mul(r.mul(t).add(e).cos()).mul(t.pow2().negate().mul(n).exp());return a=pe(a.x.add(o),a.y,a.z).div(10685e-11),$W.mul(a)},UW=ge(({outsideIOR:i,eta2:e,cosTheta1:t,thinFilmThickness:s,baseF0:r})=>{const n=Cs(i,e,Mo(0,.03,s)),a=i.div(n).pow2().mul(t.pow2().oneMinus()).oneMinus();Ht(a.lessThan(0),()=>pe(1));const l=a.sqrt(),u=k2(n,i),c=Mc({f0:u,f90:1,dotVH:t}),d=c.oneMinus(),h=n.lessThan(i).select(Math.PI,0),p=Y(Math.PI).sub(h),f=zW(r.clamp(0,.9999)),m=k2(f,n.toVec3()),x=Mc({f0:m,f90:1,dotVH:l}),g=pe(f.x.lessThan(n).select(Math.PI,0),f.y.lessThan(n).select(Math.PI,0),f.z.lessThan(n).select(Math.PI,0)),_=n.mul(s,l,2),S=pe(p).add(g),M=c.mul(x).clamp(1e-5,.9999),w=M.sqrt(),v=d.pow2().mul(x).div(pe(1).sub(M)),E=c.add(v).toVar(),F=v.sub(d).toVar();return Rs({start:1,end:2,condition:"<=",name:"m"},({m:I})=>{F.mulAssign(w);const z=VW(Y(I).mul(_),Y(I).mul(S)).mul(2);E.addAssign(F.mul(z))}),E.max(pe(0))}).setLayout({name:"evalIridescence",type:"vec3",inputs:[{name:"outsideIOR",type:"float"},{name:"eta2",type:"float"},{name:"cosTheta1",type:"float"},{name:"thinFilmThickness",type:"float"},{name:"baseF0",type:"vec3"}]}),GW=ge(({normal:i,viewDir:e,roughness:t})=>{const s=i.dot(e).saturate(),r=t.pow2(),n=Xi(t.lessThan(.25),Y(-339.2).mul(r).add(Y(161.4).mul(t)).sub(25.9),Y(-8.48).mul(r).add(Y(14.3).mul(t)).sub(9.95)),o=Xi(t.lessThan(.25),Y(44).mul(r).sub(Y(23.7).mul(t)).add(3.26),Y(1.97).mul(r).sub(Y(3.27).mul(t)).add(.72));return Xi(t.lessThan(.25),0,Y(.1).mul(t).sub(.025)).add(n.mul(s).add(o).exp()).mul(1/Math.PI).saturate()}),zy=pe(.04),Vy=Y(1);class NO extends zm{constructor(e=!1,t=!1,s=!1,r=!1,n=!1,o=!1){super(),this.clearcoat=e,this.sheen=t,this.iridescence=s,this.anisotropy=r,this.transmission=n,this.dispersion=o,this.clearcoatRadiance=null,this.clearcoatSpecularDirect=null,this.clearcoatSpecularIndirect=null,this.sheenSpecularDirect=null,this.sheenSpecularIndirect=null,this.iridescenceFresnel=null,this.iridescenceF0=null}start(e){if(this.clearcoat===!0&&(this.clearcoatRadiance=pe().toVar("clearcoatRadiance"),this.clearcoatSpecularDirect=pe().toVar("clearcoatSpecularDirect"),this.clearcoatSpecularIndirect=pe().toVar("clearcoatSpecularIndirect")),this.sheen===!0&&(this.sheenSpecularDirect=pe().toVar("sheenSpecularDirect"),this.sheenSpecularIndirect=pe().toVar("sheenSpecularIndirect")),this.iridescence===!0){const t=Fs.dot(Ks).clamp();this.iridescenceFresnel=UW({outsideIOR:Y(1),eta2:D0,cosTheta1:t,thinFilmThickness:k0,baseF0:Er}),this.iridescenceF0=AO({f:this.iridescenceFresnel,f90:1,dotVH:t})}if(this.transmission===!0){const t=Zo,s=qL.sub(Zo).normalize(),r=Ga,n=e.context;n.backdrop=OW(r,s,ho,ws,Er,uh,t,mn,Tn,iu,Hd,L0,O0,B0,this.dispersion?$0:null),n.backdropAlpha=im,ws.a.mulAssign(Cs(1,n.backdrop.a,im))}super.start(e)}computeMultiscattering(e,t,s){const r=Fs.dot(Ks).clamp(),n=Tw({roughness:ho,dotNV:r}),a=(this.iridescenceF0?vm.mix(Er,this.iridescenceF0):Er).mul(n.x).add(s.mul(n.y)),u=n.x.add(n.y).oneMinus(),c=Er.add(Er.oneMinus().mul(.047619)),d=a.mul(c).div(u.mul(c).oneMinus());e.addAssign(a),t.addAssign(d.mul(u))}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const n=Fs.dot(e).clamp().mul(t);if(this.sheen===!0&&this.sheenSpecularDirect.addAssign(n.mul(FW({lightDirection:e}))),this.clearcoat===!0){const a=zl.dot(e).clamp().mul(t);this.clearcoatSpecularDirect.addAssign(a.mul(yb({lightDirection:e,f0:zy,f90:Vy,roughness:lh,normalView:zl})))}s.directDiffuse.addAssign(n.mul(Ql({diffuseColor:ws.rgb}))),s.directSpecular.addAssign(n.mul(yb({lightDirection:e,f0:Er,f90:1,roughness:ho,iridescence:this.iridescence,f:this.iridescenceFresnel,USE_IRIDESCENCE:this.iridescence,USE_ANISOTROPY:this.anisotropy})))}directRectArea({lightColor:e,lightPosition:t,halfWidth:s,halfHeight:r,reflectedLight:n,ltc_1:o,ltc_2:a}){const l=t.add(s).sub(r),u=t.sub(s).sub(r),c=t.sub(s).add(r),d=t.add(s).add(r),h=Fs,p=Ks,f=hi.toVar(),m=RW({N:h,V:p,roughness:ho}),x=o.sample(m).toVar(),g=a.sample(m).toVar(),_=cr(pe(x.x,0,x.y),pe(0,1,0),pe(x.z,0,x.w)).toVar(),S=Er.mul(g.x).add(Er.oneMinus().mul(g.y)).toVar();n.directSpecular.addAssign(e.mul(S).mul(E2({N:h,V:p,P:f,mInv:_,p0:l,p1:u,p2:c,p3:d}))),n.directDiffuse.addAssign(e.mul(ws).mul(E2({N:h,V:p,P:f,mInv:cr(1,0,0,0,1,0,0,0,1),p0:l,p1:u,p2:c,p3:d})))}indirect(e){this.indirectDiffuse(e),this.indirectSpecular(e),this.ambientOcclusion(e)}indirectDiffuse(e){const{irradiance:t,reflectedLight:s}=e.context;s.indirectDiffuse.addAssign(t.mul(Ql({diffuseColor:ws})))}indirectSpecular(e){const{radiance:t,iblIrradiance:s,reflectedLight:r}=e.context;if(this.sheen===!0&&this.sheenSpecularIndirect.addAssign(s.mul($l,GW({normal:Fs,viewDir:Ks,roughness:Tm}))),this.clearcoat===!0){const c=zl.dot(Ks).clamp(),d=EO({dotNV:c,specularColor:zy,specularF90:Vy,roughness:lh});this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(d))}const n=pe().toVar("singleScattering"),o=pe().toVar("multiScattering"),a=s.mul(1/Math.PI);this.computeMultiscattering(n,o,uh);const l=n.add(o),u=ws.mul(l.r.max(l.g).max(l.b).oneMinus());r.indirectSpecular.addAssign(t.mul(n)),r.indirectSpecular.addAssign(o.mul(a)),r.indirectDiffuse.addAssign(u.mul(a))}ambientOcclusion(e){const{ambientOcclusion:t,reflectedLight:s}=e.context,n=Fs.dot(Ks).clamp().add(t),o=ho.mul(-16).oneMinus().negate().exp2(),a=t.sub(n.pow(o).oneMinus()).clamp();this.clearcoat===!0&&this.clearcoatSpecularIndirect.mulAssign(t),this.sheen===!0&&this.sheenSpecularIndirect.mulAssign(t),s.indirectDiffuse.mulAssign(t),s.indirectSpecular.mulAssign(a)}finish({context:e}){const{outgoingLight:t}=e;if(this.clearcoat===!0){const s=zl.dot(Ks).clamp(),r=Mc({dotVH:s,f0:zy,f90:Vy}),n=t.mul(em.mul(r).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(em));t.assign(n)}if(this.sheen===!0){const s=$l.r.max($l.g).max($l.b).mul(.157).oneMinus(),r=t.mul(s).add(this.sheenSpecularDirect,this.sheenSpecularIndirect);t.assign(r)}}}const L2=Y(1),wb=Y(-2),ef=Y(.8),Uy=Y(-1),tf=Y(.4),Gy=Y(2),sf=Y(.305),jy=Y(3),B2=Y(.21),jW=Y(4),O2=Y(4),WW=Y(16),HW=ge(([i])=>{const e=pe(Us(i)).toVar(),t=Y(-1).toVar();return Ht(e.x.greaterThan(e.z),()=>{Ht(e.x.greaterThan(e.y),()=>{t.assign(Xi(i.x.greaterThan(0),0,3))}).Else(()=>{t.assign(Xi(i.y.greaterThan(0),1,4))})}).Else(()=>{Ht(e.z.greaterThan(e.y),()=>{t.assign(Xi(i.z.greaterThan(0),2,5))}).Else(()=>{t.assign(Xi(i.y.greaterThan(0),1,4))})}),t}).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),qW=ge(([i,e])=>{const t=Ge().toVar();return Ht(e.equal(0),()=>{t.assign(Ge(i.z,i.y).div(Us(i.x)))}).ElseIf(e.equal(1),()=>{t.assign(Ge(i.x.negate(),i.z.negate()).div(Us(i.y)))}).ElseIf(e.equal(2),()=>{t.assign(Ge(i.x.negate(),i.y).div(Us(i.z)))}).ElseIf(e.equal(3),()=>{t.assign(Ge(i.z.negate(),i.y).div(Us(i.x)))}).ElseIf(e.equal(4),()=>{t.assign(Ge(i.x.negate(),i.z).div(Us(i.y)))}).Else(()=>{t.assign(Ge(i.x,i.y).div(Us(i.z)))}),Wt(.5,t.add(1))}).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),KW=ge(([i])=>{const e=Y(0).toVar();return Ht(i.greaterThanEqual(ef),()=>{e.assign(L2.sub(i).mul(Uy.sub(wb)).div(L2.sub(ef)).add(wb))}).ElseIf(i.greaterThanEqual(tf),()=>{e.assign(ef.sub(i).mul(Gy.sub(Uy)).div(ef.sub(tf)).add(Uy))}).ElseIf(i.greaterThanEqual(sf),()=>{e.assign(tf.sub(i).mul(jy.sub(Gy)).div(tf.sub(sf)).add(Gy))}).ElseIf(i.greaterThanEqual(B2),()=>{e.assign(sf.sub(i).mul(jW.sub(jy)).div(sf.sub(B2)).add(jy))}).Else(()=>{e.assign(Y(-2).mul(mo(Wt(1.16,i))))}),e}).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]}),FO=ge(([i,e])=>{const t=i.toVar();t.assign(Wt(2,t).sub(1));const s=pe(t,1).toVar();return Ht(e.equal(0),()=>{s.assign(s.zyx)}).ElseIf(e.equal(1),()=>{s.assign(s.xzy),s.xz.mulAssign(-1)}).ElseIf(e.equal(2),()=>{s.x.mulAssign(-1)}).ElseIf(e.equal(3),()=>{s.assign(s.zyx),s.xz.mulAssign(-1)}).ElseIf(e.equal(4),()=>{s.assign(s.xzy),s.xy.mulAssign(-1)}).ElseIf(e.equal(5),()=>{s.z.mulAssign(-1)}),s}).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]}),RO=ge(([i,e,t,s,r,n])=>{const o=Y(t),a=pe(e),l=wo(KW(o),wb,n),u=la(l),c=go(l),d=pe(Mb(i,a,c,s,r,n)).toVar();return Ht(u.notEqual(0),()=>{const h=pe(Mb(i,a,c.add(1),s,r,n)).toVar();d.assign(Cs(d,h,u))}),d}),Mb=ge(([i,e,t,s,r,n])=>{const o=Y(t).toVar(),a=pe(e),l=Y(HW(a)).toVar(),u=Y(ni(O2.sub(o),0)).toVar();o.assign(ni(o,O2));const c=Y(xc(o)).toVar(),d=Ge(qW(a,l).mul(c.sub(2)).add(1)).toVar();return Ht(l.greaterThan(2),()=>{d.y.addAssign(c),l.subAssign(3)}),d.x.addAssign(l.mul(c)),d.x.addAssign(u.mul(Wt(3,WW))),d.y.addAssign(Wt(4,xc(n).sub(c))),d.x.mulAssign(s),d.y.mulAssign(r),i.sample(d).grad(Ge(),Ge())}),Wy=ge(({envMap:i,mipInt:e,outputDirection:t,theta:s,axis:r,CUBEUV_TEXEL_WIDTH:n,CUBEUV_TEXEL_HEIGHT:o,CUBEUV_MAX_MIP:a})=>{const l=zo(s),u=t.mul(l).add(r.cross(t).mul(qr(s))).add(r.mul(r.dot(t).mul(l.oneMinus())));return Mb(i,u,e,n,o,a)}),IO=ge(({n:i,latitudinal:e,poleAxis:t,outputDirection:s,weights:r,samples:n,dTheta:o,mipInt:a,envMap:l,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:d})=>{const h=pe(Xi(e,t,Nm(t,s))).toVar();Ht(h.equal(pe(0)),()=>{h.assign(pe(s.z,0,s.x.negate()))}),h.assign(sa(h));const p=pe().toVar();return p.addAssign(r.element(0).mul(Wy({theta:0,axis:h,outputDirection:s,mipInt:a,envMap:l,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:d}))),Rs({start:ne(1),end:i},({i:f})=>{Ht(f.greaterThanEqual(n),()=>{iO()});const m=Y(o.mul(Y(f))).toVar();p.addAssign(r.element(f).mul(Wy({theta:m.mul(-1),axis:h,outputDirection:s,mipInt:a,envMap:l,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:d}))),p.addAssign(r.element(f).mul(Wy({theta:m,axis:h,outputDirection:s,mipInt:a,envMap:l,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:d})))}),St(p,1)}),sc=4,$2=[.125,.215,.35,.446,.526,.582],Dl=20,Hy=new gm(-1,1,1,-1,0,1),XW=new Ar(90,1),z2=new gs;let qy=null,Ky=0,Xy=0;const Fl=(1+Math.sqrt(5))/2,Ou=1/Fl,V2=[new xe(-Fl,Ou,0),new xe(Fl,Ou,0),new xe(-Ou,0,Fl),new xe(Ou,0,Fl),new xe(0,Fl,-Ou),new xe(0,Fl,Ou),new xe(-1,1,-1),new xe(1,1,-1),new xe(-1,1,1),new xe(1,1,1)],YW=new xe,DO=new WeakMap,QW=[3,1,5,0,4,2],Yy=FO(qs(),ra("faceIndex")).normalize(),Sw=pe(Yy.x,Yy.y,Yy.z);class ZW{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._backgroundBox=null}get _hasInitialized(){return this._renderer.hasInitialized()}fromScene(e,t=0,s=.1,r=100,n={}){const{size:o=256,position:a=YW,renderTarget:l=null}=n;if(this._setSize(o),this._hasInitialized===!1){console.warn("THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.");const c=l||this._allocateTarget();return n.renderTarget=c,this.fromSceneAsync(e,t,s,r,n),c}qy=this._renderer.getRenderTarget(),Ky=this._renderer.getActiveCubeFace(),Xy=this._renderer.getActiveMipmapLevel();const u=l||this._allocateTarget();return u.depthBuffer=!0,this._init(u),this._sceneToCubeUV(e,s,r,u,a),t>0&&this._blur(u,0,0,t),this._applyPMREM(u),this._cleanup(u),u}async fromSceneAsync(e,t=0,s=.1,r=100,n={}){return this._hasInitialized===!1&&await this._renderer.init(),this.fromScene(e,t,s,r,n)}fromEquirectangular(e,t=null){if(this._hasInitialized===!1){console.warn("THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead."),this._setSizeFromTexture(e);const s=t||this._allocateTarget();return this.fromEquirectangularAsync(e,s),s}return this._fromTexture(e,t)}async fromEquirectangularAsync(e,t=null){return this._hasInitialized===!1&&await this._renderer.init(),this._fromTexture(e,t)}fromCubemap(e,t=null){if(this._hasInitialized===!1){console.warn("THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."),this._setSizeFromTexture(e);const s=t||this._allocateTarget();return this.fromCubemapAsync(e,t),s}return this._fromTexture(e,t)}async fromCubemapAsync(e,t=null){return this._hasInitialized===!1&&await this._renderer.init(),this._fromTexture(e,t)}async compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=G2(),await this._compileMaterial(this._cubemapMaterial))}async compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=j2(),await this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose(),this._backgroundBox!==null&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSizeFromTexture(e){e.mapping===th||e.mapping===Kf?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4)}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(qy,Ky,Xy),e.scissorTest=!1,rf(e,0,0,e.width,e.height)}_fromTexture(e,t){this._setSizeFromTexture(e),qy=this._renderer.getRenderTarget(),Ky=this._renderer.getActiveCubeFace(),Xy=this._renderer.getActiveMipmapLevel();const s=t||this._allocateTarget();return this._init(s),this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTarget(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize;return U2(e,t)}_init(e){if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e.width||this._pingPongRenderTarget.height!==e.height){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=U2(e.width,e.height);const{_lodMax:t}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas,lodMeshes:this._lodMeshes}=JW(t)),this._blurMaterial=e8(t,e.width,e.height)}}async _compileMaterial(e){const t=new bn(this._lodPlanes[0],e);await this._renderer.compile(t,Hy)}_sceneToCubeUV(e,t,s,r,n){const o=XW;o.near=t,o.far=s;const a=[1,1,1,1,-1,1],l=[1,-1,1,-1,1,-1],u=this._renderer,c=u.autoClear;u.getClearColor(z2),u.autoClear=!1;let d=this._backgroundBox;if(d===null){const f=new co({name:"PMREM.Background",side:lr,depthWrite:!1,depthTest:!1});d=new bn(new fh,f)}let h=!1;const p=e.background;p?p.isColor&&(d.material.color.copy(p),e.background=null,h=!0):(d.material.color.copy(z2),h=!0),u.setRenderTarget(r),u.clear(),h&&u.render(d,o);for(let f=0;f<6;f++){const m=f%3;m===0?(o.up.set(0,a[f],0),o.position.set(n.x,n.y,n.z),o.lookAt(n.x+l[f],n.y,n.z)):m===1?(o.up.set(0,0,a[f]),o.position.set(n.x,n.y,n.z),o.lookAt(n.x,n.y+l[f],n.z)):(o.up.set(0,a[f],0),o.position.set(n.x,n.y,n.z),o.lookAt(n.x,n.y,n.z+l[f]));const x=this._cubeSize;rf(r,m*x,f>2?x:0,x,x),u.render(e,o)}u.autoClear=c,e.background=p}_textureToCubeUV(e,t){const s=this._renderer,r=e.mapping===th||e.mapping===Kf;r?this._cubemapMaterial===null&&(this._cubemapMaterial=G2(e)):this._equirectMaterial===null&&(this._equirectMaterial=j2(e));const n=r?this._cubemapMaterial:this._equirectMaterial;n.fragmentNode.value=e;const o=this._lodMeshes[0];o.material=n;const a=this._cubeSize;rf(t,0,0,3*a,2*a),s.setRenderTarget(t),s.render(o,Hy)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;const r=this._lodPlanes.length;for(let n=1;n<r;n++){const o=Math.sqrt(this._sigmas[n]*this._sigmas[n]-this._sigmas[n-1]*this._sigmas[n-1]),a=V2[(r-n-1)%V2.length];this._blur(e,n-1,n,o,a)}t.autoClear=s}_blur(e,t,s,r,n){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,s,r,"latitudinal",n),this._halfBlur(o,e,s,s,r,"longitudinal",n)}_halfBlur(e,t,s,r,n,o,a){const l=this._renderer,u=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,d=this._lodMeshes[r];d.material=u;const h=DO.get(u),p=this._sizeLods[s]-1,f=isFinite(n)?Math.PI/(2*p):2*Math.PI/(2*Dl-1),m=n/f,x=isFinite(n)?1+Math.floor(c*m):Dl;x>Dl&&console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Dl}`);const g=[];let _=0;for(let T=0;T<Dl;++T){const E=T/m,F=Math.exp(-E*E/2);g.push(F),T===0?_+=F:T<x&&(_+=2*F)}for(let T=0;T<g.length;T++)g[T]=g[T]/_;e.texture.frame=(e.texture.frame||0)+1,h.envMap.value=e.texture,h.samples.value=x,h.weights.array=g,h.latitudinal.value=o==="latitudinal"?1:0,a&&(h.poleAxis.value=a);const{_lodMax:S}=this;h.dTheta.value=f,h.mipInt.value=S-s;const M=this._sizeLods[r],w=3*M*(r>S-sc?r-S+sc:0),v=4*(this._cubeSize-M);rf(t,w,v,3*M,2*M),l.setRenderTarget(t),l.render(d,Hy)}}function JW(i){const e=[],t=[],s=[],r=[];let n=i;const o=i-sc+1+$2.length;for(let a=0;a<o;a++){const l=Math.pow(2,n);t.push(l);let u=1/l;a>i-sc?u=$2[a-i+sc-1]:a===0&&(u=0),s.push(u);const c=1/(l-2),d=-c,h=1+c,p=[d,d,h,d,h,h,d,d,h,h,d,h],f=6,m=6,x=3,g=2,_=1,S=new Float32Array(x*m*f),M=new Float32Array(g*m*f),w=new Float32Array(_*m*f);for(let T=0;T<f;T++){const E=T%3*2/3-1,F=T>2?0:-1,I=[E,F,0,E+2/3,F,0,E+2/3,F+1,0,E,F,0,E+2/3,F+1,0,E,F+1,0],z=QW[T];S.set(I,x*m*z),M.set(p,g*m*z);const G=[z,z,z,z,z,z];w.set(G,_*m*z)}const v=new aa;v.setAttribute("position",new Yr(S,x)),v.setAttribute("uv",new Yr(M,g)),v.setAttribute("faceIndex",new Yr(w,_)),e.push(v),r.push(new bn(v,null)),n>sc&&n--}return{lodPlanes:e,sizeLods:t,sigmas:s,lodMeshes:r}}function U2(i,e){const t={magFilter:wr,minFilter:wr,generateMipmaps:!1,type:Cr,format:fn,colorSpace:Ul},s=new So(i,e,t);return s.texture.mapping=Ox,s.texture.name="PMREM.cubeUv",s.texture.isPMREMTexture=!0,s.scissorTest=!0,s}function rf(i,e,t,s,r){i.viewport.set(e,t,s,r),i.scissor.set(e,t,s,r)}function Ew(i){const e=new pi;return e.depthTest=!1,e.depthWrite=!1,e.blending=fc,e.name=`PMREM_${i}`,e}function e8(i,e,t){const s=pn(new Array(Dl).fill(0)),r=Et(new xe(0,1,0)),n=Et(0),o=Y(Dl),a=Et(0),l=Et(1),u=ts(null),c=Et(0),d=Y(1/e),h=Y(1/t),p=Y(i),f={n:o,latitudinal:a,weights:s,poleAxis:r,outputDirection:Sw,dTheta:n,samples:l,envMap:u,mipInt:c,CUBEUV_TEXEL_WIDTH:d,CUBEUV_TEXEL_HEIGHT:h,CUBEUV_MAX_MIP:p},m=Ew("blur");return m.fragmentNode=IO({...f,latitudinal:a.equal(1)}),DO.set(m,f),m}function G2(i){const e=Ew("cubemap");return e.fragmentNode=wc(i,Sw),e}function j2(i){const e=Ew("equirect");return e.fragmentNode=ts(i,bw(Sw),0),e}const W2=new WeakMap;function t8(i){const e=Math.log2(i)-2,t=1/i;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:t,maxMip:e}}function s8(i,e,t){const s=i8(e);let r=s.get(i);if((r!==void 0?r.pmremVersion:-1)!==i.pmremVersion){const o=i.image;if(i.isCubeTexture)if(n8(o))r=t.fromCubemap(i,r);else return null;else if(o8(o))r=t.fromEquirectangular(i,r);else return null;r.pmremVersion=i.pmremVersion,s.set(i,r)}return r.texture}function i8(i){let e=W2.get(i);return e===void 0&&(e=new WeakMap,W2.set(i,e)),e}class r8 extends Ii{static get type(){return"PMREMNode"}constructor(e,t=null,s=null){super("vec3"),this._value=e,this._pmrem=null,this.uvNode=t,this.levelNode=s,this._generator=null;const r=new Yi;r.isRenderTargetTexture=!0,this._texture=ts(r),this._width=Et(0),this._height=Et(0),this._maxMip=Et(0),this.updateBeforeType=Kt.RENDER}set value(e){this._value=e,this._pmrem=null}get value(){return this._value}updateFromTexture(e){const t=t8(e.image.height);this._texture.value=e,this._width.value=t.texelWidth,this._height.value=t.texelHeight,this._maxMip.value=t.maxMip}updateBefore(e){let t=this._pmrem;const s=t?t.pmremVersion:-1,r=this._value;s!==r.pmremVersion&&(r.isPMREMTexture===!0?t=r:t=s8(r,e.renderer,this._generator),t!==null&&(this._pmrem=t,this.updateFromTexture(t)))}setup(e){this._generator===null&&(this._generator=new ZW(e.renderer)),this.updateBefore(e);let t=this.uvNode;t===null&&e.context.getUV&&(t=e.context.getUV(this)),t=cw.mul(pe(t.x,t.y.negate(),t.z));let s=this.levelNode;return s===null&&e.context.getTextureLevel&&(s=e.context.getTextureLevel(this)),RO(this._texture,t,s,this._width,this._height,this._maxMip)}dispose(){super.dispose(),this._generator!==null&&this._generator.dispose()}}function n8(i){if(i==null)return!1;let e=0;const t=6;for(let s=0;s<t;s++)i[s]!==void 0&&e++;return e===t}function o8(i){return i==null?!1:i.height>0}const Aw=ze(r8).setParameterLength(1,3),H2=new WeakMap;class a8 extends Ac{static get type(){return"EnvironmentNode"}constructor(e=null){super(),this.envNode=e}setup(e){const{material:t}=e;let s=this.envNode;if(s.isTextureNode||s.isMaterialReferenceNode){const d=s.isTextureNode?s.value:t[s.property];let h=H2.get(d);h===void 0&&(h=Aw(d),H2.set(d,h)),s=h}const n=t.useAnisotropy===!0||t.anisotropy>0?_B:Fs,o=s.context(q2(ho,n)).mul(Nf),a=s.context(l8(Ga)).mul(Math.PI).mul(Nf),l=qd(o),u=qd(a);e.context.radiance.addAssign(l),e.context.iblIrradiance.addAssign(u);const c=e.context.lightingModel.clearcoatRadiance;if(c){const d=s.context(q2(lh,zl)).mul(Nf),h=qd(d);c.addAssign(h)}}}const q2=(i,e)=>{let t=null;return{getUV:()=>(t===null&&(t=Ks.negate().reflect(e),t=i.mul(i).mix(t,e).normalize(),t=t.transformDirection(Tn)),t),getTextureLevel:()=>i}},l8=i=>({getUV:()=>i,getTextureLevel:()=>Y(1)}),u8=new sk;class kO extends pi{static get type(){return"MeshStandardNodeMaterial"}constructor(e){super(),this.isMeshStandardNodeMaterial=!0,this.lights=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(u8),this.setValues(e)}setupEnvironment(e){let t=super.setupEnvironment(e);return t===null&&e.environmentNode&&(t=e.environmentNode),t?new a8(t):null}setupLightingModel(){return new NO}setupSpecular(){const e=Cs(pe(.04),ws.rgb,ah);Er.assign(e),uh.assign(1)}setupVariants(){const e=this.metalnessNode?Y(this.metalnessNode):EB;ah.assign(e);let t=this.roughnessNode?Y(this.roughnessNode):SB;t=Mw({roughness:t}),ho.assign(t),this.setupSpecular(),ws.assign(St(ws.rgb.mul(e.oneMinus()),ws.a))}copy(e){return this.emissiveNode=e.emissiveNode,this.metalnessNode=e.metalnessNode,this.roughnessNode=e.roughnessNode,super.copy(e)}}const c8=new ZU;class d8 extends kO{static get type(){return"MeshPhysicalNodeMaterial"}constructor(e){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.iorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.dispersionNode=null,this.anisotropyNode=null,this.setDefaultValues(c8),this.setValues(e)}get useClearcoat(){return this.clearcoat>0||this.clearcoatNode!==null}get useIridescence(){return this.iridescence>0||this.iridescenceNode!==null}get useSheen(){return this.sheen>0||this.sheenNode!==null}get useAnisotropy(){return this.anisotropy>0||this.anisotropyNode!==null}get useTransmission(){return this.transmission>0||this.transmissionNode!==null}get useDispersion(){return this.dispersion>0||this.dispersionNode!==null}setupSpecular(){const e=this.iorNode?Y(this.iorNode):zB;Hd.assign(e),Er.assign(Cs(Ir(Y0(Hd.sub(1).div(Hd.add(1))).mul(vB),pe(1)).mul(_b),ws.rgb,ah)),uh.assign(Cs(_b,1,ah))}setupLightingModel(){return new NO(this.useClearcoat,this.useSheen,this.useIridescence,this.useAnisotropy,this.useTransmission,this.useDispersion)}setupVariants(e){if(super.setupVariants(e),this.useClearcoat){const t=this.clearcoatNode?Y(this.clearcoatNode):CB,s=this.clearcoatRoughnessNode?Y(this.clearcoatRoughnessNode):PB;em.assign(t),lh.assign(Mw({roughness:s}))}if(this.useSheen){const t=this.sheenNode?pe(this.sheenNode):RB,s=this.sheenRoughnessNode?Y(this.sheenRoughnessNode):IB;$l.assign(t),Tm.assign(s)}if(this.useIridescence){const t=this.iridescenceNode?Y(this.iridescenceNode):kB,s=this.iridescenceIORNode?Y(this.iridescenceIORNode):LB,r=this.iridescenceThicknessNode?Y(this.iridescenceThicknessNode):BB;vm.assign(t),D0.assign(s),k0.assign(r)}if(this.useAnisotropy){const t=(this.anisotropyNode?Ge(this.anisotropyNode):DB).toVar();Ca.assign(t.length()),Ht(Ca.equal(0),()=>{t.assign(Ge(1,0))}).Else(()=>{t.divAssign(Ge(Ca)),Ca.assign(Ca.saturate())}),tm.assign(Ca.pow2().mix(ho.pow2(),1)),Wd.assign(Vl[0].mul(t.x).add(Vl[1].mul(t.y))),Wl.assign(Vl[1].mul(t.x).sub(Vl[0].mul(t.y)))}if(this.useTransmission){const t=this.transmissionNode?Y(this.transmissionNode):OB,s=this.thicknessNode?Y(this.thicknessNode):$B,r=this.attenuationDistanceNode?Y(this.attenuationDistanceNode):VB,n=this.attenuationColorNode?pe(this.attenuationColorNode):UB;if(im.assign(t),L0.assign(s),B0.assign(r),O0.assign(n),this.useDispersion){const o=this.dispersionNode?Y(this.dispersionNode):KB;$0.assign(o)}}}setupClearcoatNormal(){return this.clearcoatNormalNode?pe(this.clearcoatNormalNode):NB}setup(e){e.context.setupClearcoatNormal=()=>uc(this.setupClearcoatNormal(e),"NORMAL","vec3"),super.setup(e)}copy(e){return this.clearcoatNode=e.clearcoatNode,this.clearcoatRoughnessNode=e.clearcoatRoughnessNode,this.clearcoatNormalNode=e.clearcoatNormalNode,this.sheenNode=e.sheenNode,this.sheenRoughnessNode=e.sheenRoughnessNode,this.iridescenceNode=e.iridescenceNode,this.iridescenceIORNode=e.iridescenceIORNode,this.iridescenceThicknessNode=e.iridescenceThicknessNode,this.specularIntensityNode=e.specularIntensityNode,this.specularColorNode=e.specularColorNode,this.transmissionNode=e.transmissionNode,this.thicknessNode=e.thicknessNode,this.attenuationDistanceNode=e.attenuationDistanceNode,this.attenuationColorNode=e.attenuationColorNode,this.dispersionNode=e.dispersionNode,this.anisotropyNode=e.anisotropyNode,super.copy(e)}}const h8=ge(({normal:i,lightDirection:e,builder:t})=>{const s=i.dot(e),r=Ge(s.mul(.5).add(.5),0);if(t.material.gradientMap){const n=jo("gradientMap","texture").context({getUV:()=>r});return pe(n.r)}else{const n=r.fwidth().mul(.5);return Cs(pe(.7),pe(1),Mo(Y(.7).sub(n.x),Y(.7).add(n.x),r.x))}});class p8 extends zm{direct({lightDirection:e,lightColor:t,reflectedLight:s},r){const n=h8({normal:Dm,lightDirection:e,builder:r}).mul(t);s.directDiffuse.addAssign(n.mul(Ql({diffuseColor:ws.rgb})))}indirect(e){const{ambientOcclusion:t,irradiance:s,reflectedLight:r}=e.context;r.indirectDiffuse.addAssign(s.mul(Ql({diffuseColor:ws}))),r.indirectDiffuse.mulAssign(t)}}const f8=new e4;class m8 extends pi{static get type(){return"MeshToonNodeMaterial"}constructor(e){super(),this.isMeshToonNodeMaterial=!0,this.lights=!0,this.setDefaultValues(f8),this.setValues(e)}setupLightingModel(){return new p8}}const LO=ge(()=>{const i=pe(Ks.z,0,Ks.x.negate()).normalize(),e=Ks.cross(i);return Ge(i.dot(Fs),e.dot(Fs)).mul(.495).add(.5)}).once(["NORMAL","VERTEX"])().toVar("matcapUV"),g8=new i4;class _8 extends pi{static get type(){return"MeshMatcapNodeMaterial"}constructor(e){super(),this.isMeshMatcapNodeMaterial=!0,this.setDefaultValues(g8),this.setValues(e)}setupVariants(e){const t=LO;let s;e.material.matcap?s=jo("matcap","texture").context({getUV:()=>t}):s=pe(Cs(.2,.8,t.y)),ws.rgb.mulAssign(s.rgb)}}class y8 extends Ii{static get type(){return"RotateNode"}constructor(e,t){super(),this.positionNode=e,this.rotationNode=t}getNodeType(e){return this.positionNode.getNodeType(e)}setup(e){const{rotationNode:t,positionNode:s}=this;if(this.getNodeType(e)==="vec2"){const n=t.cos(),o=t.sin();return Mm(n,o,o.negate(),n).mul(s)}else{const n=t,o=jl(St(1,0,0,0),St(0,zo(n.x),qr(n.x).negate(),0),St(0,qr(n.x),zo(n.x),0),St(0,0,0,1)),a=jl(St(zo(n.y),0,qr(n.y),0),St(0,1,0,0),St(qr(n.y).negate(),0,zo(n.y),0),St(0,0,0,1)),l=jl(St(zo(n.z),qr(n.z).negate(),0,0),St(qr(n.z),zo(n.z),0,0),St(0,0,1,0),St(0,0,0,1));return o.mul(a).mul(l).mul(St(s,1)).xyz}}}const Um=ze(y8).setParameterLength(2),x8=new jU;class BO extends pi{static get type(){return"SpriteNodeMaterial"}constructor(e){super(),this.isSpriteNodeMaterial=!0,this._useSizeAttenuation=!0,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.transparent=!0,this.setDefaultValues(x8),this.setValues(e)}setupPositionView(e){const{object:t,camera:s}=e,r=this.sizeAttenuation,{positionNode:n,rotationNode:o,scaleNode:a}=this,l=ru.mul(pe(n||0));let u=Ge(mn[0].xyz.length(),mn[1].xyz.length());if(a!==null&&(u=u.mul(Ge(a))),r===!1)if(s.isPerspectiveCamera)u=u.mul(l.z.negate());else{const p=Y(2).div(iu.element(1).element(1));u=u.mul(p.mul(2))}let c=wh.xy;if(t.center&&t.center.isVector2===!0){const p=MG("center","vec2",t);c=c.sub(p.sub(.5))}c=c.mul(u);const d=Y(o||FB),h=Um(c,d);return St(l.xy.add(h),l.zw)}copy(e){return this.positionNode=e.positionNode,this.rotationNode=e.rotationNode,this.scaleNode=e.scaleNode,super.copy(e)}get sizeAttenuation(){return this._useSizeAttenuation}set sizeAttenuation(e){this._useSizeAttenuation!==e&&(this._useSizeAttenuation=e,this.needsUpdate=!0)}}const b8=new XU;class w8 extends BO{static get type(){return"PointsNodeMaterial"}constructor(e){super(),this.sizeNode=null,this.isPointsNodeMaterial=!0,this.setDefaultValues(b8),this.setValues(e)}setupPositionView(){const{positionNode:e}=this;return ru.mul(pe(e||di)).xyz}setupVertex(e){const t=super.setupVertex(e);if(e.material.isNodeMaterial!==!0)return t;const{rotationNode:s,scaleNode:r,sizeNode:n}=this,o=wh.xy.toVar(),a=cc.z.div(cc.w);if(s&&s.isNode){const u=Y(s);o.assign(Um(o,u))}let l=n!==null?Ge(n):qB;return this.sizeAttenuation===!0&&(l=l.mul(l.div(hi.z.negate()))),r&&r.isNode&&(l=l.mul(Ge(r))),o.mulAssign(l.mul(2)),o.assign(o.div(cc.z)),o.y.assign(o.y.mul(a)),o.assign(o.mul(t.w)),t.addAssign(St(o,0,0)),t}get alphaToCoverage(){return this._useAlphaToCoverage}set alphaToCoverage(e){this._useAlphaToCoverage!==e&&(this._useAlphaToCoverage=e,this.needsUpdate=!0)}}class M8 extends zm{constructor(){super(),this.shadowNode=Y(1).toVar("shadowMask")}direct({lightNode:e}){e.shadowNode!==null&&this.shadowNode.mulAssign(e.shadowNode)}finish({context:e}){ws.a.mulAssign(this.shadowNode.oneMinus()),e.outgoingLight.rgb.assign(ws.rgb)}}const T8=new QU;class v8 extends pi{static get type(){return"ShadowNodeMaterial"}constructor(e){super(),this.isShadowNodeMaterial=!0,this.lights=!0,this.transparent=!0,this.setDefaultValues(T8),this.setValues(e)}setupLightingModel(){return new M8}}Qo("vec3");Qo("vec3");Qo("vec3");class S8{constructor(e,t){this.nodes=e,this.info=t,this._context=typeof self<"u"?self:null,this._animationLoop=null,this._requestId=null}start(){const e=(t,s)=>{this._requestId=this._context.requestAnimationFrame(e),this.info.autoReset===!0&&this.info.reset(),this.nodes.nodeFrame.update(),this.info.frame=this.nodes.nodeFrame.frameId,this._animationLoop!==null&&this._animationLoop(t,s)};e()}stop(){this._context.cancelAnimationFrame(this._requestId),this._requestId=null}getAnimationLoop(){return this._animationLoop}setAnimationLoop(e){this._animationLoop=e}getContext(){return this._context}setContext(e){this._context=e}dispose(){this.stop()}}class Kn{constructor(){this.weakMap=new WeakMap}get(e){let t=this.weakMap;for(let s=0;s<e.length-1;s++)if(t=t.get(e[s]),t===void 0)return;return t.get(e[e.length-1])}set(e,t){let s=this.weakMap;for(let r=0;r<e.length-1;r++){const n=e[r];s.has(n)===!1&&s.set(n,new WeakMap),s=s.get(n)}return s.set(e[e.length-1],t),this}delete(e){let t=this.weakMap;for(let s=0;s<e.length-1;s++)if(t=t.get(e[s]),t===void 0)return!1;return t.delete(e[e.length-1])}}let E8=0;function A8(i){const e=Object.keys(i);let t=Object.getPrototypeOf(i);for(;t;){const s=Object.getOwnPropertyDescriptors(t);for(const r in s)if(s[r]!==void 0){const n=s[r];n&&typeof n.get=="function"&&e.push(r)}t=Object.getPrototypeOf(t)}return e}class C8{constructor(e,t,s,r,n,o,a,l,u,c){this.id=E8++,this._nodes=e,this._geometries=t,this.renderer=s,this.object=r,this.material=n,this.scene=o,this.camera=a,this.lightsNode=l,this.context=u,this.geometry=r.geometry,this.version=n.version,this.drawRange=null,this.attributes=null,this.attributesId=null,this.pipeline=null,this.group=null,this.vertexBuffers=null,this.drawParams=null,this.bundle=null,this.clippingContext=c,this.clippingContextCacheKey=c!==null?c.cacheKey:"",this.initialNodesCacheKey=this.getDynamicCacheKey(),this.initialCacheKey=this.getCacheKey(),this._nodeBuilderState=null,this._bindings=null,this._monitor=null,this.onDispose=null,this.isRenderObject=!0,this.onMaterialDispose=()=>{this.dispose()},this.onGeometryDispose=()=>{this.attributes=null,this.attributesId=null},this.material.addEventListener("dispose",this.onMaterialDispose),this.geometry.addEventListener("dispose",this.onGeometryDispose)}updateClipping(e){this.clippingContext=e}get clippingNeedsUpdate(){return this.clippingContext===null||this.clippingContext.cacheKey===this.clippingContextCacheKey?!1:(this.clippingContextCacheKey=this.clippingContext.cacheKey,!0)}get hardwareClippingPlanes(){return this.material.hardwareClipping===!0?this.clippingContext.unionClippingCount:0}getNodeBuilderState(){return this._nodeBuilderState||(this._nodeBuilderState=this._nodes.getForRender(this))}getMonitor(){return this._monitor||(this._monitor=this.getNodeBuilderState().observer)}getBindings(){return this._bindings||(this._bindings=this.getNodeBuilderState().createBindings())}getBindingGroup(e){for(const t of this.getBindings())if(t.name===e)return t}getIndex(){return this._geometries.getIndex(this)}getIndirect(){return this._geometries.getIndirect(this)}getChainArray(){return[this.object,this.material,this.context,this.lightsNode]}setGeometry(e){this.geometry=e,this.attributes=null,this.attributesId=null}getAttributes(){if(this.attributes!==null)return this.attributes;const e=this.getNodeBuilderState().nodeAttributes,t=this.geometry,s=[],r=new Set,n={};for(const o of e){let a;if(o.node&&o.node.attribute?a=o.node.attribute:(a=t.getAttribute(o.name),n[o.name]=a.version),a===void 0)continue;s.push(a);const l=a.isInterleavedBufferAttribute?a.data:a;r.add(l)}return this.attributes=s,this.attributesId=n,this.vertexBuffers=Array.from(r.values()),s}getVertexBuffers(){return this.vertexBuffers===null&&this.getAttributes(),this.vertexBuffers}getDrawParameters(){const{object:e,material:t,geometry:s,group:r,drawRange:n}=this,o=this.drawParams||(this.drawParams={vertexCount:0,firstVertex:0,instanceCount:0,firstInstance:0}),a=this.getIndex(),l=a!==null;let u=1;if(s.isInstancedBufferGeometry===!0?u=s.instanceCount:e.count!==void 0&&(u=Math.max(0,e.count)),u===0)return null;if(o.instanceCount=u,e.isBatchedMesh===!0)return o;let c=1;t.wireframe===!0&&!e.isPoints&&!e.isLineSegments&&!e.isLine&&!e.isLineLoop&&(c=2);let d=n.start*c,h=(n.start+n.count)*c;r!==null&&(d=Math.max(d,r.start*c),h=Math.min(h,(r.start+r.count)*c));const p=s.attributes.position;let f=1/0;l?f=a.count:p!=null&&(f=p.count),d=Math.max(d,0),h=Math.min(h,f);const m=h-d;return m<0||m===1/0?null:(o.vertexCount=m,o.firstVertex=d,o)}getGeometryCacheKey(){const{geometry:e}=this;let t="";for(const s of Object.keys(e.attributes).sort()){const r=e.attributes[s];t+=s+",",r.data&&(t+=r.data.stride+","),r.offset&&(t+=r.offset+","),r.itemSize&&(t+=r.itemSize+","),r.normalized&&(t+="n,")}for(const s of Object.keys(e.morphAttributes).sort()){const r=e.morphAttributes[s];t+="morph-"+s+",";for(let n=0,o=r.length;n<o;n++){const a=r[n];t+=a.id+","}}return e.index&&(t+="index,"),t}getMaterialCacheKey(){const{object:e,material:t}=this;let s=t.customProgramCacheKey();for(const r of A8(t)){if(/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(r))continue;const n=t[r];let o;if(n!==null){const a=typeof n;a==="number"?o=n!==0?"1":"0":a==="object"?(o="{",n.isTexture&&(o+=n.mapping),o+="}"):o=String(n)}else o=String(n);s+=o+","}return s+=this.clippingContextCacheKey+",",e.geometry&&(s+=this.getGeometryCacheKey()),e.skeleton&&(s+=e.skeleton.bones.length+","),e.isBatchedMesh&&(s+=e._matricesTexture.uuid+",",e._colorsTexture!==null&&(s+=e._colorsTexture.uuid+",")),e.count>1&&(s+=e.uuid+","),s+=e.receiveShadow+",",rk(s)}get needsGeometryUpdate(){if(this.geometry.id!==this.object.geometry.id)return!0;if(this.attributes!==null){const e=this.attributesId;for(const t in e){const s=this.geometry.getAttribute(t);if(s===void 0||e[t]!==s.id)return!0}}return!1}get needsUpdate(){return this.initialNodesCacheKey!==this.getDynamicCacheKey()||this.clippingNeedsUpdate}getDynamicCacheKey(){let e=0;return this.material.isShadowPassMaterial!==!0&&(e=this._nodes.getCacheKey(this.scene,this.lightsNode)),this.camera.isArrayCamera&&(e=Qf(e,this.camera.cameras.length)),this.object.receiveShadow&&(e=Qf(e,1)),e}getCacheKey(){return this.getMaterialCacheKey()+this.getDynamicCacheKey()}dispose(){this.material.removeEventListener("dispose",this.onMaterialDispose),this.geometry.removeEventListener("dispose",this.onGeometryDispose),this.onDispose()}}const Ml=[];class P8{constructor(e,t,s,r,n,o){this.renderer=e,this.nodes=t,this.geometries=s,this.pipelines=r,this.bindings=n,this.info=o,this.chainMaps={}}get(e,t,s,r,n,o,a,l){const u=this.getChainMap(l);Ml[0]=e,Ml[1]=t,Ml[2]=o,Ml[3]=n;let c=u.get(Ml);return c===void 0?(c=this.createRenderObject(this.nodes,this.geometries,this.renderer,e,t,s,r,n,o,a,l),u.set(Ml,c)):(c.updateClipping(a),c.needsGeometryUpdate&&c.setGeometry(e.geometry),(c.version!==t.version||c.needsUpdate)&&(c.initialCacheKey!==c.getCacheKey()?(c.dispose(),c=this.get(e,t,s,r,n,o,a,l)):c.version=t.version)),Ml.length=0,c}getChainMap(e="default"){return this.chainMaps[e]||(this.chainMaps[e]=new Kn)}dispose(){this.chainMaps={}}createRenderObject(e,t,s,r,n,o,a,l,u,c,d){const h=this.getChainMap(d),p=new C8(e,t,s,r,n,o,a,l,u,c);return p.onDispose=()=>{this.pipelines.delete(p),this.bindings.delete(p),this.nodes.delete(p),h.delete(p.getChainArray())},p}}class ja{constructor(){this.data=new WeakMap}get(e){let t=this.data.get(e);return t===void 0&&(t={},this.data.set(e,t)),t}delete(e){let t=null;return this.data.has(e)&&(t=this.data.get(e),this.data.delete(e)),t}has(e){return this.data.has(e)}dispose(){this.data=new WeakMap}}const gn={VERTEX:1,INDEX:2,STORAGE:3,INDIRECT:4},Fa=16,N8=211,F8=212;class R8 extends ja{constructor(e){super(),this.backend=e}delete(e){const t=super.delete(e);return t!==null&&this.backend.destroyAttribute(e),t}update(e,t){const s=this.get(e);if(s.version===void 0)t===gn.VERTEX?this.backend.createAttribute(e):t===gn.INDEX?this.backend.createIndexAttribute(e):t===gn.STORAGE?this.backend.createStorageAttribute(e):t===gn.INDIRECT&&this.backend.createIndirectStorageAttribute(e),s.version=this._getBufferAttribute(e).version;else{const r=this._getBufferAttribute(e);(s.version<r.version||r.usage===Ju)&&(this.backend.updateAttribute(e),s.version=r.version)}}_getBufferAttribute(e){return e.isInterleavedBufferAttribute&&(e=e.data),e}}function OO(i){return i.index!==null?i.index.version:i.attributes.position.version}function K2(i){const e=[],t=i.index,s=i.attributes.position;if(t!==null){const n=t.array;for(let o=0,a=n.length;o<a;o+=3){const l=n[o+0],u=n[o+1],c=n[o+2];e.push(l,u,u,c,c,l)}}else{const n=s.array;for(let o=0,a=n.length/3-1;o<a;o+=3){const l=o+0,u=o+1,c=o+2;e.push(l,u,u,c,c,l)}}const r=new(WD(e)?XD:KD)(e,1);return r.version=OO(i),r}class I8 extends ja{constructor(e,t){super(),this.attributes=e,this.info=t,this.wireframes=new WeakMap,this.attributeCall=new WeakMap}has(e){const t=e.geometry;return super.has(t)&&this.get(t).initialized===!0}updateForRender(e){this.has(e)===!1&&this.initGeometry(e),this.updateAttributes(e)}initGeometry(e){const t=e.geometry,s=this.get(t);s.initialized=!0,this.info.memory.geometries++;const r=()=>{this.info.memory.geometries--;const n=t.index,o=e.getAttributes();n!==null&&this.attributes.delete(n);for(const l of o)this.attributes.delete(l);const a=this.wireframes.get(t);a!==void 0&&this.attributes.delete(a),t.removeEventListener("dispose",r)};t.addEventListener("dispose",r)}updateAttributes(e){const t=e.getAttributes();for(const n of t)n.isStorageBufferAttribute||n.isStorageInstancedBufferAttribute?this.updateAttribute(n,gn.STORAGE):this.updateAttribute(n,gn.VERTEX);const s=this.getIndex(e);s!==null&&this.updateAttribute(s,gn.INDEX);const r=e.geometry.indirect;r!==null&&this.updateAttribute(r,gn.INDIRECT)}updateAttribute(e,t){const s=this.info.render.calls;e.isInterleavedBufferAttribute?this.attributeCall.get(e)===void 0?(this.attributes.update(e,t),this.attributeCall.set(e,s)):this.attributeCall.get(e.data)!==s&&(this.attributes.update(e,t),this.attributeCall.set(e.data,s),this.attributeCall.set(e,s)):this.attributeCall.get(e)!==s&&(this.attributes.update(e,t),this.attributeCall.set(e,s))}getIndirect(e){return e.geometry.indirect}getIndex(e){const{geometry:t,material:s}=e;let r=t.index;if(s.wireframe===!0){const n=this.wireframes;let o=n.get(t);o===void 0?(o=K2(t),n.set(t,o)):o.version!==OO(t)&&(this.attributes.delete(o),o=K2(t),n.set(t,o)),r=o}return r}}class D8{constructor(){this.autoReset=!0,this.frame=0,this.calls=0,this.render={calls:0,frameCalls:0,drawCalls:0,triangles:0,points:0,lines:0,timestamp:0},this.compute={calls:0,frameCalls:0,timestamp:0},this.memory={geometries:0,textures:0}}update(e,t,s){this.render.drawCalls++,e.isMesh||e.isSprite?this.render.triangles+=s*(t/3):e.isPoints?this.render.points+=s*t:e.isLineSegments?this.render.lines+=s*(t/2):e.isLine?this.render.lines+=s*(t-1):console.error("THREE.WebGPUInfo: Unknown object type.")}reset(){this.render.drawCalls=0,this.render.frameCalls=0,this.compute.frameCalls=0,this.render.triangles=0,this.render.points=0,this.render.lines=0}dispose(){this.reset(),this.calls=0,this.render.calls=0,this.compute.calls=0,this.render.timestamp=0,this.compute.timestamp=0,this.memory.geometries=0,this.memory.textures=0}}class $O{constructor(e){this.cacheKey=e,this.usedTimes=0}}class k8 extends $O{constructor(e,t,s){super(e),this.vertexProgram=t,this.fragmentProgram=s}}class L8 extends $O{constructor(e,t){super(e),this.computeProgram=t,this.isComputePipeline=!0}}let B8=0;class Qy{constructor(e,t,s,r=null,n=null){this.id=B8++,this.code=e,this.stage=t,this.name=s,this.transforms=r,this.attributes=n,this.usedTimes=0}}class O8 extends ja{constructor(e,t){super(),this.backend=e,this.nodes=t,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(e,t){const{backend:s}=this,r=this.get(e);if(this._needsComputeUpdate(e)){const n=r.pipeline;n&&(n.usedTimes--,n.computeProgram.usedTimes--);const o=this.nodes.getForCompute(e);let a=this.programs.compute.get(o.computeShader);a===void 0&&(n&&n.computeProgram.usedTimes===0&&this._releaseProgram(n.computeProgram),a=new Qy(o.computeShader,"compute",e.name,o.transforms,o.nodeAttributes),this.programs.compute.set(o.computeShader,a),s.createProgram(a));const l=this._getComputeCacheKey(e,a);let u=this.caches.get(l);u===void 0&&(n&&n.usedTimes===0&&this._releasePipeline(n),u=this._getComputePipeline(e,a,l,t)),u.usedTimes++,a.usedTimes++,r.version=e.version,r.pipeline=u}return r.pipeline}getForRender(e,t=null){const{backend:s}=this,r=this.get(e);if(this._needsRenderUpdate(e)){const n=r.pipeline;n&&(n.usedTimes--,n.vertexProgram.usedTimes--,n.fragmentProgram.usedTimes--);const o=e.getNodeBuilderState(),a=e.material?e.material.name:"";let l=this.programs.vertex.get(o.vertexShader);l===void 0&&(n&&n.vertexProgram.usedTimes===0&&this._releaseProgram(n.vertexProgram),l=new Qy(o.vertexShader,"vertex",a),this.programs.vertex.set(o.vertexShader,l),s.createProgram(l));let u=this.programs.fragment.get(o.fragmentShader);u===void 0&&(n&&n.fragmentProgram.usedTimes===0&&this._releaseProgram(n.fragmentProgram),u=new Qy(o.fragmentShader,"fragment",a),this.programs.fragment.set(o.fragmentShader,u),s.createProgram(u));const c=this._getRenderCacheKey(e,l,u);let d=this.caches.get(c);d===void 0?(n&&n.usedTimes===0&&this._releasePipeline(n),d=this._getRenderPipeline(e,l,u,c,t)):e.pipeline=d,d.usedTimes++,l.usedTimes++,u.usedTimes++,r.pipeline=d}return r.pipeline}delete(e){const t=this.get(e).pipeline;return t&&(t.usedTimes--,t.usedTimes===0&&this._releasePipeline(t),t.isComputePipeline?(t.computeProgram.usedTimes--,t.computeProgram.usedTimes===0&&this._releaseProgram(t.computeProgram)):(t.fragmentProgram.usedTimes--,t.vertexProgram.usedTimes--,t.vertexProgram.usedTimes===0&&this._releaseProgram(t.vertexProgram),t.fragmentProgram.usedTimes===0&&this._releaseProgram(t.fragmentProgram))),super.delete(e)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}updateForRender(e){this.getForRender(e)}_getComputePipeline(e,t,s,r){s=s||this._getComputeCacheKey(e,t);let n=this.caches.get(s);return n===void 0&&(n=new L8(s,t),this.caches.set(s,n),this.backend.createComputePipeline(n,r)),n}_getRenderPipeline(e,t,s,r,n){r=r||this._getRenderCacheKey(e,t,s);let o=this.caches.get(r);return o===void 0&&(o=new k8(r,t,s),this.caches.set(r,o),e.pipeline=o,this.backend.createRenderPipeline(e,n)),o}_getComputeCacheKey(e,t){return e.id+","+t.id}_getRenderCacheKey(e,t,s){return t.id+","+s.id+","+this.backend.getRenderCacheKey(e)}_releasePipeline(e){this.caches.delete(e.cacheKey)}_releaseProgram(e){const t=e.code,s=e.stage;this.programs[s].delete(t)}_needsComputeUpdate(e){const t=this.get(e);return t.pipeline===void 0||t.version!==e.version}_needsRenderUpdate(e){return this.get(e).pipeline===void 0||this.backend.needsRenderUpdate(e)}}class $8 extends ja{constructor(e,t,s,r,n,o){super(),this.backend=e,this.textures=s,this.pipelines=n,this.attributes=r,this.nodes=t,this.info=o,this.pipelines.bindings=this}getForRender(e){const t=e.getBindings();for(const s of t){const r=this.get(s);r.bindGroup===void 0&&(this._init(s),this.backend.createBindings(s,t,0),r.bindGroup=s)}return t}getForCompute(e){const t=this.nodes.getForCompute(e).bindings;for(const s of t){const r=this.get(s);r.bindGroup===void 0&&(this._init(s),this.backend.createBindings(s,t,0),r.bindGroup=s)}return t}updateForCompute(e){this._updateBindings(this.getForCompute(e))}updateForRender(e){this._updateBindings(this.getForRender(e))}_updateBindings(e){for(const t of e)this._update(t,e)}_init(e){for(const t of e.bindings)if(t.isSampledTexture)this.textures.updateTexture(t.texture);else if(t.isStorageBuffer){const s=t.attribute,r=s.isIndirectStorageBufferAttribute?gn.INDIRECT:gn.STORAGE;this.attributes.update(s,r)}}_update(e,t){const{backend:s}=this;let r=!1,n=!0,o=0,a=0;for(const l of e.bindings)if(!(l.isNodeUniformsGroup&&this.nodes.updateGroup(l)===!1)){if(l.isStorageBuffer){const u=l.attribute,c=u.isIndirectStorageBufferAttribute?gn.INDIRECT:gn.STORAGE;this.attributes.update(u,c)}if(l.isUniformBuffer)l.update()&&s.updateBinding(l);else if(l.isSampler)l.update();else if(l.isSampledTexture){const u=this.textures.get(l.texture);l.needsBindingsUpdate(u.generation)&&(r=!0);const c=l.update(),d=l.texture;c&&this.textures.updateTexture(d);const h=s.get(d);if(h.externalTexture!==void 0||u.isDefaultTexture?n=!1:(o=o*10+d.id,a+=d.version),s.isWebGPUBackend===!0&&h.texture===void 0&&h.externalTexture===void 0&&(console.error("Bindings._update: binding should be available:",l,c,d,l.textureNode.value,r),this.textures.updateTexture(d),r=!0),d.isStorageTexture===!0){const p=this.get(d);l.store===!0?p.needsMipmap=!0:this.textures.needsMipmaps(d)&&p.needsMipmap===!0&&(this.backend.generateMipmaps(d),p.needsMipmap=!1)}}}r===!0&&this.backend.updateBindings(e,t,n?o:0,a)}}function z8(i,e){return i.groupOrder!==e.groupOrder?i.groupOrder-e.groupOrder:i.renderOrder!==e.renderOrder?i.renderOrder-e.renderOrder:i.z!==e.z?i.z-e.z:i.id-e.id}function X2(i,e){return i.groupOrder!==e.groupOrder?i.groupOrder-e.groupOrder:i.renderOrder!==e.renderOrder?i.renderOrder-e.renderOrder:i.z!==e.z?e.z-i.z:i.id-e.id}function Y2(i){return(i.transmission>0||i.transmissionNode)&&i.side===Da&&i.forceSinglePass===!1}class V8{constructor(e,t,s){this.renderItems=[],this.renderItemsIndex=0,this.opaque=[],this.transparentDoublePass=[],this.transparent=[],this.bundles=[],this.lightsNode=e.getNode(t,s),this.lightsArray=[],this.scene=t,this.camera=s,this.occlusionQueryCount=0}begin(){return this.renderItemsIndex=0,this.opaque.length=0,this.transparentDoublePass.length=0,this.transparent.length=0,this.bundles.length=0,this.lightsArray.length=0,this.occlusionQueryCount=0,this}getNextRenderItem(e,t,s,r,n,o,a){let l=this.renderItems[this.renderItemsIndex];return l===void 0?(l={id:e.id,object:e,geometry:t,material:s,groupOrder:r,renderOrder:e.renderOrder,z:n,group:o,clippingContext:a},this.renderItems[this.renderItemsIndex]=l):(l.id=e.id,l.object=e,l.geometry=t,l.material=s,l.groupOrder=r,l.renderOrder=e.renderOrder,l.z=n,l.group=o,l.clippingContext=a),this.renderItemsIndex++,l}push(e,t,s,r,n,o,a){const l=this.getNextRenderItem(e,t,s,r,n,o,a);e.occlusionTest===!0&&this.occlusionQueryCount++,s.transparent===!0||s.transmission>0?(Y2(s)&&this.transparentDoublePass.push(l),this.transparent.push(l)):this.opaque.push(l)}unshift(e,t,s,r,n,o,a){const l=this.getNextRenderItem(e,t,s,r,n,o,a);s.transparent===!0||s.transmission>0?(Y2(s)&&this.transparentDoublePass.unshift(l),this.transparent.unshift(l)):this.opaque.unshift(l)}pushBundle(e){this.bundles.push(e)}pushLight(e){this.lightsArray.push(e)}sort(e,t){this.opaque.length>1&&this.opaque.sort(e||z8),this.transparentDoublePass.length>1&&this.transparentDoublePass.sort(t||X2),this.transparent.length>1&&this.transparent.sort(t||X2)}finish(){this.lightsNode.setLights(this.lightsArray);for(let e=this.renderItemsIndex,t=this.renderItems.length;e<t;e++){const s=this.renderItems[e];if(s.id===null)break;s.id=null,s.object=null,s.geometry=null,s.material=null,s.groupOrder=null,s.renderOrder=null,s.z=null,s.group=null,s.clippingContext=null}}}const bd=[];class U8{constructor(e){this.lighting=e,this.lists=new Kn}get(e,t){const s=this.lists;bd[0]=e,bd[1]=t;let r=s.get(bd);return r===void 0&&(r=new V8(this.lighting,e,t),s.set(bd,r)),bd.length=0,r}dispose(){this.lists=new Kn}}let G8=0;class j8{constructor(){this.id=G8++,this.color=!0,this.clearColor=!0,this.clearColorValue={r:0,g:0,b:0,a:1},this.depth=!0,this.clearDepth=!0,this.clearDepthValue=1,this.stencil=!1,this.clearStencil=!0,this.clearStencilValue=1,this.viewport=!1,this.viewportValue=new ns,this.scissor=!1,this.scissorValue=new ns,this.renderTarget=null,this.textures=null,this.depthTexture=null,this.activeCubeFace=0,this.activeMipmapLevel=0,this.sampleCount=1,this.width=0,this.height=0,this.occlusionQueryCount=0,this.clippingContext=null,this.isRenderContext=!0}getCacheKey(){return zO(this)}}function zO(i){const{textures:e,activeCubeFace:t}=i,s=[t];for(const r of e)s.push(r.id);return ym(s)}const wd=[],W8=new mh,H8=new x0;class q8{constructor(){this.chainMaps={}}get(e,t,s=null){wd[0]=e,wd[1]=t;let r;if(s===null)r="default";else{const a=s.texture.format;r=`${s.textures.length}:${a}:${s.samples}:${s.depthBuffer}:${s.stencilBuffer}`}const n=this._getChainMap(r);let o=n.get(wd);return o===void 0&&(o=new j8,n.set(wd,o)),wd.length=0,s!==null&&(o.sampleCount=s.samples===0?1:s.samples),o}getForClear(e=null){return this.get(W8,H8,e)}_getChainMap(e){return this.chainMaps[e]||(this.chainMaps[e]=new Kn)}dispose(){this.chainMaps={}}}const K8=new xe;class X8 extends ja{constructor(e,t,s){super(),this.renderer=e,this.backend=t,this.info=s}updateRenderTarget(e,t=0){const s=this.get(e),r=e.samples===0?1:e.samples,n=s.depthTextureMips||(s.depthTextureMips={}),o=e.textures,a=this.getSize(o[0]),l=a.width>>t,u=a.height>>t;let c=e.depthTexture||n[t];const d=e.depthBuffer===!0||e.stencilBuffer===!0;let h=!1;c===void 0&&d&&(c=new Hn,c.format=e.stencilBuffer?Ko:fo,c.type=e.stencilBuffer?ka:_i,c.image.width=l,c.image.height=u,c.image.depth=a.depth,c.isArrayTexture=e.multiview===!0&&a.depth>1,n[t]=c),(s.width!==a.width||a.height!==s.height)&&(h=!0,c&&(c.needsUpdate=!0,c.image.width=l,c.image.height=u,c.image.depth=c.isArrayTexture?c.image.depth:1)),s.width=a.width,s.height=a.height,s.textures=o,s.depthTexture=c||null,s.depth=e.depthBuffer,s.stencil=e.stencilBuffer,s.renderTarget=e,s.sampleCount!==r&&(h=!0,c&&(c.needsUpdate=!0),s.sampleCount=r);const p={sampleCount:r};if(e.isXRRenderTarget!==!0){for(let f=0;f<o.length;f++){const m=o[f];h&&(m.needsUpdate=!0),this.updateTexture(m,p)}c&&this.updateTexture(c,p)}if(s.initialized!==!0){s.initialized=!0;const f=()=>{e.removeEventListener("dispose",f);for(let m=0;m<o.length;m++)this._destroyTexture(o[m]);c&&this._destroyTexture(c),this.delete(e)};e.addEventListener("dispose",f)}}updateTexture(e,t={}){const s=this.get(e);if(s.initialized===!0&&s.version===e.version)return;const r=e.isRenderTargetTexture||e.isDepthTexture||e.isFramebufferTexture,n=this.backend;if(r&&s.initialized===!0&&(n.destroySampler(e),n.destroyTexture(e)),e.isFramebufferTexture){const u=this.renderer.getRenderTarget();u?e.type=u.texture.type:e.type=xr}const{width:o,height:a,depth:l}=this.getSize(e);if(t.width=o,t.height=a,t.depth=l,t.needsMipmaps=this.needsMipmaps(e),t.levels=t.needsMipmaps?this.getMipLevels(e,o,a):1,r||e.isStorageTexture===!0)n.createSampler(e),n.createTexture(e,t),s.generation=e.version;else if(s.initialized!==!0&&n.createSampler(e),e.version>0){const c=e.image;if(c===void 0)console.warn("THREE.Renderer: Texture marked for update but image is undefined.");else if(c.complete===!1)console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");else{if(e.images){const d=[];for(const h of e.images)d.push(h);t.images=d}else t.image=c;(s.isDefaultTexture===void 0||s.isDefaultTexture===!0)&&(n.createTexture(e,t),s.isDefaultTexture=!1,s.generation=e.version),e.source.dataReady===!0&&n.updateTexture(e,t),t.needsMipmaps&&e.mipmaps.length===0&&n.generateMipmaps(e)}}else n.createDefaultTexture(e),s.isDefaultTexture=!0,s.generation=e.version;if(s.initialized!==!0){s.initialized=!0,s.generation=e.version,this.info.memory.textures++;const u=()=>{e.removeEventListener("dispose",u),this._destroyTexture(e)};e.addEventListener("dispose",u)}s.version=e.version}getSize(e,t=K8){let s=e.images?e.images[0]:e.image;return s?(s.image!==void 0&&(s=s.image),t.width=s.width||1,t.height=s.height||1,t.depth=e.isCubeTexture?6:s.depth||1):t.width=t.height=t.depth=1,t}getMipLevels(e,t,s){let r;return e.isCompressedTexture?e.mipmaps?r=e.mipmaps.length:r=1:r=Math.floor(Math.log2(Math.max(t,s)))+1,r}needsMipmaps(e){return e.isCompressedTexture===!0||e.generateMipmaps}_destroyTexture(e){this.has(e)===!0&&(this.backend.destroySampler(e),this.backend.destroyTexture(e),this.delete(e),this.info.memory.textures--)}}class Cw extends gs{constructor(e,t,s,r=1){super(e,t,s),this.a=r}set(e,t,s,r=1){return this.a=r,super.set(e,t,s)}copy(e){return e.a!==void 0&&(this.a=e.a),super.copy(e)}clone(){return new this.constructor(this.r,this.g,this.b,this.a)}}class VO extends Ps{static get type(){return"ParameterNode"}constructor(e,t=null){super(e,t),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}const Y8=(i,e)=>De(new VO(i,e));class Q8 extends Ft{static get type(){return"StackNode"}constructor(e=null){super(),this.nodes=[],this.outputNode=null,this.parent=e,this._currentCond=null,this._expressionNode=null,this.isStackNode=!0}getNodeType(e){return this.outputNode?this.outputNode.getNodeType(e):"void"}getMemberType(e,t){return this.outputNode?this.outputNode.getMemberType(e,t):"void"}add(e){return this.nodes.push(e),this}If(e,t){const s=new tc(t);return this._currentCond=Xi(e,s),this.add(this._currentCond)}ElseIf(e,t){const s=new tc(t),r=Xi(e,s);return this._currentCond.elseNode=r,this._currentCond=r,this}Else(e){return this._currentCond.elseNode=new tc(e),this}Switch(e){return this._expressionNode=De(e),this}Case(...e){const t=[];if(e.length>=2)for(let a=0;a<e.length-1;a++)t.push(this._expressionNode.equal(De(e[a])));else throw new Error("TSL: Invalid parameter length. Case() requires at least two parameters.");const s=e[e.length-1],r=new tc(s);let n=t[0];for(let a=1;a<t.length;a++)n=n.or(t[a]);const o=Xi(n,r);return this._currentCond===null?(this._currentCond=o,this.add(this._currentCond)):(this._currentCond.elseNode=o,this._currentCond=o,this)}Default(e){return this.Else(e),this}build(e,...t){const s=e.currentStack,r=R0();nh(this),e.currentStack=this;const n=e.buildStage;for(const a of this.nodes)if(n==="setup")a.build(e);else if(n==="analyze")a.build(e,this);else if(n==="generate"){const l=e.getDataFromNode(a,"any").stages,u=l&&l[e.shaderStage];if(a.isVarNode&&u&&u.length===1&&u[0]&&u[0].isStackNode)continue;a.build(e,"void")}const o=this.outputNode?this.outputNode.build(e,...t):super.build(e,...t);return nh(r),e.currentStack=s,o}}const Rf=ze(Q8).setParameterLength(0,1);function Z8(i){return Object.entries(i).map(([e,t])=>typeof t=="string"?{name:e,type:t,atomic:!1}:{name:e,type:t.type,atomic:t.atomic||!1})}class J8 extends Ft{static get type(){return"StructTypeNode"}constructor(e,t=null){super("struct"),this.membersLayout=Z8(e),this.name=t,this.isStructLayoutNode=!0}getLength(){const t=Float32Array.BYTES_PER_ELEMENT;let s=0;for(const r of this.membersLayout){const n=r.type,o=k4(n)*t,a=L4(n),l=s%8,u=l%a,c=l+u;s+=u,c!==0&&8-c<o&&(s+=8-c),s+=o}return Math.ceil(s/8)*8/t}getMemberType(e,t){const s=this.membersLayout.find(r=>r.name===t);return s?s.type:"void"}getNodeType(e){return e.getStructTypeFromNode(this,this.membersLayout,this.name).name}setup(e){e.addInclude(this)}generate(e){return this.getNodeType(e)}}class e5 extends Ft{static get type(){return"StructNode"}constructor(e,t){super("vec3"),this.structLayoutNode=e,this.values=t,this.isStructNode=!0}getNodeType(e){return this.structLayoutNode.getNodeType(e)}getMemberType(e,t){return this.structLayoutNode.getMemberType(e,t)}generate(e){const t=e.getVarFromNode(this),s=t.type,r=e.getPropertyName(t);return e.addLineFlowCode(`${r} = ${e.generateStruct(s,this.structLayoutNode.membersLayout,this.values)}`,this),t.name}}const t5=(i,e=null)=>{const t=new J8(i,e),s=(...r)=>{let n=null;if(r.length>0)if(r[0].isNode){n={};const o=Object.keys(i);for(let a=0;a<r.length;a++)n[o[a]]=r[a]}else n=r[0];return De(new e5(t,n))};return s.layout=t,s.isStruct=!0,s};class UO extends Ft{static get type(){return"OutputStructNode"}constructor(...e){super(),this.members=e,this.isOutputStructNode=!0}getNodeType(e){const t=e.getNodeProperties(this);if(t.membersLayout===void 0){const s=this.members,r=[];for(let n=0;n<s.length;n++){const o="m"+n,a=s[n].getNodeType(e);r.push({name:o,type:a,index:n})}t.membersLayout=r,t.structType=e.getOutputStructTypeFromNode(this,t.membersLayout)}return t.structType.name}generate(e){const t=e.getOutputStructName(),s=this.members,r=t!==""?t+".":"";for(let n=0;n<s.length;n++){const o=s[n].build(e);e.addLineFlowCode(`${r}m${n} = ${o}`,this)}return t}}const s5=ze(UO);function GO(i,e){for(let t=0;t<i.length;t++)if(i[t].name===e)return t;return-1}class i5 extends UO{static get type(){return"MRTNode"}constructor(e){super(),this.outputNodes=e,this.isMRTNode=!0}has(e){return this.outputNodes[e]!==void 0}get(e){return this.outputNodes[e]}merge(e){const t={...this.outputNodes,...e.outputNodes};return jO(t)}setup(e){const t=this.outputNodes,s=e.renderer.getRenderTarget(),r=[],n=s.textures;for(const o in t){const a=GO(n,o);r[a]=St(t[o])}return this.members=r,super.setup(e)}}const jO=ze(i5),r5=ge(([i])=>{const e=i.toUint().mul(747796405).add(2891336453),t=e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);return t.shiftRight(22).bitXor(t).toFloat().mul(1/2**32)}),Tb=(i,e)=>jn(Wt(4,i.mul(us(1,i))),e),n5=(i,e)=>i.lessThan(.5)?Tb(i.mul(2),e).div(2):us(1,Tb(Wt(us(1,i),2),e).div(2)),o5=(i,e,t)=>jn(wn(jn(i,e),Ri(jn(i,e),jn(us(1,i),t))),1/e),a5=(i,e)=>qr(rm.mul(e.mul(i).sub(1))).div(rm.mul(e.mul(i).sub(1))),Vo=ge(([i])=>i.fract().sub(.5).abs()).setLayout({name:"tri",type:"float",inputs:[{name:"x",type:"float"}]}),l5=ge(([i])=>pe(Vo(i.z.add(Vo(i.y.mul(1)))),Vo(i.z.add(Vo(i.x.mul(1)))),Vo(i.y.add(Vo(i.x.mul(1)))))).setLayout({name:"tri3",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),u5=ge(([i,e,t])=>{const s=pe(i).toVar(),r=Y(1.4).toVar(),n=Y(0).toVar(),o=pe(s).toVar();return Rs({start:Y(0),end:Y(3),type:"float",condition:"<="},()=>{const a=pe(l5(o.mul(2))).toVar();s.addAssign(a.add(t.mul(Y(.1).mul(e)))),o.mulAssign(1.8),r.mulAssign(1.5),s.mulAssign(1.2);const l=Y(Vo(s.z.add(Vo(s.x.add(Vo(s.y)))))).toVar();n.addAssign(l.div(r)),o.addAssign(.14)}),n}).setLayout({name:"triNoise3D",type:"float",inputs:[{name:"position",type:"vec3"},{name:"speed",type:"float"},{name:"time",type:"float"}]});class c5 extends Ft{static get type(){return"FunctionOverloadingNode"}constructor(e=[],...t){super(),this.functionNodes=e,this.parametersNodes=t,this._candidateFnCall=null,this.global=!0}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(e){const t=this.parametersNodes;let s=this._candidateFnCall;if(s===null){let r=null,n=-1;for(const o of this.functionNodes){const l=o.shaderNode.layout;if(l===null)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const u=l.inputs;if(t.length===u.length){let c=0;for(let d=0;d<t.length;d++){const h=t[d],p=u[d];h.getNodeType(e)===p.type?c++:c=0}c>n&&(r=o,n=c)}}this._candidateFnCall=s=r(...t)}return s}}const d5=ze(c5),sr=i=>(...e)=>d5(i,...e),nu=Et(0).setGroup(Rt).onRenderUpdate(i=>i.time),WO=Et(0).setGroup(Rt).onRenderUpdate(i=>i.deltaTime),h5=Et(0,"uint").setGroup(Rt).onRenderUpdate(i=>i.frameId),p5=(i=1)=>(console.warn('TSL: timerLocal() is deprecated. Use "time" instead.'),nu.mul(i)),f5=(i=1)=>(console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.'),nu.mul(i)),m5=(i=1)=>(console.warn('TSL: timerDelta() is deprecated. Use "deltaTime" instead.'),WO.mul(i)),g5=(i=nu)=>i.add(.75).mul(Math.PI*2).sin().mul(.5).add(.5),_5=(i=nu)=>i.fract().round(),y5=(i=nu)=>i.add(.5).fract().mul(2).sub(1).abs(),x5=(i=nu)=>i.fract(),b5=ge(([i,e,t=Ge(.5)])=>Um(i.sub(t),e).add(t)),w5=ge(([i,e,t=Ge(.5)])=>{const s=i.sub(t),r=s.dot(s),o=r.mul(r).mul(e);return i.add(s.mul(o))}),M5=ge(({position:i=null,horizontal:e=!0,vertical:t=!1})=>{let s;i!==null?(s=mn.toVar(),s[3][0]=i.x,s[3][1]=i.y,s[3][2]=i.z):s=mn;const r=Tn.mul(s);return rh(e)&&(r[0][0]=mn[0].length(),r[0][1]=0,r[0][2]=0),rh(t)&&(r[1][0]=0,r[1][1]=mn[1].length(),r[1][2]=0),r[2][0]=0,r[2][1]=0,r[2][2]=1,iu.mul(r).mul(di)}),T5=ge(([i=null])=>{const e=am();return am(gw(i)).sub(e).lessThan(0).select(Jo,i)});class v5 extends Ft{static get type(){return"SpriteSheetUVNode"}constructor(e,t=qs(),s=Y(0)){super("vec2"),this.countNode=e,this.uvNode=t,this.frameNode=s}setup(){const{frameNode:e,uvNode:t,countNode:s}=this,{width:r,height:n}=s,o=e.mod(r.mul(n)).floor(),a=o.mod(r),l=n.sub(o.add(1).div(r).ceil()),u=s.reciprocal(),c=Ge(a,l);return t.add(c).mul(u)}}const S5=ze(v5).setParameterLength(3),HO=ge(([i,e=null,t=null,s=Y(1),r=di,n=Dr])=>{let o=n.abs().normalize();o=o.div(o.dot(pe(1)));const a=r.yz.mul(s),l=r.zx.mul(s),u=r.xy.mul(s),c=i.value,d=e!==null?e.value:c,h=t!==null?t.value:c,p=ts(c,a).mul(o.x),f=ts(d,l).mul(o.y),m=ts(h,u).mul(o.z);return Ri(p,f,m)}),E5=(...i)=>HO(...i),$u=new $o,Tl=new xe,zu=new xe,Zy=new xe,Md=new cs,nf=new xe(0,0,-1),ao=new ns,Td=new xe,of=new xe,vd=new ns,af=new Dt,lm=new So,A5=Jo.flipX();lm.depthTexture=new Hn(1,1);let lf=!1;class Pw extends To{static get type(){return"ReflectorNode"}constructor(e={}){super(e.defaultTexture||lm.texture,A5),this._reflectorBaseNode=e.reflector||new C5(this,e),this._depthNode=null,this.setUpdateMatrix(!1)}get reflector(){return this._reflectorBaseNode}get target(){return this._reflectorBaseNode.target}getDepthNode(){if(this._depthNode===null){if(this._reflectorBaseNode.depth!==!0)throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");this._depthNode=De(new Pw({defaultTexture:lm.depthTexture,reflector:this._reflectorBaseNode}))}return this._depthNode}setup(e){return e.object.isQuadMesh||this._reflectorBaseNode.build(e),super.setup(e)}clone(){const e=new this.constructor(this.reflectorNode);return e.uvNode=this.uvNode,e.levelNode=this.levelNode,e.biasNode=this.biasNode,e.sampler=this.sampler,e.depthNode=this.depthNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e._reflectorBaseNode=this._reflectorBaseNode,e}dispose(){super.dispose(),this._reflectorBaseNode.dispose()}}class C5 extends Ft{static get type(){return"ReflectorBaseNode"}constructor(e,t={}){super();const{target:s=new Fi,resolution:r=1,generateMipmaps:n=!1,bounces:o=!0,depth:a=!1}=t;this.textureNode=e,this.target=s,this.resolution=r,this.generateMipmaps=n,this.bounces=o,this.depth=a,this.updateBeforeType=o?Kt.RENDER:Kt.FRAME,this.virtualCameras=new WeakMap,this.renderTargets=new Map,this.forceUpdate=!1,this.hasOutput=!1}_updateResolution(e,t){const s=this.resolution;t.getDrawingBufferSize(af),e.setSize(Math.round(af.width*s),Math.round(af.height*s))}setup(e){return this._updateResolution(lm,e.renderer),super.setup(e)}dispose(){super.dispose();for(const e of this.renderTargets.values())e.dispose()}getVirtualCamera(e){let t=this.virtualCameras.get(e);return t===void 0&&(t=e.clone(),this.virtualCameras.set(e,t)),t}getRenderTarget(e){let t=this.renderTargets.get(e);return t===void 0&&(t=new So(0,0,{type:Cr}),this.generateMipmaps===!0&&(t.texture.minFilter=DV,t.texture.generateMipmaps=!0),this.depth===!0&&(t.depthTexture=new Hn),this.renderTargets.set(e,t)),t}updateBefore(e){if(this.bounces===!1&&lf)return!1;lf=!0;const{scene:t,camera:s,renderer:r,material:n}=e,{target:o}=this,a=this.getVirtualCamera(s),l=this.getRenderTarget(a);r.getDrawingBufferSize(af),this._updateResolution(l,r),zu.setFromMatrixPosition(o.matrixWorld),Zy.setFromMatrixPosition(s.matrixWorld),Md.extractRotation(o.matrixWorld),Tl.set(0,0,1),Tl.applyMatrix4(Md),Td.subVectors(zu,Zy);const u=Td.dot(Tl)>0;let c=!1;if(u===!0&&this.forceUpdate===!1){if(this.hasOutput===!1){lf=!1;return}c=!0}Td.reflect(Tl).negate(),Td.add(zu),Md.extractRotation(s.matrixWorld),nf.set(0,0,-1),nf.applyMatrix4(Md),nf.add(Zy),of.subVectors(zu,nf),of.reflect(Tl).negate(),of.add(zu),a.coordinateSystem=s.coordinateSystem,a.position.copy(Td),a.up.set(0,1,0),a.up.applyMatrix4(Md),a.up.reflect(Tl),a.lookAt(of),a.near=s.near,a.far=s.far,a.updateMatrixWorld(),a.projectionMatrix.copy(s.projectionMatrix),$u.setFromNormalAndCoplanarPoint(Tl,zu),$u.applyMatrix4(a.matrixWorldInverse),ao.set($u.normal.x,$u.normal.y,$u.normal.z,$u.constant);const d=a.projectionMatrix;vd.x=(Math.sign(ao.x)+d.elements[8])/d.elements[0],vd.y=(Math.sign(ao.y)+d.elements[9])/d.elements[5],vd.z=-1,vd.w=(1+d.elements[10])/d.elements[14],ao.multiplyScalar(1/ao.dot(vd));const h=0;d.elements[2]=ao.x,d.elements[6]=ao.y,d.elements[10]=r.coordinateSystem===xo?ao.z-h:ao.z+1-h,d.elements[14]=ao.w,this.textureNode.value=l.texture,this.depth===!0&&(this.textureNode.getDepthNode().value=l.depthTexture),n.visible=!1;const p=r.getRenderTarget(),f=r.getMRT(),m=r.autoClear;r.setMRT(null),r.setRenderTarget(l),r.autoClear=!0,c?(r.clear(),this.hasOutput=!1):(r.render(t,a),this.hasOutput=!0),r.setMRT(f),r.setRenderTarget(p),r.autoClear=m,n.visible=!0,lf=!1,this.forceUpdate=!1}}const P5=i=>De(new Pw(i)),Jy=new gm(-1,1,1,-1,0,1);class N5 extends aa{constructor(e=!1){super();const t=e===!1?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new br([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new br(t,2))}}const F5=new N5;class Gm extends bn{constructor(e=null){super(F5,e),this.camera=Jy,this.isQuadMesh=!0}async renderAsync(e){return e.renderAsync(this,Jy)}render(e){e.render(this,Jy)}}const R5=new Dt;class I5 extends To{static get type(){return"RTTNode"}constructor(e,t=null,s=null,r={type:Cr}){const n=new So(t,s,r);super(n.texture,qs()),this.node=e,this.width=t,this.height=s,this.pixelRatio=1,this.renderTarget=n,this.textureNeedsUpdate=!0,this.autoUpdate=!0,this._rttNode=null,this._quadMesh=new Gm(new pi),this.updateBeforeType=Kt.RENDER}get autoResize(){return this.width===null}setup(e){return this._rttNode=this.node.context(e.getSharedContext()),this._quadMesh.material.name="RTT",this._quadMesh.material.needsUpdate=!0,super.setup(e)}setSize(e,t){this.width=e,this.height=t;const s=e*this.pixelRatio,r=t*this.pixelRatio;this.renderTarget.setSize(s,r),this.textureNeedsUpdate=!0}setPixelRatio(e){this.pixelRatio=e,this.setSize(this.width,this.height)}updateBefore({renderer:e}){if(this.textureNeedsUpdate===!1&&this.autoUpdate===!1)return;if(this.textureNeedsUpdate=!1,this.autoResize===!0){const s=e.getPixelRatio(),r=e.getSize(R5),n=r.width*s,o=r.height*s;(n!==this.renderTarget.width||o!==this.renderTarget.height)&&(this.renderTarget.setSize(n,o),this.textureNeedsUpdate=!0)}this._quadMesh.material.fragmentNode=this._rttNode;const t=e.getRenderTarget();e.setRenderTarget(this.renderTarget),this._quadMesh.render(e),e.setRenderTarget(t)}clone(){const e=new To(this.value,this.uvNode,this.levelNode);return e.sampler=this.sampler,e.referenceNode=this,e}}const qO=(i,...e)=>De(new I5(De(i),...e)),D5=(i,...e)=>i.isTextureNode?i:i.isPassNode?i.getTextureNode():qO(i,...e),Ku=ge(([i,e,t],s)=>{let r;s.renderer.coordinateSystem===xo?(i=Ge(i.x,i.y.oneMinus()).mul(2).sub(1),r=St(pe(i,e),1)):r=St(pe(i.x,i.y.oneMinus(),e).mul(2).sub(1),1);const n=St(t.mul(r));return n.xyz.div(n.w)}),k5=ge(([i,e])=>{const t=e.mul(St(i,1)),s=t.xy.div(t.w).mul(.5).add(.5).toVar();return Ge(s.x,s.y.oneMinus())}),L5=ge(([i,e,t])=>{const s=La(ci(e)),r=Vi(i.mul(s)).toVar(),n=ci(e,r).toVar(),o=ci(e,r.sub(Vi(2,0))).toVar(),a=ci(e,r.sub(Vi(1,0))).toVar(),l=ci(e,r.add(Vi(1,0))).toVar(),u=ci(e,r.add(Vi(2,0))).toVar(),c=ci(e,r.add(Vi(0,2))).toVar(),d=ci(e,r.add(Vi(0,1))).toVar(),h=ci(e,r.sub(Vi(0,1))).toVar(),p=ci(e,r.sub(Vi(0,2))).toVar(),f=Us(us(Y(2).mul(a).sub(o),n)).toVar(),m=Us(us(Y(2).mul(l).sub(u),n)).toVar(),x=Us(us(Y(2).mul(d).sub(c),n)).toVar(),g=Us(us(Y(2).mul(h).sub(p),n)).toVar(),_=Ku(i,n,t).toVar(),S=f.lessThan(m).select(_.sub(Ku(i.sub(Ge(Y(1).div(s.x),0)),a,t)),_.negate().add(Ku(i.add(Ge(Y(1).div(s.x),0)),l,t))),M=x.lessThan(g).select(_.sub(Ku(i.add(Ge(0,Y(1).div(s.y))),d,t)),_.negate().add(Ku(i.sub(Ge(0,Y(1).div(s.y))),h,t)));return sa(Nm(S,M))});class B5 extends Ft{static get type(){return"SampleNode"}constructor(e){super(),this.callback=e,this.isSampleNode=!0}setup(){return this.sample(qs())}sample(e){return this.callback(e)}}const O5=i=>De(new B5(i));class $5 extends ac{constructor(e,t,s=Float32Array){const r=ArrayBuffer.isView(e)?e:new s(e*t);super(r,t),this.isStorageInstancedBufferAttribute=!0}}class z5 extends Yr{constructor(e,t,s=Float32Array){const r=ArrayBuffer.isView(e)?e:new s(e*t);super(r,t),this.isStorageBufferAttribute=!0}}const V5=(i,e="float")=>{let t,s;e.isStruct===!0?(t=e.layout.getLength(),s=Jf("float")):(t=ak(e),s=Jf(e));const r=new z5(i,t,s);return Hl(r,e,i)},U5=(i,e="float")=>{let t,s;e.isStruct===!0?(t=e.layout.getLength(),s=Jf("float")):(t=ak(e),s=Jf(e));const r=new $5(i,t,s);return Hl(r,e,i)};class G5 extends Ft{static get type(){return"PointUVNode"}constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}const j5=ot(G5),Sd=new xn,ex=new cs;class Fr extends Ft{static get type(){return"SceneNode"}constructor(e=Fr.BACKGROUND_BLURRINESS,t=null){super(),this.scope=e,this.scene=t}setup(e){const t=this.scope,s=this.scene!==null?this.scene:e.scene;let r;return t===Fr.BACKGROUND_BLURRINESS?r=Os("backgroundBlurriness","float",s):t===Fr.BACKGROUND_INTENSITY?r=Os("backgroundIntensity","float",s):t===Fr.BACKGROUND_ROTATION?r=Et("mat4").label("backgroundRotation").setGroup(Rt).onRenderUpdate(()=>{const n=s.background;return n!==null&&n.isTexture&&n.mapping!==a0?(Sd.copy(s.backgroundRotation),Sd.x*=-1,Sd.y*=-1,Sd.z*=-1,ex.makeRotationFromEuler(Sd)):ex.identity(),ex}):console.error("THREE.SceneNode: Unknown scope:",t),r}}Fr.BACKGROUND_BLURRINESS="backgroundBlurriness";Fr.BACKGROUND_INTENSITY="backgroundIntensity";Fr.BACKGROUND_ROTATION="backgroundRotation";const KO=ot(Fr,Fr.BACKGROUND_BLURRINESS),vb=ot(Fr,Fr.BACKGROUND_INTENSITY),XO=ot(Fr,Fr.BACKGROUND_ROTATION);class W5 extends To{static get type(){return"StorageTextureNode"}constructor(e,t,s=null){super(e,t),this.storeNode=s,this.isStorageTextureNode=!0,this.access=ar.WRITE_ONLY}getInputType(){return"storageTexture"}setup(e){super.setup(e);const t=e.getNodeProperties(this);return t.storeNode=this.storeNode,t}setAccess(e){return this.access=e,this}generate(e,t){let s;return this.storeNode!==null?s=this.generateStore(e):s=super.generate(e,t),s}toReadWrite(){return this.setAccess(ar.READ_WRITE)}toReadOnly(){return this.setAccess(ar.READ_ONLY)}toWriteOnly(){return this.setAccess(ar.WRITE_ONLY)}generateStore(e){const t=e.getNodeProperties(this),{uvNode:s,storeNode:r,depthNode:n}=t,o=super.generate(e,"property"),a=s.build(e,"uvec2"),l=r.build(e,"vec4"),u=n?n.build(e,"int"):null,c=e.generateTextureStore(e,o,a,u,l);e.addLineFlowCode(c,this)}clone(){const e=super.clone();return e.storeNode=this.storeNode,e}}const YO=ze(W5).setParameterLength(1,3),H5=(i,e,t)=>{const s=YO(i,e,t);return t!==null&&s.toStack(),s},q5=ge(({texture:i,uv:e})=>{const s=pe().toVar();return Ht(e.x.lessThan(1e-4),()=>{s.assign(pe(1,0,0))}).ElseIf(e.y.lessThan(1e-4),()=>{s.assign(pe(0,1,0))}).ElseIf(e.z.lessThan(1e-4),()=>{s.assign(pe(0,0,1))}).ElseIf(e.x.greaterThan(1-1e-4),()=>{s.assign(pe(-1,0,0))}).ElseIf(e.y.greaterThan(1-1e-4),()=>{s.assign(pe(0,-1,0))}).ElseIf(e.z.greaterThan(1-1e-4),()=>{s.assign(pe(0,0,-1))}).Else(()=>{const n=i.sample(e.add(pe(-.01,0,0))).r.sub(i.sample(e.add(pe(.01,0,0))).r),o=i.sample(e.add(pe(0,-.01,0))).r.sub(i.sample(e.add(pe(0,.01,0))).r),a=i.sample(e.add(pe(0,0,-.01))).r.sub(i.sample(e.add(pe(0,0,.01))).r);s.assign(pe(n,o,a))}),s.normalize()});class K5 extends To{static get type(){return"Texture3DNode"}constructor(e,t=null,s=null){super(e,t,s),this.isTexture3DNode=!0}getInputType(){return"texture3D"}getDefaultUV(){return pe(.5,.5,.5)}setUpdateMatrix(){}setupUV(e,t){const s=this.value;return e.isFlipY()&&(s.isRenderTargetTexture===!0||s.isFramebufferTexture===!0)&&(this.sampler?t=t.flipY():t=t.setY(ne(La(this,this.levelNode).y).sub(t.y).sub(1))),t}generateUV(e,t){return t.build(e,"vec3")}normal(e){return q5({texture:this,uv:e})}}const QO=ze(K5).setParameterLength(1,3);class X5 extends km{static get type(){return"UserDataNode"}constructor(e,t,s=null){super(e,t,s),this.userData=s}updateReference(e){return this.reference=this.userData!==null?this.userData:e.object.userData,this.reference}}const Y5=(i,e,t)=>De(new X5(i,e,t)),Q2=new WeakMap;class Q5 extends Ii{static get type(){return"VelocityNode"}constructor(){super("vec2"),this.projectionMatrix=null,this.updateType=Kt.OBJECT,this.updateAfterType=Kt.OBJECT,this.previousModelWorldMatrix=Et(new cs),this.previousProjectionMatrix=Et(new cs).setGroup(Rt),this.previousCameraViewMatrix=Et(new cs)}setProjectionMatrix(e){this.projectionMatrix=e}update({frameId:e,camera:t,object:s}){const r=Z2(s);this.previousModelWorldMatrix.value.copy(r);const n=ZO(t);n.frameId!==e&&(n.frameId=e,n.previousProjectionMatrix===void 0?(n.previousProjectionMatrix=new cs,n.previousCameraViewMatrix=new cs,n.currentProjectionMatrix=new cs,n.currentCameraViewMatrix=new cs,n.previousProjectionMatrix.copy(this.projectionMatrix||t.projectionMatrix),n.previousCameraViewMatrix.copy(t.matrixWorldInverse)):(n.previousProjectionMatrix.copy(n.currentProjectionMatrix),n.previousCameraViewMatrix.copy(n.currentCameraViewMatrix)),n.currentProjectionMatrix.copy(this.projectionMatrix||t.projectionMatrix),n.currentCameraViewMatrix.copy(t.matrixWorldInverse),this.previousProjectionMatrix.value.copy(n.previousProjectionMatrix),this.previousCameraViewMatrix.value.copy(n.previousCameraViewMatrix))}updateAfter({object:e}){Z2(e).copy(e.matrixWorld)}setup(){const e=this.projectionMatrix===null?iu:Et(this.projectionMatrix),t=this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix),s=e.mul(ru).mul(di),r=this.previousProjectionMatrix.mul(t).mul(om),n=s.xy.div(s.w),o=r.xy.div(r.w);return us(n,o)}}function ZO(i){let e=Q2.get(i);return e===void 0&&(e={},Q2.set(i,e)),e}function Z2(i,e=0){const t=ZO(i);let s=t[e];return s===void 0&&(t[e]=s=new cs,t[e].copy(i.matrixWorld)),s}const Z5=ot(Q5),J5=ge(([i])=>Nw(i.rgb)),e6=ge(([i,e=Y(1)])=>e.mix(Nw(i.rgb),i.rgb)),t6=ge(([i,e=Y(1)])=>{const t=Ri(i.r,i.g,i.b).div(3),s=i.r.max(i.g.max(i.b)),r=s.sub(t).mul(e).mul(-3);return Cs(i.rgb,s,r)}),s6=ge(([i,e=Y(1)])=>{const t=pe(.57735,.57735,.57735),s=e.cos();return pe(i.rgb.mul(s).add(t.cross(i.rgb).mul(e.sin()).add(t.mul(Ua(t,i.rgb).mul(s.oneMinus())))))}),Nw=(i,e=pe(Ls.getLuminanceCoefficients(new xe)))=>Ua(i,e),i6=ge(([i,e=pe(1),t=pe(0),s=pe(1),r=Y(1),n=pe(Ls.getLuminanceCoefficients(new xe,Ul))])=>{const o=i.rgb.dot(pe(n)),a=ni(i.rgb.mul(e).add(t),0).toVar(),l=a.pow(s).toVar();return Ht(a.r.greaterThan(0),()=>{a.r.assign(l.r)}),Ht(a.g.greaterThan(0),()=>{a.g.assign(l.g)}),Ht(a.b.greaterThan(0),()=>{a.b.assign(l.b)}),a.assign(o.add(a.sub(o).mul(r))),St(a.rgb,i.a)});class r6 extends Ii{static get type(){return"PosterizeNode"}constructor(e,t){super(),this.sourceNode=e,this.stepsNode=t}setup(){const{sourceNode:e,stepsNode:t}=this;return e.mul(t).floor().div(t)}}const n6=ze(r6).setParameterLength(2),uf=new Dt;class JO extends To{static get type(){return"PassTextureNode"}constructor(e,t){super(t),this.passNode=e,this.setUpdateMatrix(!1)}setup(e){return e.object.isQuadMesh&&this.passNode.build(e),super.setup(e)}clone(){return new this.constructor(this.passNode,this.value)}}class J2 extends JO{static get type(){return"PassMultipleTextureNode"}constructor(e,t,s=!1){super(e,null),this.textureName=t,this.previousTexture=s}updateTexture(){this.value=this.previousTexture?this.passNode.getPreviousTexture(this.textureName):this.passNode.getTexture(this.textureName)}setup(e){return this.updateTexture(),super.setup(e)}clone(){const e=new this.constructor(this.passNode,this.textureName,this.previousTexture);return e.uvNode=this.uvNode,e.levelNode=this.levelNode,e.biasNode=this.biasNode,e.sampler=this.sampler,e.depthNode=this.depthNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e}}class vo extends Ii{static get type(){return"PassNode"}constructor(e,t,s,r={}){super("vec4"),this.scope=e,this.scene=t,this.camera=s,this.options=r,this._pixelRatio=1,this._width=1,this._height=1;const n=new Hn;n.isRenderTargetTexture=!0,n.name="depth";const o=new So(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:Cr,...r});o.texture.name="output",o.depthTexture=n,this.renderTarget=o,this._textures={output:o.texture,depth:n},this._textureNodes={},this._linearDepthNodes={},this._viewZNodes={},this._previousTextures={},this._previousTextureNodes={},this._cameraNear=Et(0),this._cameraFar=Et(0),this._mrt=null,this._layers=null,this._resolution=1,this.isPassNode=!0,this.updateBeforeType=Kt.FRAME,this.global=!0}setResolution(e){return this._resolution=e,this}getResolution(){return this._resolution}setLayers(e){return this._layers=e,this}getLayers(){return this._layers}setMRT(e){return this._mrt=e,this}getMRT(){return this._mrt}getTexture(e){let t=this._textures[e];return t===void 0&&(t=this.renderTarget.texture.clone(),t.name=e,this._textures[e]=t,this.renderTarget.textures.push(t)),t}getPreviousTexture(e){let t=this._previousTextures[e];return t===void 0&&(t=this.getTexture(e).clone(),this._previousTextures[e]=t),t}toggleTexture(e){const t=this._previousTextures[e];if(t!==void 0){const s=this._textures[e],r=this.renderTarget.textures.indexOf(s);this.renderTarget.textures[r]=t,this._textures[e]=t,this._previousTextures[e]=s,this._textureNodes[e].updateTexture(),this._previousTextureNodes[e].updateTexture()}}getTextureNode(e="output"){let t=this._textureNodes[e];return t===void 0&&(t=De(new J2(this,e)),t.updateTexture(),this._textureNodes[e]=t),t}getPreviousTextureNode(e="output"){let t=this._previousTextureNodes[e];return t===void 0&&(this._textureNodes[e]===void 0&&this.getTextureNode(e),t=De(new J2(this,e,!0)),t.updateTexture(),this._previousTextureNodes[e]=t),t}getViewZNode(e="depth"){let t=this._viewZNodes[e];if(t===void 0){const s=this._cameraNear,r=this._cameraFar;this._viewZNodes[e]=t=_w(this.getTextureNode(e),s,r)}return t}getLinearDepthNode(e="depth"){let t=this._linearDepthNodes[e];if(t===void 0){const s=this._cameraNear,r=this._cameraFar,n=this.getViewZNode(e);this._linearDepthNodes[e]=t=dc(n,s,r)}return t}setup({renderer:e}){return this.renderTarget.samples=this.options.samples===void 0?e.samples:this.options.samples,this.renderTarget.texture.type=e.getColorBufferType(),this.scope===vo.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(e){const{renderer:t}=e,{scene:s}=this;let r,n;const o=t.getOutputRenderTarget();o&&o.isXRRenderTarget===!0?(n=1,r=t.xr.getCamera(),t.xr.updateCamera(r),uf.set(o.width,o.height)):(r=this.camera,n=t.getPixelRatio(),t.getSize(uf)),this._pixelRatio=n,this.setSize(uf.width,uf.height);const a=t.getRenderTarget(),l=t.getMRT(),u=r.layers.mask;this._cameraNear.value=r.near,this._cameraFar.value=r.far,this._layers!==null&&(r.layers.mask=this._layers.mask);for(const c in this._previousTextures)this.toggleTexture(c);t.setRenderTarget(this.renderTarget),t.setMRT(this._mrt),t.render(s,r),t.setRenderTarget(a),t.setMRT(l),r.layers.mask=u}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio*this._resolution,r=this._height*this._pixelRatio*this._resolution;this.renderTarget.setSize(s,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}vo.COLOR="color";vo.DEPTH="depth";const o6=(i,e,t)=>De(new vo(vo.COLOR,i,e,t)),a6=(i,e)=>De(new JO(i,e)),l6=(i,e,t)=>De(new vo(vo.DEPTH,i,e,t));class u6 extends vo{static get type(){return"ToonOutlinePassNode"}constructor(e,t,s,r,n){super(vo.COLOR,e,t),this.colorNode=s,this.thicknessNode=r,this.alphaNode=n,this._materialCache=new WeakMap}updateBefore(e){const{renderer:t}=e,s=t.getRenderObjectFunction();t.setRenderObjectFunction((r,n,o,a,l,u,c,d)=>{if((l.isMeshToonMaterial||l.isMeshToonNodeMaterial)&&l.wireframe===!1){const h=this._getOutlineMaterial(l);t.renderObject(r,n,o,a,h,u,c,d)}t.renderObject(r,n,o,a,l,u,c,d)}),super.updateBefore(e),t.setRenderObjectFunction(s)}_createMaterial(){const e=new pi;e.isMeshToonOutlineMaterial=!0,e.name="Toon_Outline",e.side=lr;const t=Dr.negate(),s=iu.mul(ru),r=Y(1),n=s.mul(St(di,1)),o=s.mul(St(di.add(t),1)),a=sa(n.sub(o));return e.vertexNode=n.add(a.mul(this.thicknessNode).mul(n.w).mul(r)),e.colorNode=St(this.colorNode,this.alphaNode),e}_getOutlineMaterial(e){let t=this._materialCache.get(e);return t===void 0&&(t=this._createMaterial(),this._materialCache.set(e,t)),t}}const c6=(i,e,t=new gs(0,0,0),s=.003,r=1)=>De(new u6(i,e,De(t),De(s),De(r))),e$=ge(([i,e])=>i.mul(e).clamp()).setLayout({name:"linearToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),t$=ge(([i,e])=>(i=i.mul(e),i.div(i.add(1)).clamp())).setLayout({name:"reinhardToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),s$=ge(([i,e])=>{i=i.mul(e),i=i.sub(.004).max(0);const t=i.mul(i.mul(6.2).add(.5)),s=i.mul(i.mul(6.2).add(1.7)).add(.06);return t.div(s).pow(2.2)}).setLayout({name:"cineonToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),d6=ge(([i])=>{const e=i.mul(i.add(.0245786)).sub(90537e-9),t=i.mul(i.add(.432951).mul(.983729)).add(.238081);return e.div(t)}),i$=ge(([i,e])=>{const t=cr(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),s=cr(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return i=i.mul(e).div(.6),i=t.mul(i),i=d6(i),i=s.mul(i),i.clamp()}).setLayout({name:"acesFilmicToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),h6=cr(pe(1.6605,-.1246,-.0182),pe(-.5876,1.1329,-.1006),pe(-.0728,-.0083,1.1187)),p6=cr(pe(.6274,.0691,.0164),pe(.3293,.9195,.088),pe(.0433,.0113,.8956)),f6=ge(([i])=>{const e=pe(i).toVar(),t=pe(e.mul(e)).toVar(),s=pe(t.mul(t)).toVar();return Y(15.5).mul(s.mul(t)).sub(Wt(40.14,s.mul(e))).add(Wt(31.96,s).sub(Wt(6.868,t.mul(e))).add(Wt(.4298,t).add(Wt(.1191,e).sub(.00232))))}),r$=ge(([i,e])=>{const t=pe(i).toVar(),s=cr(pe(.856627153315983,.137318972929847,.11189821299995),pe(.0951212405381588,.761241990602591,.0767994186031903),pe(.0482516061458583,.101439036467562,.811302368396859)),r=cr(pe(1.1271005818144368,-.1413297634984383,-.14132976349843826),pe(-.11060664309660323,1.157823702216272,-.11060664309660294),pe(-.016493938717834573,-.016493938717834257,1.2519364065950405)),n=Y(-12.47393),o=Y(4.026069);return t.mulAssign(e),t.assign(p6.mul(t)),t.assign(s.mul(t)),t.assign(ni(t,1e-10)),t.assign(mo(t)),t.assign(t.sub(n).div(o.sub(n))),t.assign(wo(t,0,1)),t.assign(f6(t)),t.assign(r.mul(t)),t.assign(jn(ni(pe(0),t),pe(2.2))),t.assign(h6.mul(t)),t.assign(wo(t,0,1)),t}).setLayout({name:"agxToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),n$=ge(([i,e])=>{const t=Y(.76),s=Y(.15);i=i.mul(e);const r=Ir(i.r,Ir(i.g,i.b)),n=Xi(r.lessThan(.08),r.sub(Wt(6.25,r.mul(r))),.04);i.subAssign(n);const o=ni(i.r,ni(i.g,i.b));Ht(o.lessThan(t),()=>i);const a=us(1,t),l=us(1,a.mul(a).div(o.add(a.sub(t))));i.mulAssign(l.div(o));const u=us(1,wn(1,s.mul(o.sub(l)).add(1)));return Cs(i,pe(l),u)}).setLayout({name:"neutralToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]});class Ci extends Ft{static get type(){return"CodeNode"}constructor(e="",t=[],s=""){super("code"),this.isCodeNode=!0,this.global=!0,this.code=e,this.includes=t,this.language=s}setIncludes(e){return this.includes=e,this}getIncludes(){return this.includes}generate(e){const t=this.getIncludes(e);for(const r of t)r.build(e);const s=e.getCodeFromNode(this,this.getNodeType(e));return s.code=this.code,s.code}serialize(e){super.serialize(e),e.code=this.code,e.language=this.language}deserialize(e){super.deserialize(e),this.code=e.code,this.language=e.language}}const jm=ze(Ci).setParameterLength(1,3),m6=(i,e)=>jm(i,e,"js"),g6=(i,e)=>jm(i,e,"wgsl"),_6=(i,e)=>jm(i,e,"glsl");class o$ extends Ci{static get type(){return"FunctionNode"}constructor(e="",t=[],s=""){super(e,t,s)}getNodeType(e){return this.getNodeFunction(e).type}getInputs(e){return this.getNodeFunction(e).inputs}getNodeFunction(e){const t=e.getDataFromNode(this);let s=t.nodeFunction;return s===void 0&&(s=e.parser.parseFunction(this.code),t.nodeFunction=s),s}generate(e,t){super.generate(e);const s=this.getNodeFunction(e),r=s.name,n=s.type,o=e.getCodeFromNode(this,n);r!==""&&(o.name=r);const a=e.getPropertyName(o),l=this.getNodeFunction(e).getCode(a);return o.code=l+`
`,t==="property"?a:e.format(`${a}()`,n,t)}}const a$=(i,e=[],t="")=>{for(let n=0;n<e.length;n++){const o=e[n];typeof o=="function"&&(e[n]=o.functionNode)}const s=De(new o$(i,e,t)),r=(...n)=>s.call(...n);return r.functionNode=s,r},y6=(i,e)=>a$(i,e,"glsl"),x6=(i,e)=>a$(i,e,"wgsl");class b6 extends Ft{static get type(){return"ScriptableValueNode"}constructor(e=null){super(),this._value=e,this._cache=null,this.inputType=null,this.outputType=null,this.events=new oa,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return this.outputType!==null}set value(e){this._value!==e&&(this._cache&&this.inputType==="URL"&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=e,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const e=this.value;if(e&&this._cache===null&&this.inputType==="URL"&&e.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([e.value]));else if(e&&e.value!==null&&e.value!==void 0&&((this.inputType==="URL"||this.inputType==="String")&&typeof e.value=="string"||this.inputType==="Number"&&typeof e.value=="number"||this.inputType==="Vector2"&&e.value.isVector2||this.inputType==="Vector3"&&e.value.isVector3||this.inputType==="Vector4"&&e.value.isVector4||this.inputType==="Color"&&e.value.isColor||this.inputType==="Matrix3"&&e.value.isMatrix3||this.inputType==="Matrix4"&&e.value.isMatrix4))return e.value;return this._cache||e}getNodeType(e){return this.value&&this.value.isNode?this.value.getNodeType(e):"float"}setup(){return this.value&&this.value.isNode?this.value:Y()}serialize(e){super.serialize(e),this.value!==null?this.inputType==="ArrayBuffer"?e.value=ck(this.value):e.value=this.value?this.value.toJSON(e.meta).uuid:null:e.value=null,e.inputType=this.inputType,e.outputType=this.outputType}deserialize(e){super.deserialize(e);let t=null;e.value!==null&&(e.inputType==="ArrayBuffer"?t=dk(e.value):e.inputType==="Texture"?t=e.meta.textures[e.value]:t=e.meta.nodes[e.value]||null),this.value=t,this.inputType=e.inputType,this.outputType=e.outputType}}const If=ze(b6).setParameterLength(1);class l$ extends Map{get(e,t=null,...s){if(this.has(e))return super.get(e);if(t!==null){const r=t(...s);return this.set(e,r),r}}}class w6{constructor(e){this.scriptableNode=e}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(e){return this.scriptableNode.getInputLayout(e)}get(e){const t=this.parameters[e];return t?t.getValue():null}}const Df=new l$;class M6 extends Ft{static get type(){return"ScriptableNode"}constructor(e=null,t={}){super(),this.codeNode=e,this.parameters=t,this._local=new l$,this._output=If(null),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(e,t){return this._local.set(e,t)}getLocal(e){return this._local.get(e)}onRefresh(){this._refresh()}getInputLayout(e){for(const t of this.getLayout())if(t.inputType&&(t.id===e||t.name===e))return t}getOutputLayout(e){for(const t of this.getLayout())if(t.outputType&&(t.id===e||t.name===e))return t}setOutput(e,t){const s=this._outputs;return s[e]===void 0?s[e]=If(t):s[e].value=t,this}getOutput(e){return this._outputs[e]}getParameter(e){return this.parameters[e]}setParameter(e,t){const s=this.parameters;return t&&t.isScriptableNode?(this.deleteParameter(e),s[e]=t,s[e].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):t&&t.isScriptableValueNode?(this.deleteParameter(e),s[e]=t,s[e].events.addEventListener("refresh",this.onRefresh)):s[e]===void 0?(s[e]=If(t),s[e].events.addEventListener("refresh",this.onRefresh)):s[e].value=t,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(e){let t=this.parameters[e];return t&&(t.isScriptableNode&&(t=t.getDefaultOutput()),t.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const e of Object.keys(this.parameters))this.deleteParameter(e);return this.needsUpdate=!0,this}call(e,...t){const r=this.getObject()[e];if(typeof r=="function")return r(...t)}async callAsync(e,...t){const r=this.getObject()[e];if(typeof r=="function")return r.constructor.name==="AsyncFunction"?await r(...t):r(...t)}getNodeType(e){return this.getDefaultOutputNode().getNodeType(e)}refresh(e=null){e!==null?this.getOutput(e).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),this._object!==null)return this._object;const e=()=>this.refresh(),t=(u,c)=>this.setOutput(u,c),s=new w6(this),r=Df.get("THREE"),n=Df.get("TSL"),o=this.getMethod(),a=[s,this._local,Df,e,t,r,n];this._object=o(...a);const l=this._object.layout;if(l&&(l.cache===!1&&this._local.clear(),this._output.outputType=l.outputType||null,Array.isArray(l.elements)))for(const u of l.elements){const c=u.id||u.name;u.inputType&&(this.getParameter(c)===void 0&&this.setParameter(c,null),this.getParameter(c).inputType=u.inputType),u.outputType&&(this.getOutput(c)===void 0&&this.setOutput(c,null),this.getOutput(c).outputType=u.outputType)}return this._object}deserialize(e){super.deserialize(e);for(const t in this.parameters){let s=this.parameters[t];s.isScriptableNode&&(s=s.getDefaultOutput()),s.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const e=this.getDefaultOutput().value;return e&&e.isNode?e:Y()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),this._method!==null)return this._method;const e=["parameters","local","global","refresh","setOutput","THREE","TSL"],s=["layout","init","main","dispose"].join(", "),r="var "+s+`; var output = {};
`,n=`
return { ...output, `+s+" };",o=r+this.codeNode.code+n;return this._method=new Function(...e,o),this._method}dispose(){this._method!==null&&(this._object&&typeof this._object.dispose=="function"&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}setup(){return this.getDefaultOutputNode()}getCacheKey(e){const t=[rk(this.source),this.getDefaultOutputNode().getCacheKey(e)];for(const s in this.parameters)t.push(this.parameters[s].getCacheKey(e));return ym(t)}set needsUpdate(e){e===!0&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return this.codeNode===null?this:(this._needsOutputUpdate===!0&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value,this)}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}const T6=ze(M6).setParameterLength(1,2);function u$(i){let e;const t=i.context.getViewZ;return t!==void 0&&(e=t(this)),(e||hi.z).negate()}const Fw=ge(([i,e],t)=>{const s=u$(t);return Mo(i,e,s)}),Rw=ge(([i],e)=>{const t=u$(e);return i.mul(i,t,t).negate().exp().oneMinus()}),hh=ge(([i,e])=>St(e.toFloat().mix(lc.rgb,i.toVec3()),lc.a));function v6(i,e,t){return console.warn('THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.'),hh(i,Fw(e,t))}function S6(i,e){return console.warn('THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.'),hh(i,Rw(e))}let vl=null,Sl=null;class E6 extends Ft{static get type(){return"RangeNode"}constructor(e=Y(),t=Y()){super(),this.minNode=e,this.maxNode=t}getVectorLength(e){const t=e.getTypeLength(Ia(this.minNode.value)),s=e.getTypeLength(Ia(this.maxNode.value));return t>s?t:s}getNodeType(e){return e.object.count>1?e.getTypeFromLength(this.getVectorLength(e)):"float"}setup(e){const t=e.object;let s=null;if(t.count>1){const r=this.minNode.value,n=this.maxNode.value,o=e.getTypeLength(Ia(r)),a=e.getTypeLength(Ia(n));vl=vl||new ns,Sl=Sl||new ns,vl.setScalar(0),Sl.setScalar(0),o===1?vl.setScalar(r):r.isColor?vl.set(r.r,r.g,r.b,1):vl.set(r.x,r.y,r.z||0,r.w||0),a===1?Sl.setScalar(n):n.isColor?Sl.set(n.r,n.g,n.b,1):Sl.set(n.x,n.y,n.z||0,n.w||0);const l=4,u=l*t.count,c=new Float32Array(u);for(let h=0;h<u;h++){const p=h%l,f=vl.getComponent(p),m=Sl.getComponent(p);c[h]=_0.lerp(f,m,Math.random())}const d=this.getNodeType(e);if(t.count<=4096)s=xh(c,"vec4",t.count).element(Ba).convert(d);else{const h=new ac(c,4);e.geometry.setAttribute("__range"+this.id,h),s=nm(h).convert(d)}}else s=Y(0);return s}}const A6=ze(E6).setParameterLength(2);class C6 extends Ft{static get type(){return"ComputeBuiltinNode"}constructor(e,t){super(t),this._builtinName=e}getHash(e){return this.getBuiltinName(e)}getNodeType(){return this.nodeType}setBuiltinName(e){return this._builtinName=e,this}getBuiltinName(){return this._builtinName}hasBuiltin(e){return e.hasBuiltin(this._builtinName)}generate(e,t){const s=this.getBuiltinName(e),r=this.getNodeType(e);return e.shaderStage==="compute"?e.format(s,r,t):(console.warn(`ComputeBuiltinNode: Compute built-in value ${s} can not be accessed in the ${e.shaderStage} stage`),e.generateConst(r))}serialize(e){super.serialize(e),e.global=this.global,e._builtinName=this._builtinName}deserialize(e){super.deserialize(e),this.global=e.global,this._builtinName=e._builtinName}}const vh=(i,e)=>De(new C6(i,e)),P6=vh("numWorkgroups","uvec3"),N6=vh("workgroupId","uvec3"),F6=vh("globalId","uvec3"),R6=vh("localId","uvec3"),I6=vh("subgroupSize","uint");class D6 extends Ft{constructor(e){super(),this.scope=e}generate(e){const{scope:t}=this,{renderer:s}=e;s.backend.isWebGLBackend===!0?e.addFlowCode(`	// ${t}Barrier 
`):e.addLineFlowCode(`${t}Barrier()`,this)}}const Iw=ze(D6),k6=()=>Iw("workgroup").toStack(),L6=()=>Iw("storage").toStack(),B6=()=>Iw("texture").toStack();class O6 extends su{constructor(e,t){super(e,t),this.isWorkgroupInfoElementNode=!0}generate(e,t){let s;const r=e.context.assign;if(s=super.generate(e),r!==!0){const n=this.getNodeType(e);s=e.format(s,n,t)}return s}}class $6 extends Ft{constructor(e,t,s=0){super(t),this.bufferType=t,this.bufferCount=s,this.isWorkgroupInfoNode=!0,this.elementType=t,this.scope=e}label(e){return this.name=e,this}setScope(e){return this.scope=e,this}getElementType(){return this.elementType}getInputType(){return`${this.scope}Array`}element(e){return De(new O6(this,e))}generate(e){return e.getScopedArray(this.name||`${this.scope}Array_${this.id}`,this.scope.toLowerCase(),this.bufferType,this.bufferCount)}}const z6=(i,e)=>De(new $6("Workgroup",i,e));class Gi extends Ft{static get type(){return"AtomicFunctionNode"}constructor(e,t,s){super("uint"),this.method=e,this.pointerNode=t,this.valueNode=s,this.parents=!0}getInputType(e){return this.pointerNode.getNodeType(e)}getNodeType(e){return this.getInputType(e)}generate(e){const t=e.getNodeProperties(this),s=t.parents,r=this.method,n=this.getNodeType(e),o=this.getInputType(e),a=this.pointerNode,l=this.valueNode,u=[];u.push(`&${a.build(e,o)}`),l!==null&&u.push(l.build(e,o));const c=`${e.getMethod(r,n)}( ${u.join(", ")} )`;if(s.length===1&&s[0].isStackNode===!0)e.addLineFlowCode(c,this);else return t.constNode===void 0&&(t.constNode=ia(c,n).toConst()),t.constNode.build(e)}}Gi.ATOMIC_LOAD="atomicLoad";Gi.ATOMIC_STORE="atomicStore";Gi.ATOMIC_ADD="atomicAdd";Gi.ATOMIC_SUB="atomicSub";Gi.ATOMIC_MAX="atomicMax";Gi.ATOMIC_MIN="atomicMin";Gi.ATOMIC_AND="atomicAnd";Gi.ATOMIC_OR="atomicOr";Gi.ATOMIC_XOR="atomicXor";const V6=ze(Gi),Co=(i,e,t)=>V6(i,e,t).toStack(),U6=i=>Co(Gi.ATOMIC_LOAD,i,null),G6=(i,e)=>Co(Gi.ATOMIC_STORE,i,e),j6=(i,e)=>Co(Gi.ATOMIC_ADD,i,e),W6=(i,e)=>Co(Gi.ATOMIC_SUB,i,e),H6=(i,e)=>Co(Gi.ATOMIC_MAX,i,e),q6=(i,e)=>Co(Gi.ATOMIC_MIN,i,e),K6=(i,e)=>Co(Gi.ATOMIC_AND,i,e),X6=(i,e)=>Co(Gi.ATOMIC_OR,i,e),Y6=(i,e)=>Co(Gi.ATOMIC_XOR,i,e);let cf;function Wm(i){cf=cf||new WeakMap;let e=cf.get(i);return e===void 0&&cf.set(i,e={}),e}function Dw(i){const e=Wm(i);return e.shadowMatrix||(e.shadowMatrix=Et("mat4").setGroup(Rt).onRenderUpdate(t=>((i.castShadow!==!0||t.renderer.shadowMap.enabled===!1)&&i.shadow.updateMatrices(i),i.shadow.matrix)))}function c$(i,e=Zo){const t=Dw(i).mul(e);return t.xyz.div(t.w)}function kw(i){const e=Wm(i);return e.position||(e.position=Et(new xe).setGroup(Rt).onRenderUpdate((t,s)=>s.value.setFromMatrixPosition(i.matrixWorld)))}function d$(i){const e=Wm(i);return e.targetPosition||(e.targetPosition=Et(new xe).setGroup(Rt).onRenderUpdate((t,s)=>s.value.setFromMatrixPosition(i.target.matrixWorld)))}function Lw(i){const e=Wm(i);return e.viewPosition||(e.viewPosition=Et(new xe).setGroup(Rt).onRenderUpdate(({camera:t},s)=>{s.value=s.value||new xe,s.value.setFromMatrixPosition(i.matrixWorld),s.value.applyMatrix4(t.matrixWorldInverse)}))}const Bw=i=>Tn.transformDirection(kw(i).sub(d$(i))),Q6=i=>i.sort((e,t)=>e.id-t.id),Z6=(i,e)=>{for(const t of e)if(t.isAnalyticLightNode&&t.light.id===i)return t;return null},tx=new WeakMap,Ed=[];class Ow extends Ft{static get type(){return"LightsNode"}constructor(){super("vec3"),this.totalDiffuseNode=Qo("vec3","totalDiffuse"),this.totalSpecularNode=Qo("vec3","totalSpecular"),this.outgoingLightNode=Qo("vec3","outgoingLight"),this._lights=[],this._lightNodes=null,this._lightNodesHash=null,this.global=!0}customCacheKey(){const e=this._lights;for(let s=0;s<e.length;s++){const r=e[s];if(Ed.push(r.id),Ed.push(r.castShadow?1:0),r.isSpotLight===!0){const n=r.map!==null?r.map.id:-1,o=r.colorNode?r.colorNode.getCacheKey():-1;Ed.push(n,o)}}const t=ym(Ed);return Ed.length=0,t}getHash(e){if(this._lightNodesHash===null){this._lightNodes===null&&this.setupLightsNode(e);const t=[];for(const s of this._lightNodes)t.push(s.getSelf().getHash());this._lightNodesHash="lights-"+t.join(",")}return this._lightNodesHash}analyze(e){const t=e.getNodeProperties(this);for(const s of t.nodes)s.build(e);t.outputNode.build(e)}setupLightsNode(e){const t=[],s=this._lightNodes,r=Q6(this._lights),n=e.renderer.library;for(const o of r)if(o.isNode)t.push(De(o));else{let a=null;if(s!==null&&(a=Z6(o.id,s)),a===null){const l=n.getLightNodeClass(o.constructor);if(l===null){console.warn(`LightsNode.setupNodeLights: Light node not found for ${o.constructor.name}`);continue}let u=null;tx.has(o)?u=tx.get(o):(u=De(new l(o)),tx.set(o,u)),t.push(u)}}this._lightNodes=t}setupDirectLight(e,t,s){const{lightingModel:r,reflectedLight:n}=e.context;r.direct({...s,lightNode:t,reflectedLight:n},e)}setupDirectRectAreaLight(e,t,s){const{lightingModel:r,reflectedLight:n}=e.context;r.directRectArea({...s,lightNode:t,reflectedLight:n},e)}setupLights(e,t){for(const s of t)s.build(e)}getLightNodes(e){return this._lightNodes===null&&this.setupLightsNode(e),this._lightNodes}setup(e){const t=e.lightsNode;e.lightsNode=this;let s=this.outgoingLightNode;const r=e.context,n=r.lightingModel,o=e.getNodeProperties(this);if(n){const{totalDiffuseNode:a,totalSpecularNode:l}=this;r.outgoingLight=s;const u=e.addStack();o.nodes=u.nodes,n.start(e);const{backdrop:c,backdropAlpha:d}=r,{directDiffuse:h,directSpecular:p,indirectDiffuse:f,indirectSpecular:m}=r.reflectedLight;let x=h.add(f);c!==null&&(d!==null?x=pe(d.mix(x,c)):x=pe(c),r.material.transparent=!0),a.assign(x),l.assign(p.add(m)),s.assign(a.add(l)),n.finish(e),s=s.bypass(e.removeStack())}else o.nodes=[];return e.lightsNode=t,s}setLights(e){return this._lights=e,this._lightNodes=null,this._lightNodesHash=null,this}getLights(){return this._lights}get hasLights(){return this._lights.length>0}}const J6=(i=[])=>De(new Ow).setLights(i);class eH extends Ft{static get type(){return"ShadowBaseNode"}constructor(e){super(),this.light=e,this.updateBeforeType=Kt.RENDER,this.isShadowBaseNode=!0}setupShadowPosition({context:e,material:t}){$w.assign(t.receivedShadowPositionNode||e.shadowPositionWorld||Zo)}}const $w=Qo("vec3","shadowPositionWorld");function tH(i,e={}){return e.toneMapping=i.toneMapping,e.toneMappingExposure=i.toneMappingExposure,e.outputColorSpace=i.outputColorSpace,e.renderTarget=i.getRenderTarget(),e.activeCubeFace=i.getActiveCubeFace(),e.activeMipmapLevel=i.getActiveMipmapLevel(),e.renderObjectFunction=i.getRenderObjectFunction(),e.pixelRatio=i.getPixelRatio(),e.mrt=i.getMRT(),e.clearColor=i.getClearColor(e.clearColor||new gs),e.clearAlpha=i.getClearAlpha(),e.autoClear=i.autoClear,e.scissorTest=i.getScissorTest(),e}function sH(i,e){return e=tH(i,e),i.setMRT(null),i.setRenderObjectFunction(null),i.setClearColor(0,1),i.autoClear=!0,e}function iH(i,e){i.toneMapping=e.toneMapping,i.toneMappingExposure=e.toneMappingExposure,i.outputColorSpace=e.outputColorSpace,i.setRenderTarget(e.renderTarget,e.activeCubeFace,e.activeMipmapLevel),i.setRenderObjectFunction(e.renderObjectFunction),i.setPixelRatio(e.pixelRatio),i.setMRT(e.mrt),i.setClearColor(e.clearColor,e.clearAlpha),i.autoClear=e.autoClear,i.setScissorTest(e.scissorTest)}function rH(i,e={}){return e.background=i.background,e.backgroundNode=i.backgroundNode,e.overrideMaterial=i.overrideMaterial,e}function nH(i,e){return e=rH(i,e),i.background=null,i.backgroundNode=null,i.overrideMaterial=null,e}function oH(i,e){i.background=e.background,i.backgroundNode=e.backgroundNode,i.overrideMaterial=e.overrideMaterial}function aH(i,e,t){return t=sH(i,t),t=nH(e,t),t}function lH(i,e,t){iH(i,t),oH(e,t)}const eN=new WeakMap,h$=ge(({depthTexture:i,shadowCoord:e,depthLayer:t})=>{let s=ts(i,e.xy).label("t_basic");return i.isArrayTexture&&(s=s.depth(t)),s.compare(e.z)}),p$=ge(({depthTexture:i,shadowCoord:e,shadow:t,depthLayer:s})=>{const r=(x,g)=>{let _=ts(i,x);return i.isArrayTexture&&(_=_.depth(s)),_.compare(g)},n=Os("mapSize","vec2",t).setGroup(Rt),o=Os("radius","float",t).setGroup(Rt),a=Ge(1).div(n),l=a.x.negate().mul(o),u=a.y.negate().mul(o),c=a.x.mul(o),d=a.y.mul(o),h=l.div(2),p=u.div(2),f=c.div(2),m=d.div(2);return Ri(r(e.xy.add(Ge(l,u)),e.z),r(e.xy.add(Ge(0,u)),e.z),r(e.xy.add(Ge(c,u)),e.z),r(e.xy.add(Ge(h,p)),e.z),r(e.xy.add(Ge(0,p)),e.z),r(e.xy.add(Ge(f,p)),e.z),r(e.xy.add(Ge(l,0)),e.z),r(e.xy.add(Ge(h,0)),e.z),r(e.xy,e.z),r(e.xy.add(Ge(f,0)),e.z),r(e.xy.add(Ge(c,0)),e.z),r(e.xy.add(Ge(h,m)),e.z),r(e.xy.add(Ge(0,m)),e.z),r(e.xy.add(Ge(f,m)),e.z),r(e.xy.add(Ge(l,d)),e.z),r(e.xy.add(Ge(0,d)),e.z),r(e.xy.add(Ge(c,d)),e.z)).mul(1/17)}),f$=ge(({depthTexture:i,shadowCoord:e,shadow:t,depthLayer:s})=>{const r=(d,h)=>{let p=ts(i,d);return i.isArrayTexture&&(p=p.depth(s)),p.compare(h)},n=Os("mapSize","vec2",t).setGroup(Rt),o=Ge(1).div(n),a=o.x,l=o.y,u=e.xy,c=la(u.mul(n).add(.5));return u.subAssign(c.mul(o)),Ri(r(u,e.z),r(u.add(Ge(a,0)),e.z),r(u.add(Ge(0,l)),e.z),r(u.add(o),e.z),Cs(r(u.add(Ge(a.negate(),0)),e.z),r(u.add(Ge(a.mul(2),0)),e.z),c.x),Cs(r(u.add(Ge(a.negate(),l)),e.z),r(u.add(Ge(a.mul(2),l)),e.z),c.x),Cs(r(u.add(Ge(0,l.negate())),e.z),r(u.add(Ge(0,l.mul(2))),e.z),c.y),Cs(r(u.add(Ge(a,l.negate())),e.z),r(u.add(Ge(a,l.mul(2))),e.z),c.y),Cs(Cs(r(u.add(Ge(a.negate(),l.negate())),e.z),r(u.add(Ge(a.mul(2),l.negate())),e.z),c.x),Cs(r(u.add(Ge(a.negate(),l.mul(2))),e.z),r(u.add(Ge(a.mul(2),l.mul(2))),e.z),c.x),c.y)).mul(1/9)}),m$=ge(({depthTexture:i,shadowCoord:e,depthLayer:t})=>{const s=Y(1).toVar();let r=ts(i).sample(e.xy);i.isArrayTexture&&(r=r.depth(t)),r=r.rg;const n=Pm(e.z,r.x);return Ht(n.notEqual(Y(1)),()=>{const o=e.z.sub(r.x),a=ni(0,r.y.mul(r.y));let l=a.div(a.add(o.mul(o)));l=wo(us(l,.3).div(.95-.3)),s.assign(wo(ni(n,l)))}),s}),uH=ge(([i,e,t])=>{let s=Zo.sub(i).length();return s=s.sub(e).div(t.sub(e)),s=s.saturate(),s}),cH=i=>{const e=i.shadow.camera,t=Os("near","float",e).setGroup(Rt),s=Os("far","float",e).setGroup(Rt),r=KL(i);return uH(r,t,s)},g$=i=>{let e=eN.get(i);if(e===void 0){const t=i.isPointLight?cH(i):null;e=new pi,e.colorNode=St(0,0,0,1),e.depthNode=t,e.isShadowPassMaterial=!0,e.name="ShadowMaterial",e.fog=!1,eN.set(i,e)}return e},tN=new Kn,Vu=[],_$=(i,e,t,s)=>{Vu[0]=i,Vu[1]=e;let r=tN.get(Vu);return(r===void 0||r.shadowType!==t||r.useVelocity!==s)&&(r=(n,o,a,l,u,c,...d)=>{(n.castShadow===!0||n.receiveShadow&&t===Tf)&&(s&&(uk(n).useVelocity=!0),n.onBeforeShadow(i,n,a,e.camera,l,o.overrideMaterial,c),i.renderObject(n,o,a,l,u,c,...d),n.onAfterShadow(i,n,a,e.camera,l,o.overrideMaterial,c))},r.shadowType=t,r.useVelocity=s,tN.set(Vu,r)),Vu[0]=null,Vu[1]=null,r},dH=ge(({samples:i,radius:e,size:t,shadowPass:s,depthLayer:r})=>{const n=Y(0).toVar("meanVertical"),o=Y(0).toVar("squareMeanVertical"),a=i.lessThanEqual(Y(1)).select(Y(0),Y(2).div(i.sub(1))),l=i.lessThanEqual(Y(1)).select(Y(0),Y(-1));Rs({start:ne(0),end:ne(i),type:"int",condition:"<"},({i:c})=>{const d=l.add(Y(c).mul(a));let h=s.sample(Ri(Th.xy,Ge(0,d).mul(e)).div(t));s.value.isArrayTexture&&(h=h.depth(r)),h=h.x,n.addAssign(h),o.addAssign(h.mul(h))}),n.divAssign(i),o.divAssign(i);const u=Eo(o.sub(n.mul(n)));return Ge(n,u)}),hH=ge(({samples:i,radius:e,size:t,shadowPass:s,depthLayer:r})=>{const n=Y(0).toVar("meanHorizontal"),o=Y(0).toVar("squareMeanHorizontal"),a=i.lessThanEqual(Y(1)).select(Y(0),Y(2).div(i.sub(1))),l=i.lessThanEqual(Y(1)).select(Y(0),Y(-1));Rs({start:ne(0),end:ne(i),type:"int",condition:"<"},({i:c})=>{const d=l.add(Y(c).mul(a));let h=s.sample(Ri(Th.xy,Ge(d,0).mul(e)).div(t));s.value.isArrayTexture&&(h=h.depth(r)),n.addAssign(h.x),o.addAssign(Ri(h.y.mul(h.y),h.x.mul(h.x)))}),n.divAssign(i),o.divAssign(i);const u=Eo(o.sub(n.mul(n)));return Ge(n,u)}),pH=[h$,p$,f$,m$];let sx;const df=new Gm;class y$ extends eH{static get type(){return"ShadowNode"}constructor(e,t=null){super(e),this.shadow=t||e.shadow,this.shadowMap=null,this.vsmShadowMapVertical=null,this.vsmShadowMapHorizontal=null,this.vsmMaterialVertical=null,this.vsmMaterialHorizontal=null,this._node=null,this._cameraFrameId=new WeakMap,this.isShadowNode=!0,this.depthLayer=0}setupShadowFilter(e,{filterFn:t,depthTexture:s,shadowCoord:r,shadow:n,depthLayer:o}){const a=r.x.greaterThanEqual(0).and(r.x.lessThanEqual(1)).and(r.y.greaterThanEqual(0)).and(r.y.lessThanEqual(1)).and(r.z.lessThanEqual(1)),l=t({depthTexture:s,shadowCoord:r,shadow:n,depthLayer:o});return a.select(l,Y(1))}setupShadowCoord(e,t){const{shadow:s}=this,{renderer:r}=e,n=Os("bias","float",s).setGroup(Rt);let o=t,a;if(s.camera.isOrthographicCamera||r.logarithmicDepthBuffer!==!0)o=o.xyz.div(o.w),a=o.z,r.coordinateSystem===xo&&(a=a.mul(2).sub(1));else{const l=o.w;o=o.xy.div(l);const u=Os("near","float",s.camera).setGroup(Rt),c=Os("far","float",s.camera).setGroup(Rt);a=yw(l.negate(),u,c)}return o=pe(o.x,o.y.oneMinus(),a.add(n)),o}getShadowFilterFn(e){return pH[e]}setupRenderTarget(e,t){const s=new Hn(e.mapSize.width,e.mapSize.height);s.name="ShadowDepthTexture",s.compareFunction=m0;const r=t.createRenderTarget(e.mapSize.width,e.mapSize.height);return r.texture.name="ShadowMap",r.texture.type=e.mapType,r.depthTexture=s,{shadowMap:r,depthTexture:s}}setupShadow(e){const{renderer:t}=e,{light:s,shadow:r}=this,n=t.shadowMap.type,{depthTexture:o,shadowMap:a}=this.setupRenderTarget(r,e);if(r.camera.updateProjectionMatrix(),n===Tf&&r.isPointLightShadow!==!0){o.compareFunction=null,a.depth>1?(a._vsmShadowMapVertical||(a._vsmShadowMapVertical=e.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:Ol,type:Cr,depth:a.depth,depthBuffer:!1}),a._vsmShadowMapVertical.texture.name="VSMVertical"),this.vsmShadowMapVertical=a._vsmShadowMapVertical,a._vsmShadowMapHorizontal||(a._vsmShadowMapHorizontal=e.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:Ol,type:Cr,depth:a.depth,depthBuffer:!1}),a._vsmShadowMapHorizontal.texture.name="VSMHorizontal"),this.vsmShadowMapHorizontal=a._vsmShadowMapHorizontal):(this.vsmShadowMapVertical=e.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:Ol,type:Cr,depthBuffer:!1}),this.vsmShadowMapHorizontal=e.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:Ol,type:Cr,depthBuffer:!1}));let g=ts(o);o.isArrayTexture&&(g=g.depth(this.depthLayer));let _=ts(this.vsmShadowMapVertical.texture);o.isArrayTexture&&(_=_.depth(this.depthLayer));const S=Os("blurSamples","float",r).setGroup(Rt),M=Os("radius","float",r).setGroup(Rt),w=Os("mapSize","vec2",r).setGroup(Rt);let v=this.vsmMaterialVertical||(this.vsmMaterialVertical=new pi);v.fragmentNode=dH({samples:S,radius:M,size:w,shadowPass:g,depthLayer:this.depthLayer}).context(e.getSharedContext()),v.name="VSMVertical",v=this.vsmMaterialHorizontal||(this.vsmMaterialHorizontal=new pi),v.fragmentNode=hH({samples:S,radius:M,size:w,shadowPass:_,depthLayer:this.depthLayer}).context(e.getSharedContext()),v.name="VSMHorizontal"}const l=Os("intensity","float",r).setGroup(Rt),u=Os("normalBias","float",r).setGroup(Rt),c=Dw(s).mul($w.add(Ga.mul(u))),d=this.setupShadowCoord(e,c),h=r.filterNode||this.getShadowFilterFn(t.shadowMap.type)||null;if(h===null)throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");const p=n===Tf&&r.isPointLightShadow!==!0?this.vsmShadowMapHorizontal.texture:o,f=this.setupShadowFilter(e,{filterFn:h,shadowTexture:a.texture,depthTexture:p,shadowCoord:d,shadow:r,depthLayer:this.depthLayer});let m=ts(a.texture,d);o.isArrayTexture&&(m=m.depth(this.depthLayer));const x=Cs(1,f.rgb.mix(m,1),l.mul(m.a)).toVar();return this.shadowMap=a,this.shadow.map=a,x}setup(e){if(e.renderer.shadowMap.enabled!==!1)return ge(()=>{let t=this._node;return this.setupShadowPosition(e),t===null&&(this._node=t=this.setupShadow(e)),e.material.shadowNode&&console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'),e.material.receivedShadowNode&&(t=e.material.receivedShadowNode(t)),t})()}renderShadow(e){const{shadow:t,shadowMap:s,light:r}=this,{renderer:n,scene:o}=e;t.updateMatrices(r),s.setSize(t.mapSize.width,t.mapSize.height,s.depth),n.render(o,t.camera)}updateShadow(e){const{shadowMap:t,light:s,shadow:r}=this,{renderer:n,scene:o,camera:a}=e,l=n.shadowMap.type,u=t.depthTexture.version;this._depthVersionCached=u;const c=r.camera.layers.mask;r.camera.layers.mask&4294967294||(r.camera.layers.mask=a.layers.mask);const d=n.getRenderObjectFunction(),h=n.getMRT(),p=h?h.has("velocity"):!1;sx=aH(n,o,sx),o.overrideMaterial=g$(s),n.setRenderObjectFunction(_$(n,r,l,p)),n.setClearColor(0,0),n.setRenderTarget(t),this.renderShadow(e),n.setRenderObjectFunction(d),l===Tf&&r.isPointLightShadow!==!0&&this.vsmPass(n),r.camera.layers.mask=c,lH(n,o,sx)}vsmPass(e){const{shadow:t}=this,s=this.shadowMap.depth;this.vsmShadowMapVertical.setSize(t.mapSize.width,t.mapSize.height,s),this.vsmShadowMapHorizontal.setSize(t.mapSize.width,t.mapSize.height,s),e.setRenderTarget(this.vsmShadowMapVertical),df.material=this.vsmMaterialVertical,df.render(e),e.setRenderTarget(this.vsmShadowMapHorizontal),df.material=this.vsmMaterialHorizontal,df.render(e)}dispose(){this.shadowMap.dispose(),this.shadowMap=null,this.vsmShadowMapVertical!==null&&(this.vsmShadowMapVertical.dispose(),this.vsmShadowMapVertical=null,this.vsmMaterialVertical.dispose(),this.vsmMaterialVertical=null),this.vsmShadowMapHorizontal!==null&&(this.vsmShadowMapHorizontal.dispose(),this.vsmShadowMapHorizontal=null,this.vsmMaterialHorizontal.dispose(),this.vsmMaterialHorizontal=null),super.dispose()}updateBefore(e){const{shadow:t}=this;let s=t.needsUpdate||t.autoUpdate;s&&(this._cameraFrameId[e.camera]===e.frameId&&(s=!1),this._cameraFrameId[e.camera]=e.frameId),s&&(this.updateShadow(e),this.shadowMap.depthTexture.version===this._depthVersionCached&&(t.needsUpdate=!1))}}const x$=(i,e)=>De(new y$(i,e)),fH=new gs,$n=ge(([i,e])=>{const t=i.toVar(),s=Us(t),r=wn(1,ni(s.x,ni(s.y,s.z)));s.mulAssign(r),t.mulAssign(r.mul(e.mul(2).oneMinus()));const n=Ge(t.xy).toVar(),a=e.mul(1.5).oneMinus();return Ht(s.z.greaterThanEqual(a),()=>{Ht(t.z.greaterThan(0),()=>{n.x.assign(us(4,t.x))})}).ElseIf(s.x.greaterThanEqual(a),()=>{const l=ch(t.x);n.x.assign(t.z.mul(l).add(l.mul(2)))}).ElseIf(s.y.greaterThanEqual(a),()=>{const l=ch(t.y);n.x.assign(t.x.add(l.mul(2)).add(2)),n.y.assign(t.z.mul(l).sub(2))}),Ge(.125,.25).mul(n).add(Ge(.375,.75)).flipY()}).setLayout({name:"cubeToUV",type:"vec2",inputs:[{name:"pos",type:"vec3"},{name:"texelSizeY",type:"float"}]}),b$=ge(({depthTexture:i,bd3D:e,dp:t,texelSize:s})=>ts(i,$n(e,s.y)).compare(t)),w$=ge(({depthTexture:i,bd3D:e,dp:t,texelSize:s,shadow:r})=>{const n=Os("radius","float",r).setGroup(Rt),o=Ge(-1,1).mul(n).mul(s.y);return ts(i,$n(e.add(o.xyy),s.y)).compare(t).add(ts(i,$n(e.add(o.yyy),s.y)).compare(t)).add(ts(i,$n(e.add(o.xyx),s.y)).compare(t)).add(ts(i,$n(e.add(o.yyx),s.y)).compare(t)).add(ts(i,$n(e,s.y)).compare(t)).add(ts(i,$n(e.add(o.xxy),s.y)).compare(t)).add(ts(i,$n(e.add(o.yxy),s.y)).compare(t)).add(ts(i,$n(e.add(o.xxx),s.y)).compare(t)).add(ts(i,$n(e.add(o.yxx),s.y)).compare(t)).mul(1/9)}),mH=ge(({filterFn:i,depthTexture:e,shadowCoord:t,shadow:s})=>{const r=t.xyz.toVar(),n=r.length(),o=Et("float").setGroup(Rt).onRenderUpdate(()=>s.camera.near),a=Et("float").setGroup(Rt).onRenderUpdate(()=>s.camera.far),l=Os("bias","float",s).setGroup(Rt),u=Et(s.mapSize).setGroup(Rt),c=Y(1).toVar();return Ht(n.sub(a).lessThanEqual(0).and(n.sub(o).greaterThanEqual(0)),()=>{const d=n.sub(o).div(a.sub(o)).toVar();d.addAssign(l);const h=r.normalize(),p=Ge(1).div(u.mul(Ge(4,2)));c.assign(i({depthTexture:e,bd3D:h,dp:d,texelSize:p,shadow:s}))}),c}),sN=new ns,Uu=new Dt,Ad=new Dt;class gH extends y${static get type(){return"PointShadowNode"}constructor(e,t=null){super(e,t)}getShadowFilterFn(e){return e===MV?b$:w$}setupShadowCoord(e,t){return t}setupShadowFilter(e,{filterFn:t,shadowTexture:s,depthTexture:r,shadowCoord:n,shadow:o}){return mH({filterFn:t,shadowTexture:s,depthTexture:r,shadowCoord:n,shadow:o})}renderShadow(e){const{shadow:t,shadowMap:s,light:r}=this,{renderer:n,scene:o}=e,a=t.getFrameExtents();Ad.copy(t.mapSize),Ad.multiply(a),s.setSize(Ad.width,Ad.height),Uu.copy(t.mapSize);const l=n.autoClear,u=n.getClearColor(fH),c=n.getClearAlpha();n.autoClear=!1,n.setClearColor(t.clearColor,t.clearAlpha),n.clear();const d=t.getViewportCount();for(let h=0;h<d;h++){const p=t.getViewport(h),f=Uu.x*p.x,m=Ad.y-Uu.y-Uu.y*p.y;sN.set(f,m,Uu.x*p.z,Uu.y*p.w),s.viewport.copy(sN),t.updateMatrices(r,h),n.render(o,t.camera)}n.autoClear=l,n.setClearColor(u,c)}}const M$=(i,e)=>De(new gH(i,e));class ou extends Ac{static get type(){return"AnalyticLightNode"}constructor(e=null){super(),this.light=e,this.color=new gs,this.colorNode=e&&e.colorNode||Et(this.color).setGroup(Rt),this.baseColorNode=null,this.shadowNode=null,this.shadowColorNode=null,this.isAnalyticLightNode=!0,this.updateType=Kt.FRAME}getHash(){return this.light.uuid}getLightVector(e){return Lw(this.light).sub(e.context.positionView||hi)}setupDirect(){}setupDirectRectArea(){}setupShadowNode(){return x$(this.light)}setupShadow(e){const{renderer:t}=e;if(t.shadowMap.enabled===!1)return;let s=this.shadowColorNode;if(s===null){const r=this.light.shadow.shadowNode;let n;r!==void 0?n=De(r):n=this.setupShadowNode(),this.shadowNode=n,this.shadowColorNode=s=this.colorNode.mul(n),this.baseColorNode=this.colorNode}this.colorNode=s}setup(e){this.colorNode=this.baseColorNode||this.colorNode,this.light.castShadow?e.object.receiveShadow&&this.setupShadow(e):this.shadowNode!==null&&(this.shadowNode.dispose(),this.shadowNode=null,this.shadowColorNode=null);const t=this.setupDirect(e),s=this.setupDirectRectArea(e);t&&e.lightsNode.setupDirectLight(e,this,t),s&&e.lightsNode.setupDirectRectAreaLight(e,this,s)}update(){const{light:e}=this;this.color.copy(e.color).multiplyScalar(e.intensity)}}const zw=ge(({lightDistance:i,cutoffDistance:e,decayExponent:t})=>{const s=i.pow(t).max(.01).reciprocal();return e.greaterThan(0).select(s.mul(i.div(e).pow4().oneMinus().clamp().pow2()),s)}),T$=({color:i,lightVector:e,cutoffDistance:t,decayExponent:s})=>{const r=e.normalize(),n=e.length(),o=zw({lightDistance:n,cutoffDistance:t,decayExponent:s}),a=i.mul(o);return{lightDirection:r,lightColor:a}};class _H extends ou{static get type(){return"PointLightNode"}constructor(e=null){super(e),this.cutoffDistanceNode=Et(0).setGroup(Rt),this.decayExponentNode=Et(2).setGroup(Rt)}update(e){const{light:t}=this;super.update(e),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}setupShadowNode(){return M$(this.light)}setupDirect(e){return T$({color:this.colorNode,lightVector:this.getLightVector(e),cutoffDistance:this.cutoffDistanceNode,decayExponent:this.decayExponentNode})}}const yH=ge(([i=qs()])=>{const e=i.mul(2),t=e.x.floor(),s=e.y.floor();return t.add(s).mod(2).sign()}),xH=ge(([i=qs()],{renderer:e,material:t})=>{const s=Q0(i.mul(2).sub(1));let r;if(t.alphaToCoverage&&e.samples>1){const n=Y(s.fwidth()).toVar();r=Mo(n.oneMinus(),n.add(1),s).oneMinus()}else r=Xi(s.greaterThan(1),0,1);return r}),Yd=ge(([i,e,t])=>{const s=Y(t).toVar(),r=Y(e).toVar(),n=bo(i).toVar();return Xi(n,r,s)}).setLayout({name:"mx_select",type:"float",inputs:[{name:"b",type:"bool"},{name:"t",type:"float"},{name:"f",type:"float"}]}),um=ge(([i,e])=>{const t=bo(e).toVar(),s=Y(i).toVar();return Xi(t,s.negate(),s)}).setLayout({name:"mx_negate_if",type:"float",inputs:[{name:"val",type:"float"},{name:"b",type:"bool"}]}),xi=ge(([i])=>{const e=Y(i).toVar();return ne(go(e))}).setLayout({name:"mx_floor",type:"int",inputs:[{name:"x",type:"float"}]}),Ys=ge(([i,e])=>{const t=Y(i).toVar();return e.assign(xi(t)),t.sub(Y(e))}),bH=ge(([i,e,t,s,r,n])=>{const o=Y(n).toVar(),a=Y(r).toVar(),l=Y(s).toVar(),u=Y(t).toVar(),c=Y(e).toVar(),d=Y(i).toVar(),h=Y(us(1,a)).toVar();return us(1,o).mul(d.mul(h).add(c.mul(a))).add(o.mul(u.mul(h).add(l.mul(a))))}).setLayout({name:"mx_bilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"}]}),wH=ge(([i,e,t,s,r,n])=>{const o=Y(n).toVar(),a=Y(r).toVar(),l=pe(s).toVar(),u=pe(t).toVar(),c=pe(e).toVar(),d=pe(i).toVar(),h=Y(us(1,a)).toVar();return us(1,o).mul(d.mul(h).add(c.mul(a))).add(o.mul(u.mul(h).add(l.mul(a))))}).setLayout({name:"mx_bilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"}]}),v$=sr([bH,wH]),MH=ge(([i,e,t,s,r,n,o,a,l,u,c])=>{const d=Y(c).toVar(),h=Y(u).toVar(),p=Y(l).toVar(),f=Y(a).toVar(),m=Y(o).toVar(),x=Y(n).toVar(),g=Y(r).toVar(),_=Y(s).toVar(),S=Y(t).toVar(),M=Y(e).toVar(),w=Y(i).toVar(),v=Y(us(1,p)).toVar(),T=Y(us(1,h)).toVar();return Y(us(1,d)).toVar().mul(T.mul(w.mul(v).add(M.mul(p))).add(h.mul(S.mul(v).add(_.mul(p))))).add(d.mul(T.mul(g.mul(v).add(x.mul(p))).add(h.mul(m.mul(v).add(f.mul(p))))))}).setLayout({name:"mx_trilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"v4",type:"float"},{name:"v5",type:"float"},{name:"v6",type:"float"},{name:"v7",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]}),TH=ge(([i,e,t,s,r,n,o,a,l,u,c])=>{const d=Y(c).toVar(),h=Y(u).toVar(),p=Y(l).toVar(),f=pe(a).toVar(),m=pe(o).toVar(),x=pe(n).toVar(),g=pe(r).toVar(),_=pe(s).toVar(),S=pe(t).toVar(),M=pe(e).toVar(),w=pe(i).toVar(),v=Y(us(1,p)).toVar(),T=Y(us(1,h)).toVar();return Y(us(1,d)).toVar().mul(T.mul(w.mul(v).add(M.mul(p))).add(h.mul(S.mul(v).add(_.mul(p))))).add(d.mul(T.mul(g.mul(v).add(x.mul(p))).add(h.mul(m.mul(v).add(f.mul(p))))))}).setLayout({name:"mx_trilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"v4",type:"vec3"},{name:"v5",type:"vec3"},{name:"v6",type:"vec3"},{name:"v7",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]}),S$=sr([MH,TH]),vH=ge(([i,e,t])=>{const s=Y(t).toVar(),r=Y(e).toVar(),n=ht(i).toVar(),o=ht(n.bitAnd(ht(7))).toVar(),a=Y(Yd(o.lessThan(ht(4)),r,s)).toVar(),l=Y(Wt(2,Yd(o.lessThan(ht(4)),s,r))).toVar();return um(a,bo(o.bitAnd(ht(1)))).add(um(l,bo(o.bitAnd(ht(2)))))}).setLayout({name:"mx_gradient_float_0",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"}]}),SH=ge(([i,e,t,s])=>{const r=Y(s).toVar(),n=Y(t).toVar(),o=Y(e).toVar(),a=ht(i).toVar(),l=ht(a.bitAnd(ht(15))).toVar(),u=Y(Yd(l.lessThan(ht(8)),o,n)).toVar(),c=Y(Yd(l.lessThan(ht(4)),n,Yd(l.equal(ht(12)).or(l.equal(ht(14))),o,r))).toVar();return um(u,bo(l.bitAnd(ht(1)))).add(um(c,bo(l.bitAnd(ht(2)))))}).setLayout({name:"mx_gradient_float_1",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]}),Ki=sr([vH,SH]),EH=ge(([i,e,t])=>{const s=Y(t).toVar(),r=Y(e).toVar(),n=Sc(i).toVar();return pe(Ki(n.x,r,s),Ki(n.y,r,s),Ki(n.z,r,s))}).setLayout({name:"mx_gradient_vec3_0",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"}]}),AH=ge(([i,e,t,s])=>{const r=Y(s).toVar(),n=Y(t).toVar(),o=Y(e).toVar(),a=Sc(i).toVar();return pe(Ki(a.x,o,n,r),Ki(a.y,o,n,r),Ki(a.z,o,n,r))}).setLayout({name:"mx_gradient_vec3_1",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]}),un=sr([EH,AH]),CH=ge(([i])=>{const e=Y(i).toVar();return Wt(.6616,e)}).setLayout({name:"mx_gradient_scale2d_0",type:"float",inputs:[{name:"v",type:"float"}]}),PH=ge(([i])=>{const e=Y(i).toVar();return Wt(.982,e)}).setLayout({name:"mx_gradient_scale3d_0",type:"float",inputs:[{name:"v",type:"float"}]}),NH=ge(([i])=>{const e=pe(i).toVar();return Wt(.6616,e)}).setLayout({name:"mx_gradient_scale2d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]}),E$=sr([CH,NH]),FH=ge(([i])=>{const e=pe(i).toVar();return Wt(.982,e)}).setLayout({name:"mx_gradient_scale3d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]}),A$=sr([PH,FH]),Wr=ge(([i,e])=>{const t=ne(e).toVar(),s=ht(i).toVar();return s.shiftLeft(t).bitOr(s.shiftRight(ne(32).sub(t)))}).setLayout({name:"mx_rotl32",type:"uint",inputs:[{name:"x",type:"uint"},{name:"k",type:"int"}]}),C$=ge(([i,e,t])=>{i.subAssign(t),i.bitXorAssign(Wr(t,ne(4))),t.addAssign(e),e.subAssign(i),e.bitXorAssign(Wr(i,ne(6))),i.addAssign(t),t.subAssign(e),t.bitXorAssign(Wr(e,ne(8))),e.addAssign(i),i.subAssign(t),i.bitXorAssign(Wr(t,ne(16))),t.addAssign(e),e.subAssign(i),e.bitXorAssign(Wr(i,ne(19))),i.addAssign(t),t.subAssign(e),t.bitXorAssign(Wr(e,ne(4))),e.addAssign(i)}),Sh=ge(([i,e,t])=>{const s=ht(t).toVar(),r=ht(e).toVar(),n=ht(i).toVar();return s.bitXorAssign(r),s.subAssign(Wr(r,ne(14))),n.bitXorAssign(s),n.subAssign(Wr(s,ne(11))),r.bitXorAssign(n),r.subAssign(Wr(n,ne(25))),s.bitXorAssign(r),s.subAssign(Wr(r,ne(16))),n.bitXorAssign(s),n.subAssign(Wr(s,ne(4))),r.bitXorAssign(n),r.subAssign(Wr(n,ne(14))),s.bitXorAssign(r),s.subAssign(Wr(r,ne(24))),s}).setLayout({name:"mx_bjfinal",type:"uint",inputs:[{name:"a",type:"uint"},{name:"b",type:"uint"},{name:"c",type:"uint"}]}),ur=ge(([i])=>{const e=ht(i).toVar();return Y(e).div(Y(ht(ne(4294967295))))}).setLayout({name:"mx_bits_to_01",type:"float",inputs:[{name:"bits",type:"uint"}]}),yo=ge(([i])=>{const e=Y(i).toVar();return e.mul(e).mul(e).mul(e.mul(e.mul(6).sub(15)).add(10))}).setLayout({name:"mx_fade",type:"float",inputs:[{name:"t",type:"float"}]}),RH=ge(([i])=>{const e=ne(i).toVar(),t=ht(ht(1)).toVar(),s=ht(ht(ne(3735928559)).add(t.shiftLeft(ht(2))).add(ht(13))).toVar();return Sh(s.add(ht(e)),s,s)}).setLayout({name:"mx_hash_int_0",type:"uint",inputs:[{name:"x",type:"int"}]}),IH=ge(([i,e])=>{const t=ne(e).toVar(),s=ne(i).toVar(),r=ht(ht(2)).toVar(),n=ht().toVar(),o=ht().toVar(),a=ht().toVar();return n.assign(o.assign(a.assign(ht(ne(3735928559)).add(r.shiftLeft(ht(2))).add(ht(13))))),n.addAssign(ht(s)),o.addAssign(ht(t)),Sh(n,o,a)}).setLayout({name:"mx_hash_int_1",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]}),DH=ge(([i,e,t])=>{const s=ne(t).toVar(),r=ne(e).toVar(),n=ne(i).toVar(),o=ht(ht(3)).toVar(),a=ht().toVar(),l=ht().toVar(),u=ht().toVar();return a.assign(l.assign(u.assign(ht(ne(3735928559)).add(o.shiftLeft(ht(2))).add(ht(13))))),a.addAssign(ht(n)),l.addAssign(ht(r)),u.addAssign(ht(s)),Sh(a,l,u)}).setLayout({name:"mx_hash_int_2",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]}),kH=ge(([i,e,t,s])=>{const r=ne(s).toVar(),n=ne(t).toVar(),o=ne(e).toVar(),a=ne(i).toVar(),l=ht(ht(4)).toVar(),u=ht().toVar(),c=ht().toVar(),d=ht().toVar();return u.assign(c.assign(d.assign(ht(ne(3735928559)).add(l.shiftLeft(ht(2))).add(ht(13))))),u.addAssign(ht(a)),c.addAssign(ht(o)),d.addAssign(ht(n)),C$(u,c,d),u.addAssign(ht(r)),Sh(u,c,d)}).setLayout({name:"mx_hash_int_3",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"}]}),LH=ge(([i,e,t,s,r])=>{const n=ne(r).toVar(),o=ne(s).toVar(),a=ne(t).toVar(),l=ne(e).toVar(),u=ne(i).toVar(),c=ht(ht(5)).toVar(),d=ht().toVar(),h=ht().toVar(),p=ht().toVar();return d.assign(h.assign(p.assign(ht(ne(3735928559)).add(c.shiftLeft(ht(2))).add(ht(13))))),d.addAssign(ht(u)),h.addAssign(ht(l)),p.addAssign(ht(a)),C$(d,h,p),d.addAssign(ht(o)),h.addAssign(ht(n)),Sh(d,h,p)}).setLayout({name:"mx_hash_int_4",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"},{name:"yy",type:"int"}]}),Ns=sr([RH,IH,DH,kH,LH]),BH=ge(([i,e])=>{const t=ne(e).toVar(),s=ne(i).toVar(),r=ht(Ns(s,t)).toVar(),n=Sc().toVar();return n.x.assign(r.bitAnd(ne(255))),n.y.assign(r.shiftRight(ne(8)).bitAnd(ne(255))),n.z.assign(r.shiftRight(ne(16)).bitAnd(ne(255))),n}).setLayout({name:"mx_hash_vec3_0",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]}),OH=ge(([i,e,t])=>{const s=ne(t).toVar(),r=ne(e).toVar(),n=ne(i).toVar(),o=ht(Ns(n,r,s)).toVar(),a=Sc().toVar();return a.x.assign(o.bitAnd(ne(255))),a.y.assign(o.shiftRight(ne(8)).bitAnd(ne(255))),a.z.assign(o.shiftRight(ne(16)).bitAnd(ne(255))),a}).setLayout({name:"mx_hash_vec3_1",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]}),cn=sr([BH,OH]),$H=ge(([i])=>{const e=Ge(i).toVar(),t=ne().toVar(),s=ne().toVar(),r=Y(Ys(e.x,t)).toVar(),n=Y(Ys(e.y,s)).toVar(),o=Y(yo(r)).toVar(),a=Y(yo(n)).toVar(),l=Y(v$(Ki(Ns(t,s),r,n),Ki(Ns(t.add(ne(1)),s),r.sub(1),n),Ki(Ns(t,s.add(ne(1))),r,n.sub(1)),Ki(Ns(t.add(ne(1)),s.add(ne(1))),r.sub(1),n.sub(1)),o,a)).toVar();return E$(l)}).setLayout({name:"mx_perlin_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"}]}),zH=ge(([i])=>{const e=pe(i).toVar(),t=ne().toVar(),s=ne().toVar(),r=ne().toVar(),n=Y(Ys(e.x,t)).toVar(),o=Y(Ys(e.y,s)).toVar(),a=Y(Ys(e.z,r)).toVar(),l=Y(yo(n)).toVar(),u=Y(yo(o)).toVar(),c=Y(yo(a)).toVar(),d=Y(S$(Ki(Ns(t,s,r),n,o,a),Ki(Ns(t.add(ne(1)),s,r),n.sub(1),o,a),Ki(Ns(t,s.add(ne(1)),r),n,o.sub(1),a),Ki(Ns(t.add(ne(1)),s.add(ne(1)),r),n.sub(1),o.sub(1),a),Ki(Ns(t,s,r.add(ne(1))),n,o,a.sub(1)),Ki(Ns(t.add(ne(1)),s,r.add(ne(1))),n.sub(1),o,a.sub(1)),Ki(Ns(t,s.add(ne(1)),r.add(ne(1))),n,o.sub(1),a.sub(1)),Ki(Ns(t.add(ne(1)),s.add(ne(1)),r.add(ne(1))),n.sub(1),o.sub(1),a.sub(1)),l,u,c)).toVar();return A$(d)}).setLayout({name:"mx_perlin_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"}]}),Vw=sr([$H,zH]),VH=ge(([i])=>{const e=Ge(i).toVar(),t=ne().toVar(),s=ne().toVar(),r=Y(Ys(e.x,t)).toVar(),n=Y(Ys(e.y,s)).toVar(),o=Y(yo(r)).toVar(),a=Y(yo(n)).toVar(),l=pe(v$(un(cn(t,s),r,n),un(cn(t.add(ne(1)),s),r.sub(1),n),un(cn(t,s.add(ne(1))),r,n.sub(1)),un(cn(t.add(ne(1)),s.add(ne(1))),r.sub(1),n.sub(1)),o,a)).toVar();return E$(l)}).setLayout({name:"mx_perlin_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"}]}),UH=ge(([i])=>{const e=pe(i).toVar(),t=ne().toVar(),s=ne().toVar(),r=ne().toVar(),n=Y(Ys(e.x,t)).toVar(),o=Y(Ys(e.y,s)).toVar(),a=Y(Ys(e.z,r)).toVar(),l=Y(yo(n)).toVar(),u=Y(yo(o)).toVar(),c=Y(yo(a)).toVar(),d=pe(S$(un(cn(t,s,r),n,o,a),un(cn(t.add(ne(1)),s,r),n.sub(1),o,a),un(cn(t,s.add(ne(1)),r),n,o.sub(1),a),un(cn(t.add(ne(1)),s.add(ne(1)),r),n.sub(1),o.sub(1),a),un(cn(t,s,r.add(ne(1))),n,o,a.sub(1)),un(cn(t.add(ne(1)),s,r.add(ne(1))),n.sub(1),o,a.sub(1)),un(cn(t,s.add(ne(1)),r.add(ne(1))),n,o.sub(1),a.sub(1)),un(cn(t.add(ne(1)),s.add(ne(1)),r.add(ne(1))),n.sub(1),o.sub(1),a.sub(1)),l,u,c)).toVar();return A$(d)}).setLayout({name:"mx_perlin_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),Uw=sr([VH,UH]),GH=ge(([i])=>{const e=Y(i).toVar(),t=ne(xi(e)).toVar();return ur(Ns(t))}).setLayout({name:"mx_cell_noise_float_0",type:"float",inputs:[{name:"p",type:"float"}]}),jH=ge(([i])=>{const e=Ge(i).toVar(),t=ne(xi(e.x)).toVar(),s=ne(xi(e.y)).toVar();return ur(Ns(t,s))}).setLayout({name:"mx_cell_noise_float_1",type:"float",inputs:[{name:"p",type:"vec2"}]}),WH=ge(([i])=>{const e=pe(i).toVar(),t=ne(xi(e.x)).toVar(),s=ne(xi(e.y)).toVar(),r=ne(xi(e.z)).toVar();return ur(Ns(t,s,r))}).setLayout({name:"mx_cell_noise_float_2",type:"float",inputs:[{name:"p",type:"vec3"}]}),HH=ge(([i])=>{const e=St(i).toVar(),t=ne(xi(e.x)).toVar(),s=ne(xi(e.y)).toVar(),r=ne(xi(e.z)).toVar(),n=ne(xi(e.w)).toVar();return ur(Ns(t,s,r,n))}).setLayout({name:"mx_cell_noise_float_3",type:"float",inputs:[{name:"p",type:"vec4"}]}),qH=sr([GH,jH,WH,HH]),KH=ge(([i])=>{const e=Y(i).toVar(),t=ne(xi(e)).toVar();return pe(ur(Ns(t,ne(0))),ur(Ns(t,ne(1))),ur(Ns(t,ne(2))))}).setLayout({name:"mx_cell_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"float"}]}),XH=ge(([i])=>{const e=Ge(i).toVar(),t=ne(xi(e.x)).toVar(),s=ne(xi(e.y)).toVar();return pe(ur(Ns(t,s,ne(0))),ur(Ns(t,s,ne(1))),ur(Ns(t,s,ne(2))))}).setLayout({name:"mx_cell_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec2"}]}),YH=ge(([i])=>{const e=pe(i).toVar(),t=ne(xi(e.x)).toVar(),s=ne(xi(e.y)).toVar(),r=ne(xi(e.z)).toVar();return pe(ur(Ns(t,s,r,ne(0))),ur(Ns(t,s,r,ne(1))),ur(Ns(t,s,r,ne(2))))}).setLayout({name:"mx_cell_noise_vec3_2",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),QH=ge(([i])=>{const e=St(i).toVar(),t=ne(xi(e.x)).toVar(),s=ne(xi(e.y)).toVar(),r=ne(xi(e.z)).toVar(),n=ne(xi(e.w)).toVar();return pe(ur(Ns(t,s,r,n,ne(0))),ur(Ns(t,s,r,n,ne(1))),ur(Ns(t,s,r,n,ne(2))))}).setLayout({name:"mx_cell_noise_vec3_3",type:"vec3",inputs:[{name:"p",type:"vec4"}]}),P$=sr([KH,XH,YH,QH]),cm=ge(([i,e,t,s])=>{const r=Y(s).toVar(),n=Y(t).toVar(),o=ne(e).toVar(),a=pe(i).toVar(),l=Y(0).toVar(),u=Y(1).toVar();return Rs(o,()=>{l.addAssign(u.mul(Vw(a))),u.mulAssign(r),a.mulAssign(n)}),l}).setLayout({name:"mx_fractal_noise_float",type:"float",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),N$=ge(([i,e,t,s])=>{const r=Y(s).toVar(),n=Y(t).toVar(),o=ne(e).toVar(),a=pe(i).toVar(),l=pe(0).toVar(),u=Y(1).toVar();return Rs(o,()=>{l.addAssign(u.mul(Uw(a))),u.mulAssign(r),a.mulAssign(n)}),l}).setLayout({name:"mx_fractal_noise_vec3",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),ZH=ge(([i,e,t,s])=>{const r=Y(s).toVar(),n=Y(t).toVar(),o=ne(e).toVar(),a=pe(i).toVar();return Ge(cm(a,o,n,r),cm(a.add(pe(ne(19),ne(193),ne(17))),o,n,r))}).setLayout({name:"mx_fractal_noise_vec2",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),JH=ge(([i,e,t,s])=>{const r=Y(s).toVar(),n=Y(t).toVar(),o=ne(e).toVar(),a=pe(i).toVar(),l=pe(N$(a,o,n,r)).toVar(),u=Y(cm(a.add(pe(ne(19),ne(193),ne(17))),o,n,r)).toVar();return St(l,u)}).setLayout({name:"mx_fractal_noise_vec4",type:"vec4",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),eq=ge(([i,e,t,s,r,n,o])=>{const a=ne(o).toVar(),l=Y(n).toVar(),u=ne(r).toVar(),c=ne(s).toVar(),d=ne(t).toVar(),h=ne(e).toVar(),p=Ge(i).toVar(),f=pe(P$(Ge(h.add(c),d.add(u)))).toVar(),m=Ge(f.x,f.y).toVar();m.subAssign(.5),m.mulAssign(l),m.addAssign(.5);const x=Ge(Ge(Y(h),Y(d)).add(m)).toVar(),g=Ge(x.sub(p)).toVar();return Ht(a.equal(ne(2)),()=>Us(g.x).add(Us(g.y))),Ht(a.equal(ne(3)),()=>ni(Us(g.x),Us(g.y))),Ua(g,g)}).setLayout({name:"mx_worley_distance_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),tq=ge(([i,e,t,s,r,n,o,a,l])=>{const u=ne(l).toVar(),c=Y(a).toVar(),d=ne(o).toVar(),h=ne(n).toVar(),p=ne(r).toVar(),f=ne(s).toVar(),m=ne(t).toVar(),x=ne(e).toVar(),g=pe(i).toVar(),_=pe(P$(pe(x.add(p),m.add(h),f.add(d)))).toVar();_.subAssign(.5),_.mulAssign(c),_.addAssign(.5);const S=pe(pe(Y(x),Y(m),Y(f)).add(_)).toVar(),M=pe(S.sub(g)).toVar();return Ht(u.equal(ne(2)),()=>Us(M.x).add(Us(M.y)).add(Us(M.z))),Ht(u.equal(ne(3)),()=>ni(Us(M.x),Us(M.y),Us(M.z))),Ua(M,M)}).setLayout({name:"mx_worley_distance_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"zoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),Cc=sr([eq,tq]),sq=ge(([i,e,t])=>{const s=ne(t).toVar(),r=Y(e).toVar(),n=Ge(i).toVar(),o=ne().toVar(),a=ne().toVar(),l=Ge(Ys(n.x,o),Ys(n.y,a)).toVar(),u=Y(1e6).toVar();return Rs({start:-1,end:ne(1),name:"x",condition:"<="},({x:c})=>{Rs({start:-1,end:ne(1),name:"y",condition:"<="},({y:d})=>{const h=Y(Cc(l,c,d,o,a,r,s)).toVar();u.assign(Ir(u,h))})}),Ht(s.equal(ne(0)),()=>{u.assign(Eo(u))}),u}).setLayout({name:"mx_worley_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),iq=ge(([i,e,t])=>{const s=ne(t).toVar(),r=Y(e).toVar(),n=Ge(i).toVar(),o=ne().toVar(),a=ne().toVar(),l=Ge(Ys(n.x,o),Ys(n.y,a)).toVar(),u=Ge(1e6,1e6).toVar();return Rs({start:-1,end:ne(1),name:"x",condition:"<="},({x:c})=>{Rs({start:-1,end:ne(1),name:"y",condition:"<="},({y:d})=>{const h=Y(Cc(l,c,d,o,a,r,s)).toVar();Ht(h.lessThan(u.x),()=>{u.y.assign(u.x),u.x.assign(h)}).ElseIf(h.lessThan(u.y),()=>{u.y.assign(h)})})}),Ht(s.equal(ne(0)),()=>{u.assign(Eo(u))}),u}).setLayout({name:"mx_worley_noise_vec2_0",type:"vec2",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),rq=ge(([i,e,t])=>{const s=ne(t).toVar(),r=Y(e).toVar(),n=Ge(i).toVar(),o=ne().toVar(),a=ne().toVar(),l=Ge(Ys(n.x,o),Ys(n.y,a)).toVar(),u=pe(1e6,1e6,1e6).toVar();return Rs({start:-1,end:ne(1),name:"x",condition:"<="},({x:c})=>{Rs({start:-1,end:ne(1),name:"y",condition:"<="},({y:d})=>{const h=Y(Cc(l,c,d,o,a,r,s)).toVar();Ht(h.lessThan(u.x),()=>{u.z.assign(u.y),u.y.assign(u.x),u.x.assign(h)}).ElseIf(h.lessThan(u.y),()=>{u.z.assign(u.y),u.y.assign(h)}).ElseIf(h.lessThan(u.z),()=>{u.z.assign(h)})})}),Ht(s.equal(ne(0)),()=>{u.assign(Eo(u))}),u}).setLayout({name:"mx_worley_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),nq=ge(([i,e,t])=>{const s=ne(t).toVar(),r=Y(e).toVar(),n=pe(i).toVar(),o=ne().toVar(),a=ne().toVar(),l=ne().toVar(),u=pe(Ys(n.x,o),Ys(n.y,a),Ys(n.z,l)).toVar(),c=Y(1e6).toVar();return Rs({start:-1,end:ne(1),name:"x",condition:"<="},({x:d})=>{Rs({start:-1,end:ne(1),name:"y",condition:"<="},({y:h})=>{Rs({start:-1,end:ne(1),name:"z",condition:"<="},({z:p})=>{const f=Y(Cc(u,d,h,p,o,a,l,r,s)).toVar();c.assign(Ir(c,f))})})}),Ht(s.equal(ne(0)),()=>{c.assign(Eo(c))}),c}).setLayout({name:"mx_worley_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),oq=sr([sq,nq]),aq=ge(([i,e,t])=>{const s=ne(t).toVar(),r=Y(e).toVar(),n=pe(i).toVar(),o=ne().toVar(),a=ne().toVar(),l=ne().toVar(),u=pe(Ys(n.x,o),Ys(n.y,a),Ys(n.z,l)).toVar(),c=Ge(1e6,1e6).toVar();return Rs({start:-1,end:ne(1),name:"x",condition:"<="},({x:d})=>{Rs({start:-1,end:ne(1),name:"y",condition:"<="},({y:h})=>{Rs({start:-1,end:ne(1),name:"z",condition:"<="},({z:p})=>{const f=Y(Cc(u,d,h,p,o,a,l,r,s)).toVar();Ht(f.lessThan(c.x),()=>{c.y.assign(c.x),c.x.assign(f)}).ElseIf(f.lessThan(c.y),()=>{c.y.assign(f)})})})}),Ht(s.equal(ne(0)),()=>{c.assign(Eo(c))}),c}).setLayout({name:"mx_worley_noise_vec2_1",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),lq=sr([iq,aq]),uq=ge(([i,e,t])=>{const s=ne(t).toVar(),r=Y(e).toVar(),n=pe(i).toVar(),o=ne().toVar(),a=ne().toVar(),l=ne().toVar(),u=pe(Ys(n.x,o),Ys(n.y,a),Ys(n.z,l)).toVar(),c=pe(1e6,1e6,1e6).toVar();return Rs({start:-1,end:ne(1),name:"x",condition:"<="},({x:d})=>{Rs({start:-1,end:ne(1),name:"y",condition:"<="},({y:h})=>{Rs({start:-1,end:ne(1),name:"z",condition:"<="},({z:p})=>{const f=Y(Cc(u,d,h,p,o,a,l,r,s)).toVar();Ht(f.lessThan(c.x),()=>{c.z.assign(c.y),c.y.assign(c.x),c.x.assign(f)}).ElseIf(f.lessThan(c.y),()=>{c.z.assign(c.y),c.y.assign(f)}).ElseIf(f.lessThan(c.z),()=>{c.z.assign(f)})})})}),Ht(s.equal(ne(0)),()=>{c.assign(Eo(c))}),c}).setLayout({name:"mx_worley_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),cq=sr([rq,uq]),dq=ge(([i])=>{const e=i.y,t=i.z,s=pe().toVar();return Ht(e.lessThan(1e-4),()=>{s.assign(pe(t,t,t))}).Else(()=>{let r=i.x;r=r.sub(go(r)).mul(6).toVar();const n=ne(X0(r)),o=r.sub(Y(n)),a=t.mul(e.oneMinus()),l=t.mul(e.mul(o).oneMinus()),u=t.mul(e.mul(o.oneMinus()).oneMinus());Ht(n.equal(ne(0)),()=>{s.assign(pe(t,u,a))}).ElseIf(n.equal(ne(1)),()=>{s.assign(pe(l,t,a))}).ElseIf(n.equal(ne(2)),()=>{s.assign(pe(a,t,u))}).ElseIf(n.equal(ne(3)),()=>{s.assign(pe(a,l,t))}).ElseIf(n.equal(ne(4)),()=>{s.assign(pe(u,a,t))}).Else(()=>{s.assign(pe(t,a,l))})}),s}).setLayout({name:"mx_hsvtorgb",type:"vec3",inputs:[{name:"hsv",type:"vec3"}]}),hq=ge(([i])=>{const e=pe(i).toVar(),t=Y(e.x).toVar(),s=Y(e.y).toVar(),r=Y(e.z).toVar(),n=Y(Ir(t,Ir(s,r))).toVar(),o=Y(ni(t,ni(s,r))).toVar(),a=Y(o.sub(n)).toVar(),l=Y().toVar(),u=Y().toVar(),c=Y().toVar();return c.assign(o),Ht(o.greaterThan(0),()=>{u.assign(a.div(o))}).Else(()=>{u.assign(0)}),Ht(u.lessThanEqual(0),()=>{l.assign(0)}).Else(()=>{Ht(t.greaterThanEqual(o),()=>{l.assign(s.sub(r).div(a))}).ElseIf(s.greaterThanEqual(o),()=>{l.assign(Ri(2,r.sub(t).div(a)))}).Else(()=>{l.assign(Ri(4,t.sub(s).div(a)))}),l.mulAssign(1/6),Ht(l.lessThan(0),()=>{l.addAssign(1)})}),pe(l,u,c)}).setLayout({name:"mx_rgbtohsv",type:"vec3",inputs:[{name:"c",type:"vec3"}]}),pq=ge(([i])=>{const e=pe(i).toVar(),t=I0(U0(e,pe(.04045))).toVar(),s=pe(e.div(12.92)).toVar(),r=pe(jn(ni(e.add(pe(.055)),pe(0)).div(1.055),pe(2.4))).toVar();return Cs(s,r,t)}).setLayout({name:"mx_srgb_texture_to_lin_rec709",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),F$=(i,e)=>{i=Y(i),e=Y(e);const t=Ge(e.dFdx(),e.dFdy()).length().mul(.7071067811865476);return Mo(i.sub(t),i.add(t),e)},R$=(i,e,t,s)=>Cs(i,e,t[s].clamp()),fq=(i,e,t=qs())=>R$(i,e,t,"x"),mq=(i,e,t=qs())=>R$(i,e,t,"y"),I$=(i,e,t,s,r)=>Cs(i,e,F$(t,s[r])),gq=(i,e,t,s=qs())=>I$(i,e,t,s,"x"),_q=(i,e,t,s=qs())=>I$(i,e,t,s,"y"),yq=(i=1,e=0,t=qs())=>t.mul(i).add(e),xq=(i,e=1)=>(i=Y(i),i.abs().pow(e).mul(i.sign())),bq=(i,e=1,t=.5)=>Y(i).sub(t).mul(e).add(t),wq=(i=qs(),e=1,t=0)=>Vw(i.convert("vec2|vec3")).mul(e).add(t),Mq=(i=qs(),e=1,t=0)=>Uw(i.convert("vec2|vec3")).mul(e).add(t),Tq=(i=qs(),e=1,t=0)=>(i=i.convert("vec2|vec3"),St(Uw(i),Vw(i.add(Ge(19,73)))).mul(e).add(t)),vq=(i=qs(),e=1)=>oq(i.convert("vec2|vec3"),e,ne(1)),Sq=(i=qs(),e=1)=>lq(i.convert("vec2|vec3"),e,ne(1)),Eq=(i=qs(),e=1)=>cq(i.convert("vec2|vec3"),e,ne(1)),Aq=(i=qs())=>qH(i.convert("vec2|vec3")),Cq=(i=qs(),e=3,t=2,s=.5,r=1)=>cm(i,ne(e),t,s).mul(r),Pq=(i=qs(),e=3,t=2,s=.5,r=1)=>ZH(i,ne(e),t,s).mul(r),Nq=(i=qs(),e=3,t=2,s=.5,r=1)=>N$(i,ne(e),t,s).mul(r),Fq=(i=qs(),e=3,t=2,s=.5,r=1)=>JH(i,ne(e),t,s).mul(r),Rq=ge(([i,e,t])=>{const s=sa(i).toVar(),r=us(Y(.5).mul(e.sub(t)),Zo).div(s).toVar(),n=us(Y(-.5).mul(e.sub(t)),Zo).div(s).toVar(),o=pe().toVar();o.x=s.x.greaterThan(Y(0)).select(r.x,n.x),o.y=s.y.greaterThan(Y(0)).select(r.y,n.y),o.z=s.z.greaterThan(Y(0)).select(r.z,n.z);const a=Ir(o.x,o.y,o.z).toVar();return Zo.add(s.mul(a)).toVar().sub(t)}),D$=ge(([i,e])=>{const t=i.x,s=i.y,r=i.z;let n=e.element(0).mul(.886227);return n=n.add(e.element(1).mul(2*.511664).mul(s)),n=n.add(e.element(2).mul(2*.511664).mul(r)),n=n.add(e.element(3).mul(2*.511664).mul(t)),n=n.add(e.element(4).mul(2*.429043).mul(t).mul(s)),n=n.add(e.element(5).mul(2*.429043).mul(s).mul(r)),n=n.add(e.element(6).mul(r.mul(r).mul(.743125).sub(.247708))),n=n.add(e.element(7).mul(2*.429043).mul(t).mul(r)),n=n.add(e.element(8).mul(.429043).mul(Wt(t,t).sub(Wt(s,s)))),n});var P=Object.freeze({__proto__:null,BRDF_GGX:yb,BRDF_Lambert:Ql,BasicPointShadowFilter:b$,BasicShadowFilter:h$,Break:iO,Const:AL,Continue:kj,DFGApprox:Tw,D_GGX:SO,Discard:GL,EPSILON:Zk,F_Schlick:Mc,Fn:ge,INFINITY:dG,If:Ht,Loop:Rs,NodeAccess:ar,NodeShaderStage:Ld,NodeType:B4,NodeUpdateType:Kt,PCFShadowFilter:p$,PCFSoftShadowFilter:f$,PI:rm,PI2:hG,PointShadowFilter:w$,Return:PG,Schlick_to_F0:AO,ScriptableNodeResources:Df,ShaderNode:tc,Stack:wm,Switch:sG,TBNViewMatrix:Vl,VSMShadowFilter:m$,V_GGX_SmithCorrelated:vO,Var:EL,abs:Us,acesFilmicToneMapping:i$,acos:W0,add:Ri,addMethodChaining:Le,addNodeElement:RG,agxToneMapping:r$,all:Jk,alphaT:tm,and:Bk,anisotropy:Ca,anisotropyB:Wl,anisotropyT:Wd,any:eL,append:oG,array:Nk,arrayBuffer:rG,asin:rL,assign:Fk,atan:H0,atan2:TL,atomicAdd:j6,atomicAnd:K6,atomicFunc:Co,atomicLoad:U6,atomicMax:H6,atomicMin:q6,atomicOr:X6,atomicStore:G6,atomicSub:W6,atomicXor:Y6,attenuationColor:O0,attenuationDistance:B0,attribute:ra,attributeArray:V5,backgroundBlurriness:KO,backgroundIntensity:vb,backgroundRotation:XO,batch:eO,bentNormalView:_B,billboarding:M5,bitAnd:Vk,bitNot:Uk,bitOr:Gk,bitXor:jk,bitangentGeometry:fj,bitangentLocal:mj,bitangentView:mB,bitangentWorld:gj,bitcast:pG,blendBurn:dO,blendColor:eW,blendDodge:hO,blendOverlay:fO,blendScreen:pO,blur:IO,bool:bo,buffer:xh,bufferAttribute:yh,bumpMap:yB,burn:sW,bvec2:bk,bvec3:I0,bvec4:vk,bypass:$L,cache:qd,call:Rk,cameraFar:Na,cameraIndex:Im,cameraNear:Pa,cameraNormalMatrix:jG,cameraPosition:qL,cameraProjectionMatrix:iu,cameraProjectionMatrixInverse:UG,cameraViewMatrix:Tn,cameraWorldMatrix:GG,cbrt:yL,cdl:i6,ceil:Cm,checker:yH,cineonToneMapping:s$,clamp:wo,clearcoat:em,clearcoatNormalView:zl,clearcoatRoughness:lh,code:jm,color:yk,colorSpaceToWorking:Rm,colorToDirection:hW,compute:OL,computeSkinning:Ij,context:Fm,convert:Ek,convertColorSpace:bG,convertToTexture:D5,cos:zo,cross:Nm,cubeTexture:wc,cubeTextureBase:dw,cubeToUV:$n,dFdx:q0,dFdy:K0,dashSize:Af,debug:WL,decrement:Yk,decrementBefore:Kk,defaultBuildStages:rb,defaultShaderStages:hk,defined:rh,degrees:sL,deltaTime:WO,densityFog:S6,densityFogFactor:Rw,depth:xw,depthPass:l6,difference:fL,diffuseColor:ws,directPointLight:T$,directionToColor:gO,directionToFaceDirection:Ec,dispersion:$0,distance:pL,div:wn,dodge:iW,dot:Ua,drawIndex:QB,dynamicBufferAttribute:BL,element:Sk,emissive:lb,equal:V0,equals:dL,equirectUV:bw,exp:G0,exp2:xc,expression:ia,faceDirection:lw,faceForward:ew,faceforward:fG,float:Y,floor:go,fog:hh,fract:la,frameGroup:Pk,frameId:h5,frontFacing:QL,fwidth:uL,gain:n5,gapSize:ub,getConstNodeType:_k,getCurrentStack:R0,getDirection:FO,getDistanceAttenuation:zw,getGeometryRoughness:TO,getNormalFromDepth:L5,getParallaxCorrectNormal:Rq,getRoughness:Mw,getScreenPosition:k5,getShIrradianceAt:D$,getShadowMaterial:g$,getShadowRenderObjectFunction:_$,getTextureIndex:GO,getViewPosition:Ku,globalId:F6,glsl:_6,glslFn:y6,grayscale:J5,greaterThan:U0,greaterThanEqual:Lk,hash:r5,highpModelNormalViewMatrix:hb,highpModelViewMatrix:db,hue:s6,increment:Xk,incrementBefore:qk,instance:Ej,instanceIndex:Ba,instancedArray:U5,instancedBufferAttribute:nm,instancedDynamicBufferAttribute:cb,instancedMesh:JB,int:ne,inverseSqrt:j0,inversesqrt:mG,invocationLocalIndex:Sj,invocationSubgroupIndex:vj,ior:Hd,iridescence:vm,iridescenceIOR:D0,iridescenceThickness:k0,ivec2:Vi,ivec3:wk,ivec4:Mk,js:m6,label:SL,length:_o,lengthSq:Q0,lessThan:Dk,lessThanEqual:kk,lightPosition:kw,lightProjectionUV:c$,lightShadowMatrix:Dw,lightTargetDirection:Bw,lightTargetPosition:d$,lightViewPosition:Lw,lightingContext:nO,lights:J6,linearDepth:am,linearToneMapping:e$,localId:R6,log:Am,log2:mo,logarithmicDepthToViewZ:Hj,luminance:Nw,mat2:Mm,mat3:cr,mat4:jl,matcapUV:LO,materialAO:XB,materialAlphaTest:xB,materialAnisotropy:DB,materialAnisotropyVector:qu,materialAttenuationColor:UB,materialAttenuationDistance:VB,materialClearcoat:CB,materialClearcoatNormal:NB,materialClearcoatRoughness:PB,materialColor:bB,materialDispersion:KB,materialEmissive:MB,materialEnvIntensity:Nf,materialEnvRotation:cw,materialIOR:zB,materialIridescence:kB,materialIridescenceIOR:LB,materialIridescenceThickness:BB,materialLightMap:pw,materialLineDashOffset:HB,materialLineDashSize:jB,materialLineGapSize:WB,materialLineScale:GB,materialLineWidth:Mj,materialMetalness:EB,materialNormal:AB,materialOpacity:hw,materialPointSize:qB,materialReference:jo,materialReflectivity:Ff,materialRefractionRatio:tB,materialRotation:FB,materialRoughness:SB,materialSheen:RB,materialSheenRoughness:IB,materialShininess:wB,materialSpecular:TB,materialSpecularColor:vB,materialSpecularIntensity:_b,materialSpecularStrength:Kd,materialThickness:$B,materialTransmission:OB,max:ni,maxMipLevel:rw,mediumpModelViewMatrix:YL,metalness:ah,min:Ir,mix:Cs,mixElement:bL,mod:Em,modInt:Qk,modelDirection:YG,modelNormalMatrix:XL,modelPosition:QG,modelRadius:ej,modelScale:ZG,modelViewMatrix:ru,modelViewPosition:JG,modelViewProjection:fw,modelWorldMatrix:mn,modelWorldMatrixInverse:tj,morphReference:rO,mrt:jO,mul:Wt,mx_aastep:F$,mx_cell_noise_float:Aq,mx_contrast:bq,mx_fractal_noise_float:Cq,mx_fractal_noise_vec2:Pq,mx_fractal_noise_vec3:Nq,mx_fractal_noise_vec4:Fq,mx_hsvtorgb:dq,mx_noise_float:wq,mx_noise_vec3:Mq,mx_noise_vec4:Tq,mx_ramplr:fq,mx_ramptb:mq,mx_rgbtohsv:hq,mx_safepower:xq,mx_splitlr:gq,mx_splittb:_q,mx_srgb_texture_to_lin_rec709:pq,mx_transform_uv:yq,mx_worley_noise_float:vq,mx_worley_noise_vec2:Sq,mx_worley_noise_vec3:Eq,negate:nL,neutralToneMapping:n$,nodeArray:Gl,nodeImmutable:ot,nodeObject:De,nodeObjects:gh,nodeProxy:ze,normalFlat:ZL,normalGeometry:Dm,normalLocal:Dr,normalMap:gb,normalView:Fs,normalViewGeometry:bc,normalWorld:Ga,normalWorldGeometry:JL,normalize:sa,not:$k,notEqual:Ik,numWorkgroups:P6,objectDirection:WG,objectGroup:z0,objectPosition:KL,objectRadius:XG,objectScale:qG,objectViewPosition:KG,objectWorldMatrix:HG,oneMinus:oL,or:Ok,orthographicDepthToViewZ:Wj,oscSawtooth:x5,oscSine:g5,oscSquare:_5,oscTriangle:y5,output:lc,outputStruct:s5,overlay:nW,overloadingFn:sr,parabola:Tb,parallaxDirection:gB,parallaxUV:_j,parameter:Y8,pass:o6,passTexture:a6,pcurve:o5,perspectiveDepthToViewZ:_w,pmremTexture:Aw,pointShadow:M$,pointUV:j5,pointWidth:aG,positionGeometry:wh,positionLocal:di,positionPrevious:om,positionView:hi,positionViewDirection:Ks,positionWorld:Zo,positionWorldDirection:aw,posterize:n6,pow:jn,pow2:Y0,pow3:mL,pow4:gL,premultiplyAlpha:mO,property:Qo,radians:tL,rand:xL,range:A6,rangeFog:v6,rangeFogFactor:Fw,reciprocal:lL,reference:Os,referenceBuffer:pb,reflect:hL,reflectVector:rB,reflectView:sB,reflector:P5,refract:J0,refractVector:nB,refractView:iB,reinhardToneMapping:t$,remap:VL,remapClamp:UL,renderGroup:Rt,renderOutput:jL,rendererReference:DL,rotate:Um,rotateUV:b5,roughness:ho,round:aL,rtt:qO,sRGBTransferEOTF:NL,sRGBTransferOETF:FL,sample:O5,sampler:BG,samplerComparison:OG,saturate:Z0,saturation:e6,screen:rW,screenCoordinate:Th,screenSize:dh,screenUV:Jo,scriptable:T6,scriptableValue:If,select:Xi,setCurrentStack:nh,shaderStages:nb,shadow:x$,shadowPositionWorld:$w,shapeCircle:xH,sharedUniformGroup:Sm,sheen:$l,sheenRoughness:Tm,shiftLeft:Wk,shiftRight:Hk,shininess:sm,sign:ch,sin:qr,sinc:a5,skinning:sO,smoothstep:Mo,smoothstepElement:wL,specularColor:Er,specularF90:uh,spherizeUV:w5,split:nG,spritesheetUV:S5,sqrt:Eo,stack:Rf,step:Pm,stepElement:ML,storage:Hl,storageBarrier:L6,storageObject:Rj,storageTexture:YO,string:iG,struct:t5,sub:us,subBuild:uc,subgroupIndex:Tj,subgroupSize:I6,tan:iL,tangentGeometry:Lm,tangentLocal:Mh,tangentView:Bm,tangentWorld:fB,temp:CL,texture:ts,texture3D:QO,textureBarrier:B6,textureBicubic:DW,textureBicubicLevel:vw,textureCubeUV:RO,textureLoad:ci,textureSize:La,textureStore:H5,thickness:L0,time:nu,timerDelta:m5,timerGlobal:f5,timerLocal:p5,toneMapping:kL,toneMappingExposure:LL,toonOutlinePass:c6,transformDirection:_L,transformNormal:eB,transformNormalToView:uw,transformedClearcoatNormalView:nj,transformedNormalView:ij,transformedNormalWorld:rj,transmission:im,transpose:cL,triNoise3D:u5,triplanarTexture:E5,triplanarTextures:HO,trunc:X0,uint:ht,uniform:Et,uniformArray:pn,uniformCubeTexture:aj,uniformGroup:Ck,uniformTexture:LG,unpremultiplyAlpha:tW,userData:Y5,uv:qs,uvec2:xk,uvec3:Sc,uvec4:Tk,varying:Ao,varyingProperty:oh,vec2:Ge,vec3:pe,vec4:St,vectorComponents:tu,velocity:Z5,vertexColor:cO,vertexIndex:YB,vertexStage:PL,vibrance:t6,viewZToLogarithmicDepth:yw,viewZToOrthographicDepth:dc,viewZToPerspectiveDepth:lO,viewport:cc,viewportCoordinate:aO,viewportDepthTexture:gw,viewportLinearDepth:qj,viewportMipTexture:mw,viewportResolution:Uj,viewportSafeUV:T5,viewportSharedTexture:dW,viewportSize:oO,viewportTexture:Gj,viewportUV:Vj,wgsl:g6,wgslFn:x6,workgroupArray:z6,workgroupBarrier:k6,workgroupId:N6,workingToColorSpace:RL,xor:zk});const On=new Cw;class Iq extends ja{constructor(e,t){super(),this.renderer=e,this.nodes=t}update(e,t,s){const r=this.renderer,n=this.nodes.getBackgroundNode(e)||e.background;let o=!1;if(n===null)r._clearColor.getRGB(On),On.a=r._clearColor.a;else if(n.isColor===!0)n.getRGB(On),On.a=1,o=!0;else if(n.isNode===!0){const l=this.get(e),u=n;On.copy(r._clearColor);let c=l.backgroundMesh;if(c===void 0){let m=function(){n.removeEventListener("dispose",m),c.material.dispose(),c.geometry.dispose()};const h=Fm(St(u).mul(vb),{getUV:()=>XO.mul(JL),getTextureLevel:()=>KO});let p=fw;p=p.setZ(p.w);const f=new pi;f.name="Background.material",f.side=lr,f.depthTest=!1,f.depthWrite=!1,f.allowOverride=!1,f.fog=!1,f.lights=!1,f.vertexNode=p,f.colorNode=h,l.backgroundMeshNode=h,l.backgroundMesh=c=new bn(new v0(1,32,32),f),c.frustumCulled=!1,c.name="Background.mesh",c.onBeforeRender=function(x,g,_){this.matrixWorld.copyPosition(_.matrixWorld)},n.addEventListener("dispose",m)}const d=u.getCacheKey();l.backgroundCacheKey!==d&&(l.backgroundMeshNode.node=St(u).mul(vb),l.backgroundMeshNode.needsUpdate=!0,c.material.needsUpdate=!0,l.backgroundCacheKey=d),t.unshift(c,c.geometry,c.material,0,0,null,null)}else console.error("THREE.Renderer: Unsupported background configuration.",n);const a=r.xr.getEnvironmentBlendMode();if(a==="additive"?On.set(0,0,0,1):a==="alpha-blend"&&On.set(0,0,0,0),r.autoClear===!0||o===!0){const l=s.clearColorValue;l.r=On.r,l.g=On.g,l.b=On.b,l.a=On.a,(r.backend.isWebGLBackend===!0||r.alpha===!0)&&(l.r*=l.a,l.g*=l.a,l.b*=l.a),s.depthClearValue=r._clearDepth,s.stencilClearValue=r._clearStencil,s.clearColor=r.autoClearColor===!0,s.clearDepth=r.autoClearDepth===!0,s.clearStencil=r.autoClearStencil===!0}else s.clearColor=!1,s.clearDepth=!1,s.clearStencil=!1}}let Dq=0;class Sb{constructor(e="",t=[],s=0,r=[]){this.name=e,this.bindings=t,this.index=s,this.bindingsReference=r,this.id=Dq++}}class kq{constructor(e,t,s,r,n,o,a,l,u,c=[]){this.vertexShader=e,this.fragmentShader=t,this.computeShader=s,this.transforms=c,this.nodeAttributes=r,this.bindings=n,this.updateNodes=o,this.updateBeforeNodes=a,this.updateAfterNodes=l,this.observer=u,this.usedTimes=0}createBindings(){const e=[];for(const t of this.bindings)if(t.bindings[0].groupNode.shared!==!0){const r=new Sb(t.name,[],t.index,t);e.push(r);for(const n of t.bindings)r.bindings.push(n.clone())}else e.push(t);return e}}class iN{constructor(e,t,s=null){this.isNodeAttribute=!0,this.name=e,this.type=t,this.node=s}}class Lq{constructor(e,t,s){this.isNodeUniform=!0,this.name=e,this.type=t,this.node=s.getSelf()}get value(){return this.node.value}set value(e){this.node.value=e}get id(){return this.node.id}get groupNode(){return this.node.groupNode}}class k${constructor(e,t,s=!1,r=null){this.isNodeVar=!0,this.name=e,this.type=t,this.readOnly=s,this.count=r}}class Bq extends k${constructor(e,t,s=null,r=null){super(e,t),this.needsInterpolation=!1,this.isNodeVarying=!0,this.interpolationType=s,this.interpolationSampling=r}}class Oq{constructor(e,t,s=""){this.name=e,this.type=t,this.code=s,Object.defineProperty(this,"isNodeCode",{value:!0})}}let $q=0;class ix{constructor(e=null){this.id=$q++,this.nodesData=new WeakMap,this.parent=e}getData(e){let t=this.nodesData.get(e);return t===void 0&&this.parent!==null&&(t=this.parent.getData(e)),t}setData(e,t){this.nodesData.set(e,t)}}class zq{constructor(e,t){this.name=e,this.members=t,this.output=!1}}class Wa{constructor(e,t){this.name=e,this.value=t,this.boundary=0,this.itemSize=0,this.offset=0}setValue(e){this.value=e}getValue(){return this.value}}class Vq extends Wa{constructor(e,t=0){super(e,t),this.isNumberUniform=!0,this.boundary=4,this.itemSize=1}}class Uq extends Wa{constructor(e,t=new Dt){super(e,t),this.isVector2Uniform=!0,this.boundary=8,this.itemSize=2}}class Gq extends Wa{constructor(e,t=new xe){super(e,t),this.isVector3Uniform=!0,this.boundary=16,this.itemSize=3}}class jq extends Wa{constructor(e,t=new ns){super(e,t),this.isVector4Uniform=!0,this.boundary=16,this.itemSize=4}}class Wq extends Wa{constructor(e,t=new gs){super(e,t),this.isColorUniform=!0,this.boundary=16,this.itemSize=3}}class Hq extends Wa{constructor(e,t=new _m){super(e,t),this.isMatrix2Uniform=!0,this.boundary=8,this.itemSize=4}}class qq extends Wa{constructor(e,t=new kr){super(e,t),this.isMatrix3Uniform=!0,this.boundary=48,this.itemSize=12}}class Kq extends Wa{constructor(e,t=new cs){super(e,t),this.isMatrix4Uniform=!0,this.boundary=64,this.itemSize=16}}class Xq extends Vq{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Yq extends Uq{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Qq extends Gq{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Zq extends jq{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Jq extends Wq{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class eK extends Hq{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class tK extends qq{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class sK extends Kq{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}const rN=new WeakMap,iK=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),hf=i=>/e/g.test(i)?String(i).replace(/\+/g,""):(i=Number(i),i+(i%1?"":".0"));class L${constructor(e,t,s){this.object=e,this.material=e&&e.material||null,this.geometry=e&&e.geometry||null,this.renderer=t,this.parser=s,this.scene=null,this.camera=null,this.nodes=[],this.sequentialNodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.updateAfterNodes=[],this.hashNodes={},this.observer=null,this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.clippingContext=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:""},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.structs={vertex:[],fragment:[],compute:[],index:0},this.bindings={vertex:{},fragment:{},compute:{}},this.bindingsIndexes={},this.bindGroups=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.codes={},this.vars={},this.declarations={},this.flow={code:""},this.chaining=[],this.stack=Rf(),this.stacks=[],this.tab="	",this.currentFunctionNode=null,this.context={material:this.material},this.cache=new ix,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null,this.subBuildLayers=[],this.currentStack=null,this.subBuildFn=null}getBindGroupsCache(){let e=rN.get(this.renderer);return e===void 0&&(e=new Kn,rN.set(this.renderer,e)),e}createRenderTarget(e,t,s){return new So(e,t,s)}createCubeRenderTarget(e,t){return new _O(e,t)}includes(e){return this.nodes.includes(e)}getOutputStructName(){}_getBindGroup(e,t){const s=this.getBindGroupsCache(),r=[];let n=!0;for(const a of t)r.push(a),n=n&&a.groupNode.shared!==!0;let o;return n?(o=s.get(r),o===void 0&&(o=new Sb(e,r,this.bindingsIndexes[e].group,r),s.set(r,o))):o=new Sb(e,r,this.bindingsIndexes[e].group,r),o}getBindGroupArray(e,t){const s=this.bindings[t];let r=s[e];return r===void 0&&(this.bindingsIndexes[e]===void 0&&(this.bindingsIndexes[e]={binding:0,group:Object.keys(this.bindingsIndexes).length}),s[e]=r=[]),r}getBindings(){let e=this.bindGroups;if(e===null){const t={},s=this.bindings;for(const r of nb)for(const n in s[r]){const o=s[r][n];(t[n]||(t[n]=[])).push(...o)}e=[];for(const r in t){const n=t[r],o=this._getBindGroup(r,n);e.push(o)}this.bindGroups=e}return e}sortBindingGroups(){const e=this.getBindings();e.sort((t,s)=>t.bindings[0].groupNode.order-s.bindings[0].groupNode.order);for(let t=0;t<e.length;t++){const s=e[t];this.bindingsIndexes[s.name].group=t,s.index=t}}setHashNode(e,t){this.hashNodes[t]=e}addNode(e){this.nodes.includes(e)===!1&&(this.nodes.push(e),this.setHashNode(e,e.getHash(this)))}addSequentialNode(e){this.sequentialNodes.includes(e)===!1&&this.sequentialNodes.push(e)}buildUpdateNodes(){for(const e of this.nodes)e.getUpdateType()!==Kt.NONE&&this.updateNodes.push(e.getSelf());for(const e of this.sequentialNodes){const t=e.getUpdateBeforeType(),s=e.getUpdateAfterType();t!==Kt.NONE&&this.updateBeforeNodes.push(e.getSelf()),s!==Kt.NONE&&this.updateAfterNodes.push(e.getSelf())}}get currentNode(){return this.chaining[this.chaining.length-1]}isFilteredTexture(e){return e.magFilter===wr||e.magFilter===$x||e.magFilter===sh||e.magFilter===qo||e.minFilter===wr||e.minFilter===$x||e.minFilter===sh||e.minFilter===qo}addChain(e){this.chaining.push(e)}removeChain(e){if(this.chaining.pop()!==e)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(e){return e}getNodeFromHash(e){return this.hashNodes[e]}addFlow(e,t){return this.flowNodes[e].push(t),t}setContext(e){this.context=e}getContext(){return this.context}getSharedContext(){return{...this.context},this.context}setCache(e){this.cache=e}getCache(){return this.cache}getCacheFromNode(e,t=!0){const s=this.getDataFromNode(e);return s.cache===void 0&&(s.cache=new ix(t?this.getCache():null)),s.cache}isAvailable(){return!1}getVertexIndex(){console.warn("Abstract function.")}getInstanceIndex(){console.warn("Abstract function.")}getDrawIndex(){console.warn("Abstract function.")}getFrontFacing(){console.warn("Abstract function.")}getFragCoord(){console.warn("Abstract function.")}isFlipY(){return!1}increaseUsage(e){const t=this.getDataFromNode(e);return t.usageCount=t.usageCount===void 0?1:t.usageCount+1,t.usageCount}generateTexture(){console.warn("Abstract function.")}generateTextureLod(){console.warn("Abstract function.")}generateArrayDeclaration(e,t){return this.getType(e)+"[ "+t+" ]"}generateArray(e,t,s=null){let r=this.generateArrayDeclaration(e,t)+"( ";for(let n=0;n<t;n++){const o=s?s[n]:null;o!==null?r+=o.build(this,e):r+=this.generateConst(e),n<t-1&&(r+=", ")}return r+=" )",r}generateStruct(e,t,s=null){const r=[];for(const n of t){const{name:o,type:a}=n;s&&s[o]&&s[o].isNode?r.push(s[o].build(this,a)):r.push(this.generateConst(a))}return e+"( "+r.join(", ")+" )"}generateConst(e,t=null){if(t===null&&(e==="float"||e==="int"||e==="uint"?t=0:e==="bool"?t=!1:e==="color"?t=new gs:e==="vec2"?t=new Dt:e==="vec3"?t=new xe:e==="vec4"&&(t=new ns)),e==="float")return hf(t);if(e==="int")return`${Math.round(t)}`;if(e==="uint")return t>=0?`${Math.round(t)}u`:"0u";if(e==="bool")return t?"true":"false";if(e==="color")return`${this.getType("vec3")}( ${hf(t.r)}, ${hf(t.g)}, ${hf(t.b)} )`;const s=this.getTypeLength(e),r=this.getComponentType(e),n=o=>this.generateConst(r,o);if(s===2)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)} )`;if(s===3)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)}, ${n(t.z)} )`;if(s===4&&e!=="mat2")return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)}, ${n(t.z)}, ${n(t.w)} )`;if(s>=4&&t&&(t.isMatrix2||t.isMatrix3||t.isMatrix4))return`${this.getType(e)}( ${t.elements.map(n).join(", ")} )`;if(s>4)return`${this.getType(e)}()`;throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`)}getType(e){return e==="color"?"vec3":e}hasGeometryAttribute(e){return this.geometry&&this.geometry.getAttribute(e)!==void 0}getAttribute(e,t){const s=this.attributes;for(const n of s)if(n.name===e)return n;const r=new iN(e,t);return this.registerDeclaration(r),s.push(r),r}getPropertyName(e){return e.name}isVector(e){return/vec\d/.test(e)}isMatrix(e){return/mat\d/.test(e)}isReference(e){return e==="void"||e==="property"||e==="sampler"||e==="samplerComparison"||e==="texture"||e==="cubeTexture"||e==="storageTexture"||e==="depthTexture"||e==="texture3D"}needsToWorkingColorSpace(){return!1}getComponentTypeFromTexture(e){const t=e.type;if(e.isDataTexture){if(t===_r)return"int";if(t===_i)return"uint"}return"float"}getElementType(e){return e==="mat2"?"vec2":e==="mat3"?"vec3":e==="mat4"?"vec4":this.getComponentType(e)}getComponentType(e){if(e=this.getVectorType(e),e==="float"||e==="bool"||e==="int"||e==="uint")return e;const t=/(b|i|u|)(vec|mat)([2-4])/.exec(e);return t===null?null:t[1]==="b"?"bool":t[1]==="i"?"int":t[1]==="u"?"uint":"float"}getVectorType(e){return e==="color"?"vec3":e==="texture"||e==="cubeTexture"||e==="storageTexture"||e==="texture3D"?"vec4":e}getTypeFromLength(e,t="float"){if(e===1)return t;let s=ok(e);const r=t==="float"?"":t[0];return/mat2/.test(t)===!0&&(s=s.replace("vec","mat")),r+s}getTypeFromArray(e){return iK.get(e.constructor)}isInteger(e){return/int|uint|(i|u)vec/.test(e)}getTypeFromAttribute(e){let t=e;e.isInterleavedBufferAttribute&&(t=e.data);const s=t.array,r=e.itemSize,n=e.normalized;let o;return!(e instanceof YD)&&n!==!0&&(o=this.getTypeFromArray(s)),this.getTypeFromLength(r,o)}getTypeLength(e){const t=this.getVectorType(e),s=/vec([2-4])/.exec(t);return s!==null?Number(s[1]):t==="float"||t==="bool"||t==="int"||t==="uint"?1:/mat2/.test(e)===!0?4:/mat3/.test(e)===!0?9:/mat4/.test(e)===!0?16:0}getVectorFromMatrix(e){return e.replace("mat","vec")}changeComponentType(e,t){return this.getTypeFromLength(this.getTypeLength(e),t)}getIntegerType(e){const t=this.getComponentType(e);return t==="int"||t==="uint"?e:this.changeComponentType(e,"int")}addStack(){return this.stack=Rf(this.stack),this.stacks.push(R0()||this.stack),nh(this.stack),this.stack}removeStack(){const e=this.stack;return this.stack=e.parent,nh(this.stacks.pop()),e}getDataFromNode(e,t=this.shaderStage,s=null){s=s===null?e.isGlobal(this)?this.globalCache:this.cache:s;let r=s.getData(e);r===void 0&&(r={},s.setData(e,r)),r[t]===void 0&&(r[t]={});let n=r[t];const o=r.any?r.any.subBuilds:null,a=this.getClosestSubBuild(o);return a&&(n.subBuildsCache===void 0&&(n.subBuildsCache={}),n=n.subBuildsCache[a]||(n.subBuildsCache[a]={}),n.subBuilds=o),n}getNodeProperties(e,t="any"){const s=this.getDataFromNode(e,t);return s.properties||(s.properties={outputNode:null})}getBufferAttributeFromNode(e,t){const s=this.getDataFromNode(e);let r=s.bufferAttribute;if(r===void 0){const n=this.uniforms.index++;r=new iN("nodeAttribute"+n,t,e),this.bufferAttributes.push(r),s.bufferAttribute=r}return r}getStructTypeFromNode(e,t,s=null,r=this.shaderStage){const n=this.getDataFromNode(e,r,this.globalCache);let o=n.structType;if(o===void 0){const a=this.structs.index++;s===null&&(s="StructType"+a),o=new zq(s,t),this.structs[r].push(o),n.structType=o}return o}getOutputStructTypeFromNode(e,t){const s=this.getStructTypeFromNode(e,t,"OutputType","fragment");return s.output=!0,s}getUniformFromNode(e,t,s=this.shaderStage,r=null){const n=this.getDataFromNode(e,s,this.globalCache);let o=n.uniform;if(o===void 0){const a=this.uniforms.index++;o=new Lq(r||"nodeUniform"+a,t,e),this.uniforms[s].push(o),this.registerDeclaration(o),n.uniform=o}return o}getArrayCount(e){let t=null;return e.isArrayNode?t=e.count:e.isVarNode&&e.node.isArrayNode&&(t=e.node.count),t}getVarFromNode(e,t=null,s=e.getNodeType(this),r=this.shaderStage,n=!1){const o=this.getDataFromNode(e,r),a=this.getSubBuildProperty("variable",o.subBuilds);let l=o[a];if(l===void 0){const u=n?"_const":"_var",c=this.vars[r]||(this.vars[r]=[]),d=this.vars[u]||(this.vars[u]=0);t===null&&(t=(n?"nodeConst":"nodeVar")+d,this.vars[u]++),a!=="variable"&&(t=this.getSubBuildProperty(t,o.subBuilds));const h=this.getArrayCount(e);l=new k$(t,s,n,h),n||c.push(l),this.registerDeclaration(l),o[a]=l}return l}isDeterministic(e){if(e.isMathNode)return this.isDeterministic(e.aNode)&&(e.bNode?this.isDeterministic(e.bNode):!0)&&(e.cNode?this.isDeterministic(e.cNode):!0);if(e.isOperatorNode)return this.isDeterministic(e.aNode)&&(e.bNode?this.isDeterministic(e.bNode):!0);if(e.isArrayNode){if(e.values!==null){for(const t of e.values)if(!this.isDeterministic(t))return!1}return!0}else if(e.isConstNode)return!0;return!1}getVaryingFromNode(e,t=null,s=e.getNodeType(this),r=null,n=null){const o=this.getDataFromNode(e,"any"),a=this.getSubBuildProperty("varying",o.subBuilds);let l=o[a];if(l===void 0){const u=this.varyings,c=u.length;t===null&&(t="nodeVarying"+c),a!=="varying"&&(t=this.getSubBuildProperty(t,o.subBuilds)),l=new Bq(t,s,r,n),u.push(l),this.registerDeclaration(l),o[a]=l}return l}registerDeclaration(e){const t=this.shaderStage,s=this.declarations[t]||(this.declarations[t]={}),r=this.getPropertyName(e);let n=1,o=r;for(;s[o]!==void 0;)o=r+"_"+n++;n>1&&(e.name=o,console.warn(`THREE.TSL: Declaration name '${r}' of '${e.type}' already in use. Renamed to '${o}'.`)),s[o]=e}getCodeFromNode(e,t,s=this.shaderStage){const r=this.getDataFromNode(e);let n=r.code;if(n===void 0){const o=this.codes[s]||(this.codes[s]=[]),a=o.length;n=new Oq("nodeCode"+a,t),o.push(n),r.code=n}return n}addFlowCodeHierarchy(e,t){const{flowCodes:s,flowCodeBlock:r}=this.getDataFromNode(e);let n=!0,o=t;for(;o;){if(r.get(o)===!0){n=!1;break}o=this.getDataFromNode(o).parentNodeBlock}if(n)for(const a of s)this.addLineFlowCode(a)}addLineFlowCodeBlock(e,t,s){const r=this.getDataFromNode(e),n=r.flowCodes||(r.flowCodes=[]),o=r.flowCodeBlock||(r.flowCodeBlock=new WeakMap);n.push(t),o.set(s,!0)}addLineFlowCode(e,t=null){return e===""?this:(t!==null&&this.context.nodeBlock&&this.addLineFlowCodeBlock(t,e,this.context.nodeBlock),e=this.tab+e,/;\s*$/.test(e)||(e=e+`;
`),this.flow.code+=e,this)}addFlowCode(e){return this.flow.code+=e,this}addFlowTab(){return this.tab+="	",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(e){return this.flowsData.get(e)}flowNode(e){const t=e.getNodeType(this),s=this.flowChildNode(e,t);return this.flowsData.set(e,s),s}addInclude(e){this.currentFunctionNode!==null&&this.currentFunctionNode.includes.push(e)}buildFunctionNode(e){const t=new o$,s=this.currentFunctionNode;return this.currentFunctionNode=t,t.code=this.buildFunctionCode(e),this.currentFunctionNode=s,t}flowShaderNode(e){const t=e.layout,s={[Symbol.iterator](){let o=0;const a=Object.values(this);return{next:()=>({value:a[o],done:o++>=a.length})}}};for(const o of t.inputs)s[o.name]=new VO(o.type,o.name);e.layout=null;const r=e.call(s),n=this.flowStagesNode(r,t.type);return e.layout=t,n}flowStagesNode(e,t=null){const s=this.flow,r=this.vars,n=this.declarations,o=this.cache,a=this.buildStage,l=this.stack,u={code:""};this.flow=u,this.vars={},this.declarations={},this.cache=new ix,this.stack=Rf();for(const c of rb)this.setBuildStage(c),u.result=e.build(this,t);return u.vars=this.getVars(this.shaderStage),this.flow=s,this.vars=r,this.declarations=n,this.cache=o,this.stack=l,this.setBuildStage(a),u}getFunctionOperator(){return null}buildFunctionCode(){console.warn("Abstract function.")}flowChildNode(e,t=null){const s=this.flow,r={code:""};return this.flow=r,r.result=e.build(this,t),this.flow=s,r}flowNodeFromShaderStage(e,t,s=null,r=null){const n=this.tab,o=this.cache,a=this.shaderStage,l=this.context;this.setShaderStage(e);const u={...this.context};delete u.nodeBlock,this.cache=this.globalCache,this.tab="	",this.context=u;let c=null;if(this.buildStage==="generate"){const d=this.flowChildNode(t,s);r!==null&&(d.code+=`${this.tab+r} = ${d.result};
`),this.flowCode[e]=this.flowCode[e]+d.code,c=d}else c=t.build(this);return this.setShaderStage(a),this.cache=o,this.tab=n,this.context=l,c}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){console.warn("Abstract function.")}getVaryings(){console.warn("Abstract function.")}getVar(e,t,s=null){return`${s!==null?this.generateArrayDeclaration(e,s):this.getType(e)} ${t}`}getVars(e){let t="";const s=this.vars[e];if(s!==void 0)for(const r of s)t+=`${this.getVar(r.type,r.name)}; `;return t}getUniforms(){console.warn("Abstract function.")}getCodes(e){const t=this.codes[e];let s="";if(t!==void 0)for(const r of t)s+=r.code+`
`;return s}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(e){this.shaderStage=e}getShaderStage(){return this.shaderStage}setBuildStage(e){this.buildStage=e}getBuildStage(){return this.buildStage}buildCode(){console.warn("Abstract function.")}get subBuild(){return this.subBuildLayers[this.subBuildLayers.length-1]||null}addSubBuild(e){this.subBuildLayers.push(e)}removeSubBuild(){return this.subBuildLayers.pop()}getClosestSubBuild(e){let t;if(e&&e.isNode?e.isShaderCallNodeInternal?t=e.shaderNode.subBuilds:e.isStackNode?t=[e.subBuild]:t=this.getDataFromNode(e,"any").subBuilds:e instanceof Set?t=[...e]:t=e,!t)return null;const s=this.subBuildLayers;for(let r=t.length-1;r>=0;r--){const n=t[r];if(s.includes(n))return n}return null}getSubBuildOutput(e){return this.getSubBuildProperty("outputNode",e)}getSubBuildProperty(e="",t=null){let s;t!==null?s=this.getClosestSubBuild(t):s=this.subBuildFn;let r;return s?r=e?s+"_"+e:s:r=e,r}build(){const{object:e,material:t,renderer:s}=this;if(t!==null){let r=s.library.fromMaterial(t);r===null&&(console.error(`NodeMaterial: Material "${t.type}" is not compatible.`),r=new pi),r.build(this)}else this.addFlow("compute",e);for(const r of rb){this.setBuildStage(r),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const n of nb){this.setShaderStage(n);const o=this.flowNodes[n];for(const a of o)r==="generate"?this.flowNode(a):a.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this.buildUpdateNodes(),this}getNodeUniform(e,t){if(t==="float"||t==="int"||t==="uint")return new Xq(e);if(t==="vec2"||t==="ivec2"||t==="uvec2")return new Yq(e);if(t==="vec3"||t==="ivec3"||t==="uvec3")return new Qq(e);if(t==="vec4"||t==="ivec4"||t==="uvec4")return new Zq(e);if(t==="color")return new Jq(e);if(t==="mat2")return new eK(e);if(t==="mat3")return new tK(e);if(t==="mat4")return new sK(e);throw new Error(`Uniform "${t}" not declared.`)}format(e,t,s){if(t=this.getVectorType(t),s=this.getVectorType(s),t===s||s===null||this.isReference(s))return e;const r=this.getTypeLength(t),n=this.getTypeLength(s);return r===16&&n===9?`${this.getType(s)}( ${e}[ 0 ].xyz, ${e}[ 1 ].xyz, ${e}[ 2 ].xyz )`:r===9&&n===4?`${this.getType(s)}( ${e}[ 0 ].xy, ${e}[ 1 ].xy )`:r>4||n>4||n===0?e:r===n?`${this.getType(s)}( ${e} )`:r>n?(e=s==="bool"?`all( ${e} )`:`${e}.${"xyz".slice(0,n)}`,this.format(e,this.getTypeFromLength(n,this.getComponentType(t)),s)):n===4&&r>1?`${this.getType(s)}( ${this.format(e,t,"vec3")}, 1.0 )`:r===2?`${this.getType(s)}( ${this.format(e,t,"vec2")}, 0.0 )`:(r===1&&n>1&&t!==this.getComponentType(s)&&(e=`${this.getType(this.getComponentType(s))}( ${e} )`),`${this.getType(s)}( ${e} )`)}getSignature(){return`// Three.js r${hm} - Node System
`}*[Symbol.iterator](){}}class nN{constructor(){this.time=0,this.deltaTime=0,this.frameId=0,this.renderId=0,this.updateMap=new WeakMap,this.updateBeforeMap=new WeakMap,this.updateAfterMap=new WeakMap,this.renderer=null,this.material=null,this.camera=null,this.object=null,this.scene=null}_getMaps(e,t){let s=e.get(t);return s===void 0&&(s={renderMap:new WeakMap,frameMap:new WeakMap},e.set(t,s)),s}updateBeforeNode(e){const t=e.getUpdateBeforeType(),s=e.updateReference(this);if(t===Kt.FRAME){const{frameMap:r}=this._getMaps(this.updateBeforeMap,s);r.get(s)!==this.frameId&&e.updateBefore(this)!==!1&&r.set(s,this.frameId)}else if(t===Kt.RENDER){const{renderMap:r}=this._getMaps(this.updateBeforeMap,s);r.get(s)!==this.renderId&&e.updateBefore(this)!==!1&&r.set(s,this.renderId)}else t===Kt.OBJECT&&e.updateBefore(this)}updateAfterNode(e){const t=e.getUpdateAfterType(),s=e.updateReference(this);if(t===Kt.FRAME){const{frameMap:r}=this._getMaps(this.updateAfterMap,s);r.get(s)!==this.frameId&&e.updateAfter(this)!==!1&&r.set(s,this.frameId)}else if(t===Kt.RENDER){const{renderMap:r}=this._getMaps(this.updateAfterMap,s);r.get(s)!==this.renderId&&e.updateAfter(this)!==!1&&r.set(s,this.renderId)}else t===Kt.OBJECT&&e.updateAfter(this)}updateNode(e){const t=e.getUpdateType(),s=e.updateReference(this);if(t===Kt.FRAME){const{frameMap:r}=this._getMaps(this.updateMap,s);r.get(s)!==this.frameId&&e.update(this)!==!1&&r.set(s,this.frameId)}else if(t===Kt.RENDER){const{renderMap:r}=this._getMaps(this.updateMap,s);r.get(s)!==this.renderId&&e.update(this)!==!1&&r.set(s,this.renderId)}else t===Kt.OBJECT&&e.update(this)}update(){this.frameId++,this.lastTime===void 0&&(this.lastTime=performance.now()),this.deltaTime=(performance.now()-this.lastTime)/1e3,this.lastTime=performance.now(),this.time+=this.deltaTime}}class Gw{constructor(e,t,s=null,r="",n=!1){this.type=e,this.name=t,this.count=s,this.qualifier=r,this.isConst=n}}Gw.isNodeFunctionInput=!0;class rK extends ou{static get type(){return"DirectionalLightNode"}constructor(e=null){super(e)}setupDirect(){const e=this.colorNode;return{lightDirection:Bw(this.light),lightColor:e}}}const rx=new cs,pf=new cs;let Cd=null;class nK extends ou{static get type(){return"RectAreaLightNode"}constructor(e=null){super(e),this.halfHeight=Et(new xe).setGroup(Rt),this.halfWidth=Et(new xe).setGroup(Rt),this.updateType=Kt.RENDER}update(e){super.update(e);const{light:t}=this,s=e.camera.matrixWorldInverse;pf.identity(),rx.copy(t.matrixWorld),rx.premultiply(s),pf.extractRotation(rx),this.halfWidth.value.set(t.width*.5,0,0),this.halfHeight.value.set(0,t.height*.5,0),this.halfWidth.value.applyMatrix4(pf),this.halfHeight.value.applyMatrix4(pf)}setupDirectRectArea(e){let t,s;e.isAvailable("float32Filterable")?(t=ts(Cd.LTC_FLOAT_1),s=ts(Cd.LTC_FLOAT_2)):(t=ts(Cd.LTC_HALF_1),s=ts(Cd.LTC_HALF_2));const{colorNode:r,light:n}=this,o=Lw(n);return{lightColor:r,lightPosition:o,halfWidth:this.halfWidth,halfHeight:this.halfHeight,ltc_1:t,ltc_2:s}}static setLTC(e){Cd=e}}class jw extends ou{static get type(){return"SpotLightNode"}constructor(e=null){super(e),this.coneCosNode=Et(0).setGroup(Rt),this.penumbraCosNode=Et(0).setGroup(Rt),this.cutoffDistanceNode=Et(0).setGroup(Rt),this.decayExponentNode=Et(0).setGroup(Rt),this.colorNode=Et(this.color).setGroup(Rt)}update(e){super.update(e);const{light:t}=this;this.coneCosNode.value=Math.cos(t.angle),this.penumbraCosNode.value=Math.cos(t.angle*(1-t.penumbra)),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}getSpotAttenuation(e,t){const{coneCosNode:s,penumbraCosNode:r}=this;return Mo(s,r,t)}getLightCoord(e){const t=e.getNodeProperties(this);let s=t.projectionUV;return s===void 0&&(s=c$(this.light,e.context.positionWorld),t.projectionUV=s),s}setupDirect(e){const{colorNode:t,cutoffDistanceNode:s,decayExponentNode:r,light:n}=this,o=this.getLightVector(e),a=o.normalize(),l=a.dot(Bw(n)),u=this.getSpotAttenuation(e,l),c=o.length(),d=zw({lightDistance:c,cutoffDistance:s,decayExponent:r});let h=t.mul(u).mul(d),p,f;return n.colorNode?(f=this.getLightCoord(e),p=n.colorNode(f)):n.map&&(f=this.getLightCoord(e),p=ts(n.map,f.xy).onRenderUpdate(()=>n.map)),p&&(h=f.mul(2).sub(1).abs().lessThan(1).all().select(h.mul(p),h)),{lightColor:h,lightDirection:a}}}class oK extends jw{static get type(){return"IESSpotLightNode"}getSpotAttenuation(e,t){const s=this.light.iesMap;let r=null;if(s&&s.isTexture===!0){const n=t.acos().mul(1/Math.PI);r=ts(s,Ge(n,0),0).r}else r=super.getSpotAttenuation(t);return r}}const aK=ge(([i,e])=>{const t=i.abs().sub(e);return _o(ni(t,0)).add(Ir(ni(t.x,t.y),0))});class lK extends jw{static get type(){return"ProjectorLightNode"}update(e){super.update(e);const t=this.light;if(this.penumbraCosNode.value=Math.min(Math.cos(t.angle*(1-t.penumbra)),.99999),t.aspect===null){let s=1;t.map!==null&&(s=t.map.width/t.map.height),t.shadow.aspect=s}else t.shadow.aspect=t.aspect}getSpotAttenuation(e){const t=this.penumbraCosNode,s=this.getLightCoord(e),r=s.xyz.div(s.w),n=aK(r.xy.sub(Ge(.5)),Ge(.5)),o=wn(-1,us(1,W0(t)).sub(1));return Z0(n.mul(-2).mul(o))}}class uK extends ou{static get type(){return"AmbientLightNode"}constructor(e=null){super(e)}setup({context:e}){e.irradiance.addAssign(this.colorNode)}}class cK extends ou{static get type(){return"HemisphereLightNode"}constructor(e=null){super(e),this.lightPositionNode=kw(e),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=Et(new gs).setGroup(Rt)}update(e){const{light:t}=this;super.update(e),this.lightPositionNode.object3d=t,this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity)}setup(e){const{colorNode:t,groundColorNode:s,lightDirectionNode:r}=this,o=Ga.dot(r).mul(.5).add(.5),a=Cs(s,t,o);e.context.irradiance.addAssign(a)}}class dK extends ou{static get type(){return"LightProbeNode"}constructor(e=null){super(e);const t=[];for(let s=0;s<9;s++)t.push(new xe);this.lightProbe=pn(t)}update(e){const{light:t}=this;super.update(e);for(let s=0;s<9;s++)this.lightProbe.array[s].copy(t.sh.coefficients[s]).multiplyScalar(t.intensity)}setup(e){const t=D$(Ga,this.lightProbe);e.context.irradiance.addAssign(t)}}class B${parseFunction(){console.warn("Abstract function.")}}class Ww{constructor(e,t,s="",r=""){this.type=e,this.inputs=t,this.name=s,this.precision=r}getCode(){console.warn("Abstract function.")}}Ww.isNodeFunction=!0;const hK=/^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,pK=/[a-z_0-9]+/ig,oN="#pragma main",fK=i=>{i=i.trim();const e=i.indexOf(oN),t=e!==-1?i.slice(e+oN.length):i,s=t.match(hK);if(s!==null&&s.length===5){const r=s[4],n=[];let o=null;for(;(o=pK.exec(r))!==null;)n.push(o);const a=[];let l=0;for(;l<n.length;){const f=n[l][0]==="const";f===!0&&l++;let m=n[l][0];m==="in"||m==="out"||m==="inout"?l++:m="";const x=n[l++][0];let g=Number.parseInt(n[l][0]);Number.isNaN(g)===!1?l++:g=null;const _=n[l++][0];a.push(new Gw(x,_,g,m,f))}const u=t.substring(s[0].length),c=s[3]!==void 0?s[3]:"",d=s[2],h=s[1]!==void 0?s[1]:"",p=e!==-1?i.slice(0,e):"";return{type:d,inputs:a,name:c,precision:h,inputsCode:r,blockCode:u,headerCode:p}}else throw new Error("FunctionNode: Function is not a GLSL code.")};class mK extends Ww{constructor(e){const{type:t,inputs:s,name:r,precision:n,inputsCode:o,blockCode:a,headerCode:l}=fK(e);super(t,s,r,n),this.inputsCode=o,this.blockCode=a,this.headerCode=l}getCode(e=this.name){let t;const s=this.blockCode;if(s!==""){const{type:r,inputsCode:n,headerCode:o,precision:a}=this;let l=`${r} ${e} ( ${n.trim()} )`;a!==""&&(l=`${a} ${l}`),t=o+l+s}else t="";return t}}class gK extends B${parseFunction(e){return new mK(e)}}const aN=new WeakMap,lo=[],El=[];class _K extends ja{constructor(e,t){super(),this.renderer=e,this.backend=t,this.nodeFrame=new nN,this.nodeBuilderCache=new Map,this.callHashCache=new Kn,this.groupsData=new Kn,this.cacheLib={}}updateGroup(e){const t=e.groupNode,s=t.name;if(s===z0.name)return!0;if(s===Rt.name){const n=this.get(e),o=this.nodeFrame.renderId;return n.renderId!==o?(n.renderId=o,!0):!1}if(s===Pk.name){const n=this.get(e),o=this.nodeFrame.frameId;return n.frameId!==o?(n.frameId=o,!0):!1}lo[0]=t,lo[1]=e;let r=this.groupsData.get(lo);return r===void 0&&this.groupsData.set(lo,r={}),lo.length=0,r.version!==t.version?(r.version=t.version,!0):!1}getForRenderCacheKey(e){return e.initialCacheKey}getForRender(e){const t=this.get(e);let s=t.nodeBuilderState;if(s===void 0){const{nodeBuilderCache:r}=this,n=this.getForRenderCacheKey(e);if(s=r.get(n),s===void 0){const o=this.backend.createNodeBuilder(e.object,this.renderer);o.scene=e.scene,o.material=e.material,o.camera=e.camera,o.context.material=e.material,o.lightsNode=e.lightsNode,o.environmentNode=this.getEnvironmentNode(e.scene),o.fogNode=this.getFogNode(e.scene),o.clippingContext=e.clippingContext,this.renderer.getOutputRenderTarget()&&this.renderer.getOutputRenderTarget().multiview&&o.enableMultiview(),o.build(),s=this._createNodeBuilderState(o),r.set(n,s)}s.usedTimes++,t.nodeBuilderState=s}return s}delete(e){if(e.isRenderObject){const t=this.get(e).nodeBuilderState;t.usedTimes--,t.usedTimes===0&&this.nodeBuilderCache.delete(this.getForRenderCacheKey(e))}return super.delete(e)}getForCompute(e){const t=this.get(e);let s=t.nodeBuilderState;if(s===void 0){const r=this.backend.createNodeBuilder(e,this.renderer);r.build(),s=this._createNodeBuilderState(r),t.nodeBuilderState=s}return s}_createNodeBuilderState(e){return new kq(e.vertexShader,e.fragmentShader,e.computeShader,e.getAttributesArray(),e.getBindings(),e.updateNodes,e.updateBeforeNodes,e.updateAfterNodes,e.observer,e.transforms)}getEnvironmentNode(e){this.updateEnvironment(e);let t=null;if(e.environmentNode&&e.environmentNode.isNode)t=e.environmentNode;else{const s=this.get(e);s.environmentNode&&(t=s.environmentNode)}return t}getBackgroundNode(e){this.updateBackground(e);let t=null;if(e.backgroundNode&&e.backgroundNode.isNode)t=e.backgroundNode;else{const s=this.get(e);s.backgroundNode&&(t=s.backgroundNode)}return t}getFogNode(e){return this.updateFog(e),e.fogNode||this.get(e).fogNode||null}getCacheKey(e,t){lo[0]=e,lo[1]=t;const s=this.renderer.info.calls,r=this.callHashCache.get(lo)||{};if(r.callId!==s){const n=this.getEnvironmentNode(e),o=this.getFogNode(e);t&&El.push(t.getCacheKey(!0)),n&&El.push(n.getCacheKey()),o&&El.push(o.getCacheKey()),El.push(this.renderer.getOutputRenderTarget()&&this.renderer.getOutputRenderTarget().multiview?1:0),El.push(this.renderer.shadowMap.enabled?1:0),r.callId=s,r.cacheKey=ym(El),this.callHashCache.set(lo,r),El.length=0}return lo.length=0,r.cacheKey}get isToneMappingState(){return!this.renderer.getRenderTarget()}updateBackground(e){const t=this.get(e),s=e.background;if(s){const r=e.backgroundBlurriness===0&&t.backgroundBlurriness>0||e.backgroundBlurriness>0&&t.backgroundBlurriness===0;if(t.background!==s||r){const n=this.getCacheNode("background",s,()=>{if(s.isCubeTexture===!0||s.mapping===l0||s.mapping===u0||s.mapping===Ox){if(e.backgroundBlurriness>0||s.mapping===Ox)return Aw(s);{let o;return s.isCubeTexture===!0?o=wc(s):o=ts(s),xO(o)}}else{if(s.isTexture===!0)return ts(s,Jo.flipY()).setUpdateMatrix(!0);s.isColor!==!0&&console.error("WebGPUNodes: Unsupported background configuration.",s)}},r);t.backgroundNode=n,t.background=s,t.backgroundBlurriness=e.backgroundBlurriness}}else t.backgroundNode&&(delete t.backgroundNode,delete t.background)}getCacheNode(e,t,s,r=!1){const n=this.cacheLib[e]||(this.cacheLib[e]=new WeakMap);let o=n.get(t);return(o===void 0||r)&&(o=s(),n.set(t,o)),o}updateFog(e){const t=this.get(e),s=e.fog;if(s){if(t.fog!==s){const r=this.getCacheNode("fog",s,()=>{if(s.isFogExp2){const n=Os("color","color",s).setGroup(Rt),o=Os("density","float",s).setGroup(Rt);return hh(n,Rw(o))}else if(s.isFog){const n=Os("color","color",s).setGroup(Rt),o=Os("near","float",s).setGroup(Rt),a=Os("far","float",s).setGroup(Rt);return hh(n,Fw(o,a))}else console.error("THREE.Renderer: Unsupported fog configuration.",s)});t.fogNode=r,t.fog=s}}else delete t.fogNode,delete t.fog}updateEnvironment(e){const t=this.get(e),s=e.environment;if(s){if(t.environment!==s){const r=this.getCacheNode("environment",s,()=>{if(s.isCubeTexture===!0)return wc(s);if(s.isTexture===!0)return ts(s);console.error("Nodes: Unsupported environment configuration.",s)});t.environmentNode=r,t.environment=s}}else t.environmentNode&&(delete t.environmentNode,delete t.environment)}getNodeFrame(e=this.renderer,t=null,s=null,r=null,n=null){const o=this.nodeFrame;return o.renderer=e,o.scene=t,o.object=s,o.camera=r,o.material=n,o}getNodeFrameForRender(e){return this.getNodeFrame(e.renderer,e.scene,e.object,e.camera,e.material)}getOutputCacheKey(){const e=this.renderer;return e.toneMapping+","+e.currentColorSpace+","+e.xr.isPresenting}hasOutputChange(e){return aN.get(e)!==this.getOutputCacheKey()}getOutputNode(e){const t=this.renderer,s=this.getOutputCacheKey(),r=e.isArrayTexture?QO(e,pe(Jo,bh("gl_ViewID_OVR"))).renderOutput(t.toneMapping,t.currentColorSpace):ts(e,Jo).renderOutput(t.toneMapping,t.currentColorSpace);return aN.set(e,s),r}updateBefore(e){const t=e.getNodeBuilderState();for(const s of t.updateBeforeNodes)this.getNodeFrameForRender(e).updateBeforeNode(s)}updateAfter(e){const t=e.getNodeBuilderState();for(const s of t.updateAfterNodes)this.getNodeFrameForRender(e).updateAfterNode(s)}updateForCompute(e){const t=this.getNodeFrame(),s=this.getForCompute(e);for(const r of s.updateNodes)t.updateNode(r)}updateForRender(e){const t=this.getNodeFrameForRender(e),s=e.getNodeBuilderState();for(const r of s.updateNodes)t.updateNode(r)}needsRefresh(e){const t=this.getNodeFrameForRender(e);return e.getMonitor().needsRefresh(e,t)}dispose(){super.dispose(),this.nodeFrame=new nN,this.nodeBuilderCache=new Map,this.cacheLib={}}}const nx=new $o;class dm{constructor(e=null){this.version=0,this.clipIntersection=null,this.cacheKey="",this.shadowPass=!1,this.viewNormalMatrix=new kr,this.clippingGroupContexts=new WeakMap,this.intersectionPlanes=[],this.unionPlanes=[],this.parentVersion=null,e!==null&&(this.viewNormalMatrix=e.viewNormalMatrix,this.clippingGroupContexts=e.clippingGroupContexts,this.shadowPass=e.shadowPass,this.viewMatrix=e.viewMatrix)}projectPlanes(e,t,s){const r=e.length;for(let n=0;n<r;n++){nx.copy(e[n]).applyMatrix4(this.viewMatrix,this.viewNormalMatrix);const o=t[s+n],a=nx.normal;o.x=-a.x,o.y=-a.y,o.z=-a.z,o.w=nx.constant}}updateGlobal(e,t){this.shadowPass=e.overrideMaterial!==null&&e.overrideMaterial.isShadowPassMaterial,this.viewMatrix=t.matrixWorldInverse,this.viewNormalMatrix.getNormalMatrix(this.viewMatrix)}update(e,t){let s=!1;e.version!==this.parentVersion&&(this.intersectionPlanes=Array.from(e.intersectionPlanes),this.unionPlanes=Array.from(e.unionPlanes),this.parentVersion=e.version),this.clipIntersection!==t.clipIntersection&&(this.clipIntersection=t.clipIntersection,this.clipIntersection?this.unionPlanes.length=e.unionPlanes.length:this.intersectionPlanes.length=e.intersectionPlanes.length);const r=t.clippingPlanes,n=r.length;let o,a;if(this.clipIntersection?(o=this.intersectionPlanes,a=e.intersectionPlanes.length):(o=this.unionPlanes,a=e.unionPlanes.length),o.length!==a+n){o.length=a+n;for(let l=0;l<n;l++)o[a+l]=new ns;s=!0}this.projectPlanes(r,o,a),s&&(this.version++,this.cacheKey=`${this.intersectionPlanes.length}:${this.unionPlanes.length}`)}getGroupContext(e){if(this.shadowPass&&!e.clipShadows)return this;let t=this.clippingGroupContexts.get(e);return t===void 0&&(t=new dm(this),this.clippingGroupContexts.set(e,t)),t.update(this,e),t}get unionClippingCount(){return this.unionPlanes.length}}class yK{constructor(e,t){this.bundleGroup=e,this.camera=t}}const Pd=[];class xK{constructor(){this.bundles=new Kn}get(e,t){const s=this.bundles;Pd[0]=e,Pd[1]=t;let r=s.get(Pd);return r===void 0&&(r=new yK(e,t),s.set(Pd,r)),Pd.length=0,r}dispose(){this.bundles=new Kn}}class O${constructor(){this.lightNodes=new WeakMap,this.materialNodes=new Map,this.toneMappingNodes=new Map}fromMaterial(e){if(e.isNodeMaterial)return e;let t=null;const s=this.getMaterialNodeClass(e.type);if(s!==null){t=new s;for(const r in e)t[r]=e[r]}return t}addToneMapping(e,t){this.addType(e,t,this.toneMappingNodes)}getToneMappingFunction(e){return this.toneMappingNodes.get(e)||null}getMaterialNodeClass(e){return this.materialNodes.get(e)||null}addMaterial(e,t){this.addType(e,t,this.materialNodes)}getLightNodeClass(e){return this.lightNodes.get(e)||null}addLight(e,t){this.addClass(e,t,this.lightNodes)}addType(e,t,s){if(s.has(t)){console.warn(`Redefinition of node ${t}`);return}if(typeof e!="function")throw new Error(`Node class ${e.name} is not a class.`);if(typeof t=="function"||typeof t=="object")throw new Error(`Base class ${t} is not a class.`);s.set(t,e)}addClass(e,t,s){if(s.has(t)){console.warn(`Redefinition of node ${t.name}`);return}if(typeof e!="function")throw new Error(`Node class ${e.name} is not a class.`);if(typeof t!="function")throw new Error(`Base class ${t.name} is not a class.`);s.set(t,e)}}const bK=new Ow,Nd=[];class wK extends Kn{constructor(){super()}createNode(e=[]){return new Ow().setLights(e)}getNode(e,t){if(e.isQuadMesh)return bK;Nd[0]=e,Nd[1]=t;let s=this.get(Nd);return s===void 0&&(s=this.createNode(),this.set(Nd,s)),Nd.length=0,s}}class Bd extends So{constructor(e=1,t=1,s={}){super(e,t,s),this.isXRRenderTarget=!0,this._hasExternalTextures=!1,this._autoAllocateDepthBuffer=!0,this._isOpaqueFramebuffer=!1}copy(e){return super.copy(e),this._hasExternalTextures=e._hasExternalTextures,this._autoAllocateDepthBuffer=e._autoAllocateDepthBuffer,this._isOpaqueFramebuffer=e._isOpaqueFramebuffer,this}}const lN=new xe,uN=new xe;class MK extends oa{constructor(e,t=!1){super(),this.enabled=!1,this.isPresenting=!1,this.cameraAutoUpdate=!0,this._renderer=e,this._cameraL=new Ar,this._cameraL.viewport=new ns,this._cameraR=new Ar,this._cameraR.viewport=new ns,this._cameras=[this._cameraL,this._cameraR],this._cameraXR=new m4,this._currentDepthNear=null,this._currentDepthFar=null,this._controllers=[],this._controllerInputSources=[],this._xrRenderTarget=null,this._layers=[],this._supportsLayers=!1,this._frameBufferTargets=null,this._createXRLayer=CK.bind(this),this._gl=null,this._currentAnimationContext=null,this._currentAnimationLoop=null,this._currentPixelRatio=null,this._currentSize=new Dt,this._onSessionEvent=SK.bind(this),this._onSessionEnd=EK.bind(this),this._onInputSourcesChange=AK.bind(this),this._onAnimationFrame=PK.bind(this),this._referenceSpace=null,this._referenceSpaceType="local-floor",this._customReferenceSpace=null,this._framebufferScaleFactor=1,this._foveation=1,this._session=null,this._glBaseLayer=null,this._glBinding=null,this._glProjLayer=null,this._xrFrame=null,this._useLayers=typeof XRWebGLBinding<"u"&&"createProjectionLayer"in XRWebGLBinding.prototype,this._useMultiviewIfPossible=t,this._useMultiview=!1}getController(e){return this._getController(e).getTargetRaySpace()}getControllerGrip(e){return this._getController(e).getGripSpace()}getHand(e){return this._getController(e).getHandSpace()}getFoveation(){if(!(this._glProjLayer===null&&this._glBaseLayer===null))return this._foveation}setFoveation(e){this._foveation=e,this._glProjLayer!==null&&(this._glProjLayer.fixedFoveation=e),this._glBaseLayer!==null&&this._glBaseLayer.fixedFoveation!==void 0&&(this._glBaseLayer.fixedFoveation=e)}getFramebufferScaleFactor(){return this._framebufferScaleFactor}setFramebufferScaleFactor(e){this._framebufferScaleFactor=e,this.isPresenting===!0&&console.warn("THREE.XRManager: Cannot change framebuffer scale while presenting.")}getReferenceSpaceType(){return this._referenceSpaceType}setReferenceSpaceType(e){this._referenceSpaceType=e,this.isPresenting===!0&&console.warn("THREE.XRManager: Cannot change reference space type while presenting.")}getReferenceSpace(){return this._customReferenceSpace||this._referenceSpace}setReferenceSpace(e){this._customReferenceSpace=e}getCamera(){return this._cameraXR}getEnvironmentBlendMode(){if(this._session!==null)return this._session.environmentBlendMode}getFrame(){return this._xrFrame}useMultiview(){return this._useMultiview}createQuadLayer(e,t,s,r,n,o,a,l={}){const u=new yc(e,t),c=new Bd(n,o,{format:fn,type:xr,depthTexture:new Hn(n,o,l.stencil?ka:_i,void 0,void 0,void 0,void 0,void 0,void 0,l.stencil?Ko:fo),stencilBuffer:l.stencil,resolveDepthBuffer:!1,resolveStencilBuffer:!1});c._autoAllocateDepthBuffer=!0;const d=new co({color:16777215,side:Wo});d.map=c.texture,d.map.offset.y=1,d.map.repeat.y=-1;const h=new bn(u,d);h.position.copy(s),h.quaternion.copy(r);const p={type:"quad",width:e,height:t,translation:s,quaternion:r,pixelwidth:n,pixelheight:o,plane:h,material:d,rendercall:a,renderTarget:c};if(this._layers.push(p),this._session!==null){p.plane.material=new co({color:16777215,side:Wo}),p.plane.material.blending=zd,p.plane.material.blendEquation=Un,p.plane.material.blendSrc=Aa,p.plane.material.blendDst=Aa,p.xrlayer=this._createXRLayer(p);const f=this._session.renderState.layers;f.unshift(p.xrlayer),this._session.updateRenderState({layers:f})}else c.isXRRenderTarget=!1;return h}createCylinderLayer(e,t,s,r,n,o,a,l,u={}){const c=new T0(e,e,e*t/s,64,64,!0,Math.PI-t/2,t),d=new Bd(o,a,{format:fn,type:xr,depthTexture:new Hn(o,a,u.stencil?ka:_i,void 0,void 0,void 0,void 0,void 0,void 0,u.stencil?Ko:fo),stencilBuffer:u.stencil,resolveDepthBuffer:!1,resolveStencilBuffer:!1});d._autoAllocateDepthBuffer=!0;const h=new co({color:16777215,side:lr});h.map=d.texture,h.map.offset.y=1,h.map.repeat.y=-1;const p=new bn(c,h);p.position.copy(r),p.quaternion.copy(n);const f={type:"cylinder",radius:e,centralAngle:t,aspectratio:s,translation:r,quaternion:n,pixelwidth:o,pixelheight:a,plane:p,material:h,rendercall:l,renderTarget:d};if(this._layers.push(f),this._session!==null){f.plane.material=new co({color:16777215,side:lr}),f.plane.material.blending=zd,f.plane.material.blendEquation=Un,f.plane.material.blendSrc=Aa,f.plane.material.blendDst=Aa,f.xrlayer=this._createXRLayer(f);const m=this._session.renderState.layers;m.unshift(f.xrlayer),this._session.updateRenderState({layers:m})}else d.isXRRenderTarget=!1;return p}renderLayers(){const e=new xe,t=new za,s=this._renderer,r=this.isPresenting,n=s.getOutputRenderTarget(),o=s._frameBufferTarget;this.isPresenting=!1;const a=new Dt;s.getSize(a);const l=s._quad;for(const u of this._layers)if(u.renderTarget.isXRRenderTarget=this._session!==null,u.renderTarget._hasExternalTextures=u.renderTarget.isXRRenderTarget,u.renderTarget.isXRRenderTarget&&this._supportsLayers){u.xrlayer.transform=new XRRigidTransform(u.plane.getWorldPosition(e),u.plane.getWorldQuaternion(t));const c=this._glBinding.getSubImage(u.xrlayer,this._xrFrame);s.backend.setXRRenderTargetTextures(u.renderTarget,c.colorTexture,void 0),s._setXRLayerSize(u.renderTarget.width,u.renderTarget.height),s.setOutputRenderTarget(u.renderTarget),s.setRenderTarget(null),s._frameBufferTarget=null,this._frameBufferTargets||(this._frameBufferTargets=new WeakMap);const{frameBufferTarget:d,quad:h}=this._frameBufferTargets.get(u.renderTarget)||{frameBufferTarget:null,quad:null};d?(s._frameBufferTarget=d,s._quad=h):(s._quad=new Gm(new pi),this._frameBufferTargets.set(u.renderTarget,{frameBufferTarget:s._getFrameBufferTarget(),quad:s._quad})),u.rendercall(),s._frameBufferTarget=null}else s.setRenderTarget(u.renderTarget),u.rendercall();s.setRenderTarget(null),s.setOutputRenderTarget(n),s._frameBufferTarget=o,s._setXRLayerSize(a.x,a.y),s._quad=l,this.isPresenting=r}getSession(){return this._session}async setSession(e){const t=this._renderer,s=t.backend;this._gl=t.getContext();const r=this._gl,n=r.getContextAttributes();if(this._session=e,e!==null){if(s.isWebGPUBackend===!0)throw new Error('THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.');if(e.addEventListener("select",this._onSessionEvent),e.addEventListener("selectstart",this._onSessionEvent),e.addEventListener("selectend",this._onSessionEvent),e.addEventListener("squeeze",this._onSessionEvent),e.addEventListener("squeezestart",this._onSessionEvent),e.addEventListener("squeezeend",this._onSessionEvent),e.addEventListener("end",this._onSessionEnd),e.addEventListener("inputsourceschange",this._onInputSourcesChange),await s.makeXRCompatible(),this._currentPixelRatio=t.getPixelRatio(),t.getSize(this._currentSize),this._currentAnimationContext=t._animation.getContext(),this._currentAnimationLoop=t._animation.getAnimationLoop(),t._animation.stop(),this._useLayers===!0){let o=null,a=null,l=null;t.depth&&(l=t.stencil?r.DEPTH24_STENCIL8:r.DEPTH_COMPONENT24,o=t.stencil?Ko:fo,a=t.stencil?ka:_i);const u={colorFormat:r.RGBA8,depthFormat:l,scaleFactor:this._framebufferScaleFactor,clearOnAccess:!1};this._useMultiviewIfPossible&&t.hasFeature("OVR_multiview2")&&(u.textureType="texture-array",this._useMultiview=!0);const c=new XRWebGLBinding(e,r),d=c.createProjectionLayer(u),h=[d];this._glBinding=c,this._glProjLayer=d,t.setPixelRatio(1),t._setXRLayerSize(d.textureWidth,d.textureHeight);const p=this._useMultiview?2:1,f=new Hn(d.textureWidth,d.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,o,p);if(this._xrRenderTarget=new Bd(d.textureWidth,d.textureHeight,{format:fn,type:xr,colorSpace:t.outputColorSpace,depthTexture:f,stencilBuffer:t.stencil,samples:n.antialias?4:0,resolveDepthBuffer:d.ignoreDepthValues===!1,resolveStencilBuffer:d.ignoreDepthValues===!1,depth:this._useMultiview?2:1,multiview:this._useMultiview}),this._xrRenderTarget._hasExternalTextures=!0,this._xrRenderTarget.depth=this._useMultiview?2:1,this._supportsLayers=e.enabledFeatures.includes("layers"),this._referenceSpace=await e.requestReferenceSpace(this.getReferenceSpaceType()),this._supportsLayers)for(const m of this._layers)m.plane.material=new co({color:16777215,side:m.type==="cylinder"?lr:Wo}),m.plane.material.blending=zd,m.plane.material.blendEquation=Un,m.plane.material.blendSrc=Aa,m.plane.material.blendDst=Aa,m.xrlayer=this._createXRLayer(m),h.unshift(m.xrlayer);e.updateRenderState({layers:h})}else{const o={antialias:t.samples>0,alpha:!0,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:this.getFramebufferScaleFactor()},a=new XRWebGLLayer(e,r,o);this._glBaseLayer=a,e.updateRenderState({baseLayer:a}),t.setPixelRatio(1),t._setXRLayerSize(a.framebufferWidth,a.framebufferHeight),this._xrRenderTarget=new Bd(a.framebufferWidth,a.framebufferHeight,{format:fn,type:xr,colorSpace:t.outputColorSpace,stencilBuffer:t.stencil,resolveDepthBuffer:a.ignoreDepthValues===!1,resolveStencilBuffer:a.ignoreDepthValues===!1}),this._xrRenderTarget._isOpaqueFramebuffer=!0,this._referenceSpace=await e.requestReferenceSpace(this.getReferenceSpaceType())}this.setFoveation(this.getFoveation()),t._animation.setAnimationLoop(this._onAnimationFrame),t._animation.setContext(e),t._animation.start(),this.isPresenting=!0,this.dispatchEvent({type:"sessionstart"})}}updateCamera(e){const t=this._session;if(t===null)return;const s=e.near,r=e.far,n=this._cameraXR,o=this._cameraL,a=this._cameraR;n.near=a.near=o.near=s,n.far=a.far=o.far=r,n.isMultiViewCamera=this._useMultiview,(this._currentDepthNear!==n.near||this._currentDepthFar!==n.far)&&(t.updateRenderState({depthNear:n.near,depthFar:n.far}),this._currentDepthNear=n.near,this._currentDepthFar=n.far),o.layers.mask=e.layers.mask|2,a.layers.mask=e.layers.mask|4,n.layers.mask=o.layers.mask|a.layers.mask;const l=e.parent,u=n.cameras;cN(n,l);for(let c=0;c<u.length;c++)cN(u[c],l);u.length===2?TK(n,o,a):n.projectionMatrix.copy(o.projectionMatrix),vK(e,n,l)}_getController(e){let t=this._controllers[e];return t===void 0&&(t=new GU,this._controllers[e]=t),t}}function TK(i,e,t){lN.setFromMatrixPosition(e.matrixWorld),uN.setFromMatrixPosition(t.matrixWorld);const s=lN.distanceTo(uN),r=e.projectionMatrix.elements,n=t.projectionMatrix.elements,o=r[14]/(r[10]-1),a=r[14]/(r[10]+1),l=(r[9]+1)/r[5],u=(r[9]-1)/r[5],c=(r[8]-1)/r[0],d=(n[8]+1)/n[0],h=o*c,p=o*d,f=s/(-c+d),m=f*-c;if(e.matrixWorld.decompose(i.position,i.quaternion,i.scale),i.translateX(m),i.translateZ(f),i.matrixWorld.compose(i.position,i.quaternion,i.scale),i.matrixWorldInverse.copy(i.matrixWorld).invert(),r[10]===-1)i.projectionMatrix.copy(e.projectionMatrix),i.projectionMatrixInverse.copy(e.projectionMatrixInverse);else{const x=o+f,g=a+f,_=h-m,S=p+(s-m),M=l*a/g*x,w=u*a/g*x;i.projectionMatrix.makePerspective(_,S,M,w,x,g),i.projectionMatrixInverse.copy(i.projectionMatrix).invert()}}function cN(i,e){e===null?i.matrixWorld.copy(i.matrix):i.matrixWorld.multiplyMatrices(e.matrixWorld,i.matrix),i.matrixWorldInverse.copy(i.matrixWorld).invert()}function vK(i,e,t){t===null?i.matrix.copy(e.matrixWorld):(i.matrix.copy(t.matrixWorld),i.matrix.invert(),i.matrix.multiply(e.matrixWorld)),i.matrix.decompose(i.position,i.quaternion,i.scale),i.updateMatrixWorld(!0),i.projectionMatrix.copy(e.projectionMatrix),i.projectionMatrixInverse.copy(e.projectionMatrixInverse),i.isPerspectiveCamera&&(i.fov=_c*2*Math.atan(1/i.projectionMatrix.elements[5]),i.zoom=1)}function SK(i){const e=this._controllerInputSources.indexOf(i.inputSource);if(e===-1)return;const t=this._controllers[e];if(t!==void 0){const s=this.getReferenceSpace();t.update(i.inputSource,i.frame,s),t.dispatchEvent({type:i.type,data:i.inputSource})}}function EK(){const i=this._session,e=this._renderer;i.removeEventListener("select",this._onSessionEvent),i.removeEventListener("selectstart",this._onSessionEvent),i.removeEventListener("selectend",this._onSessionEvent),i.removeEventListener("squeeze",this._onSessionEvent),i.removeEventListener("squeezestart",this._onSessionEvent),i.removeEventListener("squeezeend",this._onSessionEvent),i.removeEventListener("end",this._onSessionEnd),i.removeEventListener("inputsourceschange",this._onInputSourcesChange);for(let t=0;t<this._controllers.length;t++){const s=this._controllerInputSources[t];s!==null&&(this._controllerInputSources[t]=null,this._controllers[t].disconnect(s))}if(this._currentDepthNear=null,this._currentDepthFar=null,e._resetXRState(),this._session=null,this._xrRenderTarget=null,this._supportsLayers===!0)for(const t of this._layers)t.renderTarget=new Bd(t.pixelwidth,t.pixelheight,{format:fn,type:xr,depthTexture:new Hn(t.pixelwidth,t.pixelheight,t.stencilBuffer?ka:_i,void 0,void 0,void 0,void 0,void 0,void 0,t.stencilBuffer?Ko:fo),stencilBuffer:t.stencilBuffer,resolveDepthBuffer:!1,resolveStencilBuffer:!1}),t.renderTarget.isXRRenderTarget=!1,t.plane.material=t.material,t.material.map=t.renderTarget.texture,t.material.map.offset.y=1,t.material.map.repeat.y=-1,delete t.xrlayer;this.isPresenting=!1,this._useMultiview=!1,e._animation.stop(),e._animation.setAnimationLoop(this._currentAnimationLoop),e._animation.setContext(this._currentAnimationContext),e._animation.start(),e.setPixelRatio(this._currentPixelRatio),e.setSize(this._currentSize.width,this._currentSize.height,!1),this.dispatchEvent({type:"sessionend"})}function AK(i){const e=this._controllers,t=this._controllerInputSources;for(let s=0;s<i.removed.length;s++){const r=i.removed[s],n=t.indexOf(r);n>=0&&(t[n]=null,e[n].disconnect(r))}for(let s=0;s<i.added.length;s++){const r=i.added[s];let n=t.indexOf(r);if(n===-1){for(let a=0;a<e.length;a++)if(a>=t.length){t.push(r),n=a;break}else if(t[a]===null){t[a]=r,n=a;break}if(n===-1)break}const o=e[n];o&&o.connect(r)}}function CK(i){return i.type==="quad"?this._glBinding.createQuadLayer({transform:new XRRigidTransform(i.translation,i.quaternion),width:i.width/2,height:i.height/2,space:this._referenceSpace,viewPixelWidth:i.pixelwidth,viewPixelHeight:i.pixelheight,clearOnAccess:!1}):this._glBinding.createCylinderLayer({transform:new XRRigidTransform(i.translation,i.quaternion),radius:i.radius,centralAngle:i.centralAngle,aspectRatio:i.aspectRatio,space:this._referenceSpace,viewPixelWidth:i.pixelwidth,viewPixelHeight:i.pixelheight,clearOnAccess:!1})}function PK(i,e){if(e===void 0)return;const t=this._cameraXR,s=this._renderer,r=s.backend,n=this._glBaseLayer,o=this.getReferenceSpace(),a=e.getViewerPose(o);if(this._xrFrame=e,a!==null){const l=a.views;this._glBaseLayer!==null&&r.setXRTarget(n.framebuffer);let u=!1;l.length!==t.cameras.length&&(t.cameras.length=0,u=!0);for(let c=0;c<l.length;c++){const d=l[c];let h;if(this._useLayers===!0){const f=this._glBinding.getViewSubImage(this._glProjLayer,d);h=f.viewport,c===0&&r.setXRRenderTargetTextures(this._xrRenderTarget,f.colorTexture,this._glProjLayer.ignoreDepthValues&&!this._useMultiview?void 0:f.depthStencilTexture)}else h=n.getViewport(d);let p=this._cameras[c];p===void 0&&(p=new Ar,p.layers.enable(c),p.viewport=new ns,this._cameras[c]=p),p.matrix.fromArray(d.transform.matrix),p.matrix.decompose(p.position,p.quaternion,p.scale),p.projectionMatrix.fromArray(d.projectionMatrix),p.projectionMatrixInverse.copy(p.projectionMatrix).invert(),p.viewport.set(h.x,h.y,h.width,h.height),c===0&&(t.matrix.copy(p.matrix),t.matrix.decompose(t.position,t.quaternion,t.scale)),u===!0&&t.cameras.push(p)}s.setOutputRenderTarget(this._xrRenderTarget)}for(let l=0;l<this._controllers.length;l++){const u=this._controllerInputSources[l],c=this._controllers[l];u!==null&&c!==void 0&&c.update(u,e,o)}this._currentAnimationLoop&&this._currentAnimationLoop(i,e),e.detectedPlanes&&this.dispatchEvent({type:"planesdetected",data:e}),this._xrFrame=null}const dN=new mh,ff=new Dt,ox=new ns,ax=new w0,lx=new M0,mf=new cs,Sa=new ns;class NK{constructor(e,t={}){this.isRenderer=!0;const{logarithmicDepthBuffer:s=!1,alpha:r=!0,depth:n=!0,stencil:o=!1,antialias:a=!1,samples:l=0,getFallback:u=null,colorBufferType:c=Cr,multiview:d=!1}=t;this.domElement=e.getDomElement(),this.backend=e,this.samples=l||a===!0?4:0,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.alpha=r,this.logarithmicDepthBuffer=s,this.outputColorSpace=jr,this.toneMapping=nc,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=n,this.stencil=o,this.info=new D8,this.overrideNodes={modelViewMatrix:null,modelNormalViewMatrix:null},this.library=new O$,this.lighting=new wK,this._getFallback=u,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new ns(0,0,this._width,this._height),this._scissor=new ns(0,0,this._width,this._height),this._scissorTest=!1,this._attributes=null,this._geometries=null,this._nodes=null,this._animation=null,this._bindings=null,this._objects=null,this._pipelines=null,this._bundles=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._quad=new Gm(new pi),this._quad.material.name="Renderer_output",this._currentRenderContext=null,this._opaqueSort=null,this._transparentSort=null,this._frameBufferTarget=null;const h=this.alpha===!0?0:1;this._clearColor=new Cw(0,0,0,h),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._activeCubeFace=0,this._activeMipmapLevel=0,this._outputRenderTarget=null,this._mrt=null,this._renderObjectFunction=null,this._currentRenderObjectFunction=null,this._currentRenderBundle=null,this._handleObjectFunction=this._renderObjectDirect,this._isDeviceLost=!1,this.onDeviceLost=this._onDeviceLost,this._colorBufferType=c,this._initialized=!1,this._initPromise=null,this._compilationPromises=null,this.transparent=!0,this.opaque=!0,this.shadowMap={enabled:!1,type:TV},this.xr=new MK(this,d),this.debug={checkShaderErrors:!0,onShaderError:null,getShaderAsync:async(p,f,m)=>{await this.compileAsync(p,f);const x=this._renderLists.get(p,f),g=this._renderContexts.get(p,f,this._renderTarget),_=p.overrideMaterial||m.material,S=this._objects.get(m,_,p,f,x.lightsNode,g,g.clippingContext),{fragmentShader:M,vertexShader:w}=S.getNodeBuilderState();return{fragmentShader:M,vertexShader:w}}}}async init(){if(this._initialized)throw new Error("Renderer: Backend has already been initialized.");return this._initPromise!==null?this._initPromise:(this._initPromise=new Promise(async(e,t)=>{let s=this.backend;try{await s.init(this)}catch(r){if(this._getFallback!==null)try{this.backend=s=this._getFallback(r),await s.init(this)}catch(n){t(n);return}else{t(r);return}}this._nodes=new _K(this,s),this._animation=new S8(this._nodes,this.info),this._attributes=new R8(s),this._background=new Iq(this,this._nodes),this._geometries=new I8(this._attributes,this.info),this._textures=new X8(this,s,this.info),this._pipelines=new O8(s,this._nodes),this._bindings=new $8(s,this._nodes,this._textures,this._attributes,this._pipelines,this.info),this._objects=new P8(this,this._nodes,this._geometries,this._pipelines,this._bindings,this.info),this._renderLists=new U8(this.lighting),this._bundles=new xK,this._renderContexts=new q8,this._animation.start(),this._initialized=!0,e(this)}),this._initPromise)}get coordinateSystem(){return this.backend.coordinateSystem}async compileAsync(e,t,s=null){if(this._isDeviceLost===!0)return;this._initialized===!1&&await this.init();const r=this._nodes.nodeFrame,n=r.renderId,o=this._currentRenderContext,a=this._currentRenderObjectFunction,l=this._compilationPromises,u=e.isScene===!0?e:dN;s===null&&(s=e);const c=this._renderTarget,d=this._renderContexts.get(s,t,c),h=this._activeMipmapLevel,p=[];this._currentRenderContext=d,this._currentRenderObjectFunction=this.renderObject,this._handleObjectFunction=this._createObjectPipeline,this._compilationPromises=p,r.renderId++,r.update(),d.depth=this.depth,d.stencil=this.stencil,d.clippingContext||(d.clippingContext=new dm),d.clippingContext.updateGlobal(u,t),u.onBeforeRender(this,e,t,c);const f=this._renderLists.get(e,t);if(f.begin(),this._projectObject(e,t,0,f,d.clippingContext),s!==e&&s.traverseVisible(function(S){S.isLight&&S.layers.test(t.layers)&&f.pushLight(S)}),f.finish(),c!==null){this._textures.updateRenderTarget(c,h);const S=this._textures.get(c);d.textures=S.textures,d.depthTexture=S.depthTexture}else d.textures=null,d.depthTexture=null;this._background.update(u,f,d);const m=f.opaque,x=f.transparent,g=f.transparentDoublePass,_=f.lightsNode;this.opaque===!0&&m.length>0&&this._renderObjects(m,t,u,_),this.transparent===!0&&x.length>0&&this._renderTransparents(x,g,t,u,_),r.renderId=n,this._currentRenderContext=o,this._currentRenderObjectFunction=a,this._compilationPromises=l,this._handleObjectFunction=this._renderObjectDirect,await Promise.all(p)}async renderAsync(e,t){this._initialized===!1&&await this.init(),this._renderScene(e,t)}async waitForGPU(){await this.backend.waitForGPU()}set highPrecision(e){e===!0?(this.overrideNodes.modelViewMatrix=db,this.overrideNodes.modelNormalViewMatrix=hb):this.highPrecision&&(this.overrideNodes.modelViewMatrix=null,this.overrideNodes.modelNormalViewMatrix=null)}get highPrecision(){return this.overrideNodes.modelViewMatrix===db&&this.overrideNodes.modelNormalViewMatrix===hb}setMRT(e){return this._mrt=e,this}getMRT(){return this._mrt}getColorBufferType(){return this._colorBufferType}_onDeviceLost(e){let t=`THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;e.reason&&(t+=`
Reason: ${e.reason}`),console.error(t),this._isDeviceLost=!0}_renderBundle(e,t,s){const{bundleGroup:r,camera:n,renderList:o}=e,a=this._currentRenderContext,l=this._bundles.get(r,n),u=this.backend.get(l);u.renderContexts===void 0&&(u.renderContexts=new Set);const c=r.version!==u.version,d=u.renderContexts.has(a)===!1||c;if(u.renderContexts.add(a),d){this.backend.beginBundle(a),(u.renderObjects===void 0||c)&&(u.renderObjects=[]),this._currentRenderBundle=l;const{transparentDoublePass:h,transparent:p,opaque:f}=o;this.opaque===!0&&f.length>0&&this._renderObjects(f,n,t,s),this.transparent===!0&&p.length>0&&this._renderTransparents(p,h,n,t,s),this._currentRenderBundle=null,this.backend.finishBundle(a,l),u.version=r.version}else{const{renderObjects:h}=u;for(let p=0,f=h.length;p<f;p++){const m=h[p];this._nodes.needsRefresh(m)&&(this._nodes.updateBefore(m),this._nodes.updateForRender(m),this._bindings.updateForRender(m),this._nodes.updateAfter(m))}}this.backend.addBundle(a,l)}render(e,t){if(this._initialized===!1)return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."),this.renderAsync(e,t);this._renderScene(e,t)}_getFrameBufferTarget(){const{currentToneMapping:e,currentColorSpace:t}=this;if(e!==nc===!1&&t!==Ul===!1)return null;const{width:n,height:o}=this.getDrawingBufferSize(ff),{depth:a,stencil:l}=this;let u=this._frameBufferTarget;u===null&&(u=new So(n,o,{depthBuffer:a,stencilBuffer:l,type:this._colorBufferType,format:fn,colorSpace:Ul,generateMipmaps:!1,minFilter:wr,magFilter:wr,samples:this.samples}),u.isPostProcessingRenderTarget=!0,this._frameBufferTarget=u);const c=this.getOutputRenderTarget();return u.depthBuffer=a,u.stencilBuffer=l,c!==null?u.setSize(c.width,c.height,c.depth):u.setSize(n,o,1),u.viewport.copy(this._viewport),u.scissor.copy(this._scissor),u.viewport.multiplyScalar(this._pixelRatio),u.scissor.multiplyScalar(this._pixelRatio),u.scissorTest=this._scissorTest,u.multiview=c!==null?c.multiview:!1,u.resolveDepthBuffer=c!==null?c.resolveDepthBuffer:!0,u._autoAllocateDepthBuffer=c!==null?c._autoAllocateDepthBuffer:!1,u}_renderScene(e,t,s=!0){if(this._isDeviceLost===!0)return;const r=s?this._getFrameBufferTarget():null,n=this._nodes.nodeFrame,o=n.renderId,a=this._currentRenderContext,l=this._currentRenderObjectFunction,u=e.isScene===!0?e:dN,c=this._renderTarget||this._outputRenderTarget,d=this._activeCubeFace,h=this._activeMipmapLevel;let p;r!==null?(p=r,this.setRenderTarget(p)):p=c;const f=this._renderContexts.get(e,t,p);this._currentRenderContext=f,this._currentRenderObjectFunction=this._renderObjectFunction||this.renderObject,this.info.calls++,this.info.render.calls++,this.info.render.frameCalls++,n.renderId=this.info.calls;const m=this.coordinateSystem,x=this.xr;if(t.coordinateSystem!==m&&x.isPresenting===!1&&(t.coordinateSystem=m,t.updateProjectionMatrix(),t.isArrayCamera))for(const L of t.cameras)L.coordinateSystem=m,L.updateProjectionMatrix();e.matrixWorldAutoUpdate===!0&&e.updateMatrixWorld(),t.parent===null&&t.matrixWorldAutoUpdate===!0&&t.updateMatrixWorld(),x.enabled===!0&&x.isPresenting===!0&&(x.cameraAutoUpdate===!0&&x.updateCamera(t),t=x.getCamera());let g=this._viewport,_=this._scissor,S=this._pixelRatio;p!==null&&(g=p.viewport,_=p.scissor,S=1),this.getDrawingBufferSize(ff),ox.set(0,0,ff.width,ff.height);const M=g.minDepth===void 0?0:g.minDepth,w=g.maxDepth===void 0?1:g.maxDepth;f.viewportValue.copy(g).multiplyScalar(S).floor(),f.viewportValue.width>>=h,f.viewportValue.height>>=h,f.viewportValue.minDepth=M,f.viewportValue.maxDepth=w,f.viewport=f.viewportValue.equals(ox)===!1,f.scissorValue.copy(_).multiplyScalar(S).floor(),f.scissor=this._scissorTest&&f.scissorValue.equals(ox)===!1,f.scissorValue.width>>=h,f.scissorValue.height>>=h,f.clippingContext||(f.clippingContext=new dm),f.clippingContext.updateGlobal(u,t),u.onBeforeRender(this,e,t,p);const v=t.isArrayCamera?lx:ax;t.isArrayCamera||(mf.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),v.setFromProjectionMatrix(mf,m));const T=this._renderLists.get(e,t);if(T.begin(),this._projectObject(e,t,0,T,f.clippingContext),T.finish(),this.sortObjects===!0&&T.sort(this._opaqueSort,this._transparentSort),p!==null){this._textures.updateRenderTarget(p,h);const L=this._textures.get(p);f.textures=L.textures,f.depthTexture=L.depthTexture,f.width=L.width,f.height=L.height,f.renderTarget=p,f.depth=p.depthBuffer,f.stencil=p.stencilBuffer}else f.textures=null,f.depthTexture=null,f.width=this.domElement.width,f.height=this.domElement.height,f.depth=this.depth,f.stencil=this.stencil;f.width>>=h,f.height>>=h,f.activeCubeFace=d,f.activeMipmapLevel=h,f.occlusionQueryCount=T.occlusionQueryCount,this._background.update(u,T,f),f.camera=t,this.backend.beginRender(f);const{bundles:E,lightsNode:F,transparentDoublePass:I,transparent:z,opaque:G}=T;return E.length>0&&this._renderBundles(E,u,F),this.opaque===!0&&G.length>0&&this._renderObjects(G,t,u,F),this.transparent===!0&&z.length>0&&this._renderTransparents(z,I,t,u,F),this.backend.finishRender(f),n.renderId=o,this._currentRenderContext=a,this._currentRenderObjectFunction=l,r!==null&&(this.setRenderTarget(c,d,h),this._renderOutput(p)),u.onAfterRender(this,e,t,p),f}_setXRLayerSize(e,t){this._width=e,this._height=t,this.setViewport(0,0,e,t)}_renderOutput(e){const t=this._quad;this._nodes.hasOutputChange(e.texture)&&(t.material.fragmentNode=this._nodes.getOutputNode(e.texture),t.material.needsUpdate=!0);const s=this.autoClear,r=this.xr.enabled;this.autoClear=!1,this.xr.enabled=!1,this._renderScene(t,t.camera,!1),this.autoClear=s,this.xr.enabled=r}getMaxAnisotropy(){return this.backend.getMaxAnisotropy()}getActiveCubeFace(){return this._activeCubeFace}getActiveMipmapLevel(){return this._activeMipmapLevel}async setAnimationLoop(e){this._initialized===!1&&await this.init(),this._animation.setAnimationLoop(e)}async getArrayBufferAsync(e){return await this.backend.getArrayBufferAsync(e)}getContext(){return this.backend.getContext()}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(e){return e.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(e){return e.set(this._width,this._height)}setPixelRatio(e=1){this._pixelRatio!==e&&(this._pixelRatio=e,this.setSize(this._width,this._height,!1))}setDrawingBufferSize(e,t,s){this.xr&&this.xr.isPresenting||(this._width=e,this._height=t,this._pixelRatio=s,this.domElement.width=Math.floor(e*s),this.domElement.height=Math.floor(t*s),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize())}setSize(e,t,s=!0){this.xr&&this.xr.isPresenting||(this._width=e,this._height=t,this.domElement.width=Math.floor(e*this._pixelRatio),this.domElement.height=Math.floor(t*this._pixelRatio),s===!0&&(this.domElement.style.width=e+"px",this.domElement.style.height=t+"px"),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize())}setOpaqueSort(e){this._opaqueSort=e}setTransparentSort(e){this._transparentSort=e}getScissor(e){const t=this._scissor;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e}setScissor(e,t,s,r){const n=this._scissor;e.isVector4?n.copy(e):n.set(e,t,s,r)}getScissorTest(){return this._scissorTest}setScissorTest(e){this._scissorTest=e,this.backend.setScissorTest(e)}getViewport(e){return e.copy(this._viewport)}setViewport(e,t,s,r,n=0,o=1){const a=this._viewport;e.isVector4?a.copy(e):a.set(e,t,s,r),a.minDepth=n,a.maxDepth=o}getClearColor(e){return e.copy(this._clearColor)}setClearColor(e,t=1){this._clearColor.set(e),this._clearColor.a=t}getClearAlpha(){return this._clearColor.a}setClearAlpha(e){this._clearColor.a=e}getClearDepth(){return this._clearDepth}setClearDepth(e){this._clearDepth=e}getClearStencil(){return this._clearStencil}setClearStencil(e){this._clearStencil=e}isOccluded(e){const t=this._currentRenderContext;return t&&this.backend.isOccluded(t,e)}clear(e=!0,t=!0,s=!0){if(this._initialized===!1)return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."),this.clearAsync(e,t,s);const r=this._renderTarget||this._getFrameBufferTarget();let n=null;if(r!==null){this._textures.updateRenderTarget(r);const o=this._textures.get(r);n=this._renderContexts.getForClear(r),n.textures=o.textures,n.depthTexture=o.depthTexture,n.width=o.width,n.height=o.height,n.renderTarget=r,n.depth=r.depthBuffer,n.stencil=r.stencilBuffer,n.clearColorValue=this.backend.getClearColor(),n.activeCubeFace=this.getActiveCubeFace(),n.activeMipmapLevel=this.getActiveMipmapLevel()}this.backend.clear(e,t,s,n),r!==null&&this._renderTarget===null&&this._renderOutput(r)}clearColor(){return this.clear(!0,!1,!1)}clearDepth(){return this.clear(!1,!0,!1)}clearStencil(){return this.clear(!1,!1,!0)}async clearAsync(e=!0,t=!0,s=!0){this._initialized===!1&&await this.init(),this.clear(e,t,s)}async clearColorAsync(){this.clearAsync(!0,!1,!1)}async clearDepthAsync(){this.clearAsync(!1,!0,!1)}async clearStencilAsync(){this.clearAsync(!1,!1,!0)}get currentToneMapping(){return this.isOutputTarget?this.toneMapping:nc}get currentColorSpace(){return this.isOutputTarget?this.outputColorSpace:Ul}get isOutputTarget(){return this._renderTarget===this._outputRenderTarget||this._renderTarget===null}dispose(){this.info.dispose(),this.backend.dispose(),this._animation.dispose(),this._objects.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),this._frameBufferTarget!==null&&this._frameBufferTarget.dispose(),Object.values(this.backend.timestampQueryPool).forEach(e=>{e!==null&&e.dispose()}),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(e,t=0,s=0){this._renderTarget=e,this._activeCubeFace=t,this._activeMipmapLevel=s}getRenderTarget(){return this._renderTarget}setOutputRenderTarget(e){this._outputRenderTarget=e}getOutputRenderTarget(){return this._outputRenderTarget}_resetXRState(){this.backend.setXRTarget(null),this.setOutputRenderTarget(null),this.setRenderTarget(null),this._frameBufferTarget.dispose(),this._frameBufferTarget=null}setRenderObjectFunction(e){this._renderObjectFunction=e}getRenderObjectFunction(){return this._renderObjectFunction}compute(e){if(this._isDeviceLost===!0)return;if(this._initialized===!1)return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."),this.computeAsync(e);const t=this._nodes.nodeFrame,s=t.renderId;this.info.calls++,this.info.compute.calls++,this.info.compute.frameCalls++,t.renderId=this.info.calls;const r=this.backend,n=this._pipelines,o=this._bindings,a=this._nodes,l=Array.isArray(e)?e:[e];if(l[0]===void 0||l[0].isComputeNode!==!0)throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");r.beginCompute(e);for(const u of l){if(n.has(u)===!1){const h=()=>{u.removeEventListener("dispose",h),n.delete(u),o.delete(u),a.delete(u)};u.addEventListener("dispose",h);const p=u.onInitFunction;p!==null&&p.call(u,{renderer:this})}a.updateForCompute(u),o.updateForCompute(u);const c=o.getForCompute(u),d=n.getForCompute(u,c);r.compute(e,u,c,d)}r.finishCompute(e),t.renderId=s}async computeAsync(e){this._initialized===!1&&await this.init(),this.compute(e)}async hasFeatureAsync(e){return this._initialized===!1&&await this.init(),this.backend.hasFeature(e)}async resolveTimestampsAsync(e="render"){return this._initialized===!1&&await this.init(),this.backend.resolveTimestampsAsync(e)}hasFeature(e){return this._initialized===!1?(console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."),!1):this.backend.hasFeature(e)}hasInitialized(){return this._initialized}async initTextureAsync(e){this._initialized===!1&&await this.init(),this._textures.updateTexture(e)}initTexture(e){this._initialized===!1&&console.warn("THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead."),this._textures.updateTexture(e)}copyFramebufferToTexture(e,t=null){if(t!==null)if(t.isVector2)t=Sa.set(t.x,t.y,e.image.width,e.image.height).floor();else if(t.isVector4)t=Sa.copy(t).floor();else{console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");return}else t=Sa.set(0,0,e.image.width,e.image.height);let s=this._currentRenderContext,r;s!==null?r=s.renderTarget:(r=this._renderTarget||this._getFrameBufferTarget(),r!==null&&(this._textures.updateRenderTarget(r),s=this._textures.get(r))),this._textures.updateTexture(e,{renderTarget:r}),this.backend.copyFramebufferToTexture(e,s,t)}copyTextureToTexture(e,t,s=null,r=null,n=0,o=0){this._textures.updateTexture(e),this._textures.updateTexture(t),this.backend.copyTextureToTexture(e,t,s,r,n,o)}async readRenderTargetPixelsAsync(e,t,s,r,n,o=0,a=0){return this.backend.copyTextureToBuffer(e.textures[o],t,s,r,n,a)}_projectObject(e,t,s,r,n){if(e.visible===!1)return;if(e.layers.test(t.layers)){if(e.isGroup)s=e.renderOrder,e.isClippingGroup&&e.enabled&&(n=n.getGroupContext(e));else if(e.isLOD)e.autoUpdate===!0&&e.update(t);else if(e.isLight)r.pushLight(e);else if(e.isSprite){const l=t.isArrayCamera?lx:ax;if(!e.frustumCulled||l.intersectsSprite(e,t)){this.sortObjects===!0&&Sa.setFromMatrixPosition(e.matrixWorld).applyMatrix4(mf);const{geometry:u,material:c}=e;c.visible&&r.push(e,u,c,s,Sa.z,null,n)}}else if(e.isLineLoop)console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");else if(e.isMesh||e.isLine||e.isPoints){const l=t.isArrayCamera?lx:ax;if(!e.frustumCulled||l.intersectsObject(e,t)){const{geometry:u,material:c}=e;if(this.sortObjects===!0&&(u.boundingSphere===null&&u.computeBoundingSphere(),Sa.copy(u.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(mf)),Array.isArray(c)){const d=u.groups;for(let h=0,p=d.length;h<p;h++){const f=d[h],m=c[f.materialIndex];m&&m.visible&&r.push(e,u,m,s,Sa.z,f,n)}}else c.visible&&r.push(e,u,c,s,Sa.z,null,n)}}}if(e.isBundleGroup===!0&&this.backend.beginBundle!==void 0){const l=r;r=this._renderLists.get(e,t),r.begin(),l.pushBundle({bundleGroup:e,camera:t,renderList:r}),r.finish()}const a=e.children;for(let l=0,u=a.length;l<u;l++)this._projectObject(a[l],t,s,r,n)}_renderBundles(e,t,s){for(const r of e)this._renderBundle(r,t,s)}_renderTransparents(e,t,s,r,n){if(t.length>0){for(const{material:o}of t)o.side=lr;this._renderObjects(t,s,r,n,"backSide");for(const{material:o}of t)o.side=Wo;this._renderObjects(e,s,r,n);for(const{material:o}of t)o.side=Da}else this._renderObjects(e,s,r,n)}_renderObjects(e,t,s,r,n=null){for(let o=0,a=e.length;o<a;o++){const{object:l,geometry:u,material:c,group:d,clippingContext:h}=e[o];this._currentRenderObjectFunction(l,s,t,u,c,d,r,h,n)}}renderObject(e,t,s,r,n,o,a,l=null,u=null){let c,d,h;if(e.onBeforeRender(this,t,s,r,n,o),n.allowOverride===!0&&t.overrideMaterial!==null){const p=t.overrideMaterial;n.positionNode&&n.positionNode.isNode&&(c=p.positionNode,p.positionNode=n.positionNode),p.alphaTest=n.alphaTest,p.alphaMap=n.alphaMap,p.transparent=n.transparent||n.transmission>0,p.isShadowPassMaterial&&(p.side=n.shadowSide===null?n.side:n.shadowSide,n.depthNode&&n.depthNode.isNode&&(h=p.depthNode,p.depthNode=n.depthNode),n.castShadowNode&&n.castShadowNode.isNode&&(d=p.colorNode,p.colorNode=n.castShadowNode),n.castShadowPositionNode&&n.castShadowPositionNode.isNode&&(c=p.positionNode,p.positionNode=n.castShadowPositionNode)),n=p}n.transparent===!0&&n.side===Da&&n.forceSinglePass===!1?(n.side=lr,this._handleObjectFunction(e,n,t,s,a,o,l,"backSide"),n.side=Wo,this._handleObjectFunction(e,n,t,s,a,o,l,u),n.side=Da):this._handleObjectFunction(e,n,t,s,a,o,l,u),c!==void 0&&(t.overrideMaterial.positionNode=c),h!==void 0&&(t.overrideMaterial.depthNode=h),d!==void 0&&(t.overrideMaterial.colorNode=d),e.onAfterRender(this,t,s,r,n,o)}_renderObjectDirect(e,t,s,r,n,o,a,l){const u=this._objects.get(e,t,s,r,n,this._currentRenderContext,a,l);u.drawRange=e.geometry.drawRange,u.group=o;const c=this._nodes.needsRefresh(u);c&&(this._nodes.updateBefore(u),this._geometries.updateForRender(u),this._nodes.updateForRender(u),this._bindings.updateForRender(u)),this._pipelines.updateForRender(u),this._currentRenderBundle!==null&&(this.backend.get(this._currentRenderBundle).renderObjects.push(u),u.bundle=this._currentRenderBundle.bundleGroup),this.backend.draw(u,this.info),c&&this._nodes.updateAfter(u)}_createObjectPipeline(e,t,s,r,n,o,a,l){const u=this._objects.get(e,t,s,r,n,this._currentRenderContext,a,l);u.drawRange=e.geometry.drawRange,u.group=o,this._nodes.updateBefore(u),this._geometries.updateForRender(u),this._nodes.updateForRender(u),this._bindings.updateForRender(u),this._pipelines.getForRender(u,this._compilationPromises),this._nodes.updateAfter(u)}get compile(){return this.compileAsync}}class Hw{constructor(e=""){this.name=e,this.visibility=0}setVisibility(e){this.visibility|=e}clone(){return Object.assign(new this.constructor,this)}}function FK(i){return i+(Fa-i%Fa)%Fa}let $$=class extends Hw{constructor(e,t=null){super(e),this.isBuffer=!0,this.bytesPerElement=Float32Array.BYTES_PER_ELEMENT,this._buffer=t}get byteLength(){return FK(this._buffer.byteLength)}get buffer(){return this._buffer}update(){return!0}};class z$ extends $${constructor(e,t=null){super(e,t),this.isUniformBuffer=!0}}let RK=0;class V$ extends z${constructor(e,t){super("UniformBuffer_"+RK++,e?e.value:null),this.nodeUniform=e,this.groupNode=t}get buffer(){return this.nodeUniform.value}}class IK extends z${constructor(e){super(e),this.isUniformsGroup=!0,this._values=null,this.uniforms=[]}addUniform(e){return this.uniforms.push(e),this}removeUniform(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}get values(){return this._values===null&&(this._values=Array.from(this.buffer)),this._values}get buffer(){let e=this._buffer;if(e===null){const t=this.byteLength;e=new Float32Array(new ArrayBuffer(t)),this._buffer=e}return e}get byteLength(){const e=this.bytesPerElement;let t=0;for(let s=0,r=this.uniforms.length;s<r;s++){const n=this.uniforms[s],o=n.boundary,a=n.itemSize*e,l=t%Fa,u=l%o,c=l+u;t+=u,c!==0&&Fa-c<a&&(t+=Fa-c),n.offset=t/e,t+=a}return Math.ceil(t/Fa)*Fa}update(){let e=!1;for(const t of this.uniforms)this.updateByType(t)===!0&&(e=!0);return e}updateByType(e){if(e.isNumberUniform)return this.updateNumber(e);if(e.isVector2Uniform)return this.updateVector2(e);if(e.isVector3Uniform)return this.updateVector3(e);if(e.isVector4Uniform)return this.updateVector4(e);if(e.isColorUniform)return this.updateColor(e);if(e.isMatrix3Uniform)return this.updateMatrix3(e);if(e.isMatrix4Uniform)return this.updateMatrix4(e);console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.",e)}updateNumber(e){let t=!1;const s=this.values,r=e.getValue(),n=e.offset,o=e.getType();if(s[n]!==r){const a=this._getBufferForType(o);a[n]=s[n]=r,t=!0}return t}updateVector2(e){let t=!1;const s=this.values,r=e.getValue(),n=e.offset,o=e.getType();if(s[n+0]!==r.x||s[n+1]!==r.y){const a=this._getBufferForType(o);a[n+0]=s[n+0]=r.x,a[n+1]=s[n+1]=r.y,t=!0}return t}updateVector3(e){let t=!1;const s=this.values,r=e.getValue(),n=e.offset,o=e.getType();if(s[n+0]!==r.x||s[n+1]!==r.y||s[n+2]!==r.z){const a=this._getBufferForType(o);a[n+0]=s[n+0]=r.x,a[n+1]=s[n+1]=r.y,a[n+2]=s[n+2]=r.z,t=!0}return t}updateVector4(e){let t=!1;const s=this.values,r=e.getValue(),n=e.offset,o=e.getType();if(s[n+0]!==r.x||s[n+1]!==r.y||s[n+2]!==r.z||s[n+4]!==r.w){const a=this._getBufferForType(o);a[n+0]=s[n+0]=r.x,a[n+1]=s[n+1]=r.y,a[n+2]=s[n+2]=r.z,a[n+3]=s[n+3]=r.w,t=!0}return t}updateColor(e){let t=!1;const s=this.values,r=e.getValue(),n=e.offset;if(s[n+0]!==r.r||s[n+1]!==r.g||s[n+2]!==r.b){const o=this.buffer;o[n+0]=s[n+0]=r.r,o[n+1]=s[n+1]=r.g,o[n+2]=s[n+2]=r.b,t=!0}return t}updateMatrix3(e){let t=!1;const s=this.values,r=e.getValue().elements,n=e.offset;if(s[n+0]!==r[0]||s[n+1]!==r[1]||s[n+2]!==r[2]||s[n+4]!==r[3]||s[n+5]!==r[4]||s[n+6]!==r[5]||s[n+8]!==r[6]||s[n+9]!==r[7]||s[n+10]!==r[8]){const o=this.buffer;o[n+0]=s[n+0]=r[0],o[n+1]=s[n+1]=r[1],o[n+2]=s[n+2]=r[2],o[n+4]=s[n+4]=r[3],o[n+5]=s[n+5]=r[4],o[n+6]=s[n+6]=r[5],o[n+8]=s[n+8]=r[6],o[n+9]=s[n+9]=r[7],o[n+10]=s[n+10]=r[8],t=!0}return t}updateMatrix4(e){let t=!1;const s=this.values,r=e.getValue().elements,n=e.offset;return kK(s,r,n)===!1&&(this.buffer.set(r,n),DK(s,r,n),t=!0),t}_getBufferForType(e){return e==="int"||e==="ivec2"||e==="ivec3"||e==="ivec4"?new Int32Array(this.buffer.buffer):e==="uint"||e==="uvec2"||e==="uvec3"||e==="uvec4"?new Uint32Array(this.buffer.buffer):this.buffer}}function DK(i,e,t){for(let s=0,r=e.length;s<r;s++)i[t+s]=e[s]}function kK(i,e,t){for(let s=0,r=e.length;s<r;s++)if(i[t+s]!==e[s])return!1;return!0}let LK=0;class U$ extends IK{constructor(e,t){super(e),this.id=LK++,this.groupNode=t,this.isNodeUniformsGroup=!0}}let BK=0;class OK extends Hw{constructor(e,t){super(e),this.id=BK++,this.texture=t,this.version=t?t.version:0,this.store=!1,this.generation=null,this.isSampledTexture=!0}needsBindingsUpdate(e){const{texture:t}=this;return e!==this.generation?(this.generation=e,!0):t.isVideoTexture}update(){const{texture:e,version:t}=this;return t!==e.version?(this.version=e.version,!0):!1}}class Hm extends OK{constructor(e,t,s,r=null){super(e,t?t.value:null),this.textureNode=t,this.groupNode=s,this.access=r}needsBindingsUpdate(e){return this.textureNode.value!==this.texture||super.needsBindingsUpdate(e)}update(){const{textureNode:e}=this;return this.texture!==e.value?(this.texture=e.value,!0):super.update()}}class G$ extends Hm{constructor(e,t,s,r=null){super(e,t,s,r),this.isSampledCubeTexture=!0}}class j$ extends Hm{constructor(e,t,s,r=null){super(e,t,s,r),this.isSampledTexture3D=!0}}const $K={textureDimensions:"textureSize",equals:"equal"},zK={low:"lowp",medium:"mediump",high:"highp"},hN={swizzleAssign:!0,storageBuffer:!1},pN={perspective:"smooth",linear:"noperspective"},fN={centroid:"centroid"},mN=`
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;class VK extends L${constructor(e,t){super(e,t,new gK),this.uniformGroups={},this.transforms=[],this.extensions={},this.builtins={vertex:[],fragment:[],compute:[]}}needsToWorkingColorSpace(e){return e.isVideoTexture===!0&&e.colorSpace!==ea}getMethod(e){return $K[e]||e}getOutputStructName(){return""}buildFunctionCode(e){const t=e.layout,s=this.flowShaderNode(e),r=[];for(const o of t.inputs)r.push(this.getType(o.type)+" "+o.name);return`${this.getType(t.type)} ${t.name}( ${r.join(", ")} ) {

	${s.vars}

${s.code}
	return ${s.result};

}`}setupPBO(e){const t=e.value;if(t.pbo===void 0){const s=t.array,r=t.count*t.itemSize,{itemSize:n}=t,o=t.array.constructor.name.toLowerCase().includes("int");let a=o?h0:d0;n===2?a=o?p0:Ol:n===3?a=o?OV:c0:n===4&&(a=o?f0:fn);const l={Float32Array:Kr,Uint8Array:xr,Uint16Array:Zu,Uint32Array:_i,Int8Array:Vd,Int16Array:Ud,Int32Array:_r,Uint8ClampedArray:xr},u=Math.pow(2,Math.ceil(Math.log2(Math.sqrt(r/n))));let c=Math.ceil(r/n/u);u*c*n<r&&c++;const d=u*c*n,h=new s.constructor(d);h.set(s,0),t.array=h;const p=new WU(t.array,u,c,a,l[t.array.constructor.name]||Kr);p.needsUpdate=!0,p.isPBOTexture=!0;const f=new To(p,null,null);f.setPrecision("high"),t.pboNode=f,t.pbo=f.value,this.getUniformFromNode(t.pboNode,"texture",this.shaderStage,this.context.label)}}getPropertyName(e,t=this.shaderStage){return e.isNodeUniform&&e.node.isTextureNode!==!0&&e.node.isBufferNode!==!0?t.charAt(0)+"_"+e.name:super.getPropertyName(e,t)}generatePBO(e){const{node:t,indexNode:s}=e,r=t.value;if(this.renderer.backend.has(r)){const c=this.renderer.backend.get(r);c.pbo=r.pbo}const n=this.getUniformFromNode(r.pboNode,"texture",this.shaderStage,this.context.label),o=this.getPropertyName(n);this.increaseUsage(s);const a=s.build(this,"uint"),l=this.getDataFromNode(e);let u=l.propertyName;if(u===void 0){const c=this.getVarFromNode(e);u=this.getPropertyName(c);const d=this.getDataFromNode(t);let h=d.propertySizeName;h===void 0&&(h=u+"Size",this.getVarFromNode(t,h,"uint"),this.addLineFlowCode(`${h} = uint( textureSize( ${o}, 0 ).x )`,e),d.propertySizeName=h);const{itemSize:p}=r,f="."+tu.join("").slice(0,p),m=`ivec2(${a} % ${h}, ${a} / ${h})`,x=this.generateTextureLoad(null,o,m,null,"0");let g="vec4";r.pbo.type===_i?g="uvec4":r.pbo.type===_r&&(g="ivec4"),this.addLineFlowCode(`${u} = ${g}(${x})${f}`,e),l.propertyName=u}return u}generateTextureLoad(e,t,s,r,n="0"){return r?`texelFetch( ${t}, ivec3( ${s}, ${r} ), ${n} )`:`texelFetch( ${t}, ${s}, ${n} )`}generateTexture(e,t,s,r){return e.isDepthTexture?(r&&(s=`vec4( ${s}, ${r} )`),`texture( ${t}, ${s} ).x`):(r&&(s=`vec3( ${s}, ${r} )`),`texture( ${t}, ${s} )`)}generateTextureLevel(e,t,s,r){return`textureLod( ${t}, ${s}, ${r} )`}generateTextureBias(e,t,s,r){return`texture( ${t}, ${s}, ${r} )`}generateTextureGrad(e,t,s,r){return`textureGrad( ${t}, ${s}, ${r[0]}, ${r[1]} )`}generateTextureCompare(e,t,s,r,n,o=this.shaderStage){if(o==="fragment")return n?`texture( ${t}, vec4( ${s}, ${n}, ${r} ) )`:`texture( ${t}, vec3( ${s}, ${r} ) )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`)}getVars(e){const t=[],s=this.vars[e];if(s!==void 0)for(const r of s)t.push(`${this.getVar(r.type,r.name,r.count)};`);return t.join(`
	`)}getUniforms(e){const t=this.uniforms[e],s=[],r={};for(const o of t){let a=null,l=!1;if(o.type==="texture"||o.type==="texture3D"){const c=o.node.value;let d="";(c.isDataTexture===!0||c.isData3DTexture===!0)&&(c.type===_i?d="u":c.type===_r&&(d="i")),o.type==="texture3D"&&c.isArrayTexture===!1?a=`${d}sampler3D ${o.name};`:c.compareFunction?c.isArrayTexture===!0?a=`sampler2DArrayShadow ${o.name};`:a=`sampler2DShadow ${o.name};`:c.isArrayTexture===!0||c.isDataArrayTexture===!0||c.isCompressedArrayTexture===!0?a=`${d}sampler2DArray ${o.name};`:a=`${d}sampler2D ${o.name};`}else if(o.type==="cubeTexture")a=`samplerCube ${o.name};`;else if(o.type==="buffer"){const c=o.node,d=this.getType(c.bufferType),h=c.bufferCount,p=h>0?h:"";a=`${c.name} {
	${d} ${o.name}[${p}];
};
`}else a=`${this.getVectorType(o.type)} ${this.getPropertyName(o,e)};`,l=!0;const u=o.node.precision;if(u!==null&&(a=zK[u]+" "+a),l){a="	"+a;const c=o.groupNode.name;(r[c]||(r[c]=[])).push(a)}else a="uniform "+a,s.push(a)}let n="";for(const o in r){const a=r[o];n+=this._getGLSLUniformStruct(e+"_"+o,a.join(`
`))+`
`}return n+=s.join(`
`),n}getTypeFromAttribute(e){let t=super.getTypeFromAttribute(e);if(/^[iu]/.test(t)&&e.gpuType!==_r){let s=e;e.isInterleavedBufferAttribute&&(s=e.data);const r=s.array;r instanceof Uint32Array||r instanceof Int32Array||(t=t.slice(1))}return t}getAttributes(e){let t="";if(e==="vertex"||e==="compute"){const s=this.getAttributesArray();let r=0;for(const n of s)t+=`layout( location = ${r++} ) in ${n.type} ${n.name};
`}return t}getStructMembers(e){const t=[];for(const s of e.members)t.push(`	${s.type} ${s.name};`);return t.join(`
`)}getStructs(e){const t=[],s=this.structs[e],r=[];for(const n of s)if(n.output)for(const o of n.members)r.push(`layout( location = ${o.index} ) out ${o.type} ${o.name};`);else{let o="struct "+n.name+` {
`;o+=this.getStructMembers(n),o+=`
};
`,t.push(o)}return r.length===0&&r.push("layout( location = 0 ) out vec4 fragColor;"),`
`+r.join(`
`)+`

`+t.join(`
`)}getVaryings(e){let t="";const s=this.varyings;if(e==="vertex"||e==="compute")for(const r of s){e==="compute"&&(r.needsInterpolation=!0);const n=this.getType(r.type);if(r.needsInterpolation)if(r.interpolationType){const o=pN[r.interpolationType]||r.interpolationType,a=fN[r.interpolationSampling]||"";t+=`${o} ${a} out ${n} ${r.name};
`}else{const o=n.includes("int")||n.includes("uv")||n.includes("iv")?"flat ":"";t+=`${o}out ${n} ${r.name};
`}else t+=`${n} ${r.name};
`}else if(e==="fragment"){for(const r of s)if(r.needsInterpolation){const n=this.getType(r.type);if(r.interpolationType){const o=pN[r.interpolationType]||r.interpolationType,a=fN[r.interpolationSampling]||"";t+=`${o} ${a} in ${n} ${r.name};
`}else{const o=n.includes("int")||n.includes("uv")||n.includes("iv")?"flat ":"";t+=`${o}in ${n} ${r.name};
`}}}for(const r of this.builtins[e])t+=`${r};
`;return t}getVertexIndex(){return"uint( gl_VertexID )"}getInstanceIndex(){return"uint( gl_InstanceID )"}getInvocationLocalIndex(){return`uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((s,r)=>s*r,1)}u`}getDrawIndex(){return this.renderer.backend.extensions.has("WEBGL_multi_draw")?"uint( gl_DrawID )":null}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord.xy"}getFragDepth(){return"gl_FragDepth"}enableExtension(e,t,s=this.shaderStage){const r=this.extensions[s]||(this.extensions[s]=new Map);r.has(e)===!1&&r.set(e,{name:e,behavior:t})}getExtensions(e){const t=[];if(e==="vertex"){const r=this.renderer.backend.extensions;this.object.isBatchedMesh&&r.has("WEBGL_multi_draw")&&this.enableExtension("GL_ANGLE_multi_draw","require",e)}const s=this.extensions[e];if(s!==void 0)for(const{name:r,behavior:n}of s.values())t.push(`#extension ${r} : ${n}`);return t.join(`
`)}getClipDistance(){return"gl_ClipDistance"}isAvailable(e){let t=hN[e];if(t===void 0){let s;switch(t=!1,e){case"float32Filterable":s="OES_texture_float_linear";break;case"clipDistance":s="WEBGL_clip_cull_distance";break}if(s!==void 0){const r=this.renderer.backend.extensions;r.has(s)&&(r.get(s),t=!0)}hN[e]=t}return t}isFlipY(){return!0}enableHardwareClipping(e){this.enableExtension("GL_ANGLE_clip_cull_distance","require"),this.builtins.vertex.push(`out float gl_ClipDistance[ ${e} ]`)}enableMultiview(){this.enableExtension("GL_OVR_multiview2","require","fragment"),this.enableExtension("GL_OVR_multiview2","require","vertex"),this.builtins.vertex.push("layout(num_views = 2) in")}registerTransform(e,t){this.transforms.push({varyingName:e,attributeNode:t})}getTransforms(){const e=this.transforms;let t="";for(let s=0;s<e.length;s++){const r=e[s],n=this.getPropertyName(r.attributeNode);n&&(t+=`${r.varyingName} = ${n};
	`)}return t}_getGLSLUniformStruct(e,t){return`
layout( std140 ) uniform ${e} {
${t}
};`}_getGLSLVertexCode(e){return`#version 300 es

${this.getSignature()}

// extensions
${e.extensions}

// precision
${mN}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`}_getGLSLFragmentCode(e){return`#version 300 es

${this.getSignature()}

// extensions
${e.extensions}

// precision
${mN}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

// structs
${e.structs}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`}buildCode(){const e=this.material!==null?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const t in e){let s=`// code

`;s+=this.flowCode[t];const r=this.flowNodes[t],n=r[r.length-1];for(const a of r){const l=this.getFlowData(a),u=a.name;u&&(s.length>0&&(s+=`
`),s+=`	// flow -> ${u}
	`),s+=`${l.code}
	`,a===n&&t!=="compute"&&(s+=`// result
	`,t==="vertex"?(s+="gl_Position = ",s+=`${l.result};`):t==="fragment"&&(a.outputNode.isOutputStructNode||(s+="fragColor = ",s+=`${l.result};`)))}const o=e[t];o.extensions=this.getExtensions(t),o.uniforms=this.getUniforms(t),o.attributes=this.getAttributes(t),o.varyings=this.getVaryings(t),o.vars=this.getVars(t),o.structs=this.getStructs(t),o.codes=this.getCodes(t),o.transforms=this.getTransforms(t),o.flow=s}this.material!==null?(this.vertexShader=this._getGLSLVertexCode(e.vertex),this.fragmentShader=this._getGLSLFragmentCode(e.fragment)):this.computeShader=this._getGLSLVertexCode(e.compute)}getUniformFromNode(e,t,s,r=null){const n=super.getUniformFromNode(e,t,s,r),o=this.getDataFromNode(e,s,this.globalCache);let a=o.uniformGPU;if(a===void 0){const l=e.groupNode,u=l.name,c=this.getBindGroupArray(u,s);if(t==="texture")a=new Hm(n.name,n.node,l),c.push(a);else if(t==="cubeTexture")a=new G$(n.name,n.node,l),c.push(a);else if(t==="texture3D")a=new j$(n.name,n.node,l),c.push(a);else if(t==="buffer"){e.name=`NodeBuffer_${e.id}`,n.name=`buffer${e.id}`;const d=new V$(e,l);d.name=e.name,c.push(d),a=d}else{const d=this.uniformGroups[s]||(this.uniformGroups[s]={});let h=d[u];h===void 0&&(h=new U$(s+"_"+u,l),d[u]=h,c.push(h)),a=this.getNodeUniform(n,t),h.addUniform(a)}o.uniformGPU=a}return n}}let ux=null,Gu=null;class W${constructor(e={}){this.parameters=Object.assign({},e),this.data=new WeakMap,this.renderer=null,this.domElement=null,this.timestampQueryPool={render:null,compute:null},this.trackTimestamp=e.trackTimestamp===!0}async init(e){this.renderer=e}get coordinateSystem(){}beginRender(){}finishRender(){}beginCompute(){}finishCompute(){}draw(){}compute(){}createProgram(){}destroyProgram(){}createBindings(){}updateBindings(){}updateBinding(){}createRenderPipeline(){}createComputePipeline(){}needsRenderUpdate(){}getRenderCacheKey(){}createNodeBuilder(){}createSampler(){}destroySampler(){}createDefaultTexture(){}createTexture(){}updateTexture(){}generateMipmaps(){}destroyTexture(){}async copyTextureToBuffer(){}copyTextureToTexture(){}copyFramebufferToTexture(){}createAttribute(){}createIndexAttribute(){}createStorageAttribute(){}updateAttribute(){}destroyAttribute(){}getContext(){}updateSize(){}updateViewport(){}isOccluded(){}async resolveTimestampsAsync(e="render"){if(!this.trackTimestamp){ta("WebGPURenderer: Timestamp tracking is disabled.");return}const t=this.timestampQueryPool[e];if(!t){ta(`WebGPURenderer: No timestamp query pool for type '${e}' found.`);return}const s=await t.resolveQueriesAsync();return this.renderer.info[e].timestamp=s,s}async waitForGPU(){}async getArrayBufferAsync(){}async hasFeatureAsync(){}hasFeature(){}getMaxAnisotropy(){}getDrawingBufferSize(){return ux=ux||new Dt,this.renderer.getDrawingBufferSize(ux)}setScissorTest(){}getClearColor(){const e=this.renderer;return Gu=Gu||new Cw,e.getClearColor(Gu),Gu.getRGB(Gu),Gu}getDomElement(){let e=this.domElement;return e===null&&(e=this.parameters.canvas!==void 0?this.parameters.canvas:_U(),"setAttribute"in e&&e.setAttribute("data-engine",`three.js r${hm} webgpu`),this.domElement=e),e}set(e,t){this.data.set(e,t)}get(e){let t=this.data.get(e);return t===void 0&&(t={},this.data.set(e,t)),t}has(e){return this.data.has(e)}delete(e){this.data.delete(e)}dispose(){}}let UK=0;class GK{constructor(e,t){this.buffers=[e.bufferGPU,t],this.type=e.type,this.bufferType=e.bufferType,this.pbo=e.pbo,this.byteLength=e.byteLength,this.bytesPerElement=e.BYTES_PER_ELEMENT,this.version=e.version,this.isInteger=e.isInteger,this.activeBufferIndex=0,this.baseId=e.id}get id(){return`${this.baseId}|${this.activeBufferIndex}`}get bufferGPU(){return this.buffers[this.activeBufferIndex]}get transformBuffer(){return this.buffers[this.activeBufferIndex^1]}switchBuffers(){this.activeBufferIndex^=1}}class jK{constructor(e){this.backend=e}createAttribute(e,t){const s=this.backend,{gl:r}=s,n=e.array,o=e.usage||r.STATIC_DRAW,a=e.isInterleavedBufferAttribute?e.data:e,l=s.get(a);let u=l.bufferGPU;u===void 0&&(u=this._createBuffer(r,t,n,o),l.bufferGPU=u,l.bufferType=t,l.version=a.version);let c;if(n instanceof Float32Array)c=r.FLOAT;else if(typeof Float16Array<"u"&&n instanceof Float16Array)c=r.HALF_FLOAT;else if(n instanceof Uint16Array)e.isFloat16BufferAttribute?c=r.HALF_FLOAT:c=r.UNSIGNED_SHORT;else if(n instanceof Int16Array)c=r.SHORT;else if(n instanceof Uint32Array)c=r.UNSIGNED_INT;else if(n instanceof Int32Array)c=r.INT;else if(n instanceof Int8Array)c=r.BYTE;else if(n instanceof Uint8Array)c=r.UNSIGNED_BYTE;else if(n instanceof Uint8ClampedArray)c=r.UNSIGNED_BYTE;else throw new Error("THREE.WebGLBackend: Unsupported buffer data format: "+n);let d={bufferGPU:u,bufferType:t,type:c,byteLength:n.byteLength,bytesPerElement:n.BYTES_PER_ELEMENT,version:e.version,pbo:e.pbo,isInteger:c===r.INT||c===r.UNSIGNED_INT||e.gpuType===_r,id:UK++};if(e.isStorageBufferAttribute||e.isStorageInstancedBufferAttribute){const h=this._createBuffer(r,t,n,o);d=new GK(d,h)}s.set(e,d)}updateAttribute(e){const t=this.backend,{gl:s}=t,r=e.array,n=e.isInterleavedBufferAttribute?e.data:e,o=t.get(n),a=o.bufferType,l=e.isInterleavedBufferAttribute?e.data.updateRanges:e.updateRanges;if(s.bindBuffer(a,o.bufferGPU),l.length===0)s.bufferSubData(a,0,r);else{for(let u=0,c=l.length;u<c;u++){const d=l[u];s.bufferSubData(a,d.start*r.BYTES_PER_ELEMENT,r,d.start,d.count)}n.clearUpdateRanges()}s.bindBuffer(a,null),o.version=n.version}destroyAttribute(e){const t=this.backend,{gl:s}=t;e.isInterleavedBufferAttribute&&t.delete(e.data);const r=t.get(e);s.deleteBuffer(r.bufferGPU),t.delete(e)}async getArrayBufferAsync(e){const t=this.backend,{gl:s}=t,r=e.isInterleavedBufferAttribute?e.data:e,{bufferGPU:n}=t.get(r),o=e.array,a=o.byteLength;s.bindBuffer(s.COPY_READ_BUFFER,n);const l=s.createBuffer();s.bindBuffer(s.COPY_WRITE_BUFFER,l),s.bufferData(s.COPY_WRITE_BUFFER,a,s.STREAM_READ),s.copyBufferSubData(s.COPY_READ_BUFFER,s.COPY_WRITE_BUFFER,0,0,a),await t.utils._clientWaitAsync();const u=new e.array.constructor(o.length);return s.bindBuffer(s.COPY_WRITE_BUFFER,l),s.getBufferSubData(s.COPY_WRITE_BUFFER,0,u),s.deleteBuffer(l),s.bindBuffer(s.COPY_READ_BUFFER,null),s.bindBuffer(s.COPY_WRITE_BUFFER,null),u.buffer}_createBuffer(e,t,s,r){const n=e.createBuffer();return e.bindBuffer(t,n),e.bufferData(t,s,r),e.bindBuffer(t,null),n}}let cx,Fd;class WK{constructor(e){this.backend=e,this.gl=this.backend.gl,this.enabled={},this.currentFlipSided=null,this.currentCullFace=null,this.currentProgram=null,this.currentBlendingEnabled=!1,this.currentBlending=null,this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentPremultipledAlpha=null,this.currentPolygonOffsetFactor=null,this.currentPolygonOffsetUnits=null,this.currentColorMask=null,this.currentDepthFunc=null,this.currentDepthMask=null,this.currentStencilFunc=null,this.currentStencilRef=null,this.currentStencilFuncMask=null,this.currentStencilFail=null,this.currentStencilZFail=null,this.currentStencilZPass=null,this.currentStencilMask=null,this.currentLineWidth=null,this.currentClippingPlanes=0,this.currentVAO=null,this.currentIndex=null,this.currentBoundFramebuffers={},this.currentDrawbuffers=new WeakMap,this.maxTextures=this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS),this.currentTextureSlot=null,this.currentBoundTextures={},this.currentBoundBufferBases={},this._init()}_init(){const e=this.gl;cx={[Un]:e.FUNC_ADD,[xD]:e.FUNC_SUBTRACT,[bD]:e.FUNC_REVERSE_SUBTRACT},Fd={[Aa]:e.ZERO,[wD]:e.ONE,[MD]:e.SRC_COLOR,[Wf]:e.SRC_ALPHA,[CD]:e.SRC_ALPHA_SATURATE,[ED]:e.DST_COLOR,[vD]:e.DST_ALPHA,[TD]:e.ONE_MINUS_SRC_COLOR,[Hf]:e.ONE_MINUS_SRC_ALPHA,[AD]:e.ONE_MINUS_DST_COLOR,[SD]:e.ONE_MINUS_DST_ALPHA};const t=e.getParameter(e.SCISSOR_BOX),s=e.getParameter(e.VIEWPORT);this.currentScissor=new ns().fromArray(t),this.currentViewport=new ns().fromArray(s),this._tempVec4=new ns}enable(e){const{enabled:t}=this;t[e]!==!0&&(this.gl.enable(e),t[e]=!0)}disable(e){const{enabled:t}=this;t[e]!==!1&&(this.gl.disable(e),t[e]=!1)}setFlipSided(e){if(this.currentFlipSided!==e){const{gl:t}=this;e?t.frontFace(t.CW):t.frontFace(t.CCW),this.currentFlipSided=e}}setCullFace(e){const{gl:t}=this;e!==xV?(this.enable(t.CULL_FACE),e!==this.currentCullFace&&(e===bV?t.cullFace(t.BACK):e===wV?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):this.disable(t.CULL_FACE),this.currentCullFace=e}setLineWidth(e){const{currentLineWidth:t,gl:s}=this;e!==t&&(s.lineWidth(e),this.currentLineWidth=e)}setBlending(e,t,s,r,n,o,a,l){const{gl:u}=this;if(e===fc){this.currentBlendingEnabled===!0&&(this.disable(u.BLEND),this.currentBlendingEnabled=!1);return}if(this.currentBlendingEnabled===!1&&(this.enable(u.BLEND),this.currentBlendingEnabled=!0),e!==zd){if(e!==this.currentBlending||l!==this.currentPremultipledAlpha){if((this.currentBlendEquation!==Un||this.currentBlendEquationAlpha!==Un)&&(u.blendEquation(u.FUNC_ADD),this.currentBlendEquation=Un,this.currentBlendEquationAlpha=Un),l)switch(e){case Ho:u.blendFuncSeparate(u.ONE,u.ONE_MINUS_SRC_ALPHA,u.ONE,u.ONE_MINUS_SRC_ALPHA);break;case Uf:u.blendFunc(u.ONE,u.ONE);break;case Gf:u.blendFuncSeparate(u.ZERO,u.ONE_MINUS_SRC_COLOR,u.ZERO,u.ONE);break;case jf:u.blendFuncSeparate(u.DST_COLOR,u.ONE_MINUS_SRC_ALPHA,u.ZERO,u.ONE);break;default:console.error("THREE.WebGLState: Invalid blending: ",e);break}else switch(e){case Ho:u.blendFuncSeparate(u.SRC_ALPHA,u.ONE_MINUS_SRC_ALPHA,u.ONE,u.ONE_MINUS_SRC_ALPHA);break;case Uf:u.blendFuncSeparate(u.SRC_ALPHA,u.ONE,u.ONE,u.ONE);break;case Gf:console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case jf:console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:console.error("THREE.WebGLState: Invalid blending: ",e);break}this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentBlending=e,this.currentPremultipledAlpha=l}return}n=n||t,o=o||s,a=a||r,(t!==this.currentBlendEquation||n!==this.currentBlendEquationAlpha)&&(u.blendEquationSeparate(cx[t],cx[n]),this.currentBlendEquation=t,this.currentBlendEquationAlpha=n),(s!==this.currentBlendSrc||r!==this.currentBlendDst||o!==this.currentBlendSrcAlpha||a!==this.currentBlendDstAlpha)&&(u.blendFuncSeparate(Fd[s],Fd[r],Fd[o],Fd[a]),this.currentBlendSrc=s,this.currentBlendDst=r,this.currentBlendSrcAlpha=o,this.currentBlendDstAlpha=a),this.currentBlending=e,this.currentPremultipledAlpha=!1}setColorMask(e){this.currentColorMask!==e&&(this.gl.colorMask(e,e,e,e),this.currentColorMask=e)}setDepthTest(e){const{gl:t}=this;e?this.enable(t.DEPTH_TEST):this.disable(t.DEPTH_TEST)}setDepthMask(e){this.currentDepthMask!==e&&(this.gl.depthMask(e),this.currentDepthMask=e)}setDepthFunc(e){if(this.currentDepthFunc!==e){const{gl:t}=this;switch(e){case PD:t.depthFunc(t.NEVER);break;case ND:t.depthFunc(t.ALWAYS);break;case FD:t.depthFunc(t.LESS);break;case qf:t.depthFunc(t.LEQUAL);break;case RD:t.depthFunc(t.EQUAL);break;case ID:t.depthFunc(t.GEQUAL);break;case DD:t.depthFunc(t.GREATER);break;case kD:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.LEQUAL)}this.currentDepthFunc=e}}scissor(e,t,s,r){const n=this._tempVec4.set(e,t,s,r);if(this.currentScissor.equals(n)===!1){const{gl:o}=this;o.scissor(n.x,n.y,n.z,n.w),this.currentScissor.copy(n)}}viewport(e,t,s,r){const n=this._tempVec4.set(e,t,s,r);if(this.currentViewport.equals(n)===!1){const{gl:o}=this;o.viewport(n.x,n.y,n.z,n.w),this.currentViewport.copy(n)}}setScissorTest(e){const t=this.gl;e?t.enable(t.SCISSOR_TEST):t.disable(t.SCISSOR_TEST)}setStencilTest(e){const{gl:t}=this;e?this.enable(t.STENCIL_TEST):this.disable(t.STENCIL_TEST)}setStencilMask(e){this.currentStencilMask!==e&&(this.gl.stencilMask(e),this.currentStencilMask=e)}setStencilFunc(e,t,s){(this.currentStencilFunc!==e||this.currentStencilRef!==t||this.currentStencilFuncMask!==s)&&(this.gl.stencilFunc(e,t,s),this.currentStencilFunc=e,this.currentStencilRef=t,this.currentStencilFuncMask=s)}setStencilOp(e,t,s){(this.currentStencilFail!==e||this.currentStencilZFail!==t||this.currentStencilZPass!==s)&&(this.gl.stencilOp(e,t,s),this.currentStencilFail=e,this.currentStencilZFail=t,this.currentStencilZPass=s)}setMaterial(e,t,s){const{gl:r}=this;e.side===Da?this.disable(r.CULL_FACE):this.enable(r.CULL_FACE);let n=e.side===lr;t&&(n=!n),this.setFlipSided(n),e.blending===Ho&&e.transparent===!1?this.setBlending(fc):this.setBlending(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),this.setDepthFunc(e.depthFunc),this.setDepthTest(e.depthTest),this.setDepthMask(e.depthWrite),this.setColorMask(e.colorWrite);const o=e.stencilWrite;if(this.setStencilTest(o),o&&(this.setStencilMask(e.stencilWriteMask),this.setStencilFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),this.setStencilOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),this.setPolygonOffset(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),e.alphaToCoverage===!0&&this.backend.renderer.samples>1?this.enable(r.SAMPLE_ALPHA_TO_COVERAGE):this.disable(r.SAMPLE_ALPHA_TO_COVERAGE),s>0&&this.currentClippingPlanes!==s)for(let l=0;l<8;l++)l<s?this.enable(12288+l):this.disable(12288+l)}setPolygonOffset(e,t,s){const{gl:r}=this;e?(this.enable(r.POLYGON_OFFSET_FILL),(this.currentPolygonOffsetFactor!==t||this.currentPolygonOffsetUnits!==s)&&(r.polygonOffset(t,s),this.currentPolygonOffsetFactor=t,this.currentPolygonOffsetUnits=s)):this.disable(r.POLYGON_OFFSET_FILL)}useProgram(e){return this.currentProgram!==e?(this.gl.useProgram(e),this.currentProgram=e,!0):!1}setVertexState(e,t=null){const s=this.gl;return this.currentVAO!==e||this.currentIndex!==t?(s.bindVertexArray(e),t!==null&&s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,t),this.currentVAO=e,this.currentIndex=t,!0):!1}resetVertexState(){const e=this.gl;e.bindVertexArray(null),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),this.currentVAO=null,this.currentIndex=null}bindFramebuffer(e,t){const{gl:s,currentBoundFramebuffers:r}=this;return r[e]!==t?(s.bindFramebuffer(e,t),r[e]=t,e===s.DRAW_FRAMEBUFFER&&(r[s.FRAMEBUFFER]=t),e===s.FRAMEBUFFER&&(r[s.DRAW_FRAMEBUFFER]=t),!0):!1}drawBuffers(e,t){const{gl:s}=this;let r=[],n=!1;if(e.textures!==null){r=this.currentDrawbuffers.get(t),r===void 0&&(r=[],this.currentDrawbuffers.set(t,r));const o=e.textures;if(r.length!==o.length||r[0]!==s.COLOR_ATTACHMENT0){for(let a=0,l=o.length;a<l;a++)r[a]=s.COLOR_ATTACHMENT0+a;r.length=o.length,n=!0}}else r[0]!==s.BACK&&(r[0]=s.BACK,n=!0);n&&s.drawBuffers(r)}activeTexture(e){const{gl:t,currentTextureSlot:s,maxTextures:r}=this;e===void 0&&(e=t.TEXTURE0+r-1),s!==e&&(t.activeTexture(e),this.currentTextureSlot=e)}bindTexture(e,t,s){const{gl:r,currentTextureSlot:n,currentBoundTextures:o,maxTextures:a}=this;s===void 0&&(n===null?s=r.TEXTURE0+a-1:s=n);let l=o[s];l===void 0&&(l={type:void 0,texture:void 0},o[s]=l),(l.type!==e||l.texture!==t)&&(n!==s&&(r.activeTexture(s),this.currentTextureSlot=s),r.bindTexture(e,t),l.type=e,l.texture=t)}bindBufferBase(e,t,s){const{gl:r}=this,n=`${e}-${t}`;return this.currentBoundBufferBases[n]!==s?(r.bindBufferBase(e,t,s),this.currentBoundBufferBases[n]=s,!0):!1}unbindTexture(){const{gl:e,currentTextureSlot:t,currentBoundTextures:s}=this,r=s[t];r!==void 0&&r.type!==void 0&&(e.bindTexture(r.type,null),r.type=void 0,r.texture=void 0)}}class HK{constructor(e){this.backend=e,this.gl=this.backend.gl,this.extensions=e.extensions}convert(e,t=ea){const{gl:s,extensions:r}=this;let n;const o=Ls.getTransfer(t);if(e===xr)return s.UNSIGNED_BYTE;if(e===kV)return s.UNSIGNED_SHORT_4_4_4_4;if(e===LV)return s.UNSIGNED_SHORT_5_5_5_1;if(e===BD)return s.UNSIGNED_INT_5_9_9_9_REV;if(e===Vd)return s.BYTE;if(e===Ud)return s.SHORT;if(e===Zu)return s.UNSIGNED_SHORT;if(e===_r)return s.INT;if(e===_i)return s.UNSIGNED_INT;if(e===Kr)return s.FLOAT;if(e===Cr)return s.HALF_FLOAT;if(e===BV)return s.ALPHA;if(e===c0)return s.RGB;if(e===fn)return s.RGBA;if(e===fo)return s.DEPTH_COMPONENT;if(e===Ko)return s.DEPTH_STENCIL;if(e===d0)return s.RED;if(e===h0)return s.RED_INTEGER;if(e===Ol)return s.RG;if(e===p0)return s.RG_INTEGER;if(e===f0)return s.RGBA_INTEGER;if(e===uy||e===vf||e===Sf||e===Ef)if(o===jt)if(n=r.get("WEBGL_compressed_texture_s3tc_srgb"),n!==null){if(e===uy)return n.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(e===vf)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(e===Sf)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(e===Ef)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(n=r.get("WEBGL_compressed_texture_s3tc"),n!==null){if(e===uy)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===vf)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===Sf)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===Ef)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(e===IP||e===DP||e===kP||e===LP)if(n=r.get("WEBGL_compressed_texture_pvrtc"),n!==null){if(e===IP)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===DP)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===kP)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===LP)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(e===BP||e===zx||e===Vx)if(n=r.get("WEBGL_compressed_texture_etc"),n!==null){if(e===BP||e===zx)return o===jt?n.COMPRESSED_SRGB8_ETC2:n.COMPRESSED_RGB8_ETC2;if(e===Vx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:n.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(e===Ux||e===Gx||e===jx||e===Wx||e===Hx||e===qx||e===Kx||e===Xx||e===Yx||e===Qx||e===Zx||e===Jx||e===eb||e===tb)if(n=r.get("WEBGL_compressed_texture_astc"),n!==null){if(e===Ux)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:n.COMPRESSED_RGBA_ASTC_4x4_KHR;if(e===Gx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:n.COMPRESSED_RGBA_ASTC_5x4_KHR;if(e===jx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:n.COMPRESSED_RGBA_ASTC_5x5_KHR;if(e===Wx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:n.COMPRESSED_RGBA_ASTC_6x5_KHR;if(e===Hx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:n.COMPRESSED_RGBA_ASTC_6x6_KHR;if(e===qx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:n.COMPRESSED_RGBA_ASTC_8x5_KHR;if(e===Kx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:n.COMPRESSED_RGBA_ASTC_8x6_KHR;if(e===Xx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:n.COMPRESSED_RGBA_ASTC_8x8_KHR;if(e===Yx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:n.COMPRESSED_RGBA_ASTC_10x5_KHR;if(e===Qx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:n.COMPRESSED_RGBA_ASTC_10x6_KHR;if(e===Zx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:n.COMPRESSED_RGBA_ASTC_10x8_KHR;if(e===Jx)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:n.COMPRESSED_RGBA_ASTC_10x10_KHR;if(e===eb)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:n.COMPRESSED_RGBA_ASTC_12x10_KHR;if(e===tb)return o===jt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:n.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(e===cy)if(n=r.get("EXT_texture_compression_bptc"),n!==null){if(e===cy)return o===jt?n.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:n.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;if(e===$V||e===OP||e===$P||e===zP)if(n=r.get("EXT_texture_compression_rgtc"),n!==null){if(e===cy)return n.COMPRESSED_RED_RGTC1_EXT;if(e===OP)return n.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(e===$P)return n.COMPRESSED_RED_GREEN_RGTC2_EXT;if(e===zP)return n.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return e===ka?s.UNSIGNED_INT_24_8:s[e]!==void 0?s[e]:null}_clientWaitAsync(){const{gl:e}=this,t=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),new Promise((s,r)=>{function n(){const o=e.clientWaitSync(t,e.SYNC_FLUSH_COMMANDS_BIT,0);if(o===e.WAIT_FAILED){e.deleteSync(t),r();return}if(o===e.TIMEOUT_EXPIRED){requestAnimationFrame(n);return}e.deleteSync(t),s()}n()})}}let gN=!1,gf,dx,_N;class qK{constructor(e){this.backend=e,this.gl=e.gl,this.extensions=e.extensions,this.defaultTextures={},gN===!1&&(this._init(),gN=!0)}_init(){const e=this.gl;gf={[mc]:e.REPEAT,[Ra]:e.CLAMP_TO_EDGE,[gc]:e.MIRRORED_REPEAT},dx={[yi]:e.NEAREST,[LD]:e.NEAREST_MIPMAP_NEAREST,[sh]:e.NEAREST_MIPMAP_LINEAR,[wr]:e.LINEAR,[$x]:e.LINEAR_MIPMAP_NEAREST,[qo]:e.LINEAR_MIPMAP_LINEAR},_N={[OD]:e.NEVER,[jD]:e.ALWAYS,[m0]:e.LESS,[zD]:e.LEQUAL,[$D]:e.EQUAL,[GD]:e.GEQUAL,[VD]:e.GREATER,[UD]:e.NOTEQUAL}}getGLTextureType(e){const{gl:t}=this;let s;return e.isCubeTexture===!0?s=t.TEXTURE_CUBE_MAP:e.isArrayTexture===!0||e.isDataArrayTexture===!0||e.isCompressedArrayTexture===!0?s=t.TEXTURE_2D_ARRAY:e.isData3DTexture===!0?s=t.TEXTURE_3D:s=t.TEXTURE_2D,s}getInternalFormat(e,t,s,r,n=!1){const{gl:o,extensions:a}=this;if(e!==null){if(o[e]!==void 0)return o[e];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+e+"'")}let l=t;if(t===o.RED&&(s===o.FLOAT&&(l=o.R32F),s===o.HALF_FLOAT&&(l=o.R16F),s===o.UNSIGNED_BYTE&&(l=o.R8),s===o.UNSIGNED_SHORT&&(l=o.R16),s===o.UNSIGNED_INT&&(l=o.R32UI),s===o.BYTE&&(l=o.R8I),s===o.SHORT&&(l=o.R16I),s===o.INT&&(l=o.R32I)),t===o.RED_INTEGER&&(s===o.UNSIGNED_BYTE&&(l=o.R8UI),s===o.UNSIGNED_SHORT&&(l=o.R16UI),s===o.UNSIGNED_INT&&(l=o.R32UI),s===o.BYTE&&(l=o.R8I),s===o.SHORT&&(l=o.R16I),s===o.INT&&(l=o.R32I)),t===o.RG&&(s===o.FLOAT&&(l=o.RG32F),s===o.HALF_FLOAT&&(l=o.RG16F),s===o.UNSIGNED_BYTE&&(l=o.RG8),s===o.UNSIGNED_SHORT&&(l=o.RG16),s===o.UNSIGNED_INT&&(l=o.RG32UI),s===o.BYTE&&(l=o.RG8I),s===o.SHORT&&(l=o.RG16I),s===o.INT&&(l=o.RG32I)),t===o.RG_INTEGER&&(s===o.UNSIGNED_BYTE&&(l=o.RG8UI),s===o.UNSIGNED_SHORT&&(l=o.RG16UI),s===o.UNSIGNED_INT&&(l=o.RG32UI),s===o.BYTE&&(l=o.RG8I),s===o.SHORT&&(l=o.RG16I),s===o.INT&&(l=o.RG32I)),t===o.RGB){const u=n?Xf:Ls.getTransfer(r);s===o.FLOAT&&(l=o.RGB32F),s===o.HALF_FLOAT&&(l=o.RGB16F),s===o.UNSIGNED_BYTE&&(l=o.RGB8),s===o.UNSIGNED_SHORT&&(l=o.RGB16),s===o.UNSIGNED_INT&&(l=o.RGB32UI),s===o.BYTE&&(l=o.RGB8I),s===o.SHORT&&(l=o.RGB16I),s===o.INT&&(l=o.RGB32I),s===o.UNSIGNED_BYTE&&(l=u===jt?o.SRGB8:o.RGB8),s===o.UNSIGNED_SHORT_5_6_5&&(l=o.RGB565),s===o.UNSIGNED_SHORT_5_5_5_1&&(l=o.RGB5_A1),s===o.UNSIGNED_SHORT_4_4_4_4&&(l=o.RGB4),s===o.UNSIGNED_INT_5_9_9_9_REV&&(l=o.RGB9_E5)}if(t===o.RGB_INTEGER&&(s===o.UNSIGNED_BYTE&&(l=o.RGB8UI),s===o.UNSIGNED_SHORT&&(l=o.RGB16UI),s===o.UNSIGNED_INT&&(l=o.RGB32UI),s===o.BYTE&&(l=o.RGB8I),s===o.SHORT&&(l=o.RGB16I),s===o.INT&&(l=o.RGB32I)),t===o.RGBA){const u=n?Xf:Ls.getTransfer(r);s===o.FLOAT&&(l=o.RGBA32F),s===o.HALF_FLOAT&&(l=o.RGBA16F),s===o.UNSIGNED_BYTE&&(l=o.RGBA8),s===o.UNSIGNED_SHORT&&(l=o.RGBA16),s===o.UNSIGNED_INT&&(l=o.RGBA32UI),s===o.BYTE&&(l=o.RGBA8I),s===o.SHORT&&(l=o.RGBA16I),s===o.INT&&(l=o.RGBA32I),s===o.UNSIGNED_BYTE&&(l=u===jt?o.SRGB8_ALPHA8:o.RGBA8),s===o.UNSIGNED_SHORT_4_4_4_4&&(l=o.RGBA4),s===o.UNSIGNED_SHORT_5_5_5_1&&(l=o.RGB5_A1)}return t===o.RGBA_INTEGER&&(s===o.UNSIGNED_BYTE&&(l=o.RGBA8UI),s===o.UNSIGNED_SHORT&&(l=o.RGBA16UI),s===o.UNSIGNED_INT&&(l=o.RGBA32UI),s===o.BYTE&&(l=o.RGBA8I),s===o.SHORT&&(l=o.RGBA16I),s===o.INT&&(l=o.RGBA32I)),t===o.DEPTH_COMPONENT&&(s===o.UNSIGNED_SHORT&&(l=o.DEPTH_COMPONENT16),s===o.UNSIGNED_INT&&(l=o.DEPTH_COMPONENT24),s===o.FLOAT&&(l=o.DEPTH_COMPONENT32F)),t===o.DEPTH_STENCIL&&s===o.UNSIGNED_INT_24_8&&(l=o.DEPTH24_STENCIL8),(l===o.R16F||l===o.R32F||l===o.RG16F||l===o.RG32F||l===o.RGBA16F||l===o.RGBA32F)&&a.get("EXT_color_buffer_float"),l}setTextureParameters(e,t){const{gl:s,extensions:r,backend:n}=this,o=Ls.getPrimaries(Ls.workingColorSpace),a=t.colorSpace===ea?null:Ls.getPrimaries(t.colorSpace),l=t.colorSpace===ea||o===a?s.NONE:s.BROWSER_DEFAULT_WEBGL;s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,t.flipY),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.premultiplyAlpha),s.pixelStorei(s.UNPACK_ALIGNMENT,t.unpackAlignment),s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL,l),s.texParameteri(e,s.TEXTURE_WRAP_S,gf[t.wrapS]),s.texParameteri(e,s.TEXTURE_WRAP_T,gf[t.wrapT]),(e===s.TEXTURE_3D||e===s.TEXTURE_2D_ARRAY)&&(t.isArrayTexture||s.texParameteri(e,s.TEXTURE_WRAP_R,gf[t.wrapR])),s.texParameteri(e,s.TEXTURE_MAG_FILTER,dx[t.magFilter]);const u=t.mipmaps!==void 0&&t.mipmaps.length>0,c=t.minFilter===wr&&u?qo:t.minFilter;if(s.texParameteri(e,s.TEXTURE_MIN_FILTER,dx[c]),t.compareFunction&&(s.texParameteri(e,s.TEXTURE_COMPARE_MODE,s.COMPARE_REF_TO_TEXTURE),s.texParameteri(e,s.TEXTURE_COMPARE_FUNC,_N[t.compareFunction])),r.has("EXT_texture_filter_anisotropic")===!0){if(t.magFilter===yi||t.minFilter!==sh&&t.minFilter!==qo||t.type===Kr&&r.has("OES_texture_float_linear")===!1)return;if(t.anisotropy>1){const d=r.get("EXT_texture_filter_anisotropic");s.texParameterf(e,d.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(t.anisotropy,n.getMaxAnisotropy()))}}}createDefaultTexture(e){const{gl:t,backend:s,defaultTextures:r}=this,n=this.getGLTextureType(e);let o=r[n];o===void 0&&(o=t.createTexture(),s.state.bindTexture(n,o),t.texParameteri(n,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(n,t.TEXTURE_MAG_FILTER,t.NEAREST),r[n]=o),s.set(e,{textureGPU:o,glTextureType:n,isDefault:!0})}createTexture(e,t){const{gl:s,backend:r}=this,{levels:n,width:o,height:a,depth:l}=t,u=r.utils.convert(e.format,e.colorSpace),c=r.utils.convert(e.type),d=this.getInternalFormat(e.internalFormat,u,c,e.colorSpace,e.isVideoTexture),h=s.createTexture(),p=this.getGLTextureType(e);r.state.bindTexture(p,h),this.setTextureParameters(p,e),e.isArrayTexture||e.isDataArrayTexture||e.isCompressedArrayTexture?s.texStorage3D(s.TEXTURE_2D_ARRAY,n,d,o,a,l):e.isData3DTexture?s.texStorage3D(s.TEXTURE_3D,n,d,o,a,l):e.isVideoTexture||s.texStorage2D(p,n,d,o,a),r.set(e,{textureGPU:h,glTextureType:p,glFormat:u,glType:c,glInternalFormat:d})}copyBufferToTexture(e,t){const{gl:s,backend:r}=this,{textureGPU:n,glTextureType:o,glFormat:a,glType:l}=r.get(t),{width:u,height:c}=t.source.data;s.bindBuffer(s.PIXEL_UNPACK_BUFFER,e),r.state.bindTexture(o,n),s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,!1),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),s.texSubImage2D(o,0,0,0,u,c,a,l,0),s.bindBuffer(s.PIXEL_UNPACK_BUFFER,null),r.state.unbindTexture()}updateTexture(e,t){const{gl:s}=this,{width:r,height:n}=t,{textureGPU:o,glTextureType:a,glFormat:l,glType:u,glInternalFormat:c}=this.backend.get(e);if(!(e.isRenderTargetTexture||o===void 0))if(this.backend.state.bindTexture(a,o),this.setTextureParameters(a,e),e.isCompressedTexture){const d=e.mipmaps,h=t.image;for(let p=0;p<d.length;p++){const f=d[p];e.isCompressedArrayTexture?e.format!==s.RGBA?l!==null?s.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY,p,0,0,0,f.width,f.height,h.depth,l,f.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):s.texSubImage3D(s.TEXTURE_2D_ARRAY,p,0,0,0,f.width,f.height,h.depth,l,u,f.data):l!==null?s.compressedTexSubImage2D(s.TEXTURE_2D,p,0,0,f.width,f.height,l,f.data):console.warn("Unsupported compressed texture format")}}else if(e.isCubeTexture){const d=t.images;for(let h=0;h<6;h++){const p=yN(d[h]);s.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+h,0,0,0,r,n,l,u,p)}}else if(e.isDataArrayTexture||e.isArrayTexture){const d=t.image;s.texSubImage3D(s.TEXTURE_2D_ARRAY,0,0,0,0,d.width,d.height,d.depth,l,u,d.data)}else if(e.isData3DTexture){const d=t.image;s.texSubImage3D(s.TEXTURE_3D,0,0,0,0,d.width,d.height,d.depth,l,u,d.data)}else if(e.isVideoTexture)e.update(),s.texImage2D(a,0,c,l,u,t.image);else{const d=yN(t.image);s.texSubImage2D(a,0,0,0,r,n,l,u,d)}}generateMipmaps(e){const{gl:t,backend:s}=this,{textureGPU:r,glTextureType:n}=s.get(e);s.state.bindTexture(n,r),t.generateMipmap(n)}deallocateRenderBuffers(e){const{gl:t,backend:s}=this;if(e){const r=s.get(e);if(r.renderBufferStorageSetup=void 0,r.framebuffers){for(const n in r.framebuffers)t.deleteFramebuffer(r.framebuffers[n]);delete r.framebuffers}if(r.depthRenderbuffer&&(t.deleteRenderbuffer(r.depthRenderbuffer),delete r.depthRenderbuffer),r.stencilRenderbuffer&&(t.deleteRenderbuffer(r.stencilRenderbuffer),delete r.stencilRenderbuffer),r.msaaFrameBuffer&&(t.deleteFramebuffer(r.msaaFrameBuffer),delete r.msaaFrameBuffer),r.msaaRenderbuffers){for(let n=0;n<r.msaaRenderbuffers.length;n++)t.deleteRenderbuffer(r.msaaRenderbuffers[n]);delete r.msaaRenderbuffers}}}destroyTexture(e){const{gl:t,backend:s}=this,{textureGPU:r,renderTarget:n}=s.get(e);this.deallocateRenderBuffers(n),t.deleteTexture(r),s.delete(e)}copyTextureToTexture(e,t,s=null,r=null,n=0,o=0){const{gl:a,backend:l}=this,{state:u}=this.backend,{textureGPU:c,glTextureType:d,glType:h,glFormat:p}=l.get(t);u.bindTexture(d,c);let f,m,x,g,_,S,M,w,v;const T=e.isCompressedTexture?e.mipmaps[o]:e.image;if(s!==null)f=s.max.x-s.min.x,m=s.max.y-s.min.y,x=s.isBox3?s.max.z-s.min.z:1,g=s.min.x,_=s.min.y,S=s.isBox3?s.min.z:0;else{const Q=Math.pow(2,-n);f=Math.floor(T.width*Q),m=Math.floor(T.height*Q),e.isDataArrayTexture||e.isArrayTexture?x=T.depth:e.isData3DTexture?x=Math.floor(T.depth*Q):x=1,g=0,_=0,S=0}r!==null?(M=r.x,w=r.y,v=r.z):(M=0,w=0,v=0),a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,t.flipY),a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.premultiplyAlpha),a.pixelStorei(a.UNPACK_ALIGNMENT,t.unpackAlignment);const E=a.getParameter(a.UNPACK_ROW_LENGTH),F=a.getParameter(a.UNPACK_IMAGE_HEIGHT),I=a.getParameter(a.UNPACK_SKIP_PIXELS),z=a.getParameter(a.UNPACK_SKIP_ROWS),G=a.getParameter(a.UNPACK_SKIP_IMAGES);a.pixelStorei(a.UNPACK_ROW_LENGTH,T.width),a.pixelStorei(a.UNPACK_IMAGE_HEIGHT,T.height),a.pixelStorei(a.UNPACK_SKIP_PIXELS,g),a.pixelStorei(a.UNPACK_SKIP_ROWS,_),a.pixelStorei(a.UNPACK_SKIP_IMAGES,S);const L=t.isDataArrayTexture||t.isData3DTexture||t.isArrayTexture;if(e.isRenderTargetTexture||e.isDepthTexture){const Q=l.get(e),q=l.get(t),J=l.get(Q.renderTarget),ee=l.get(q.renderTarget),se=J.framebuffers[Q.cacheKey],fe=ee.framebuffers[q.cacheKey];u.bindFramebuffer(a.READ_FRAMEBUFFER,se),u.bindFramebuffer(a.DRAW_FRAMEBUFFER,fe);let ue=a.COLOR_BUFFER_BIT;e.isDepthTexture&&(ue=a.DEPTH_BUFFER_BIT),a.blitFramebuffer(g,_,f,m,M,w,f,m,ue,a.NEAREST),u.bindFramebuffer(a.READ_FRAMEBUFFER,null),u.bindFramebuffer(a.DRAW_FRAMEBUFFER,null)}else L?e.isDataTexture||e.isData3DTexture?a.texSubImage3D(d,o,M,w,v,f,m,x,p,h,T.data):t.isCompressedArrayTexture?a.compressedTexSubImage3D(d,o,M,w,v,f,m,x,p,T.data):a.texSubImage3D(d,o,M,w,v,f,m,x,p,h,T):e.isDataTexture?a.texSubImage2D(d,o,M,w,f,m,p,h,T.data):e.isCompressedTexture?a.compressedTexSubImage2D(d,o,M,w,T.width,T.height,p,T.data):a.texSubImage2D(d,o,M,w,f,m,p,h,T);a.pixelStorei(a.UNPACK_ROW_LENGTH,E),a.pixelStorei(a.UNPACK_IMAGE_HEIGHT,F),a.pixelStorei(a.UNPACK_SKIP_PIXELS,I),a.pixelStorei(a.UNPACK_SKIP_ROWS,z),a.pixelStorei(a.UNPACK_SKIP_IMAGES,G),o===0&&t.generateMipmaps&&a.generateMipmap(d),u.unbindTexture()}copyFramebufferToTexture(e,t,s){const{gl:r}=this,{state:n}=this.backend,{textureGPU:o}=this.backend.get(e),{x:a,y:l,z:u,w:c}=s,d=e.isDepthTexture===!0||t.renderTarget&&t.renderTarget.samples>0,h=t.renderTarget?t.renderTarget.height:this.backend.getDrawingBufferSize().y;if(d){const p=a!==0||l!==0;let f,m;if(e.isDepthTexture===!0?(f=r.DEPTH_BUFFER_BIT,m=r.DEPTH_ATTACHMENT,t.stencil&&(f|=r.STENCIL_BUFFER_BIT)):(f=r.COLOR_BUFFER_BIT,m=r.COLOR_ATTACHMENT0),p){const x=this.backend.get(t.renderTarget),g=x.framebuffers[t.getCacheKey()],_=x.msaaFrameBuffer;n.bindFramebuffer(r.DRAW_FRAMEBUFFER,g),n.bindFramebuffer(r.READ_FRAMEBUFFER,_);const S=h-l-c;r.blitFramebuffer(a,S,a+u,S+c,a,S,a+u,S+c,f,r.NEAREST),n.bindFramebuffer(r.READ_FRAMEBUFFER,g),n.bindTexture(r.TEXTURE_2D,o),r.copyTexSubImage2D(r.TEXTURE_2D,0,0,0,a,S,u,c),n.unbindTexture()}else{const x=r.createFramebuffer();n.bindFramebuffer(r.DRAW_FRAMEBUFFER,x),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,m,r.TEXTURE_2D,o,0),r.blitFramebuffer(0,0,u,c,0,0,u,c,f,r.NEAREST),r.deleteFramebuffer(x)}}else n.bindTexture(r.TEXTURE_2D,o),r.copyTexSubImage2D(r.TEXTURE_2D,0,0,0,a,h-c-l,u,c),n.unbindTexture();e.generateMipmaps&&this.generateMipmaps(e),this.backend._setFramebuffer(t)}setupRenderBufferStorage(e,t,s,r=!1){const{gl:n}=this,o=t.renderTarget,{depthTexture:a,depthBuffer:l,stencilBuffer:u,width:c,height:d}=o;if(n.bindRenderbuffer(n.RENDERBUFFER,e),l&&!u){let h=n.DEPTH_COMPONENT24;r===!0?this.extensions.get("WEBGL_multisampled_render_to_texture").renderbufferStorageMultisampleEXT(n.RENDERBUFFER,o.samples,h,c,d):s>0?(a&&a.isDepthTexture&&a.type===n.FLOAT&&(h=n.DEPTH_COMPONENT32F),n.renderbufferStorageMultisample(n.RENDERBUFFER,s,h,c,d)):n.renderbufferStorage(n.RENDERBUFFER,h,c,d),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,e)}else l&&u&&(s>0?n.renderbufferStorageMultisample(n.RENDERBUFFER,s,n.DEPTH24_STENCIL8,c,d):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,c,d),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,e));n.bindRenderbuffer(n.RENDERBUFFER,null)}async copyTextureToBuffer(e,t,s,r,n,o){const{backend:a,gl:l}=this,{textureGPU:u,glFormat:c,glType:d}=this.backend.get(e),h=l.createFramebuffer();l.bindFramebuffer(l.READ_FRAMEBUFFER,h);const p=e.isCubeTexture?l.TEXTURE_CUBE_MAP_POSITIVE_X+o:l.TEXTURE_2D;l.framebufferTexture2D(l.READ_FRAMEBUFFER,l.COLOR_ATTACHMENT0,p,u,0);const f=this._getTypedArrayType(d),m=this._getBytesPerTexel(d,c),g=r*n*m,_=l.createBuffer();l.bindBuffer(l.PIXEL_PACK_BUFFER,_),l.bufferData(l.PIXEL_PACK_BUFFER,g,l.STREAM_READ),l.readPixels(t,s,r,n,c,d,0),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),await a.utils._clientWaitAsync();const S=new f(g/f.BYTES_PER_ELEMENT);return l.bindBuffer(l.PIXEL_PACK_BUFFER,_),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,S),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),l.deleteFramebuffer(h),S}_getTypedArrayType(e){const{gl:t}=this;if(e===t.UNSIGNED_BYTE)return Uint8Array;if(e===t.UNSIGNED_SHORT_4_4_4_4||e===t.UNSIGNED_SHORT_5_5_5_1||e===t.UNSIGNED_SHORT_5_6_5||e===t.UNSIGNED_SHORT)return Uint16Array;if(e===t.UNSIGNED_INT)return Uint32Array;if(e===t.HALF_FLOAT)return Uint16Array;if(e===t.FLOAT)return Float32Array;throw new Error(`Unsupported WebGL type: ${e}`)}_getBytesPerTexel(e,t){const{gl:s}=this;let r=0;if(e===s.UNSIGNED_BYTE&&(r=1),(e===s.UNSIGNED_SHORT_4_4_4_4||e===s.UNSIGNED_SHORT_5_5_5_1||e===s.UNSIGNED_SHORT_5_6_5||e===s.UNSIGNED_SHORT||e===s.HALF_FLOAT)&&(r=2),(e===s.UNSIGNED_INT||e===s.FLOAT)&&(r=4),t===s.RGBA)return r*4;if(t===s.RGB)return r*3;if(t===s.ALPHA)return r}}function yN(i){return i.isDataTexture?i.image.data:typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&i instanceof ImageBitmap||typeof OffscreenCanvas<"u"&&i instanceof OffscreenCanvas?i:i.data}class KK{constructor(e){this.backend=e,this.gl=this.backend.gl,this.availableExtensions=this.gl.getSupportedExtensions(),this.extensions={}}get(e){let t=this.extensions[e];return t===void 0&&(t=this.gl.getExtension(e),this.extensions[e]=t),t}has(e){return this.availableExtensions.includes(e)}}class XK{constructor(e){this.backend=e,this.maxAnisotropy=null}getMaxAnisotropy(){if(this.maxAnisotropy!==null)return this.maxAnisotropy;const e=this.backend.gl,t=this.backend.extensions;if(t.has("EXT_texture_filter_anisotropic")===!0){const s=t.get("EXT_texture_filter_anisotropic");this.maxAnisotropy=e.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else this.maxAnisotropy=0;return this.maxAnisotropy}}const xN={WEBGL_multi_draw:"WEBGL_multi_draw",WEBGL_compressed_texture_astc:"texture-compression-astc",WEBGL_compressed_texture_etc:"texture-compression-etc2",WEBGL_compressed_texture_etc1:"texture-compression-etc1",WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBKIT_WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBGL_compressed_texture_s3tc:"texture-compression-bc",EXT_texture_compression_bptc:"texture-compression-bptc",EXT_disjoint_timer_query_webgl2:"timestamp-query",OVR_multiview2:"OVR_multiview2"};class YK{constructor(e){this.gl=e.gl,this.extensions=e.extensions,this.info=e.renderer.info,this.mode=null,this.index=0,this.type=null,this.object=null}render(e,t){const{gl:s,mode:r,object:n,type:o,info:a,index:l}=this;l!==0?s.drawElements(r,t,o,e):s.drawArrays(r,e,t),a.update(n,t,1)}renderInstances(e,t,s){const{gl:r,mode:n,type:o,index:a,object:l,info:u}=this;s!==0&&(a!==0?r.drawElementsInstanced(n,t,o,e,s):r.drawArraysInstanced(n,e,t,s),u.update(l,t,s))}renderMultiDraw(e,t,s){const{extensions:r,mode:n,object:o,info:a}=this;if(s===0)return;const l=r.get("WEBGL_multi_draw");if(l===null)for(let u=0;u<s;u++)this.render(e[u],t[u]);else{this.index!==0?l.multiDrawElementsWEBGL(n,t,0,this.type,e,0,s):l.multiDrawArraysWEBGL(n,e,0,t,0,s);let u=0;for(let c=0;c<s;c++)u+=t[c];a.update(o,u,1)}}renderMultiDrawInstances(e,t,s,r){const{extensions:n,mode:o,object:a,info:l}=this;if(s===0)return;const u=n.get("WEBGL_multi_draw");if(u===null)for(let c=0;c<s;c++)this.renderInstances(e[c],t[c],r[c]);else{this.index!==0?u.multiDrawElementsInstancedWEBGL(o,t,0,this.type,e,0,r,0,s):u.multiDrawArraysInstancedWEBGL(o,e,0,t,0,r,0,s);let c=0;for(let d=0;d<s;d++)c+=t[d]*r[d];l.update(a,c,1)}}}class H${constructor(e=256){this.trackTimestamp=!0,this.maxQueries=e,this.currentQueryIndex=0,this.queryOffsets=new Map,this.isDisposed=!1,this.lastValue=0,this.pendingResolve=!1}allocateQueriesForContext(){}async resolveQueriesAsync(){}dispose(){}}class QK extends H${constructor(e,t,s=2048){if(super(s),this.gl=e,this.type=t,this.ext=e.getExtension("EXT_disjoint_timer_query_webgl2")||e.getExtension("EXT_disjoint_timer_query"),!this.ext){console.warn("EXT_disjoint_timer_query not supported; timestamps will be disabled."),this.trackTimestamp=!1;return}this.queries=[];for(let r=0;r<this.maxQueries;r++)this.queries.push(e.createQuery());this.activeQuery=null,this.queryStates=new Map}allocateQueriesForContext(e){if(!this.trackTimestamp)return null;if(this.currentQueryIndex+2>this.maxQueries)return ta(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`),null;const t=this.currentQueryIndex;return this.currentQueryIndex+=2,this.queryStates.set(t,"inactive"),this.queryOffsets.set(e.id,t),t}beginQuery(e){if(!this.trackTimestamp||this.isDisposed)return;const t=this.queryOffsets.get(e.id);if(t==null||this.activeQuery!==null)return;const s=this.queries[t];if(s)try{this.queryStates.get(t)==="inactive"&&(this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT,s),this.activeQuery=t,this.queryStates.set(t,"started"))}catch(r){console.error("Error in beginQuery:",r),this.activeQuery=null,this.queryStates.set(t,"inactive")}}endQuery(e){if(!this.trackTimestamp||this.isDisposed)return;const t=this.queryOffsets.get(e.id);if(t!=null&&this.activeQuery===t)try{this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),this.queryStates.set(t,"ended"),this.activeQuery=null}catch(s){console.error("Error in endQuery:",s),this.queryStates.set(t,"inactive"),this.activeQuery=null}}async resolveQueriesAsync(){if(!this.trackTimestamp||this.pendingResolve)return this.lastValue;this.pendingResolve=!0;try{const e=[];for(const[r,n]of this.queryStates)if(n==="ended"){const o=this.queries[r];e.push(this.resolveQuery(o))}if(e.length===0)return this.lastValue;const s=(await Promise.all(e)).reduce((r,n)=>r+n,0);return this.lastValue=s,this.currentQueryIndex=0,this.queryOffsets.clear(),this.queryStates.clear(),this.activeQuery=null,s}catch(e){return console.error("Error resolving queries:",e),this.lastValue}finally{this.pendingResolve=!1}}async resolveQuery(e){return new Promise(t=>{if(this.isDisposed){t(this.lastValue);return}let s,r=!1;const n=()=>{s&&(clearTimeout(s),s=null)},o=l=>{r||(r=!0,n(),t(l))},a=()=>{if(this.isDisposed){o(this.lastValue);return}try{if(this.gl.getParameter(this.ext.GPU_DISJOINT_EXT)){o(this.lastValue);return}if(!this.gl.getQueryParameter(e,this.gl.QUERY_RESULT_AVAILABLE)){s=setTimeout(a,1);return}const c=this.gl.getQueryParameter(e,this.gl.QUERY_RESULT);t(Number(c)/1e6)}catch(l){console.error("Error checking query:",l),t(this.lastValue)}};a()})}dispose(){if(!this.isDisposed&&(this.isDisposed=!0,!!this.trackTimestamp)){for(const e of this.queries)this.gl.deleteQuery(e);this.queries=[],this.queryStates.clear(),this.queryOffsets.clear(),this.lastValue=0,this.activeQuery=null}}}const bN=new Dt;class wN extends W${constructor(e={}){super(e),this.isWebGLBackend=!0,this.attributeUtils=null,this.extensions=null,this.capabilities=null,this.textureUtils=null,this.bufferRenderer=null,this.gl=null,this.state=null,this.utils=null,this.vaoCache={},this.transformFeedbackCache={},this.discard=!1,this.disjoint=null,this.parallel=null,this._currentContext=null,this._knownBindings=new WeakSet,this._supportsInvalidateFramebuffer=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),this._xrFramebuffer=null}init(e){super.init(e);const t=this.parameters,s={antialias:e.samples>0,alpha:!0,depth:e.depth,stencil:e.stencil},r=t.context!==void 0?t.context:e.domElement.getContext("webgl2",s);function n(o){o.preventDefault();const a={api:"WebGL",message:o.statusMessage||"Unknown reason",reason:null,originalEvent:o};e.onDeviceLost(a)}this._onContextLost=n,e.domElement.addEventListener("webglcontextlost",n,!1),this.gl=r,this.extensions=new KK(this),this.capabilities=new XK(this),this.attributeUtils=new jK(this),this.textureUtils=new qK(this),this.bufferRenderer=new YK(this),this.state=new WK(this),this.utils=new HK(this),this.extensions.get("EXT_color_buffer_float"),this.extensions.get("WEBGL_clip_cull_distance"),this.extensions.get("OES_texture_float_linear"),this.extensions.get("EXT_color_buffer_half_float"),this.extensions.get("WEBGL_multisampled_render_to_texture"),this.extensions.get("WEBGL_render_shared_exponent"),this.extensions.get("WEBGL_multi_draw"),this.extensions.get("OVR_multiview2"),this.disjoint=this.extensions.get("EXT_disjoint_timer_query_webgl2"),this.parallel=this.extensions.get("KHR_parallel_shader_compile")}get coordinateSystem(){return Pr}async getArrayBufferAsync(e){return await this.attributeUtils.getArrayBufferAsync(e)}async waitForGPU(){await this.utils._clientWaitAsync()}async makeXRCompatible(){this.gl.getContextAttributes().xrCompatible!==!0&&await this.gl.makeXRCompatible()}setXRTarget(e){this._xrFramebuffer=e}setXRRenderTargetTextures(e,t,s=null){const r=this.gl;if(this.set(e.texture,{textureGPU:t,glInternalFormat:r.RGBA8}),s!==null){const n=e.stencilBuffer?r.DEPTH24_STENCIL8:r.DEPTH_COMPONENT24;this.set(e.depthTexture,{textureGPU:s,glInternalFormat:n}),this.extensions.has("WEBGL_multisampled_render_to_texture")===!0&&e._autoAllocateDepthBuffer===!0&&e.multiview===!1&&console.warn("THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided"),e._autoAllocateDepthBuffer=!1}}initTimestampQuery(e){if(!this.disjoint||!this.trackTimestamp)return;const t=e.isComputeNode?"compute":"render";this.timestampQueryPool[t]||(this.timestampQueryPool[t]=new QK(this.gl,t,2048));const s=this.timestampQueryPool[t];s.allocateQueriesForContext(e)!==null&&s.beginQuery(e)}prepareTimestampBuffer(e){if(!this.disjoint||!this.trackTimestamp)return;const t=e.isComputeNode?"compute":"render";this.timestampQueryPool[t].endQuery(e)}getContext(){return this.gl}beginRender(e){const{state:t}=this,s=this.get(e);if(e.viewport)this.updateViewport(e);else{const{width:n,height:o}=this.getDrawingBufferSize(bN);t.viewport(0,0,n,o)}if(e.scissor){const{x:n,y:o,width:a,height:l}=e.scissorValue;t.scissor(n,e.height-l-o,a,l)}this.initTimestampQuery(e),s.previousContext=this._currentContext,this._currentContext=e,this._setFramebuffer(e),this.clear(e.clearColor,e.clearDepth,e.clearStencil,e,!1);const r=e.occlusionQueryCount;r>0&&(s.currentOcclusionQueries=s.occlusionQueries,s.currentOcclusionQueryObjects=s.occlusionQueryObjects,s.lastOcclusionObject=null,s.occlusionQueries=new Array(r),s.occlusionQueryObjects=new Array(r),s.occlusionQueryIndex=0)}finishRender(e){const{gl:t,state:s}=this,r=this.get(e),n=r.previousContext;s.resetVertexState();const o=e.occlusionQueryCount;o>0&&(o>r.occlusionQueryIndex&&t.endQuery(t.ANY_SAMPLES_PASSED),this.resolveOccludedAsync(e));const a=e.textures;if(a!==null)for(let u=0;u<a.length;u++){const c=a[u];c.generateMipmaps&&this.generateMipmaps(c)}this._currentContext=n;const l=e.renderTarget;if(e.textures!==null&&l){const u=this.get(l);if(l.samples>0&&this._useMultisampledExtension(l)===!1){const c=u.framebuffers[e.getCacheKey()];let d=t.COLOR_BUFFER_BIT;l.resolveDepthBuffer&&(l.depthBuffer&&(d|=t.DEPTH_BUFFER_BIT),l.stencilBuffer&&l.resolveStencilBuffer&&(d|=t.STENCIL_BUFFER_BIT));const h=u.msaaFrameBuffer,p=u.msaaRenderbuffers,f=e.textures,m=f.length>1;if(s.bindFramebuffer(t.READ_FRAMEBUFFER,h),s.bindFramebuffer(t.DRAW_FRAMEBUFFER,c),m)for(let x=0;x<f.length;x++)t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0+x,t.RENDERBUFFER,null),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+x,t.TEXTURE_2D,null,0);for(let x=0;x<f.length;x++){if(m){const{textureGPU:g}=this.get(f[x]);t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,p[x]),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,g,0)}if(e.scissor){const{x:g,y:_,width:S,height:M}=e.scissorValue,w=e.height-M-_;t.blitFramebuffer(g,w,g+S,w+M,g,w,g+S,w+M,d,t.NEAREST)}else t.blitFramebuffer(0,0,e.width,e.height,0,0,e.width,e.height,d,t.NEAREST)}if(m)for(let x=0;x<f.length;x++){const{textureGPU:g}=this.get(f[x]);t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0+x,t.RENDERBUFFER,p[x]),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+x,t.TEXTURE_2D,g,0)}this._supportsInvalidateFramebuffer===!0&&t.invalidateFramebuffer(t.READ_FRAMEBUFFER,u.invalidationArray)}else if(l.resolveDepthBuffer===!1&&u.framebuffers){const c=u.framebuffers[e.getCacheKey()];s.bindFramebuffer(t.DRAW_FRAMEBUFFER,c),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,u.depthInvalidationArray)}}if(n!==null)if(this._setFramebuffer(n),n.viewport)this.updateViewport(n);else{const{width:u,height:c}=this.getDrawingBufferSize(bN);s.viewport(0,0,u,c)}this.prepareTimestampBuffer(e)}resolveOccludedAsync(e){const t=this.get(e),{currentOcclusionQueries:s,currentOcclusionQueryObjects:r}=t;if(s&&r){const n=new WeakSet,{gl:o}=this;t.currentOcclusionQueryObjects=null,t.currentOcclusionQueries=null;const a=()=>{let l=0;for(let u=0;u<s.length;u++){const c=s[u];c!==null&&o.getQueryParameter(c,o.QUERY_RESULT_AVAILABLE)&&(o.getQueryParameter(c,o.QUERY_RESULT)===0&&n.add(r[u]),s[u]=null,o.deleteQuery(c),l++)}l<s.length?requestAnimationFrame(a):t.occluded=n};a()}}isOccluded(e,t){const s=this.get(e);return s.occluded&&s.occluded.has(t)}updateViewport(e){const{state:t}=this,{x:s,y:r,width:n,height:o}=e.viewportValue;t.viewport(s,e.height-o-r,n,o)}setScissorTest(e){this.state.setScissorTest(e)}getClearColor(){const e=super.getClearColor();return e.r*=e.a,e.g*=e.a,e.b*=e.a,e}clear(e,t,s,r=null,n=!0){const{gl:o,renderer:a}=this;r===null&&(r={textures:null,clearColorValue:this.getClearColor()});let l=0;if(e&&(l|=o.COLOR_BUFFER_BIT),t&&(l|=o.DEPTH_BUFFER_BIT),s&&(l|=o.STENCIL_BUFFER_BIT),l!==0){let u;r.clearColorValue?u=r.clearColorValue:u=this.getClearColor();const c=a.getClearDepth(),d=a.getClearStencil();if(t&&this.state.setDepthMask(!0),r.textures===null)o.clearColor(u.r,u.g,u.b,u.a),o.clear(l);else{if(n&&this._setFramebuffer(r),e)for(let h=0;h<r.textures.length;h++)h===0?o.clearBufferfv(o.COLOR,h,[u.r,u.g,u.b,u.a]):o.clearBufferfv(o.COLOR,h,[0,0,0,1]);t&&s?o.clearBufferfi(o.DEPTH_STENCIL,0,c,d):t?o.clearBufferfv(o.DEPTH,0,[c]):s&&o.clearBufferiv(o.STENCIL,0,[d])}}}beginCompute(e){const{state:t,gl:s}=this;t.bindFramebuffer(s.FRAMEBUFFER,null),this.initTimestampQuery(e)}compute(e,t,s,r){const{state:n,gl:o}=this;this.discard===!1&&(o.enable(o.RASTERIZER_DISCARD),this.discard=!0);const{programGPU:a,transformBuffers:l,attributes:u}=this.get(r),c=this._getVaoKey(u),d=this.vaoCache[c];d===void 0?this.vaoCache[c]=this._createVao(u):n.setVertexState(d),n.useProgram(a),this._bindUniforms(s);const h=this._getTransformFeedback(l);o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,h),o.beginTransformFeedback(o.POINTS),u[0].isStorageInstancedBufferAttribute?o.drawArraysInstanced(o.POINTS,0,1,t.count):o.drawArrays(o.POINTS,0,t.count),o.endTransformFeedback(),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,null);for(let p=0;p<l.length;p++){const f=l[p];f.pbo&&this.has(f.pbo)&&this.textureUtils.copyBufferToTexture(f.transformBuffer,f.pbo),f.switchBuffers()}}finishCompute(e){const t=this.gl;this.discard=!1,t.disable(t.RASTERIZER_DISCARD),this.prepareTimestampBuffer(e),this._currentContext&&this._setFramebuffer(this._currentContext)}_isRenderCameraDepthArray(e){return e.depthTexture&&e.depthTexture.isArrayTexture&&e.camera.isArrayCamera}draw(e){const{object:t,pipeline:s,material:r,context:n,hardwareClippingPlanes:o}=e,{programGPU:a}=this.get(s),{gl:l,state:u}=this,c=this.get(n),d=e.getDrawParameters();if(d===null)return;this._bindUniforms(e.getBindings());const h=t.isMesh&&t.matrixWorld.determinant()<0;u.setMaterial(r,h,o),u.useProgram(a);const p=e.getAttributes(),f=this.get(p);let m=f.vaoGPU;if(m===void 0){const E=this._getVaoKey(p);m=this.vaoCache[E],m===void 0&&(m=this._createVao(p),this.vaoCache[E]=m,f.vaoGPU=m)}const x=e.getIndex(),g=x!==null?this.get(x).bufferGPU:null;u.setVertexState(m,g);const _=c.lastOcclusionObject;if(_!==t&&_!==void 0){if(_!==null&&_.occlusionTest===!0&&(l.endQuery(l.ANY_SAMPLES_PASSED),c.occlusionQueryIndex++),t.occlusionTest===!0){const E=l.createQuery();l.beginQuery(l.ANY_SAMPLES_PASSED,E),c.occlusionQueries[c.occlusionQueryIndex]=E,c.occlusionQueryObjects[c.occlusionQueryIndex]=t}c.lastOcclusionObject=t}const S=this.bufferRenderer;t.isPoints?S.mode=l.POINTS:t.isLineSegments?S.mode=l.LINES:t.isLine?S.mode=l.LINE_STRIP:t.isLineLoop?S.mode=l.LINE_LOOP:r.wireframe===!0?(u.setLineWidth(r.wireframeLinewidth*this.renderer.getPixelRatio()),S.mode=l.LINES):S.mode=l.TRIANGLES;const{vertexCount:M,instanceCount:w}=d;let{firstVertex:v}=d;if(S.object=t,x!==null){v*=x.array.BYTES_PER_ELEMENT;const E=this.get(x);S.index=x.count,S.type=E.type}else S.index=0;const T=()=>{t.isBatchedMesh?t._multiDrawInstances!==null?(ta("THREE.WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),S.renderMultiDrawInstances(t._multiDrawStarts,t._multiDrawCounts,t._multiDrawCount,t._multiDrawInstances)):this.hasFeature("WEBGL_multi_draw")?S.renderMultiDraw(t._multiDrawStarts,t._multiDrawCounts,t._multiDrawCount):ta("THREE.WebGLRenderer: WEBGL_multi_draw not supported."):w>1?S.renderInstances(v,M,w):S.render(v,M)};if(e.camera.isArrayCamera===!0&&e.camera.cameras.length>0&&e.camera.isMultiViewCamera===!1){const E=this.get(e.camera),F=e.camera.cameras,I=e.getBindingGroup("cameraIndex").bindings[0];if(E.indexesGPU===void 0||E.indexesGPU.length!==F.length){const J=new Uint32Array([0,0,0,0]),ee=[];for(let se=0,fe=F.length;se<fe;se++){const ue=l.createBuffer();J[0]=se,l.bindBuffer(l.UNIFORM_BUFFER,ue),l.bufferData(l.UNIFORM_BUFFER,J,l.STATIC_DRAW),ee.push(ue)}E.indexesGPU=ee}const z=this.get(I),G=this.renderer.getPixelRatio(),L=this._currentContext.renderTarget,Q=this._isRenderCameraDepthArray(this._currentContext),q=this._currentContext.activeCubeFace;if(Q){const J=this.get(L.depthTexture);if(J.clearedRenderId!==this.renderer._nodes.nodeFrame.renderId){J.clearedRenderId=this.renderer._nodes.nodeFrame.renderId;const{stencilBuffer:ee}=L;for(let se=0,fe=F.length;se<fe;se++)this.renderer._activeCubeFace=se,this._currentContext.activeCubeFace=se,this._setFramebuffer(this._currentContext),this.clear(!1,!0,ee,this._currentContext,!1);this.renderer._activeCubeFace=q,this._currentContext.activeCubeFace=q}}for(let J=0,ee=F.length;J<ee;J++){const se=F[J];if(t.layers.test(se.layers)){Q&&(this.renderer._activeCubeFace=J,this._currentContext.activeCubeFace=J,this._setFramebuffer(this._currentContext));const fe=se.viewport;if(fe!==void 0){const ue=fe.x*G,U=fe.y*G,k=fe.width*G,j=fe.height*G;u.viewport(Math.floor(ue),Math.floor(e.context.height-j-U),Math.floor(k),Math.floor(j))}u.bindBufferBase(l.UNIFORM_BUFFER,z.index,E.indexesGPU[J]),T()}this._currentContext.activeCubeFace=q,this.renderer._activeCubeFace=q}}else T()}needsRenderUpdate(){return!1}getRenderCacheKey(){return""}createDefaultTexture(e){this.textureUtils.createDefaultTexture(e)}createTexture(e,t){this.textureUtils.createTexture(e,t)}updateTexture(e,t){this.textureUtils.updateTexture(e,t)}generateMipmaps(e){this.textureUtils.generateMipmaps(e)}destroyTexture(e){this.textureUtils.destroyTexture(e)}async copyTextureToBuffer(e,t,s,r,n,o){return this.textureUtils.copyTextureToBuffer(e,t,s,r,n,o)}createSampler(){}destroySampler(){}createNodeBuilder(e,t){return new VK(e,t)}createProgram(e){const t=this.gl,{stage:s,code:r}=e,n=s==="fragment"?t.createShader(t.FRAGMENT_SHADER):t.createShader(t.VERTEX_SHADER);t.shaderSource(n,r),t.compileShader(n),this.set(e,{shaderGPU:n})}destroyProgram(e){this.delete(e)}createRenderPipeline(e,t){const s=this.gl,r=e.pipeline,{fragmentProgram:n,vertexProgram:o}=r,a=s.createProgram(),l=this.get(n).shaderGPU,u=this.get(o).shaderGPU;if(s.attachShader(a,l),s.attachShader(a,u),s.linkProgram(a),this.set(r,{programGPU:a,fragmentShader:l,vertexShader:u}),t!==null&&this.parallel){const c=new Promise(d=>{const h=this.parallel,p=()=>{s.getProgramParameter(a,h.COMPLETION_STATUS_KHR)?(this._completeCompile(e,r),d()):requestAnimationFrame(p)};p()});t.push(c);return}this._completeCompile(e,r)}_handleSource(e,t){const s=e.split(`
`),r=[],n=Math.max(t-6,0),o=Math.min(t+6,s.length);for(let a=n;a<o;a++){const l=a+1;r.push(`${l===t?">":" "} ${l}: ${s[a]}`)}return r.join(`
`)}_getShaderErrors(e,t,s){const r=e.getShaderParameter(t,e.COMPILE_STATUS),n=e.getShaderInfoLog(t).trim();if(r&&n==="")return"";const o=/ERROR: 0:(\d+)/.exec(n);if(o){const a=parseInt(o[1]);return s.toUpperCase()+`

`+n+`

`+this._handleSource(e.getShaderSource(t),a)}else return n}_logProgramError(e,t,s){if(this.renderer.debug.checkShaderErrors){const r=this.gl,n=r.getProgramInfoLog(e).trim();if(r.getProgramParameter(e,r.LINK_STATUS)===!1)if(typeof this.renderer.debug.onShaderError=="function")this.renderer.debug.onShaderError(r,e,s,t);else{const o=this._getShaderErrors(r,s,"vertex"),a=this._getShaderErrors(r,t,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(e,r.VALIDATE_STATUS)+`

Program Info Log: `+n+`
`+o+`
`+a)}else n!==""&&console.warn("THREE.WebGLProgram: Program Info Log:",n)}}_completeCompile(e,t){const{state:s,gl:r}=this,n=this.get(t),{programGPU:o,fragmentShader:a,vertexShader:l}=n;r.getProgramParameter(o,r.LINK_STATUS)===!1&&this._logProgramError(o,a,l),s.useProgram(o);const u=e.getBindings();this._setupBindings(u,o),this.set(t,{programGPU:o})}createComputePipeline(e,t){const{state:s,gl:r}=this,n={stage:"fragment",code:`#version 300 es
precision highp float;
void main() {}`};this.createProgram(n);const{computeProgram:o}=e,a=r.createProgram(),l=this.get(n).shaderGPU,u=this.get(o).shaderGPU,c=o.transforms,d=[],h=[];for(let x=0;x<c.length;x++){const g=c[x];d.push(g.varyingName),h.push(g.attributeNode)}r.attachShader(a,l),r.attachShader(a,u),r.transformFeedbackVaryings(a,d,r.SEPARATE_ATTRIBS),r.linkProgram(a),r.getProgramParameter(a,r.LINK_STATUS)===!1&&this._logProgramError(a,l,u),s.useProgram(a),this._setupBindings(t,a);const p=o.attributes,f=[],m=[];for(let x=0;x<p.length;x++){const g=p[x].node.attribute;f.push(g),this.has(g)||this.attributeUtils.createAttribute(g,r.ARRAY_BUFFER)}for(let x=0;x<h.length;x++){const g=h[x].attribute;this.has(g)||this.attributeUtils.createAttribute(g,r.ARRAY_BUFFER);const _=this.get(g);m.push(_)}this.set(e,{programGPU:a,transformBuffers:m,attributes:f})}createBindings(e,t){if(this._knownBindings.has(t)===!1){this._knownBindings.add(t);let s=0,r=0;for(const n of t){this.set(n,{textures:r,uniformBuffers:s});for(const o of n.bindings)o.isUniformBuffer&&s++,o.isSampledTexture&&r++}}this.updateBindings(e,t)}updateBindings(e){const{gl:t}=this,s=this.get(e);let r=s.uniformBuffers,n=s.textures;for(const o of e.bindings)if(o.isUniformsGroup||o.isUniformBuffer){const a=o.buffer,l=t.createBuffer();t.bindBuffer(t.UNIFORM_BUFFER,l),t.bufferData(t.UNIFORM_BUFFER,a,t.DYNAMIC_DRAW),this.set(o,{index:r++,bufferGPU:l})}else if(o.isSampledTexture){const{textureGPU:a,glTextureType:l}=this.get(o.texture);this.set(o,{index:n++,textureGPU:a,glTextureType:l})}}updateBinding(e){const t=this.gl;if(e.isUniformsGroup||e.isUniformBuffer){const r=this.get(e).bufferGPU,n=e.buffer;t.bindBuffer(t.UNIFORM_BUFFER,r),t.bufferData(t.UNIFORM_BUFFER,n,t.DYNAMIC_DRAW)}}createIndexAttribute(e){const t=this.gl;this.attributeUtils.createAttribute(e,t.ELEMENT_ARRAY_BUFFER)}createAttribute(e){if(this.has(e))return;const t=this.gl;this.attributeUtils.createAttribute(e,t.ARRAY_BUFFER)}createStorageAttribute(e){if(this.has(e))return;const t=this.gl;this.attributeUtils.createAttribute(e,t.ARRAY_BUFFER)}updateAttribute(e){this.attributeUtils.updateAttribute(e)}destroyAttribute(e){this.attributeUtils.destroyAttribute(e)}hasFeature(e){const t=Object.keys(xN).filter(r=>xN[r]===e),s=this.extensions;for(let r=0;r<t.length;r++)if(s.has(t[r]))return!0;return!1}getMaxAnisotropy(){return this.capabilities.getMaxAnisotropy()}copyTextureToTexture(e,t,s=null,r=null,n=0,o=0){this.textureUtils.copyTextureToTexture(e,t,s,r,n,o)}copyFramebufferToTexture(e,t,s){this.textureUtils.copyFramebufferToTexture(e,t,s)}_setFramebuffer(e){const{gl:t,state:s}=this;let r=null;if(e.textures!==null){const n=e.renderTarget,o=this.get(n),{samples:a,depthBuffer:l,stencilBuffer:u}=n,c=n.isWebGLCubeRenderTarget===!0,d=n.isRenderTarget3D===!0,h=n.depth>1,p=n.isXRRenderTarget===!0,f=p===!0&&n._hasExternalTextures===!0;let m=o.msaaFrameBuffer,x=o.depthRenderbuffer;const g=this.extensions.get("WEBGL_multisampled_render_to_texture"),_=this.extensions.get("OVR_multiview2"),S=this._useMultisampledExtension(n),M=zO(e);let w;if(c?(o.cubeFramebuffers||(o.cubeFramebuffers={}),w=o.cubeFramebuffers[M]):p&&f===!1?w=this._xrFramebuffer:(o.framebuffers||(o.framebuffers={}),w=o.framebuffers[M]),w===void 0){w=t.createFramebuffer(),s.bindFramebuffer(t.FRAMEBUFFER,w);const v=e.textures,T=[];if(c){o.cubeFramebuffers[M]=w;const{textureGPU:F}=this.get(v[0]),I=this.renderer._activeCubeFace;t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+I,F,0)}else{o.framebuffers[M]=w;for(let F=0;F<v.length;F++){const I=v[F],z=this.get(I);z.renderTarget=e.renderTarget,z.cacheKey=M;const G=t.COLOR_ATTACHMENT0+F;if(n.multiview)_.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER,G,z.textureGPU,0,a,0,2);else if(d||h){const L=this.renderer._activeCubeFace;t.framebufferTextureLayer(t.FRAMEBUFFER,G,z.textureGPU,0,L)}else S?g.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,G,t.TEXTURE_2D,z.textureGPU,0,a):t.framebufferTexture2D(t.FRAMEBUFFER,G,t.TEXTURE_2D,z.textureGPU,0)}}const E=u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;if(n._autoAllocateDepthBuffer===!0){const F=t.createRenderbuffer();this.textureUtils.setupRenderBufferStorage(F,e,0,S),o.xrDepthRenderbuffer=F,T.push(u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT),t.bindRenderbuffer(t.RENDERBUFFER,F),t.framebufferRenderbuffer(t.FRAMEBUFFER,E,t.RENDERBUFFER,F)}else if(e.depthTexture!==null){T.push(u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT);const F=this.get(e.depthTexture);if(F.renderTarget=e.renderTarget,F.cacheKey=M,n.multiview)_.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER,E,F.textureGPU,0,a,0,2);else if(f&&S)g.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,E,t.TEXTURE_2D,F.textureGPU,0,a);else if(e.depthTexture.isArrayTexture){const I=this.renderer._activeCubeFace;t.framebufferTextureLayer(t.FRAMEBUFFER,E,F.textureGPU,0,I)}else t.framebufferTexture2D(t.FRAMEBUFFER,E,t.TEXTURE_2D,F.textureGPU,0)}o.depthInvalidationArray=T}else{if(this._isRenderCameraDepthArray(e)){s.bindFramebuffer(t.FRAMEBUFFER,w);const T=this.renderer._activeCubeFace,E=this.get(e.depthTexture),F=u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;t.framebufferTextureLayer(t.FRAMEBUFFER,F,E.textureGPU,0,T)}if((p||S||n.multiview)&&n._isOpaqueFramebuffer!==!0){s.bindFramebuffer(t.FRAMEBUFFER,w);const T=this.get(e.textures[0]);n.multiview?_.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,T.textureGPU,0,a,0,2):S?g.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,T.textureGPU,0,a):t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,T.textureGPU,0);const E=u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;if(n._autoAllocateDepthBuffer===!0){const F=o.xrDepthRenderbuffer;t.bindRenderbuffer(t.RENDERBUFFER,F),t.framebufferRenderbuffer(t.FRAMEBUFFER,E,t.RENDERBUFFER,F)}else{const F=this.get(e.depthTexture);n.multiview?_.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER,E,F.textureGPU,0,a,0,2):S?g.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,E,t.TEXTURE_2D,F.textureGPU,0,a):t.framebufferTexture2D(t.FRAMEBUFFER,E,t.TEXTURE_2D,F.textureGPU,0)}}}if(a>0&&S===!1&&!n.multiview){if(m===void 0){const v=[];m=t.createFramebuffer(),s.bindFramebuffer(t.FRAMEBUFFER,m);const T=[],E=e.textures;for(let F=0;F<E.length;F++){T[F]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,T[F]),v.push(t.COLOR_ATTACHMENT0+F);const I=e.textures[F],z=this.get(I);t.renderbufferStorageMultisample(t.RENDERBUFFER,a,z.glInternalFormat,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+F,t.RENDERBUFFER,T[F])}if(t.bindRenderbuffer(t.RENDERBUFFER,null),o.msaaFrameBuffer=m,o.msaaRenderbuffers=T,l&&x===void 0){x=t.createRenderbuffer(),this.textureUtils.setupRenderBufferStorage(x,e,a),o.depthRenderbuffer=x;const F=u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;v.push(F)}o.invalidationArray=v}r=o.msaaFrameBuffer}else r=w;s.drawBuffers(e,w)}s.bindFramebuffer(t.FRAMEBUFFER,r)}_getVaoKey(e){let t="";for(let s=0;s<e.length;s++){const r=this.get(e[s]);t+=":"+r.id}return t}_createVao(e){const{gl:t}=this,s=t.createVertexArray();t.bindVertexArray(s);for(let r=0;r<e.length;r++){const n=e[r],o=this.get(n);t.bindBuffer(t.ARRAY_BUFFER,o.bufferGPU),t.enableVertexAttribArray(r);let a,l;n.isInterleavedBufferAttribute===!0?(a=n.data.stride*o.bytesPerElement,l=n.offset*o.bytesPerElement):(a=0,l=0),o.isInteger?t.vertexAttribIPointer(r,n.itemSize,o.type,a,l):t.vertexAttribPointer(r,n.itemSize,o.type,n.normalized,a,l),n.isInstancedBufferAttribute&&!n.isInterleavedBufferAttribute?t.vertexAttribDivisor(r,n.meshPerAttribute):n.isInterleavedBufferAttribute&&n.data.isInstancedInterleavedBuffer&&t.vertexAttribDivisor(r,n.data.meshPerAttribute)}return t.bindBuffer(t.ARRAY_BUFFER,null),s}_getTransformFeedback(e){let t="";for(let n=0;n<e.length;n++)t+=":"+e[n].id;let s=this.transformFeedbackCache[t];if(s!==void 0)return s;const{gl:r}=this;s=r.createTransformFeedback(),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,s);for(let n=0;n<e.length;n++){const o=e[n];r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER,n,o.transformBuffer)}return r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,null),this.transformFeedbackCache[t]=s,s}_setupBindings(e,t){const s=this.gl;for(const r of e)for(const n of r.bindings){const a=this.get(n).index;if(n.isUniformsGroup||n.isUniformBuffer){const l=s.getUniformBlockIndex(t,n.name);s.uniformBlockBinding(t,l,a)}else if(n.isSampledTexture){const l=s.getUniformLocation(t,n.name);s.uniform1i(l,a)}}}_bindUniforms(e){const{gl:t,state:s}=this;for(const r of e)for(const n of r.bindings){const o=this.get(n),a=o.index;n.isUniformsGroup||n.isUniformBuffer?s.bindBufferBase(t.UNIFORM_BUFFER,a,o.bufferGPU):n.isSampledTexture&&s.bindTexture(o.glTextureType,o.textureGPU,t.TEXTURE0+a)}}_useMultisampledExtension(e){return e.multiview===!0?!0:e.samples>0&&this.extensions.has("WEBGL_multisampled_render_to_texture")===!0&&e._autoAllocateDepthBuffer!==!1}dispose(){const e=this.extensions.get("WEBGL_lose_context");e&&e.loseContext(),this.renderer.domElement.removeEventListener("webglcontextlost",this._onContextLost)}}const ic={PointList:"point-list",LineList:"line-list",LineStrip:"line-strip",TriangleList:"triangle-list",TriangleStrip:"triangle-strip"},tr={Never:"never",Less:"less",Equal:"equal",LessEqual:"less-equal",Greater:"greater",NotEqual:"not-equal",GreaterEqual:"greater-equal",Always:"always"},gr={Store:"store"},Es={Load:"load",Clear:"clear"},hx={CCW:"ccw"},px={None:"none",Front:"front",Back:"back"},Tc={Uint16:"uint16",Uint32:"uint32"},ce={R8Unorm:"r8unorm",R8Snorm:"r8snorm",R8Uint:"r8uint",R8Sint:"r8sint",R16Uint:"r16uint",R16Sint:"r16sint",R16Float:"r16float",RG8Unorm:"rg8unorm",RG8Snorm:"rg8snorm",RG8Uint:"rg8uint",RG8Sint:"rg8sint",R32Uint:"r32uint",R32Sint:"r32sint",R32Float:"r32float",RG16Uint:"rg16uint",RG16Sint:"rg16sint",RG16Float:"rg16float",RGBA8Unorm:"rgba8unorm",RGBA8UnormSRGB:"rgba8unorm-srgb",RGBA8Snorm:"rgba8snorm",RGBA8Uint:"rgba8uint",RGBA8Sint:"rgba8sint",BGRA8Unorm:"bgra8unorm",BGRA8UnormSRGB:"bgra8unorm-srgb",RGB9E5UFloat:"rgb9e5ufloat",RGB10A2Unorm:"rgb10a2unorm",RG11B10UFloat:"rgb10a2unorm",RG32Uint:"rg32uint",RG32Sint:"rg32sint",RG32Float:"rg32float",RGBA16Uint:"rgba16uint",RGBA16Sint:"rgba16sint",RGBA16Float:"rgba16float",RGBA32Uint:"rgba32uint",RGBA32Sint:"rgba32sint",RGBA32Float:"rgba32float",Depth16Unorm:"depth16unorm",Depth24Plus:"depth24plus",Depth24PlusStencil8:"depth24plus-stencil8",Depth32Float:"depth32float",Depth32FloatStencil8:"depth32float-stencil8",BC1RGBAUnorm:"bc1-rgba-unorm",BC1RGBAUnormSRGB:"bc1-rgba-unorm-srgb",BC2RGBAUnorm:"bc2-rgba-unorm",BC2RGBAUnormSRGB:"bc2-rgba-unorm-srgb",BC3RGBAUnorm:"bc3-rgba-unorm",BC3RGBAUnormSRGB:"bc3-rgba-unorm-srgb",BC4RUnorm:"bc4-r-unorm",BC4RSnorm:"bc4-r-snorm",BC5RGUnorm:"bc5-rg-unorm",BC5RGSnorm:"bc5-rg-snorm",BC6HRGBUFloat:"bc6h-rgb-ufloat",BC6HRGBFloat:"bc6h-rgb-float",BC7RGBAUnorm:"bc7-rgba-unorm",BC7RGBAUnormSRGB:"bc7-rgba-srgb",ETC2RGB8Unorm:"etc2-rgb8unorm",ETC2RGB8UnormSRGB:"etc2-rgb8unorm-srgb",ETC2RGB8A1Unorm:"etc2-rgb8a1unorm",ETC2RGB8A1UnormSRGB:"etc2-rgb8a1unorm-srgb",ETC2RGBA8Unorm:"etc2-rgba8unorm",ETC2RGBA8UnormSRGB:"etc2-rgba8unorm-srgb",EACR11Unorm:"eac-r11unorm",EACR11Snorm:"eac-r11snorm",EACRG11Unorm:"eac-rg11unorm",EACRG11Snorm:"eac-rg11snorm",ASTC4x4Unorm:"astc-4x4-unorm",ASTC4x4UnormSRGB:"astc-4x4-unorm-srgb",ASTC5x4Unorm:"astc-5x4-unorm",ASTC5x4UnormSRGB:"astc-5x4-unorm-srgb",ASTC5x5Unorm:"astc-5x5-unorm",ASTC5x5UnormSRGB:"astc-5x5-unorm-srgb",ASTC6x5Unorm:"astc-6x5-unorm",ASTC6x5UnormSRGB:"astc-6x5-unorm-srgb",ASTC6x6Unorm:"astc-6x6-unorm",ASTC6x6UnormSRGB:"astc-6x6-unorm-srgb",ASTC8x5Unorm:"astc-8x5-unorm",ASTC8x5UnormSRGB:"astc-8x5-unorm-srgb",ASTC8x6Unorm:"astc-8x6-unorm",ASTC8x6UnormSRGB:"astc-8x6-unorm-srgb",ASTC8x8Unorm:"astc-8x8-unorm",ASTC8x8UnormSRGB:"astc-8x8-unorm-srgb",ASTC10x5Unorm:"astc-10x5-unorm",ASTC10x5UnormSRGB:"astc-10x5-unorm-srgb",ASTC10x6Unorm:"astc-10x6-unorm",ASTC10x6UnormSRGB:"astc-10x6-unorm-srgb",ASTC10x8Unorm:"astc-10x8-unorm",ASTC10x8UnormSRGB:"astc-10x8-unorm-srgb",ASTC10x10Unorm:"astc-10x10-unorm",ASTC10x10UnormSRGB:"astc-10x10-unorm-srgb",ASTC12x10Unorm:"astc-12x10-unorm",ASTC12x10UnormSRGB:"astc-12x10-unorm-srgb",ASTC12x12Unorm:"astc-12x12-unorm",ASTC12x12UnormSRGB:"astc-12x12-unorm-srgb"},fx={ClampToEdge:"clamp-to-edge",Repeat:"repeat",MirrorRepeat:"mirror-repeat"},kl={Linear:"linear",Nearest:"nearest"},as={Zero:"zero",One:"one",Src:"src",OneMinusSrc:"one-minus-src",SrcAlpha:"src-alpha",OneMinusSrcAlpha:"one-minus-src-alpha",Dst:"dst",OneMinusDst:"one-minus-dst",DstAlpha:"dst-alpha",OneMinusDstAlpha:"one-minus-dst-alpha",SrcAlphaSaturated:"src-alpha-saturated",Constant:"constant",OneMinusConstant:"one-minus-constant"},Al={Add:"add",Subtract:"subtract",ReverseSubtract:"reverse-subtract",Min:"min",Max:"max"},MN={None:0,All:15},Ea={Keep:"keep",Zero:"zero",Replace:"replace",Invert:"invert",IncrementClamp:"increment-clamp",DecrementClamp:"decrement-clamp",IncrementWrap:"increment-wrap",DecrementWrap:"decrement-wrap"},mx={Storage:"storage",ReadOnlyStorage:"read-only-storage"},gx={WriteOnly:"write-only",ReadOnly:"read-only",ReadWrite:"read-write"},TN={NonFiltering:"non-filtering",Comparison:"comparison"},Cl={Float:"float",UnfilterableFloat:"unfilterable-float",Depth:"depth",SInt:"sint",UInt:"uint"},vN={TwoD:"2d",ThreeD:"3d"},Pi={TwoD:"2d",TwoDArray:"2d-array",Cube:"cube",ThreeD:"3d"},ZK={All:"all"},_f={Vertex:"vertex",Instance:"instance"},Eb={CoreFeaturesAndLimits:"core-features-and-limits",DepthClipControl:"depth-clip-control",Depth32FloatStencil8:"depth32float-stencil8",TextureCompressionBC:"texture-compression-bc",TextureCompressionBCSliced3D:"texture-compression-bc-sliced-3d",TextureCompressionETC2:"texture-compression-etc2",TextureCompressionASTC:"texture-compression-astc",TextureCompressionASTCSliced3D:"texture-compression-astc-sliced-3d",TimestampQuery:"timestamp-query",IndirectFirstInstance:"indirect-first-instance",ShaderF16:"shader-f16",RG11B10UFloat:"rg11b10ufloat-renderable",BGRA8UNormStorage:"bgra8unorm-storage",Float32Filterable:"float32-filterable",Float32Blendable:"float32-blendable",ClipDistances:"clip-distances",DualSourceBlending:"dual-source-blending",Subgroups:"subgroups",TextureFormatsTier1:"texture-formats-tier1",TextureFormatsTier2:"texture-formats-tier2"};class JK extends Hw{constructor(e,t){super(e),this.texture=t,this.version=t?t.version:0,this.isSampler=!0}}class e9 extends JK{constructor(e,t,s){super(e,t?t.value:null),this.textureNode=t,this.groupNode=s}update(){this.texture=this.textureNode.value}}class t9 extends $${constructor(e,t){super(e,t?t.array:null),this.attribute=t,this.isStorageBuffer=!0}}let s9=0;class i9 extends t9{constructor(e,t){super("StorageBuffer_"+s9++,e?e.value:null),this.nodeUniform=e,this.access=e?e.access:ar.READ_WRITE,this.groupNode=t}get buffer(){return this.nodeUniform.value}}class r9 extends ja{constructor(e){super(),this.device=e;const t=`
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`,s=`
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`,r=`
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;this.mipmapSampler=e.createSampler({minFilter:kl.Linear}),this.flipYSampler=e.createSampler({minFilter:kl.Nearest}),this.transferPipelines={},this.flipYPipelines={},this.mipmapVertexShaderModule=e.createShaderModule({label:"mipmapVertex",code:t}),this.mipmapFragmentShaderModule=e.createShaderModule({label:"mipmapFragment",code:s}),this.flipYFragmentShaderModule=e.createShaderModule({label:"flipYFragment",code:r})}getTransferPipeline(e){let t=this.transferPipelines[e];return t===void 0&&(t=this.device.createRenderPipeline({label:`mipmap-${e}`,vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.mipmapFragmentShaderModule,entryPoint:"main",targets:[{format:e}]},primitive:{topology:ic.TriangleStrip,stripIndexFormat:Tc.Uint32},layout:"auto"}),this.transferPipelines[e]=t),t}getFlipYPipeline(e){let t=this.flipYPipelines[e];return t===void 0&&(t=this.device.createRenderPipeline({label:`flipY-${e}`,vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.flipYFragmentShaderModule,entryPoint:"main",targets:[{format:e}]},primitive:{topology:ic.TriangleStrip,stripIndexFormat:Tc.Uint32},layout:"auto"}),this.flipYPipelines[e]=t),t}flipY(e,t,s=0){const r=t.format,{width:n,height:o}=t.size,a=this.getTransferPipeline(r),l=this.getFlipYPipeline(r),u=this.device.createTexture({size:{width:n,height:o,depthOrArrayLayers:1},format:r,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),c=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:Pi.TwoD,baseArrayLayer:s}),d=u.createView({baseMipLevel:0,mipLevelCount:1,dimension:Pi.TwoD,baseArrayLayer:0}),h=this.device.createCommandEncoder({}),p=(f,m,x)=>{const g=f.getBindGroupLayout(0),_=this.device.createBindGroup({layout:g,entries:[{binding:0,resource:this.flipYSampler},{binding:1,resource:m}]}),S=h.beginRenderPass({colorAttachments:[{view:x,loadOp:Es.Clear,storeOp:gr.Store,clearValue:[0,0,0,0]}]});S.setPipeline(f),S.setBindGroup(0,_),S.draw(4,1,0,0),S.end()};p(a,c,d),p(l,d,c),this.device.queue.submit([h.finish()]),u.destroy()}generateMipmaps(e,t,s=0){const r=this.get(e);r.useCount===void 0&&(r.useCount=0,r.layers=[]);const n=r.layers[s]||this._mipmapCreateBundles(e,t,s),o=this.device.createCommandEncoder({});this._mipmapRunBundles(o,n),this.device.queue.submit([o.finish()]),r.useCount!==0&&(r.layers[s]=n),r.useCount++}_mipmapCreateBundles(e,t,s){const r=this.getTransferPipeline(t.format),n=r.getBindGroupLayout(0);let o=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:Pi.TwoD,baseArrayLayer:s});const a=[];for(let l=1;l<t.mipLevelCount;l++){const u=this.device.createBindGroup({layout:n,entries:[{binding:0,resource:this.mipmapSampler},{binding:1,resource:o}]}),c=e.createView({baseMipLevel:l,mipLevelCount:1,dimension:Pi.TwoD,baseArrayLayer:s}),d={colorAttachments:[{view:c,loadOp:Es.Clear,storeOp:gr.Store,clearValue:[0,0,0,0]}]},h=this.device.createRenderBundleEncoder({colorFormats:[t.format]});h.setPipeline(r),h.setBindGroup(0,u),h.draw(4,1,0,0),a.push({renderBundles:[h.finish()],passDescriptor:d}),o=c}return a}_mipmapRunBundles(e,t){const s=t.length;for(let r=0;r<s;r++){const n=t[r],o=e.beginRenderPass(n.passDescriptor);o.executeBundles(n.renderBundles),o.end()}}}const n9={[OD]:"never",[m0]:"less",[$D]:"equal",[zD]:"less-equal",[VD]:"greater",[GD]:"greater-equal",[jD]:"always",[UD]:"not-equal"},o9=[0,1,3,2,4,5];class a9{constructor(e){this.backend=e,this._passUtils=null,this.defaultTexture={},this.defaultCubeTexture={},this.defaultVideoFrame=null,this.colorBuffer=null,this.depthTexture=new Hn,this.depthTexture.name="depthBuffer"}createSampler(e){const t=this.backend,s=t.device,r=t.get(e),n={addressModeU:this._convertAddressMode(e.wrapS),addressModeV:this._convertAddressMode(e.wrapT),addressModeW:this._convertAddressMode(e.wrapR),magFilter:this._convertFilterMode(e.magFilter),minFilter:this._convertFilterMode(e.minFilter),mipmapFilter:this._convertFilterMode(e.minFilter),maxAnisotropy:1};n.magFilter===kl.Linear&&n.minFilter===kl.Linear&&n.mipmapFilter===kl.Linear&&(n.maxAnisotropy=e.anisotropy),e.isDepthTexture&&e.compareFunction!==null&&(n.compare=n9[e.compareFunction]),r.sampler=s.createSampler(n)}createDefaultTexture(e){let t;const s=Ab(e);e.isCubeTexture?t=this._getDefaultCubeTextureGPU(s):e.isVideoTexture?this.backend.get(e).externalTexture=this._getDefaultVideoFrame():t=this._getDefaultTextureGPU(s),this.backend.get(e).texture=t}createTexture(e,t={}){const s=this.backend,r=s.get(e);if(r.initialized)throw new Error("WebGPUTextureUtils: Texture already initialized.");t.needsMipmaps===void 0&&(t.needsMipmaps=!1),t.levels===void 0&&(t.levels=1),t.depth===void 0&&(t.depth=1);const{width:n,height:o,depth:a,levels:l}=t;e.isFramebufferTexture&&(t.renderTarget?t.format=this.backend.utils.getCurrentColorFormat(t.renderTarget):t.format=this.backend.utils.getPreferredCanvasFormat());const u=this._getDimension(e),c=e.internalFormat||t.format||Ab(e,s.device);r.format=c;const{samples:d,primarySamples:h,isMSAA:p}=s.utils.getTextureSampleData(e);let f=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC;e.isStorageTexture===!0&&(f|=GPUTextureUsage.STORAGE_BINDING),e.isCompressedTexture!==!0&&e.isCompressedArrayTexture!==!0&&(f|=GPUTextureUsage.RENDER_ATTACHMENT);const m={label:e.name,size:{width:n,height:o,depthOrArrayLayers:a},mipLevelCount:l,sampleCount:h,dimension:u,format:c,usage:f};if(e.isVideoTexture){const x=e.source.data,g=new VideoFrame(x);m.size.width=g.displayWidth,m.size.height=g.displayHeight,g.close(),r.externalTexture=x}else{if(c===void 0){console.warn("WebGPURenderer: Texture format not supported."),this.createDefaultTexture(e);return}e.isCubeTexture&&(m.textureBindingViewDimension=Pi.Cube),r.texture=s.device.createTexture(m)}if(p){const x=Object.assign({},m);x.label=x.label+"-msaa",x.sampleCount=d,r.msaaTexture=s.device.createTexture(x)}r.initialized=!0,r.textureDescriptorGPU=m}destroyTexture(e){const t=this.backend,s=t.get(e);s.texture!==void 0&&s.texture.destroy(),s.msaaTexture!==void 0&&s.msaaTexture.destroy(),t.delete(e)}destroySampler(e){const s=this.backend.get(e);delete s.sampler}generateMipmaps(e){const t=this.backend.get(e);if(e.isCubeTexture)for(let s=0;s<6;s++)this._generateMipmaps(t.texture,t.textureDescriptorGPU,s);else{const s=e.image.depth||1;for(let r=0;r<s;r++)this._generateMipmaps(t.texture,t.textureDescriptorGPU,r)}}getColorBuffer(){this.colorBuffer&&this.colorBuffer.destroy();const e=this.backend,{width:t,height:s}=e.getDrawingBufferSize();return this.colorBuffer=e.device.createTexture({label:"colorBuffer",size:{width:t,height:s,depthOrArrayLayers:1},sampleCount:e.utils.getSampleCount(e.renderer.samples),format:e.utils.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),this.colorBuffer}getDepthBuffer(e=!0,t=!1){const s=this.backend,{width:r,height:n}=s.getDrawingBufferSize(),o=this.depthTexture,a=s.get(o).texture;let l,u;if(t?(l=Ko,u=ka):e&&(l=fo,u=_i),a!==void 0){if(o.image.width===r&&o.image.height===n&&o.format===l&&o.type===u)return a;this.destroyTexture(o)}return o.name="depthBuffer",o.format=l,o.type=u,o.image.width=r,o.image.height=n,this.createTexture(o,{width:r,height:n}),s.get(o).texture}updateTexture(e,t){const s=this.backend.get(e),{textureDescriptorGPU:r}=s;if(!(e.isRenderTargetTexture||r===void 0)){if(e.isDataTexture)this._copyBufferToTexture(t.image,s.texture,r,0,e.flipY);else if(e.isArrayTexture||e.isDataArrayTexture||e.isData3DTexture)for(let n=0;n<t.image.depth;n++)this._copyBufferToTexture(t.image,s.texture,r,n,e.flipY,n);else if(e.isCompressedTexture||e.isCompressedArrayTexture)this._copyCompressedBufferToTexture(e.mipmaps,s.texture,r);else if(e.isCubeTexture)this._copyCubeMapToTexture(t.images,s.texture,r,e.flipY,e.premultiplyAlpha);else if(e.isVideoTexture){const n=e.source.data;s.externalTexture=n}else this._copyImageToTexture(t.image,s.texture,r,0,e.flipY,e.premultiplyAlpha);s.version=e.version,e.onUpdate&&e.onUpdate(e)}}async copyTextureToBuffer(e,t,s,r,n,o){const a=this.backend.device,l=this.backend.get(e),u=l.texture,c=l.textureDescriptorGPU.format,d=this._getBytesPerTexel(c);let h=r*d;h=Math.ceil(h/256)*256;const p=a.createBuffer({size:r*n*d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),f=a.createCommandEncoder();f.copyTextureToBuffer({texture:u,origin:{x:t,y:s,z:o}},{buffer:p,bytesPerRow:h},{width:r,height:n});const m=this._getTypedArrayType(c);a.queue.submit([f.finish()]),await p.mapAsync(GPUMapMode.READ);const x=p.getMappedRange();return new m(x)}_getDefaultTextureGPU(e){let t=this.defaultTexture[e];if(t===void 0){const s=new Yi;s.minFilter=yi,s.magFilter=yi,this.createTexture(s,{width:1,height:1,format:e}),this.defaultTexture[e]=t=s}return this.backend.get(t).texture}_getDefaultCubeTextureGPU(e){let t=this.defaultTexture[e];if(t===void 0){const s=new mm;s.minFilter=yi,s.magFilter=yi,this.createTexture(s,{width:1,height:1,depth:6}),this.defaultCubeTexture[e]=t=s}return this.backend.get(t).texture}_getDefaultVideoFrame(){let e=this.defaultVideoFrame;if(e===null){const t={timestamp:0,codedWidth:1,codedHeight:1,format:"RGBA"};this.defaultVideoFrame=e=new VideoFrame(new Uint8Array([0,0,0,255]),t)}return e}_copyCubeMapToTexture(e,t,s,r,n){for(let o=0;o<6;o++){const a=e[o],l=r===!0?o9[o]:o;a.isDataTexture?this._copyBufferToTexture(a.image,t,s,l,r):this._copyImageToTexture(a,t,s,l,r,n)}}_copyImageToTexture(e,t,s,r,n,o){this.backend.device.queue.copyExternalImageToTexture({source:e,flipY:n},{texture:t,mipLevel:0,origin:{x:0,y:0,z:r},premultipliedAlpha:o},{width:e.width,height:e.height,depthOrArrayLayers:1})}_getPassUtils(){let e=this._passUtils;return e===null&&(this._passUtils=e=new r9(this.backend.device)),e}_generateMipmaps(e,t,s=0){this._getPassUtils().generateMipmaps(e,t,s)}_flipY(e,t,s=0){this._getPassUtils().flipY(e,t,s)}_copyBufferToTexture(e,t,s,r,n,o=0){const a=this.backend.device,l=e.data,u=this._getBytesPerTexel(s.format),c=e.width*u;a.queue.writeTexture({texture:t,mipLevel:0,origin:{x:0,y:0,z:r}},l,{offset:e.width*e.height*u*o,bytesPerRow:c},{width:e.width,height:e.height,depthOrArrayLayers:1}),n===!0&&this._flipY(t,s,r)}_copyCompressedBufferToTexture(e,t,s){const r=this.backend.device,n=this._getBlockData(s.format),o=s.size.depthOrArrayLayers>1;for(let a=0;a<e.length;a++){const l=e[a],u=l.width,c=l.height,d=o?s.size.depthOrArrayLayers:1,h=Math.ceil(u/n.width)*n.byteLength,p=h*Math.ceil(c/n.height);for(let f=0;f<d;f++)r.queue.writeTexture({texture:t,mipLevel:a,origin:{x:0,y:0,z:f}},l.data,{offset:f*p,bytesPerRow:h,rowsPerImage:Math.ceil(c/n.height)},{width:Math.ceil(u/n.width)*n.width,height:Math.ceil(c/n.height)*n.height,depthOrArrayLayers:1})}}_getBlockData(e){if(e===ce.BC1RGBAUnorm||e===ce.BC1RGBAUnormSRGB)return{byteLength:8,width:4,height:4};if(e===ce.BC2RGBAUnorm||e===ce.BC2RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(e===ce.BC3RGBAUnorm||e===ce.BC3RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(e===ce.BC4RUnorm||e===ce.BC4RSnorm)return{byteLength:8,width:4,height:4};if(e===ce.BC5RGUnorm||e===ce.BC5RGSnorm)return{byteLength:16,width:4,height:4};if(e===ce.BC6HRGBUFloat||e===ce.BC6HRGBFloat)return{byteLength:16,width:4,height:4};if(e===ce.BC7RGBAUnorm||e===ce.BC7RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(e===ce.ETC2RGB8Unorm||e===ce.ETC2RGB8UnormSRGB)return{byteLength:8,width:4,height:4};if(e===ce.ETC2RGB8A1Unorm||e===ce.ETC2RGB8A1UnormSRGB)return{byteLength:8,width:4,height:4};if(e===ce.ETC2RGBA8Unorm||e===ce.ETC2RGBA8UnormSRGB)return{byteLength:16,width:4,height:4};if(e===ce.EACR11Unorm)return{byteLength:8,width:4,height:4};if(e===ce.EACR11Snorm)return{byteLength:8,width:4,height:4};if(e===ce.EACRG11Unorm)return{byteLength:16,width:4,height:4};if(e===ce.EACRG11Snorm)return{byteLength:16,width:4,height:4};if(e===ce.ASTC4x4Unorm||e===ce.ASTC4x4UnormSRGB)return{byteLength:16,width:4,height:4};if(e===ce.ASTC5x4Unorm||e===ce.ASTC5x4UnormSRGB)return{byteLength:16,width:5,height:4};if(e===ce.ASTC5x5Unorm||e===ce.ASTC5x5UnormSRGB)return{byteLength:16,width:5,height:5};if(e===ce.ASTC6x5Unorm||e===ce.ASTC6x5UnormSRGB)return{byteLength:16,width:6,height:5};if(e===ce.ASTC6x6Unorm||e===ce.ASTC6x6UnormSRGB)return{byteLength:16,width:6,height:6};if(e===ce.ASTC8x5Unorm||e===ce.ASTC8x5UnormSRGB)return{byteLength:16,width:8,height:5};if(e===ce.ASTC8x6Unorm||e===ce.ASTC8x6UnormSRGB)return{byteLength:16,width:8,height:6};if(e===ce.ASTC8x8Unorm||e===ce.ASTC8x8UnormSRGB)return{byteLength:16,width:8,height:8};if(e===ce.ASTC10x5Unorm||e===ce.ASTC10x5UnormSRGB)return{byteLength:16,width:10,height:5};if(e===ce.ASTC10x6Unorm||e===ce.ASTC10x6UnormSRGB)return{byteLength:16,width:10,height:6};if(e===ce.ASTC10x8Unorm||e===ce.ASTC10x8UnormSRGB)return{byteLength:16,width:10,height:8};if(e===ce.ASTC10x10Unorm||e===ce.ASTC10x10UnormSRGB)return{byteLength:16,width:10,height:10};if(e===ce.ASTC12x10Unorm||e===ce.ASTC12x10UnormSRGB)return{byteLength:16,width:12,height:10};if(e===ce.ASTC12x12Unorm||e===ce.ASTC12x12UnormSRGB)return{byteLength:16,width:12,height:12}}_convertAddressMode(e){let t=fx.ClampToEdge;return e===mc?t=fx.Repeat:e===gc&&(t=fx.MirrorRepeat),t}_convertFilterMode(e){let t=kl.Linear;return(e===yi||e===LD||e===sh)&&(t=kl.Nearest),t}_getBytesPerTexel(e){if(e===ce.R8Unorm||e===ce.R8Snorm||e===ce.R8Uint||e===ce.R8Sint)return 1;if(e===ce.R16Uint||e===ce.R16Sint||e===ce.R16Float||e===ce.RG8Unorm||e===ce.RG8Snorm||e===ce.RG8Uint||e===ce.RG8Sint)return 2;if(e===ce.R32Uint||e===ce.R32Sint||e===ce.R32Float||e===ce.RG16Uint||e===ce.RG16Sint||e===ce.RG16Float||e===ce.RGBA8Unorm||e===ce.RGBA8UnormSRGB||e===ce.RGBA8Snorm||e===ce.RGBA8Uint||e===ce.RGBA8Sint||e===ce.BGRA8Unorm||e===ce.BGRA8UnormSRGB||e===ce.RGB9E5UFloat||e===ce.RGB10A2Unorm||e===ce.RG11B10UFloat||e===ce.Depth32Float||e===ce.Depth24Plus||e===ce.Depth24PlusStencil8||e===ce.Depth32FloatStencil8)return 4;if(e===ce.RG32Uint||e===ce.RG32Sint||e===ce.RG32Float||e===ce.RGBA16Uint||e===ce.RGBA16Sint||e===ce.RGBA16Float)return 8;if(e===ce.RGBA32Uint||e===ce.RGBA32Sint||e===ce.RGBA32Float)return 16}_getTypedArrayType(e){if(e===ce.R8Uint)return Uint8Array;if(e===ce.R8Sint)return Int8Array;if(e===ce.R8Unorm)return Uint8Array;if(e===ce.R8Snorm)return Int8Array;if(e===ce.RG8Uint)return Uint8Array;if(e===ce.RG8Sint)return Int8Array;if(e===ce.RG8Unorm)return Uint8Array;if(e===ce.RG8Snorm)return Int8Array;if(e===ce.RGBA8Uint)return Uint8Array;if(e===ce.RGBA8Sint)return Int8Array;if(e===ce.RGBA8Unorm)return Uint8Array;if(e===ce.RGBA8Snorm)return Int8Array;if(e===ce.R16Uint)return Uint16Array;if(e===ce.R16Sint)return Int16Array;if(e===ce.RG16Uint)return Uint16Array;if(e===ce.RG16Sint)return Int16Array;if(e===ce.RGBA16Uint)return Uint16Array;if(e===ce.RGBA16Sint)return Int16Array;if(e===ce.R16Float||e===ce.RG16Float||e===ce.RGBA16Float)return Uint16Array;if(e===ce.R32Uint)return Uint32Array;if(e===ce.R32Sint)return Int32Array;if(e===ce.R32Float)return Float32Array;if(e===ce.RG32Uint)return Uint32Array;if(e===ce.RG32Sint)return Int32Array;if(e===ce.RG32Float)return Float32Array;if(e===ce.RGBA32Uint)return Uint32Array;if(e===ce.RGBA32Sint)return Int32Array;if(e===ce.RGBA32Float)return Float32Array;if(e===ce.BGRA8Unorm||e===ce.BGRA8UnormSRGB)return Uint8Array;if(e===ce.RGB10A2Unorm||e===ce.RGB9E5UFloat||e===ce.RG11B10UFloat)return Uint32Array;if(e===ce.Depth32Float)return Float32Array;if(e===ce.Depth24Plus||e===ce.Depth24PlusStencil8)return Uint32Array;if(e===ce.Depth32FloatStencil8)return Float32Array}_getDimension(e){let t;return e.is3DTexture||e.isData3DTexture?t=vN.ThreeD:t=vN.TwoD,t}}function Ab(i,e=null){const t=i.format,s=i.type,r=i.colorSpace,n=Ls.getTransfer(r);let o;if(i.isCompressedTexture===!0||i.isCompressedArrayTexture===!0)switch(t){case vf:o=n===jt?ce.BC1RGBAUnormSRGB:ce.BC1RGBAUnorm;break;case Sf:o=n===jt?ce.BC2RGBAUnormSRGB:ce.BC2RGBAUnorm;break;case Ef:o=n===jt?ce.BC3RGBAUnormSRGB:ce.BC3RGBAUnorm;break;case zx:o=n===jt?ce.ETC2RGB8UnormSRGB:ce.ETC2RGB8Unorm;break;case Vx:o=n===jt?ce.ETC2RGBA8UnormSRGB:ce.ETC2RGBA8Unorm;break;case Ux:o=n===jt?ce.ASTC4x4UnormSRGB:ce.ASTC4x4Unorm;break;case Gx:o=n===jt?ce.ASTC5x4UnormSRGB:ce.ASTC5x4Unorm;break;case jx:o=n===jt?ce.ASTC5x5UnormSRGB:ce.ASTC5x5Unorm;break;case Wx:o=n===jt?ce.ASTC6x5UnormSRGB:ce.ASTC6x5Unorm;break;case Hx:o=n===jt?ce.ASTC6x6UnormSRGB:ce.ASTC6x6Unorm;break;case qx:o=n===jt?ce.ASTC8x5UnormSRGB:ce.ASTC8x5Unorm;break;case Kx:o=n===jt?ce.ASTC8x6UnormSRGB:ce.ASTC8x6Unorm;break;case Xx:o=n===jt?ce.ASTC8x8UnormSRGB:ce.ASTC8x8Unorm;break;case Yx:o=n===jt?ce.ASTC10x5UnormSRGB:ce.ASTC10x5Unorm;break;case Qx:o=n===jt?ce.ASTC10x6UnormSRGB:ce.ASTC10x6Unorm;break;case Zx:o=n===jt?ce.ASTC10x8UnormSRGB:ce.ASTC10x8Unorm;break;case Jx:o=n===jt?ce.ASTC10x10UnormSRGB:ce.ASTC10x10Unorm;break;case eb:o=n===jt?ce.ASTC12x10UnormSRGB:ce.ASTC12x10Unorm;break;case tb:o=n===jt?ce.ASTC12x12UnormSRGB:ce.ASTC12x12Unorm;break;case fn:o=n===jt?ce.RGBA8UnormSRGB:ce.RGBA8Unorm;break;default:console.error("WebGPURenderer: Unsupported texture format.",t)}else switch(t){case fn:switch(s){case Vd:o=ce.RGBA8Snorm;break;case Ud:o=ce.RGBA16Sint;break;case Zu:o=ce.RGBA16Uint;break;case _i:o=ce.RGBA32Uint;break;case _r:o=ce.RGBA32Sint;break;case xr:o=n===jt?ce.RGBA8UnormSRGB:ce.RGBA8Unorm;break;case Cr:o=ce.RGBA16Float;break;case Kr:o=ce.RGBA32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.",s)}break;case c0:switch(s){case BD:o=ce.RGB9E5UFloat;break;default:console.error("WebGPURenderer: Unsupported texture type with RGBFormat.",s)}break;case d0:switch(s){case Vd:o=ce.R8Snorm;break;case Ud:o=ce.R16Sint;break;case Zu:o=ce.R16Uint;break;case _i:o=ce.R32Uint;break;case _r:o=ce.R32Sint;break;case xr:o=ce.R8Unorm;break;case Cr:o=ce.R16Float;break;case Kr:o=ce.R32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RedFormat.",s)}break;case Ol:switch(s){case Vd:o=ce.RG8Snorm;break;case Ud:o=ce.RG16Sint;break;case Zu:o=ce.RG16Uint;break;case _i:o=ce.RG32Uint;break;case _r:o=ce.RG32Sint;break;case xr:o=ce.RG8Unorm;break;case Cr:o=ce.RG16Float;break;case Kr:o=ce.RG32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RGFormat.",s)}break;case fo:switch(s){case Zu:o=ce.Depth16Unorm;break;case _i:o=ce.Depth24Plus;break;case Kr:o=ce.Depth32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with DepthFormat.",s)}break;case Ko:switch(s){case ka:o=ce.Depth24PlusStencil8;break;case Kr:e&&e.features.has(Eb.Depth32FloatStencil8)===!1&&console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'),o=ce.Depth32FloatStencil8;break;default:console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.",s)}break;case h0:switch(s){case _r:o=ce.R32Sint;break;case _i:o=ce.R32Uint;break;default:console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.",s)}break;case p0:switch(s){case _r:o=ce.RG32Sint;break;case _i:o=ce.RG32Uint;break;default:console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.",s)}break;case f0:switch(s){case _r:o=ce.RGBA32Sint;break;case _i:o=ce.RGBA32Uint;break;default:console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.",s)}break;default:console.error("WebGPURenderer: Unsupported texture format.",t)}return o}const l9=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i,u9=/([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig,SN={f32:"float",i32:"int",u32:"uint",bool:"bool","vec2<f32>":"vec2","vec2<i32>":"ivec2","vec2<u32>":"uvec2","vec2<bool>":"bvec2",vec2f:"vec2",vec2i:"ivec2",vec2u:"uvec2",vec2b:"bvec2","vec3<f32>":"vec3","vec3<i32>":"ivec3","vec3<u32>":"uvec3","vec3<bool>":"bvec3",vec3f:"vec3",vec3i:"ivec3",vec3u:"uvec3",vec3b:"bvec3","vec4<f32>":"vec4","vec4<i32>":"ivec4","vec4<u32>":"uvec4","vec4<bool>":"bvec4",vec4f:"vec4",vec4i:"ivec4",vec4u:"uvec4",vec4b:"bvec4","mat2x2<f32>":"mat2",mat2x2f:"mat2","mat3x3<f32>":"mat3",mat3x3f:"mat3","mat4x4<f32>":"mat4",mat4x4f:"mat4",sampler:"sampler",texture_1d:"texture",texture_2d:"texture",texture_2d_array:"texture",texture_multisampled_2d:"cubeTexture",texture_depth_2d:"depthTexture",texture_depth_2d_array:"depthTexture",texture_depth_multisampled_2d:"depthTexture",texture_depth_cube:"depthTexture",texture_depth_cube_array:"depthTexture",texture_3d:"texture3D",texture_cube:"cubeTexture",texture_cube_array:"cubeTexture",texture_storage_1d:"storageTexture",texture_storage_2d:"storageTexture",texture_storage_2d_array:"storageTexture",texture_storage_3d:"storageTexture"},c9=i=>{i=i.trim();const e=i.match(l9);if(e!==null&&e.length===4){const t=e[2],s=[];let r=null;for(;(r=u9.exec(t))!==null;)s.push({name:r[1],type:r[2]});const n=[];for(let c=0;c<s.length;c++){const{name:d,type:h}=s[c];let p=h;p.startsWith("ptr")?p="pointer":(p.startsWith("texture")&&(p=h.split("<")[0]),p=SN[p]),n.push(new Gw(p,d))}const o=i.substring(e[0].length),a=e[3]||"void",l=e[1]!==void 0?e[1]:"";return{type:SN[a]||a,inputs:n,name:l,inputsCode:t,blockCode:o,outputType:a}}else throw new Error("FunctionNode: Function is not a WGSL code.")};class d9 extends Ww{constructor(e){const{type:t,inputs:s,name:r,inputsCode:n,blockCode:o,outputType:a}=c9(e);super(t,s,r),this.inputsCode=n,this.blockCode=o,this.outputType=a}getCode(e=this.name){const t=this.outputType!=="void"?"-> "+this.outputType:"";return`fn ${e} ( ${this.inputsCode.trim()} ) ${t}`+this.blockCode}}class h9 extends B${parseFunction(e){return new d9(e)}}const ju=typeof self<"u"?self.GPUShaderStage:{VERTEX:1,FRAGMENT:2,COMPUTE:4},p9={[ar.READ_ONLY]:"read",[ar.WRITE_ONLY]:"write",[ar.READ_WRITE]:"read_write"},EN={[mc]:"repeat",[Ra]:"clamp",[gc]:"mirror"},yf={vertex:ju?ju.VERTEX:1,fragment:ju?ju.FRAGMENT:2,compute:ju?ju.COMPUTE:4},AN={instance:!0,swizzleAssign:!1,storageBuffer:!0},f9={"^^":"tsl_xor"},m9={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat2:"mat2x2<f32>",mat3:"mat3x3<f32>",mat4:"mat4x4<f32>"},CN={},dn={tsl_xor:new Ci("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),mod_float:new Ci("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new Ci("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new Ci("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new Ci("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new Ci("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new Ci("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new Ci("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new Ci("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping_float:new Ci("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),mirrorWrapping_float:new Ci("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),clampWrapping_float:new Ci("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),biquadraticTexture:new Ci(`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`)},Od={dFdx:"dpdx",dFdy:"- dpdy",mod_float:"tsl_mod_float",mod_vec2:"tsl_mod_vec2",mod_vec3:"tsl_mod_vec3",mod_vec4:"tsl_mod_vec4",equals_bool:"tsl_equals_bool",equals_bvec2:"tsl_equals_bvec2",equals_bvec3:"tsl_equals_bvec3",equals_bvec4:"tsl_equals_bvec4",inversesqrt:"inverseSqrt",bitcast:"bitcast<f32>"};typeof navigator<"u"&&/Windows/g.test(navigator.userAgent)&&(dn.pow_float=new Ci("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"),dn.pow_vec2=new Ci("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }",[dn.pow_float]),dn.pow_vec3=new Ci("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }",[dn.pow_float]),dn.pow_vec4=new Ci("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }",[dn.pow_float]),Od.pow_float="tsl_pow_float",Od.pow_vec2="tsl_pow_vec2",Od.pow_vec3="tsl_pow_vec3",Od.pow_vec4="tsl_pow_vec4");let q$="";(typeof navigator<"u"&&/Firefox|Deno/g.test(navigator.userAgent))!==!0&&(q$+=`diagnostic( off, derivative_uniformity );
`);class g9 extends L${constructor(e,t){super(e,t,new h9),this.uniformGroups={},this.builtins={},this.directives={},this.scopedArrays=new Map}needsToWorkingColorSpace(e){return e.isVideoTexture===!0&&e.colorSpace!==ea}_generateTextureSample(e,t,s,r,n=this.shaderStage){return n==="fragment"?r?`textureSample( ${t}, ${t}_sampler, ${s}, ${r} )`:`textureSample( ${t}, ${t}_sampler, ${s} )`:this._generateTextureSampleLevel(e,t,s,"0",r)}_generateVideoSample(e,t,s=this.shaderStage){if(s==="fragment")return`textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`;console.error(`WebGPURenderer: THREE.VideoTexture does not support ${s} shader.`)}_generateTextureSampleLevel(e,t,s,r,n){return this.isUnfilterable(e)===!1?`textureSampleLevel( ${t}, ${t}_sampler, ${s}, ${r} )`:this.isFilteredTexture(e)?this.generateFilteredTexture(e,t,s,r):this.generateTextureLod(e,t,s,n,r)}generateWrapFunction(e){const t=`tsl_coord_${EN[e.wrapS]}S_${EN[e.wrapT]}_${e.isData3DTexture?"3d":"2d"}T`;let s=CN[t];if(s===void 0){const r=[],n=e.isData3DTexture?"vec3f":"vec2f";let o=`fn ${t}( coord : ${n} ) -> ${n} {

	return ${n}(
`;const a=(l,u)=>{l===mc?(r.push(dn.repeatWrapping_float),o+=`		tsl_repeatWrapping_float( coord.${u} )`):l===Ra?(r.push(dn.clampWrapping_float),o+=`		tsl_clampWrapping_float( coord.${u} )`):l===gc?(r.push(dn.mirrorWrapping_float),o+=`		tsl_mirrorWrapping_float( coord.${u} )`):(o+=`		coord.${u}`,console.warn(`WebGPURenderer: Unsupported texture wrap type "${l}" for vertex shader.`))};a(e.wrapS,"x"),o+=`,
`,a(e.wrapT,"y"),e.isData3DTexture&&(o+=`,
`,a(e.wrapR,"z")),o+=`
	);

}
`,CN[t]=s=new Ci(o,r)}return s.build(this),t}generateArrayDeclaration(e,t){return`array< ${this.getType(e)}, ${t} >`}generateTextureDimension(e,t,s){const r=this.getDataFromNode(e,this.shaderStage,this.globalCache);r.dimensionsSnippet===void 0&&(r.dimensionsSnippet={});let n=r.dimensionsSnippet[s];if(r.dimensionsSnippet[s]===void 0){let o,a;const{primarySamples:l}=this.renderer.backend.utils.getTextureSampleData(e),u=l>1;e.isData3DTexture?a="vec3<u32>":a="vec2<u32>",u||e.isVideoTexture||e.isStorageTexture?o=t:o=`${t}${s?`, u32( ${s} )`:""}`,n=new Cf(new Pf(`textureDimensions( ${o} )`,a)),r.dimensionsSnippet[s]=n,(e.isArrayTexture||e.isDataArrayTexture||e.isData3DTexture)&&(r.arrayLayerCount=new Cf(new Pf(`textureNumLayers(${t})`,"u32"))),e.isTextureCube&&(r.cubeFaceCount=new Cf(new Pf("6u","u32")))}return n.build(this)}generateFilteredTexture(e,t,s,r="0u"){this._include("biquadraticTexture");const n=this.generateWrapFunction(e),o=this.generateTextureDimension(e,t,r);return`tsl_biquadraticTexture( ${t}, ${n}( ${s} ), ${o}, u32( ${r} ) )`}generateTextureLod(e,t,s,r,n="0u"){const o=this.generateWrapFunction(e),a=this.generateTextureDimension(e,t,n),l=e.isData3DTexture?"vec3":"vec2",u=`${l}<u32>( ${o}( ${s} ) * ${l}<f32>( ${a} ) )`;return this.generateTextureLoad(e,t,u,r,n)}generateTextureLoad(e,t,s,r,n="0u"){let o;return e.isVideoTexture===!0?o=`textureLoad( ${t}, ${s} )`:r?o=`textureLoad( ${t}, ${s}, ${r}, u32( ${n} ) )`:(o=`textureLoad( ${t}, ${s}, u32( ${n} ) )`,this.renderer.backend.compatibilityMode&&e.isDepthTexture&&(o+=".x")),o}generateTextureStore(e,t,s,r,n){let o;return r?o=`textureStore( ${t}, ${s}, ${r}, ${n} )`:o=`textureStore( ${t}, ${s}, ${n} )`,o}isSampleCompare(e){return e.isDepthTexture===!0&&e.compareFunction!==null}isUnfilterable(e){return this.getComponentTypeFromTexture(e)!=="float"||!this.isAvailable("float32Filterable")&&e.isDataTexture===!0&&e.type===Kr||this.isSampleCompare(e)===!1&&e.minFilter===yi&&e.magFilter===yi||this.renderer.backend.utils.getTextureSampleData(e).primarySamples>1}generateTexture(e,t,s,r,n=this.shaderStage){let o=null;return e.isVideoTexture===!0?o=this._generateVideoSample(t,s,n):this.isUnfilterable(e)?o=this.generateTextureLod(e,t,s,r,"0",n):o=this._generateTextureSample(e,t,s,r,n),o}generateTextureGrad(e,t,s,r,n,o=this.shaderStage){if(o==="fragment")return`textureSampleGrad( ${t}, ${t}_sampler, ${s},  ${r[0]}, ${r[1]} )`;console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${o} shader.`)}generateTextureCompare(e,t,s,r,n,o=this.shaderStage){if(o==="fragment")return e.isDepthTexture===!0&&e.isArrayTexture===!0?`textureSampleCompare( ${t}, ${t}_sampler, ${s}, ${n}, ${r} )`:`textureSampleCompare( ${t}, ${t}_sampler, ${s}, ${r} )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`)}generateTextureLevel(e,t,s,r,n,o=this.shaderStage){let a=null;return e.isVideoTexture===!0?a=this._generateVideoSample(t,s,o):a=this._generateTextureSampleLevel(e,t,s,r,n),a}generateTextureBias(e,t,s,r,n,o=this.shaderStage){if(o==="fragment")return`textureSampleBias( ${t}, ${t}_sampler, ${s}, ${r} )`;console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${o} shader.`)}getPropertyName(e,t=this.shaderStage){if(e.isNodeVarying===!0&&e.needsInterpolation===!0){if(t==="vertex")return`varyings.${e.name}`}else if(e.isNodeUniform===!0){const s=e.name,r=e.type;return r==="texture"||r==="cubeTexture"||r==="storageTexture"||r==="texture3D"?s:r==="buffer"||r==="storageBuffer"||r==="indirectStorageBuffer"?this.isCustomStruct(e)?s:s+".value":e.groupNode.name+"."+s}return super.getPropertyName(e)}getOutputStructName(){return"output"}getFunctionOperator(e){const t=f9[e];return t!==void 0?(this._include(t),t):null}getNodeAccess(e,t){return t!=="compute"?ar.READ_ONLY:e.access}getStorageAccess(e,t){return p9[this.getNodeAccess(e,t)]}getUniformFromNode(e,t,s,r=null){const n=super.getUniformFromNode(e,t,s,r),o=this.getDataFromNode(e,s,this.globalCache);if(o.uniformGPU===void 0){let a;const l=e.groupNode,u=l.name,c=this.getBindGroupArray(u,s);if(t==="texture"||t==="cubeTexture"||t==="storageTexture"||t==="texture3D"){let d=null;const h=this.getNodeAccess(e,s);if(t==="texture"||t==="storageTexture"?d=new Hm(n.name,n.node,l,h):t==="cubeTexture"?d=new G$(n.name,n.node,l,h):t==="texture3D"&&(d=new j$(n.name,n.node,l,h)),d.store=e.isStorageTextureNode===!0,d.setVisibility(yf[s]),this.isUnfilterable(e.value)===!1&&d.store===!1){const p=new e9(`${n.name}_sampler`,n.node,l);p.setVisibility(yf[s]),c.push(p,d),a=[p,d]}else c.push(d),a=[d]}else if(t==="buffer"||t==="storageBuffer"||t==="indirectStorageBuffer"){const d=t==="buffer"?V$:i9,h=new d(e,l);h.setVisibility(yf[s]),c.push(h),a=h,n.name=r||"NodeBuffer_"+n.id}else{const d=this.uniformGroups[s]||(this.uniformGroups[s]={});let h=d[u];h===void 0&&(h=new U$(u,l),h.setVisibility(yf[s]),d[u]=h,c.push(h)),a=this.getNodeUniform(n,t),h.addUniform(a)}o.uniformGPU=a}return n}getBuiltin(e,t,s,r=this.shaderStage){const n=this.builtins[r]||(this.builtins[r]=new Map);return n.has(e)===!1&&n.set(e,{name:e,property:t,type:s}),t}hasBuiltin(e,t=this.shaderStage){return this.builtins[t]!==void 0&&this.builtins[t].has(e)}getVertexIndex(){return this.shaderStage==="vertex"?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}buildFunctionCode(e){const t=e.layout,s=this.flowShaderNode(e),r=[];for(const o of t.inputs)r.push(o.name+" : "+this.getType(o.type));let n=`fn ${t.name}( ${r.join(", ")} ) -> ${this.getType(t.type)} {
${s.vars}
${s.code}
`;return s.result&&(n+=`	return ${s.result};
`),n+=`
}
`,n}getInstanceIndex(){return this.shaderStage==="vertex"?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getInvocationLocalIndex(){return this.getBuiltin("local_invocation_index","invocationLocalIndex","u32","attribute")}getSubgroupSize(){return this.enableSubGroups(),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute")}getInvocationSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_invocation_id","invocationSubgroupIndex","u32","attribute")}getSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_id","subgroupIndex","u32","attribute")}getDrawIndex(){return null}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>")+".xy"}getFragDepth(){return"output."+this.getBuiltin("frag_depth","depth","f32","output")}getClipDistance(){return"varyings.hw_clip_distances"}isFlipY(){return!1}enableDirective(e,t=this.shaderStage){(this.directives[t]||(this.directives[t]=new Set)).add(e)}getDirectives(e){const t=[],s=this.directives[e];if(s!==void 0)for(const r of s)t.push(`enable ${r};`);return t.join(`
`)}enableSubGroups(){this.enableDirective("subgroups")}enableSubgroupsF16(){this.enableDirective("subgroups-f16")}enableClipDistances(){this.enableDirective("clip_distances")}enableShaderF16(){this.enableDirective("f16")}enableDualSourceBlending(){this.enableDirective("dual_source_blending")}enableHardwareClipping(e){this.enableClipDistances(),this.getBuiltin("clip_distances","hw_clip_distances",`array<f32, ${e} >`,"vertex")}getBuiltins(e){const t=[],s=this.builtins[e];if(s!==void 0)for(const{name:r,property:n,type:o}of s.values())t.push(`@builtin( ${r} ) ${n} : ${o}`);return t.join(`,
	`)}getScopedArray(e,t,s,r){return this.scopedArrays.has(e)===!1&&this.scopedArrays.set(e,{name:e,scope:t,bufferType:s,bufferCount:r}),e}getScopedArrays(e){if(e!=="compute")return;const t=[];for(const{name:s,scope:r,bufferType:n,bufferCount:o}of this.scopedArrays.values()){const a=this.getType(n);t.push(`var<${r}> ${s}: array< ${a}, ${o} >;`)}return t.join(`
`)}getAttributes(e){const t=[];if(e==="compute"&&(this.getBuiltin("global_invocation_id","globalId","vec3<u32>","attribute"),this.getBuiltin("workgroup_id","workgroupId","vec3<u32>","attribute"),this.getBuiltin("local_invocation_id","localId","vec3<u32>","attribute"),this.getBuiltin("num_workgroups","numWorkgroups","vec3<u32>","attribute"),this.renderer.hasFeature("subgroups")&&(this.enableDirective("subgroups",e),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute"))),e==="vertex"||e==="compute"){const s=this.getBuiltins("attribute");s&&t.push(s);const r=this.getAttributesArray();for(let n=0,o=r.length;n<o;n++){const a=r[n],l=a.name,u=this.getType(a.type);t.push(`@location( ${n} ) ${l} : ${u}`)}}return t.join(`,
	`)}getStructMembers(e){const t=[];for(const s of e.members){const r=e.output?"@location( "+s.index+" ) ":"";let n=this.getType(s.type);s.atomic&&(n="atomic< "+n+" >"),t.push(`	${r+s.name} : ${n}`)}return e.output&&t.push(`	${this.getBuiltins("output")}`),t.join(`,
`)}getStructs(e){let t="";const s=this.structs[e];if(s.length>0){const r=[];for(const n of s){let o=`struct ${n.name} {
`;o+=this.getStructMembers(n),o+=`
};`,r.push(o)}t=`
`+r.join(`

`)+`
`}return t}getVar(e,t,s=null){let r=`var ${t} : `;return s!==null?r+=this.generateArrayDeclaration(e,s):r+=this.getType(e),r}getVars(e){const t=[],s=this.vars[e];if(s!==void 0)for(const r of s)t.push(`	${this.getVar(r.type,r.name,r.count)};`);return`
${t.join(`
`)}
`}getVaryings(e){const t=[];if(e==="vertex"&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),e==="vertex"||e==="fragment"){const n=this.varyings,o=this.vars[e];for(let a=0;a<n.length;a++){const l=n[a];if(l.needsInterpolation){let u=`@location( ${a} )`;if(l.interpolationType){const c=l.interpolationSampling!==null?`, ${l.interpolationSampling} )`:" )";u+=` @interpolate( ${l.interpolationType}${c}`}else/^(int|uint|ivec|uvec)/.test(l.type)&&(u+=` @interpolate( ${this.renderer.backend.compatibilityMode?"flat, either":"flat"} )`);t.push(`${u} ${l.name} : ${this.getType(l.type)}`)}else e==="vertex"&&o.includes(l)===!1&&o.push(l)}}const s=this.getBuiltins(e);s&&t.push(s);const r=t.join(`,
	`);return e==="vertex"?this._getWGSLStruct("VaryingsStruct","	"+r):r}isCustomStruct(e){const t=e.value,s=e.node,r=(t.isBufferAttribute||t.isInstancedBufferAttribute)&&s.structTypeNode!==null,n=s.value&&s.value.array&&typeof s.value.itemSize=="number"&&s.value.array.length>s.value.itemSize;return r&&!n}getUniforms(e){const t=this.uniforms[e],s=[],r=[],n=[],o={};for(const l of t){const u=l.groupNode.name,c=this.bindingsIndexes[u];if(l.type==="texture"||l.type==="cubeTexture"||l.type==="storageTexture"||l.type==="texture3D"){const d=l.node.value;this.isUnfilterable(d)===!1&&l.node.isStorageTextureNode!==!0&&(this.isSampleCompare(d)?s.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${l.name}_sampler : sampler_comparison;`):s.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${l.name}_sampler : sampler;`));let h,p="";const{primarySamples:f}=this.renderer.backend.utils.getTextureSampleData(d);if(f>1&&(p="_multisampled"),d.isCubeTexture===!0)h="texture_cube<f32>";else if(d.isDepthTexture===!0)this.renderer.backend.compatibilityMode&&d.compareFunction===null?h=`texture${p}_2d<f32>`:h=`texture_depth${p}_2d${d.isArrayTexture===!0?"_array":""}`;else if(l.node.isStorageTextureNode===!0){const m=Ab(d),x=this.getStorageAccess(l.node,e),g=l.node.value.is3DTexture,_=l.node.value.isArrayTexture;h=`texture_storage_${g?"3d":`2d${_?"_array":""}`}<${m}, ${x}>`}else if(d.isArrayTexture===!0||d.isDataArrayTexture===!0||d.isCompressedArrayTexture===!0)h="texture_2d_array<f32>";else if(d.is3DTexture===!0||d.isData3DTexture===!0)h="texture_3d<f32>";else if(d.isVideoTexture===!0)h="texture_external";else{const m=this.getComponentTypeFromTexture(d).charAt(0);h=`texture${p}_2d<${m}32>`}s.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${l.name} : ${h};`)}else if(l.type==="buffer"||l.type==="storageBuffer"||l.type==="indirectStorageBuffer"){const d=l.node,h=this.getType(d.getNodeType(this)),p=d.bufferCount,f=p>0&&l.type==="buffer"?", "+p:"",m=d.isStorageBufferNode?`storage, ${this.getStorageAccess(d,e)}`:"uniform";if(this.isCustomStruct(l))r.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var<${m}> ${l.name} : ${h};`);else{const g=`	value : array< ${d.isAtomic?`atomic<${h}>`:`${h}`}${f} >`;r.push(this._getWGSLStructBinding(l.name,g,m,c.binding++,c.group))}}else{const d=this.getType(this.getVectorType(l.type)),h=l.groupNode.name;(o[h]||(o[h]={index:c.binding++,id:c.group,snippets:[]})).snippets.push(`	${l.name} : ${d}`)}}for(const l in o){const u=o[l];n.push(this._getWGSLStructBinding(l,u.snippets.join(`,
`),"uniform",u.index,u.id))}let a=s.join(`
`);return a+=r.join(`
`),a+=n.join(`
`),a}buildCode(){const e=this.material!==null?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const t in e){this.shaderStage=t;const s=e[t];s.uniforms=this.getUniforms(t),s.attributes=this.getAttributes(t),s.varyings=this.getVaryings(t),s.structs=this.getStructs(t),s.vars=this.getVars(t),s.codes=this.getCodes(t),s.directives=this.getDirectives(t),s.scopedArrays=this.getScopedArrays(t);let r=`// code

`;r+=this.flowCode[t];const n=this.flowNodes[t],o=n[n.length-1],a=o.outputNode,l=a!==void 0&&a.isOutputStructNode===!0;for(const u of n){const c=this.getFlowData(u),d=u.name;if(d&&(r.length>0&&(r+=`
`),r+=`	// flow -> ${d}
`),r+=`${c.code}
	`,u===o&&t!=="compute"){if(r+=`// result

	`,t==="vertex")r+=`varyings.Vertex = ${c.result};`;else if(t==="fragment")if(l)s.returnType=a.getNodeType(this),s.structs+="var<private> output : "+s.returnType+";",r+=`return ${c.result};`;else{let h="	@location(0) color: vec4<f32>";const p=this.getBuiltins("output");p&&(h+=`,
	`+p),s.returnType="OutputStruct",s.structs+=this._getWGSLStruct("OutputStruct",h),s.structs+=`
var<private> output : OutputStruct;`,r+=`output.color = ${c.result};

	return output;`}}}s.flow=r}this.shaderStage=null,this.material!==null?(this.vertexShader=this._getWGSLVertexCode(e.vertex),this.fragmentShader=this._getWGSLFragmentCode(e.fragment)):this.computeShader=this._getWGSLComputeCode(e.compute,(this.object.workgroupSize||[64]).join(", "))}getMethod(e,t=null){let s;return t!==null&&(s=this._getWGSLMethod(e+"_"+t)),s===void 0&&(s=this._getWGSLMethod(e)),s||e}getType(e){return m9[e]||e}isAvailable(e){let t=AN[e];return t===void 0&&(e==="float32Filterable"?t=this.renderer.hasFeature("float32-filterable"):e==="clipDistance"&&(t=this.renderer.hasFeature("clip-distances")),AN[e]=t),t}_getWGSLMethod(e){return dn[e]!==void 0&&this._include(e),Od[e]}_include(e){const t=dn[e];return t.build(this),this.currentFunctionNode!==null&&this.currentFunctionNode.includes.push(t),t}_getWGSLVertexCode(e){return`${this.getSignature()}
// directives
${e.directives}

// structs
${e.structs}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`}_getWGSLFragmentCode(e){return`${this.getSignature()}
// global
${q$}

// structs
${e.structs}

// uniforms
${e.uniforms}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`}_getWGSLComputeCode(e,t){return`${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// structs
${e.structs}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${t} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = globalId.x + globalId.y * numWorkgroups.x * u32(${t}) + globalId.z * numWorkgroups.x * numWorkgroups.y * u32(${t});

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`}_getWGSLStruct(e,t){return`
struct ${e} {
${t}
};`}_getWGSLStructBinding(e,t,s,r=0,n=0){const o=e+"Struct";return`${this._getWGSLStruct(o,t)}
@binding( ${r} ) @group( ${n} )
var<${s}> ${e} : ${o};`}}class _9{constructor(e){this.backend=e}getCurrentDepthStencilFormat(e){let t;return e.depthTexture!==null?t=this.getTextureFormatGPU(e.depthTexture):e.depth&&e.stencil?t=ce.Depth24PlusStencil8:e.depth&&(t=ce.Depth24Plus),t}getTextureFormatGPU(e){return this.backend.get(e).format}getTextureSampleData(e){let t;if(e.isFramebufferTexture)t=1;else if(e.isDepthTexture&&!e.renderTarget){const n=this.backend.renderer,o=n.getRenderTarget();t=o?o.samples:n.samples}else e.renderTarget&&(t=e.renderTarget.samples);t=t||1;const s=t>1&&e.renderTarget!==null&&e.isDepthTexture!==!0&&e.isFramebufferTexture!==!0;return{samples:t,primarySamples:s?1:t,isMSAA:s}}getCurrentColorFormat(e){let t;return e.textures!==null?t=this.getTextureFormatGPU(e.textures[0]):t=this.getPreferredCanvasFormat(),t}getCurrentColorSpace(e){return e.textures!==null?e.textures[0].colorSpace:this.backend.renderer.outputColorSpace}getPrimitiveTopology(e,t){if(e.isPoints)return ic.PointList;if(e.isLineSegments||e.isMesh&&t.wireframe===!0)return ic.LineList;if(e.isLine)return ic.LineStrip;if(e.isMesh)return ic.TriangleList}getSampleCount(e){let t=1;return e>1&&(t=Math.pow(2,Math.floor(Math.log2(e))),t===2&&(t=4)),t}getSampleCountRenderContext(e){return e.textures!==null?this.getSampleCount(e.sampleCount):this.getSampleCount(this.backend.renderer.samples)}getPreferredCanvasFormat(){const e=this.backend.parameters.outputType;if(e===void 0)return navigator.gpu.getPreferredCanvasFormat();if(e===xr)return ce.BGRA8Unorm;if(e===Cr)return ce.RGBA16Float;throw new Error("Unsupported outputType")}}const K$=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]);typeof Float16Array<"u"&&K$.set(Float16Array,["float16"]);const y9=new Map([[YD,["float16"]]]),x9=new Map([[Int32Array,"sint32"],[Int16Array,"sint32"],[Uint32Array,"uint32"],[Uint16Array,"uint32"],[Float32Array,"float32"]]);class b9{constructor(e){this.backend=e}createAttribute(e,t){const s=this._getBufferAttribute(e),r=this.backend,n=r.get(s);let o=n.buffer;if(o===void 0){const a=r.device;let l=s.array;if(e.normalized===!1){if(l.constructor===Int16Array||l.constructor===Int8Array)l=new Int32Array(l);else if((l.constructor===Uint16Array||l.constructor===Uint8Array)&&(l=new Uint32Array(l),t&GPUBufferUsage.INDEX))for(let d=0;d<l.length;d++)l[d]===65535&&(l[d]=4294967295)}if(s.array=l,(s.isStorageBufferAttribute||s.isStorageInstancedBufferAttribute)&&s.itemSize===3){l=new l.constructor(s.count*4);for(let d=0;d<s.count;d++)l.set(s.array.subarray(d*3,d*3+3),d*4);s.itemSize=4,s.array=l,n._force3to4BytesAlignment=!0}const u=l.byteLength,c=u+(4-u%4)%4;o=a.createBuffer({label:s.name,size:c,usage:t,mappedAtCreation:!0}),new l.constructor(o.getMappedRange()).set(l),o.unmap(),n.buffer=o}}updateAttribute(e){const t=this._getBufferAttribute(e),s=this.backend,r=s.device,n=s.get(t),o=s.get(t).buffer;let a=t.array;if(n._force3to4BytesAlignment===!0){a=new a.constructor(t.count*4);for(let c=0;c<t.count;c++)a.set(t.array.subarray(c*3,c*3+3),c*4);t.array=a}const l=this._isTypedArray(a),u=t.updateRanges;if(u.length===0)r.queue.writeBuffer(o,0,a,0);else{const c=l?1:a.BYTES_PER_ELEMENT;for(let d=0,h=u.length;d<h;d++){const p=u[d];let f,m;if(n._force3to4BytesAlignment===!0){const g=Math.floor(p.start/3),_=Math.ceil(p.count/3);f=g*4*c,m=_*4*c}else f=p.start*c,m=p.count*c;const x=f*(l?a.BYTES_PER_ELEMENT:1);r.queue.writeBuffer(o,x,a,f,m)}t.clearUpdateRanges()}}createShaderVertexBuffers(e){const t=e.getAttributes(),s=new Map;for(let r=0;r<t.length;r++){const n=t[r],o=n.array.BYTES_PER_ELEMENT,a=this._getBufferAttribute(n);let l=s.get(a);if(l===void 0){let d,h;n.isInterleavedBufferAttribute===!0?(d=n.data.stride*o,h=n.data.isInstancedInterleavedBuffer?_f.Instance:_f.Vertex):(d=n.itemSize*o,h=n.isInstancedBufferAttribute?_f.Instance:_f.Vertex),n.normalized===!1&&(n.array.constructor===Int16Array||n.array.constructor===Uint16Array)&&(d=4),l={arrayStride:d,attributes:[],stepMode:h},s.set(a,l)}const u=this._getVertexFormat(n),c=n.isInterleavedBufferAttribute===!0?n.offset*o:0;l.attributes.push({shaderLocation:r,offset:c,format:u})}return Array.from(s.values())}destroyAttribute(e){const t=this.backend;t.get(this._getBufferAttribute(e)).buffer.destroy(),t.delete(e)}async getArrayBufferAsync(e){const t=this.backend,s=t.device,n=t.get(this._getBufferAttribute(e)).buffer,o=n.size,a=s.createBuffer({label:`${e.name}_readback`,size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),l=s.createCommandEncoder({label:`readback_encoder_${e.name}`});l.copyBufferToBuffer(n,0,a,0,o);const u=l.finish();s.queue.submit([u]),await a.mapAsync(GPUMapMode.READ);const c=a.getMappedRange(),d=new e.array.constructor(c.slice(0));return a.unmap(),d.buffer}_getVertexFormat(e){const{itemSize:t,normalized:s}=e,r=e.array.constructor,n=e.constructor;let o;if(t===1)o=x9.get(r);else{const l=(y9.get(n)||K$.get(r))[s?1:0];if(l){const u=r.BYTES_PER_ELEMENT*t,d=Math.floor((u+3)/4)*4/r.BYTES_PER_ELEMENT;if(d%1)throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");o=`${l}x${d}`}}return o||console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."),o}_isTypedArray(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}_getBufferAttribute(e){return e.isInterleavedBufferAttribute&&(e=e.data),e}}class w9{constructor(e){this.backend=e,this.bindGroupLayoutCache=new WeakMap}createBindingsLayout(e){const t=this.backend,s=t.device,r=[];let n=0;for(const o of e.bindings){const a={binding:n++,visibility:o.visibility};if(o.isUniformBuffer||o.isStorageBuffer){const l={};o.isStorageBuffer&&(o.visibility&4&&(o.access===ar.READ_WRITE||o.access===ar.WRITE_ONLY)?l.type=mx.Storage:l.type=mx.ReadOnlyStorage),a.buffer=l}else if(o.isSampler){const l={};o.texture.isDepthTexture&&(o.texture.compareFunction!==null?l.type=TN.Comparison:t.compatibilityMode&&(l.type=TN.NonFiltering)),a.sampler=l}else if(o.isSampledTexture&&o.texture.isVideoTexture)a.externalTexture={};else if(o.isSampledTexture&&o.store){const l={};l.format=this.backend.get(o.texture).texture.format;const u=o.access;u===ar.READ_WRITE?l.access=gx.ReadWrite:u===ar.WRITE_ONLY?l.access=gx.WriteOnly:l.access=gx.ReadOnly,o.texture.isArrayTexture?l.viewDimension=Pi.TwoDArray:o.texture.is3DTexture&&(l.viewDimension=Pi.ThreeD),a.storageTexture=l}else if(o.isSampledTexture){const l={},{primarySamples:u}=t.utils.getTextureSampleData(o.texture);if(u>1&&(l.multisampled=!0,o.texture.isDepthTexture||(l.sampleType=Cl.UnfilterableFloat)),o.texture.isDepthTexture)t.compatibilityMode&&o.texture.compareFunction===null?l.sampleType=Cl.UnfilterableFloat:l.sampleType=Cl.Depth;else if(o.texture.isDataTexture||o.texture.isDataArrayTexture||o.texture.isData3DTexture){const c=o.texture.type;c===_r?l.sampleType=Cl.SInt:c===_i?l.sampleType=Cl.UInt:c===Kr&&(this.backend.hasFeature("float32-filterable")?l.sampleType=Cl.Float:l.sampleType=Cl.UnfilterableFloat)}o.isSampledCubeTexture?l.viewDimension=Pi.Cube:o.texture.isArrayTexture||o.texture.isDataArrayTexture||o.texture.isCompressedArrayTexture?l.viewDimension=Pi.TwoDArray:o.isSampledTexture3D&&(l.viewDimension=Pi.ThreeD),a.texture=l}else console.error(`WebGPUBindingUtils: Unsupported binding "${o}".`);r.push(a)}return s.createBindGroupLayout({entries:r})}createBindings(e,t,s,r=0){const{backend:n,bindGroupLayoutCache:o}=this,a=n.get(e);let l=o.get(e.bindingsReference);l===void 0&&(l=this.createBindingsLayout(e),o.set(e.bindingsReference,l));let u;s>0&&(a.groups===void 0&&(a.groups=[],a.versions=[]),a.versions[s]===r&&(u=a.groups[s])),u===void 0&&(u=this.createBindGroup(e,l),s>0&&(a.groups[s]=u,a.versions[s]=r)),a.group=u,a.layout=l}updateBinding(e){const t=this.backend,s=t.device,r=e.buffer,n=t.get(e).buffer;s.queue.writeBuffer(n,0,r,0)}createBindGroupIndex(e,t){const r=this.backend.device,n=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,o=e[0],a=r.createBuffer({label:"bindingCameraIndex_"+o,size:16,usage:n});r.queue.writeBuffer(a,0,e,0);const l=[{binding:0,resource:{buffer:a}}];return r.createBindGroup({label:"bindGroupCameraIndex_"+o,layout:t,entries:l})}createBindGroup(e,t){const s=this.backend,r=s.device;let n=0;const o=[];for(const a of e.bindings){if(a.isUniformBuffer){const l=s.get(a);if(l.buffer===void 0){const u=a.byteLength,c=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,d=r.createBuffer({label:"bindingBuffer_"+a.name,size:u,usage:c});l.buffer=d}o.push({binding:n,resource:{buffer:l.buffer}})}else if(a.isStorageBuffer){const l=s.get(a);if(l.buffer===void 0){const u=a.attribute;l.buffer=s.get(u).buffer}o.push({binding:n,resource:{buffer:l.buffer}})}else if(a.isSampler){const l=s.get(a.texture);o.push({binding:n,resource:l.sampler})}else if(a.isSampledTexture){const l=s.get(a.texture);let u;if(l.externalTexture!==void 0)u=r.importExternalTexture({source:l.externalTexture});else{const c=a.store?1:l.texture.mipLevelCount,d=`view-${l.texture.width}-${l.texture.height}-${c}`;if(u=l[d],u===void 0){const h=ZK.All;let p;a.isSampledCubeTexture?p=Pi.Cube:a.isSampledTexture3D?p=Pi.ThreeD:a.texture.isArrayTexture||a.texture.isDataArrayTexture||a.texture.isCompressedArrayTexture?p=Pi.TwoDArray:p=Pi.TwoD,u=l[d]=l.texture.createView({aspect:h,dimension:p,mipLevelCount:c})}}o.push({binding:n,resource:u})}n++}return r.createBindGroup({label:"bindGroup_"+e.name,layout:t,entries:o})}}class M9{constructor(e){this.backend=e,this._activePipelines=new WeakMap}setPipeline(e,t){this._activePipelines.get(e)!==t&&(e.setPipeline(t),this._activePipelines.set(e,t))}_getSampleCount(e){return this.backend.utils.getSampleCountRenderContext(e)}createRenderPipeline(e,t){const{object:s,material:r,geometry:n,pipeline:o}=e,{vertexProgram:a,fragmentProgram:l}=o,u=this.backend,c=u.device,d=u.utils,h=u.get(o),p=[];for(const L of e.getBindings()){const Q=u.get(L);p.push(Q.layout)}const f=u.attributeUtils.createShaderVertexBuffers(e);let m;r.blending!==fc&&(r.blending!==Ho||r.transparent!==!1)&&(m=this._getBlending(r));let x={};r.stencilWrite===!0&&(x={compare:this._getStencilCompare(r),failOp:this._getStencilOperation(r.stencilFail),depthFailOp:this._getStencilOperation(r.stencilZFail),passOp:this._getStencilOperation(r.stencilZPass)});const g=this._getColorWriteMask(r),_=[];if(e.context.textures!==null){const L=e.context.textures;for(let Q=0;Q<L.length;Q++){const q=d.getTextureFormatGPU(L[Q]);_.push({format:q,blend:m,writeMask:g})}}else{const L=d.getCurrentColorFormat(e.context);_.push({format:L,blend:m,writeMask:g})}const S=u.get(a).module,M=u.get(l).module,w=this._getPrimitiveState(s,n,r),v=this._getDepthCompare(r),T=d.getCurrentDepthStencilFormat(e.context),E=this._getSampleCount(e.context),F={label:`renderPipeline_${r.name||r.type}_${r.id}`,vertex:Object.assign({},S,{buffers:f}),fragment:Object.assign({},M,{targets:_}),primitive:w,multisample:{count:E,alphaToCoverageEnabled:r.alphaToCoverage&&E>1},layout:c.createPipelineLayout({bindGroupLayouts:p})},I={},z=e.context.depth,G=e.context.stencil;if((z===!0||G===!0)&&(z===!0&&(I.format=T,I.depthWriteEnabled=r.depthWrite,I.depthCompare=v),G===!0&&(I.stencilFront=x,I.stencilBack={},I.stencilReadMask=r.stencilFuncMask,I.stencilWriteMask=r.stencilWriteMask),r.polygonOffset===!0&&(I.depthBias=r.polygonOffsetUnits,I.depthBiasSlopeScale=r.polygonOffsetFactor,I.depthBiasClamp=0),F.depthStencil=I),t===null)h.pipeline=c.createRenderPipeline(F);else{const L=new Promise(Q=>{c.createRenderPipelineAsync(F).then(q=>{h.pipeline=q,Q()})});t.push(L)}}createBundleEncoder(e,t="renderBundleEncoder"){const s=this.backend,{utils:r,device:n}=s,o=r.getCurrentDepthStencilFormat(e),a=r.getCurrentColorFormat(e),l=this._getSampleCount(e),u={label:t,colorFormats:[a],depthStencilFormat:o,sampleCount:l};return n.createRenderBundleEncoder(u)}createComputePipeline(e,t){const s=this.backend,r=s.device,n=s.get(e.computeProgram).module,o=s.get(e),a=[];for(const l of t){const u=s.get(l);a.push(u.layout)}o.pipeline=r.createComputePipeline({compute:n,layout:r.createPipelineLayout({bindGroupLayouts:a})})}_getBlending(e){let t,s;const r=e.blending,n=e.blendSrc,o=e.blendDst,a=e.blendEquation;if(r===zd){const l=e.blendSrcAlpha!==null?e.blendSrcAlpha:n,u=e.blendDstAlpha!==null?e.blendDstAlpha:o,c=e.blendEquationAlpha!==null?e.blendEquationAlpha:a;t={srcFactor:this._getBlendFactor(n),dstFactor:this._getBlendFactor(o),operation:this._getBlendOperation(a)},s={srcFactor:this._getBlendFactor(l),dstFactor:this._getBlendFactor(u),operation:this._getBlendOperation(c)}}else{const l=e.premultipliedAlpha,u=(c,d,h,p)=>{t={srcFactor:c,dstFactor:d,operation:Al.Add},s={srcFactor:h,dstFactor:p,operation:Al.Add}};if(l)switch(r){case Ho:u(as.One,as.OneMinusSrcAlpha,as.One,as.OneMinusSrcAlpha);break;case Uf:u(as.One,as.One,as.One,as.One);break;case Gf:u(as.Zero,as.OneMinusSrc,as.Zero,as.One);break;case jf:u(as.Dst,as.OneMinusSrcAlpha,as.Zero,as.One);break}else switch(r){case Ho:u(as.SrcAlpha,as.OneMinusSrcAlpha,as.One,as.OneMinusSrcAlpha);break;case Uf:u(as.SrcAlpha,as.One,as.One,as.One);break;case Gf:console.error("THREE.WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true");break;case jf:console.error("THREE.WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true");break}}if(t!==void 0&&s!==void 0)return{color:t,alpha:s};console.error("THREE.WebGPURenderer: Invalid blending: ",r)}_getBlendFactor(e){let t;switch(e){case Aa:t=as.Zero;break;case wD:t=as.One;break;case MD:t=as.Src;break;case TD:t=as.OneMinusSrc;break;case Wf:t=as.SrcAlpha;break;case Hf:t=as.OneMinusSrcAlpha;break;case ED:t=as.Dst;break;case AD:t=as.OneMinusDst;break;case vD:t=as.DstAlpha;break;case SD:t=as.OneMinusDstAlpha;break;case CD:t=as.SrcAlphaSaturated;break;case N8:t=as.Constant;break;case F8:t=as.OneMinusConstant;break;default:console.error("THREE.WebGPURenderer: Blend factor not supported.",e)}return t}_getStencilCompare(e){let t;const s=e.stencilFunc;switch(s){case KV:t=tr.Never;break;case sb:t=tr.Always;break;case XV:t=tr.Less;break;case QV:t=tr.LessEqual;break;case YV:t=tr.Equal;break;case eU:t=tr.GreaterEqual;break;case ZV:t=tr.Greater;break;case JV:t=tr.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid stencil function.",s)}return t}_getStencilOperation(e){let t;switch(e){case Nl:t=Ea.Keep;break;case VV:t=Ea.Zero;break;case UV:t=Ea.Replace;break;case qV:t=Ea.Invert;break;case GV:t=Ea.IncrementClamp;break;case jV:t=Ea.DecrementClamp;break;case WV:t=Ea.IncrementWrap;break;case HV:t=Ea.DecrementWrap;break;default:console.error("THREE.WebGPURenderer: Invalid stencil operation.",t)}return t}_getBlendOperation(e){let t;switch(e){case Un:t=Al.Add;break;case xD:t=Al.Subtract;break;case bD:t=Al.ReverseSubtract;break;case vV:t=Al.Min;break;case SV:t=Al.Max;break;default:console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.",e)}return t}_getPrimitiveState(e,t,s){const r={},n=this.backend.utils;switch(r.topology=n.getPrimitiveTopology(e,s),t.index!==null&&e.isLine===!0&&e.isLineSegments!==!0&&(r.stripIndexFormat=t.index.array instanceof Uint16Array?Tc.Uint16:Tc.Uint32),s.side){case Wo:r.frontFace=hx.CCW,r.cullMode=px.Back;break;case lr:r.frontFace=hx.CCW,r.cullMode=px.Front;break;case Da:r.frontFace=hx.CCW,r.cullMode=px.None;break;default:console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.",s.side);break}return r}_getColorWriteMask(e){return e.colorWrite===!0?MN.All:MN.None}_getDepthCompare(e){let t;if(e.depthTest===!1)t=tr.Always;else{const s=e.depthFunc;switch(s){case PD:t=tr.Never;break;case ND:t=tr.Always;break;case FD:t=tr.Less;break;case qf:t=tr.LessEqual;break;case RD:t=tr.Equal;break;case ID:t=tr.GreaterEqual;break;case DD:t=tr.Greater;break;case kD:t=tr.NotEqual;break;default:console.error("THREE.WebGPUPipelineUtils: Invalid depth function.",s)}}return t}}class T9 extends H${constructor(e,t,s=2048){super(s),this.device=e,this.type=t,this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxQueries,label:`queryset_global_timestamp_${t}`});const r=this.maxQueries*8;this.resolveBuffer=this.device.createBuffer({label:`buffer_timestamp_resolve_${t}`,size:r,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.resultBuffer=this.device.createBuffer({label:`buffer_timestamp_result_${t}`,size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})}allocateQueriesForContext(e){if(!this.trackTimestamp||this.isDisposed)return null;if(this.currentQueryIndex+2>this.maxQueries)return ta(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`),null;const t=this.currentQueryIndex;return this.currentQueryIndex+=2,this.queryOffsets.set(e.id,t),t}async resolveQueriesAsync(){if(!this.trackTimestamp||this.currentQueryIndex===0||this.isDisposed)return this.lastValue;if(this.pendingResolve)return this.pendingResolve;this.pendingResolve=this._resolveQueries();try{return await this.pendingResolve}finally{this.pendingResolve=null}}async _resolveQueries(){if(this.isDisposed)return this.lastValue;try{if(this.resultBuffer.mapState!=="unmapped")return this.lastValue;const e=new Map(this.queryOffsets),t=this.currentQueryIndex,s=t*8;this.currentQueryIndex=0,this.queryOffsets.clear();const r=this.device.createCommandEncoder();r.resolveQuerySet(this.querySet,0,t,this.resolveBuffer,0),r.copyBufferToBuffer(this.resolveBuffer,0,this.resultBuffer,0,s);const n=r.finish();if(this.device.queue.submit([n]),this.resultBuffer.mapState!=="unmapped")return this.lastValue;if(await this.resultBuffer.mapAsync(GPUMapMode.READ,0,s),this.isDisposed)return this.resultBuffer.mapState==="mapped"&&this.resultBuffer.unmap(),this.lastValue;const o=new BigUint64Array(this.resultBuffer.getMappedRange(0,s));let a=0;for(const[,l]of e){const u=o[l],c=o[l+1],d=Number(c-u)/1e6;a+=d}return this.resultBuffer.unmap(),this.lastValue=a,a}catch(e){return console.error("Error resolving queries:",e),this.resultBuffer.mapState==="mapped"&&this.resultBuffer.unmap(),this.lastValue}}async dispose(){if(!this.isDisposed){if(this.isDisposed=!0,this.pendingResolve)try{await this.pendingResolve}catch(e){console.error("Error waiting for pending resolve:",e)}if(this.resultBuffer&&this.resultBuffer.mapState==="mapped")try{this.resultBuffer.unmap()}catch(e){console.error("Error unmapping buffer:",e)}this.querySet&&(this.querySet.destroy(),this.querySet=null),this.resolveBuffer&&(this.resolveBuffer.destroy(),this.resolveBuffer=null),this.resultBuffer&&(this.resultBuffer.destroy(),this.resultBuffer=null),this.queryOffsets.clear(),this.pendingResolve=null}}}class v9 extends W${constructor(e={}){super(e),this.isWebGPUBackend=!0,this.parameters.alpha=e.alpha===void 0?!0:e.alpha,this.parameters.compatibilityMode=e.compatibilityMode===void 0?!1:e.compatibilityMode,this.parameters.requiredLimits=e.requiredLimits===void 0?{}:e.requiredLimits,this.compatibilityMode=this.parameters.compatibilityMode,this.device=null,this.context=null,this.colorBuffer=null,this.defaultRenderPassdescriptor=null,this.utils=new _9(this),this.attributeUtils=new b9(this),this.bindingUtils=new w9(this),this.pipelineUtils=new M9(this),this.textureUtils=new a9(this),this.occludedResolveCache=new Map}async init(e){await super.init(e);const t=this.parameters;let s;if(t.device===void 0){const o={powerPreference:t.powerPreference,featureLevel:t.compatibilityMode?"compatibility":void 0},a=typeof navigator<"u"?await navigator.gpu.requestAdapter(o):null;if(a===null)throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");const l=Object.values(Eb),u=[];for(const d of l)a.features.has(d)&&u.push(d);const c={requiredFeatures:u,requiredLimits:t.requiredLimits};s=await a.requestDevice(c)}else s=t.device;s.lost.then(o=>{const a={api:"WebGPU",message:o.message||"Unknown reason",reason:o.reason||null,originalEvent:o};e.onDeviceLost(a)});const r=t.context!==void 0?t.context:e.domElement.getContext("webgpu");this.device=s,this.context=r;const n=t.alpha?"premultiplied":"opaque";this.trackTimestamp=this.trackTimestamp&&this.hasFeature(Eb.TimestampQuery),this.context.configure({device:this.device,format:this.utils.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:n}),this.updateSize()}get coordinateSystem(){return xo}async getArrayBufferAsync(e){return await this.attributeUtils.getArrayBufferAsync(e)}getContext(){return this.context}_getDefaultRenderPassDescriptor(){let e=this.defaultRenderPassdescriptor;if(e===null){const s=this.renderer;e={colorAttachments:[{view:null}]},(this.renderer.depth===!0||this.renderer.stencil===!0)&&(e.depthStencilAttachment={view:this.textureUtils.getDepthBuffer(s.depth,s.stencil).createView()});const r=e.colorAttachments[0];this.renderer.samples>0?r.view=this.colorBuffer.createView():r.resolveTarget=void 0,this.defaultRenderPassdescriptor=e}const t=e.colorAttachments[0];return this.renderer.samples>0?t.resolveTarget=this.context.getCurrentTexture().createView():t.view=this.context.getCurrentTexture().createView(),e}_isRenderCameraDepthArray(e){return e.depthTexture&&e.depthTexture.image.depth>1&&e.camera.isArrayCamera}_getRenderPassDescriptor(e,t={}){const s=e.renderTarget,r=this.get(s);let n=r.descriptors;if(n===void 0||r.width!==s.width||r.height!==s.height||r.dimensions!==s.dimensions||r.activeMipmapLevel!==e.activeMipmapLevel||r.activeCubeFace!==e.activeCubeFace||r.samples!==s.samples){n={},r.descriptors=n;const u=()=>{s.removeEventListener("dispose",u),this.delete(s)};s.hasEventListener("dispose",u)===!1&&s.addEventListener("dispose",u)}const o=e.getCacheKey();let a=n[o];if(a===void 0){const u=e.textures,c=[];let d;const h=this._isRenderCameraDepthArray(e);for(let p=0;p<u.length;p++){const f=this.get(u[p]),m={label:`colorAttachment_${p}`,baseMipLevel:e.activeMipmapLevel,mipLevelCount:1,baseArrayLayer:e.activeCubeFace,arrayLayerCount:1,dimension:Pi.TwoD};if(s.isRenderTarget3D)d=e.activeCubeFace,m.baseArrayLayer=0,m.dimension=Pi.ThreeD,m.depthOrArrayLayers=u[p].image.depth;else if(s.isRenderTarget&&u[p].image.depth>1)if(h===!0){const x=e.camera.cameras;for(let g=0;g<x.length;g++){const _={...m,baseArrayLayer:g,arrayLayerCount:1,dimension:Pi.TwoD},S=f.texture.createView(_);c.push({view:S,resolveTarget:void 0,depthSlice:void 0})}}else m.dimension=Pi.TwoDArray,m.depthOrArrayLayers=u[p].image.depth;if(h!==!0){const x=f.texture.createView(m);let g,_;f.msaaTexture!==void 0?(g=f.msaaTexture.createView(),_=x):(g=x,_=void 0),c.push({view:g,resolveTarget:_,depthSlice:d})}}if(a={textureViews:c},e.depth){const p=this.get(e.depthTexture),f={};e.depthTexture.isArrayTexture&&(f.dimension=Pi.TwoD,f.arrayLayerCount=1,f.baseArrayLayer=e.activeCubeFace),a.depthStencilView=p.texture.createView(f)}n[o]=a,r.width=s.width,r.height=s.height,r.samples=s.samples,r.activeMipmapLevel=e.activeMipmapLevel,r.activeCubeFace=e.activeCubeFace,r.dimensions=s.dimensions}const l={colorAttachments:[]};for(let u=0;u<a.textureViews.length;u++){const c=a.textureViews[u];let d={r:0,g:0,b:0,a:1};u===0&&t.clearValue&&(d=t.clearValue),l.colorAttachments.push({view:c.view,depthSlice:c.depthSlice,resolveTarget:c.resolveTarget,loadOp:t.loadOp||Es.Load,storeOp:t.storeOp||gr.Store,clearValue:d})}return a.depthStencilView&&(l.depthStencilAttachment={view:a.depthStencilView}),l}beginRender(e){const t=this.get(e),s=this.device,r=e.occlusionQueryCount;let n;r>0&&(t.currentOcclusionQuerySet&&t.currentOcclusionQuerySet.destroy(),t.currentOcclusionQueryBuffer&&t.currentOcclusionQueryBuffer.destroy(),t.currentOcclusionQuerySet=t.occlusionQuerySet,t.currentOcclusionQueryBuffer=t.occlusionQueryBuffer,t.currentOcclusionQueryObjects=t.occlusionQueryObjects,n=s.createQuerySet({type:"occlusion",count:r,label:`occlusionQuerySet_${e.id}`}),t.occlusionQuerySet=n,t.occlusionQueryIndex=0,t.occlusionQueryObjects=new Array(r),t.lastOcclusionObject=null);let o;e.textures===null?o=this._getDefaultRenderPassDescriptor():o=this._getRenderPassDescriptor(e,{loadOp:Es.Load}),this.initTimestampQuery(e,o),o.occlusionQuerySet=n;const a=o.depthStencilAttachment;if(e.textures!==null){const u=o.colorAttachments;for(let c=0;c<u.length;c++){const d=u[c];e.clearColor?(d.clearValue=c===0?e.clearColorValue:{r:0,g:0,b:0,a:1},d.loadOp=Es.Clear):d.loadOp=Es.Load,d.storeOp=gr.Store}}else{const u=o.colorAttachments[0];e.clearColor?(u.clearValue=e.clearColorValue,u.loadOp=Es.Clear):u.loadOp=Es.Load,u.storeOp=gr.Store}e.depth&&(e.clearDepth?(a.depthClearValue=e.clearDepthValue,a.depthLoadOp=Es.Clear):a.depthLoadOp=Es.Load,a.depthStoreOp=gr.Store),e.stencil&&(e.clearStencil?(a.stencilClearValue=e.clearStencilValue,a.stencilLoadOp=Es.Clear):a.stencilLoadOp=Es.Load,a.stencilStoreOp=gr.Store);const l=s.createCommandEncoder({label:"renderContext_"+e.id});if(this._isRenderCameraDepthArray(e)===!0){const u=e.camera.cameras;!t.layerDescriptors||t.layerDescriptors.length!==u.length?this._createDepthLayerDescriptors(e,t,o,u):this._updateDepthLayerDescriptors(e,t,u),t.bundleEncoders=[],t.bundleSets=[];for(let c=0;c<u.length;c++){const d=this.pipelineUtils.createBundleEncoder(e,"renderBundleArrayCamera_"+c),h={attributes:{},bindingGroups:[],pipeline:null,index:null};t.bundleEncoders.push(d),t.bundleSets.push(h)}t.currentPass=null}else{const u=l.beginRenderPass(o);if(t.currentPass=u,e.viewport&&this.updateViewport(e),e.scissor){const{x:c,y:d,width:h,height:p}=e.scissorValue;u.setScissorRect(c,d,h,p)}}t.descriptor=o,t.encoder=l,t.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},t.renderBundles=[]}_createDepthLayerDescriptors(e,t,s,r){const n=s.depthStencilAttachment;t.layerDescriptors=[];const o=this.get(e.depthTexture);o.viewCache||(o.viewCache=[]);for(let a=0;a<r.length;a++){const l={...s,colorAttachments:[{...s.colorAttachments[0],view:s.colorAttachments[a].view}]};if(s.depthStencilAttachment){const u=a;o.viewCache[u]||(o.viewCache[u]=o.texture.createView({dimension:Pi.TwoD,baseArrayLayer:a,arrayLayerCount:1})),l.depthStencilAttachment={view:o.viewCache[u],depthLoadOp:n.depthLoadOp||Es.Clear,depthStoreOp:n.depthStoreOp||gr.Store,depthClearValue:n.depthClearValue||1},e.stencil&&(l.depthStencilAttachment.stencilLoadOp=n.stencilLoadOp,l.depthStencilAttachment.stencilStoreOp=n.stencilStoreOp,l.depthStencilAttachment.stencilClearValue=n.stencilClearValue)}else l.depthStencilAttachment={...n};t.layerDescriptors.push(l)}}_updateDepthLayerDescriptors(e,t,s){for(let r=0;r<s.length;r++){const n=t.layerDescriptors[r];if(n.depthStencilAttachment){const o=n.depthStencilAttachment;e.depth&&(e.clearDepth?(o.depthClearValue=e.clearDepthValue,o.depthLoadOp=Es.Clear):o.depthLoadOp=Es.Load),e.stencil&&(e.clearStencil?(o.stencilClearValue=e.clearStencilValue,o.stencilLoadOp=Es.Clear):o.stencilLoadOp=Es.Load)}}}finishRender(e){const t=this.get(e),s=e.occlusionQueryCount;t.renderBundles.length>0&&t.currentPass.executeBundles(t.renderBundles),s>t.occlusionQueryIndex&&t.currentPass.endOcclusionQuery();const r=t.encoder;if(this._isRenderCameraDepthArray(e)===!0){const n=[];for(let o=0;o<t.bundleEncoders.length;o++){const a=t.bundleEncoders[o];n.push(a.finish())}for(let o=0;o<t.layerDescriptors.length;o++)if(o<n.length){const a=t.layerDescriptors[o],l=r.beginRenderPass(a);if(e.viewport){const{x:u,y:c,width:d,height:h,minDepth:p,maxDepth:f}=e.viewportValue;l.setViewport(u,c,d,h,p,f)}if(e.scissor){const{x:u,y:c,width:d,height:h}=e.scissorValue;l.setScissorRect(u,c,d,h)}l.executeBundles([n[o]]),l.end()}}else t.currentPass&&t.currentPass.end();if(s>0){const n=s*8;let o=this.occludedResolveCache.get(n);o===void 0&&(o=this.device.createBuffer({size:n,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.occludedResolveCache.set(n,o));const a=this.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});t.encoder.resolveQuerySet(t.occlusionQuerySet,0,s,o,0),t.encoder.copyBufferToBuffer(o,0,a,0,n),t.occlusionQueryBuffer=a,this.resolveOccludedAsync(e)}if(this.device.queue.submit([t.encoder.finish()]),e.textures!==null){const n=e.textures;for(let o=0;o<n.length;o++){const a=n[o];a.generateMipmaps===!0&&this.textureUtils.generateMipmaps(a)}}}isOccluded(e,t){const s=this.get(e);return s.occluded&&s.occluded.has(t)}async resolveOccludedAsync(e){const t=this.get(e),{currentOcclusionQueryBuffer:s,currentOcclusionQueryObjects:r}=t;if(s&&r){const n=new WeakSet;t.currentOcclusionQueryObjects=null,t.currentOcclusionQueryBuffer=null,await s.mapAsync(GPUMapMode.READ);const o=s.getMappedRange(),a=new BigUint64Array(o);for(let l=0;l<r.length;l++)a[l]===BigInt(0)&&n.add(r[l]);s.destroy(),t.occluded=n}}updateViewport(e){const{currentPass:t}=this.get(e),{x:s,y:r,width:n,height:o,minDepth:a,maxDepth:l}=e.viewportValue;t.setViewport(s,r,n,o,a,l)}getClearColor(){const e=super.getClearColor();return this.renderer.alpha===!0&&(e.r*=e.a,e.g*=e.a,e.b*=e.a),e}clear(e,t,s,r=null){const n=this.device,o=this.renderer;let a=[],l,u,c,d;if(e){const f=this.getClearColor();u={r:f.r,g:f.g,b:f.b,a:f.a}}if(r===null){c=o.depth,d=o.stencil;const f=this._getDefaultRenderPassDescriptor();if(e){a=f.colorAttachments;const m=a[0];m.clearValue=u,m.loadOp=Es.Clear,m.storeOp=gr.Store}(c||d)&&(l=f.depthStencilAttachment)}else{c=r.depth,d=r.stencil;const f={loadOp:e?Es.Clear:Es.Load,clearValue:e?u:void 0};c&&(f.depthLoadOp=t?Es.Clear:Es.Load,f.depthClearValue=t?o.getClearDepth():void 0,f.depthStoreOp=gr.Store),d&&(f.stencilLoadOp=s?Es.Clear:Es.Load,f.stencilClearValue=s?o.getClearStencil():void 0,f.stencilStoreOp=gr.Store);const m=this._getRenderPassDescriptor(r,f);a=m.colorAttachments,l=m.depthStencilAttachment}c&&l&&l.depthLoadOp===void 0&&(t?(l.depthLoadOp=Es.Clear,l.depthClearValue=o.getClearDepth(),l.depthStoreOp=gr.Store):(l.depthLoadOp=Es.Load,l.depthStoreOp=gr.Store)),d&&l&&l.stencilLoadOp===void 0&&(s?(l.stencilLoadOp=Es.Clear,l.stencilClearValue=o.getClearStencil(),l.stencilStoreOp=gr.Store):(l.stencilLoadOp=Es.Load,l.stencilStoreOp=gr.Store));const h=n.createCommandEncoder({label:"clear"});h.beginRenderPass({colorAttachments:a,depthStencilAttachment:l}).end(),n.queue.submit([h.finish()])}beginCompute(e){const t=this.get(e),s={label:"computeGroup_"+e.id};this.initTimestampQuery(e,s),t.cmdEncoderGPU=this.device.createCommandEncoder({label:"computeGroup_"+e.id}),t.passEncoderGPU=t.cmdEncoderGPU.beginComputePass(s)}compute(e,t,s,r){const{passEncoderGPU:n}=this.get(e),o=this.get(r).pipeline;this.pipelineUtils.setPipeline(n,o);for(let c=0,d=s.length;c<d;c++){const h=s[c],p=this.get(h);n.setBindGroup(c,p.group)}const a=this.device.limits.maxComputeWorkgroupsPerDimension,l=this.get(t);l.dispatchSize===void 0&&(l.dispatchSize={x:0,y:1,z:1});const{dispatchSize:u}=l;t.dispatchCount>a?(u.x=Math.min(t.dispatchCount,a),u.y=Math.ceil(t.dispatchCount/a)):u.x=t.dispatchCount,n.dispatchWorkgroups(u.x,u.y,u.z)}finishCompute(e){const t=this.get(e);t.passEncoderGPU.end(),this.device.queue.submit([t.cmdEncoderGPU.finish()])}async waitForGPU(){await this.device.queue.onSubmittedWorkDone()}draw(e,t){const{object:s,material:r,context:n,pipeline:o}=e,a=e.getBindings(),l=this.get(n),u=this.get(o).pipeline,c=e.getIndex(),d=c!==null,h=e.getDrawParameters();if(h===null)return;const p=(m,x)=>{this.pipelineUtils.setPipeline(m,u),x.pipeline=u;const g=x.bindingGroups;for(let S=0,M=a.length;S<M;S++){const w=a[S],v=this.get(w);g[w.index]!==w.id&&(m.setBindGroup(w.index,v.group),g[w.index]=w.id)}if(d===!0&&x.index!==c){const S=this.get(c).buffer,M=c.array instanceof Uint16Array?Tc.Uint16:Tc.Uint32;m.setIndexBuffer(S,M),x.index=c}const _=e.getVertexBuffers();for(let S=0,M=_.length;S<M;S++){const w=_[S];if(x.attributes[S]!==w){const v=this.get(w).buffer;m.setVertexBuffer(S,v),x.attributes[S]=w}}n.stencil===!0&&r.stencilWrite===!0&&l.currentStencilRef!==r.stencilRef&&(m.setStencilReference(r.stencilRef),l.currentStencilRef=r.stencilRef)},f=(m,x)=>{if(p(m,x),s.isBatchedMesh===!0){const g=s._multiDrawStarts,_=s._multiDrawCounts,S=s._multiDrawCount,M=s._multiDrawInstances;M!==null&&ta("THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");for(let w=0;w<S;w++){const v=M?M[w]:1,T=v>1?0:w;d===!0?m.drawIndexed(_[w],v,g[w]/c.array.BYTES_PER_ELEMENT,0,T):m.draw(_[w],v,g[w],T),t.update(s,_[w],v)}}else if(d===!0){const{vertexCount:g,instanceCount:_,firstVertex:S}=h,M=e.getIndirect();if(M!==null){const w=this.get(M).buffer;m.drawIndexedIndirect(w,0)}else m.drawIndexed(g,_,S,0,0);t.update(s,g,_)}else{const{vertexCount:g,instanceCount:_,firstVertex:S}=h,M=e.getIndirect();if(M!==null){const w=this.get(M).buffer;m.drawIndirect(w,0)}else m.draw(g,_,S,0);t.update(s,g,_)}};if(e.camera.isArrayCamera&&e.camera.cameras.length>0){const m=this.get(e.camera),x=e.camera.cameras,g=e.getBindingGroup("cameraIndex");if(m.indexesGPU===void 0||m.indexesGPU.length!==x.length){const S=this.get(g),M=[],w=new Uint32Array([0,0,0,0]);for(let v=0,T=x.length;v<T;v++){w[0]=v;const E=this.bindingUtils.createBindGroupIndex(w,S.layout);M.push(E)}m.indexesGPU=M}const _=this.renderer.getPixelRatio();for(let S=0,M=x.length;S<M;S++){const w=x[S];if(s.layers.test(w.layers)){const v=w.viewport;let T=l.currentPass,E=l.currentSets;if(l.bundleEncoders){const F=l.bundleEncoders[S],I=l.bundleSets[S];T=F,E=I}v&&T.setViewport(Math.floor(v.x*_),Math.floor(v.y*_),Math.floor(v.width*_),Math.floor(v.height*_),n.viewportValue.minDepth,n.viewportValue.maxDepth),g&&m.indexesGPU&&(T.setBindGroup(g.index,m.indexesGPU[S]),E.bindingGroups[g.index]=g.id),f(T,E)}}}else if(l.currentPass){if(l.occlusionQuerySet!==void 0){const m=l.lastOcclusionObject;m!==s&&(m!==null&&m.occlusionTest===!0&&(l.currentPass.endOcclusionQuery(),l.occlusionQueryIndex++),s.occlusionTest===!0&&(l.currentPass.beginOcclusionQuery(l.occlusionQueryIndex),l.occlusionQueryObjects[l.occlusionQueryIndex]=s),l.lastOcclusionObject=s)}f(l.currentPass,l.currentSets)}}needsRenderUpdate(e){const t=this.get(e),{object:s,material:r}=e,n=this.utils,o=n.getSampleCountRenderContext(e.context),a=n.getCurrentColorSpace(e.context),l=n.getCurrentColorFormat(e.context),u=n.getCurrentDepthStencilFormat(e.context),c=n.getPrimitiveTopology(s,r);let d=!1;return(t.material!==r||t.materialVersion!==r.version||t.transparent!==r.transparent||t.blending!==r.blending||t.premultipliedAlpha!==r.premultipliedAlpha||t.blendSrc!==r.blendSrc||t.blendDst!==r.blendDst||t.blendEquation!==r.blendEquation||t.blendSrcAlpha!==r.blendSrcAlpha||t.blendDstAlpha!==r.blendDstAlpha||t.blendEquationAlpha!==r.blendEquationAlpha||t.colorWrite!==r.colorWrite||t.depthWrite!==r.depthWrite||t.depthTest!==r.depthTest||t.depthFunc!==r.depthFunc||t.stencilWrite!==r.stencilWrite||t.stencilFunc!==r.stencilFunc||t.stencilFail!==r.stencilFail||t.stencilZFail!==r.stencilZFail||t.stencilZPass!==r.stencilZPass||t.stencilFuncMask!==r.stencilFuncMask||t.stencilWriteMask!==r.stencilWriteMask||t.side!==r.side||t.alphaToCoverage!==r.alphaToCoverage||t.sampleCount!==o||t.colorSpace!==a||t.colorFormat!==l||t.depthStencilFormat!==u||t.primitiveTopology!==c||t.clippingContextCacheKey!==e.clippingContextCacheKey)&&(t.material=r,t.materialVersion=r.version,t.transparent=r.transparent,t.blending=r.blending,t.premultipliedAlpha=r.premultipliedAlpha,t.blendSrc=r.blendSrc,t.blendDst=r.blendDst,t.blendEquation=r.blendEquation,t.blendSrcAlpha=r.blendSrcAlpha,t.blendDstAlpha=r.blendDstAlpha,t.blendEquationAlpha=r.blendEquationAlpha,t.colorWrite=r.colorWrite,t.depthWrite=r.depthWrite,t.depthTest=r.depthTest,t.depthFunc=r.depthFunc,t.stencilWrite=r.stencilWrite,t.stencilFunc=r.stencilFunc,t.stencilFail=r.stencilFail,t.stencilZFail=r.stencilZFail,t.stencilZPass=r.stencilZPass,t.stencilFuncMask=r.stencilFuncMask,t.stencilWriteMask=r.stencilWriteMask,t.side=r.side,t.alphaToCoverage=r.alphaToCoverage,t.sampleCount=o,t.colorSpace=a,t.colorFormat=l,t.depthStencilFormat=u,t.primitiveTopology=c,t.clippingContextCacheKey=e.clippingContextCacheKey,d=!0),d}getRenderCacheKey(e){const{object:t,material:s}=e,r=this.utils,n=e.context;return[s.transparent,s.blending,s.premultipliedAlpha,s.blendSrc,s.blendDst,s.blendEquation,s.blendSrcAlpha,s.blendDstAlpha,s.blendEquationAlpha,s.colorWrite,s.depthWrite,s.depthTest,s.depthFunc,s.stencilWrite,s.stencilFunc,s.stencilFail,s.stencilZFail,s.stencilZPass,s.stencilFuncMask,s.stencilWriteMask,s.side,r.getSampleCountRenderContext(n),r.getCurrentColorSpace(n),r.getCurrentColorFormat(n),r.getCurrentDepthStencilFormat(n),r.getPrimitiveTopology(t,s),e.getGeometryCacheKey(),e.clippingContextCacheKey].join()}createSampler(e){this.textureUtils.createSampler(e)}destroySampler(e){this.textureUtils.destroySampler(e)}createDefaultTexture(e){this.textureUtils.createDefaultTexture(e)}createTexture(e,t){this.textureUtils.createTexture(e,t)}updateTexture(e,t){this.textureUtils.updateTexture(e,t)}generateMipmaps(e){this.textureUtils.generateMipmaps(e)}destroyTexture(e){this.textureUtils.destroyTexture(e)}async copyTextureToBuffer(e,t,s,r,n,o){return this.textureUtils.copyTextureToBuffer(e,t,s,r,n,o)}initTimestampQuery(e,t){if(!this.trackTimestamp)return;const s=e.isComputeNode?"compute":"render";this.timestampQueryPool[s]||(this.timestampQueryPool[s]=new T9(this.device,s,2048));const r=this.timestampQueryPool[s],n=r.allocateQueriesForContext(e);t.timestampWrites={querySet:r.querySet,beginningOfPassWriteIndex:n,endOfPassWriteIndex:n+1}}createNodeBuilder(e,t){return new g9(e,t)}createProgram(e){const t=this.get(e);t.module={module:this.device.createShaderModule({code:e.code,label:e.stage+(e.name!==""?`_${e.name}`:"")}),entryPoint:"main"}}destroyProgram(e){this.delete(e)}createRenderPipeline(e,t){this.pipelineUtils.createRenderPipeline(e,t)}createComputePipeline(e,t){this.pipelineUtils.createComputePipeline(e,t)}beginBundle(e){const t=this.get(e);t._currentPass=t.currentPass,t._currentSets=t.currentSets,t.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},t.currentPass=this.pipelineUtils.createBundleEncoder(e)}finishBundle(e,t){const s=this.get(e),n=s.currentPass.finish();this.get(t).bundleGPU=n,s.currentSets=s._currentSets,s.currentPass=s._currentPass}addBundle(e,t){this.get(e).renderBundles.push(this.get(t).bundleGPU)}createBindings(e,t,s,r){this.bindingUtils.createBindings(e,t,s,r)}updateBindings(e,t,s,r){this.bindingUtils.createBindings(e,t,s,r)}updateBinding(e){this.bindingUtils.updateBinding(e)}createIndexAttribute(e){let t=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;(e.isStorageBufferAttribute||e.isStorageInstancedBufferAttribute)&&(t|=GPUBufferUsage.STORAGE),this.attributeUtils.createAttribute(e,t)}createAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createStorageAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createIndirectStorageAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.STORAGE|GPUBufferUsage.INDIRECT|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}updateAttribute(e){this.attributeUtils.updateAttribute(e)}destroyAttribute(e){this.attributeUtils.destroyAttribute(e)}updateSize(){this.colorBuffer=this.textureUtils.getColorBuffer(),this.defaultRenderPassdescriptor=null}getMaxAnisotropy(){return 16}hasFeature(e){return this.device.features.has(e)}copyTextureToTexture(e,t,s=null,r=null,n=0,o=0){let a=0,l=0,u=0,c=0,d=0,h=0,p=e.image.width,f=e.image.height,m=1;s!==null&&(s.isBox3===!0?(c=s.min.x,d=s.min.y,h=s.min.z,p=s.max.x-s.min.x,f=s.max.y-s.min.y,m=s.max.z-s.min.z):(c=s.min.x,d=s.min.y,p=s.max.x-s.min.x,f=s.max.y-s.min.y,m=1)),r!==null&&(a=r.x,l=r.y,u=r.z||0);const x=this.device.createCommandEncoder({label:"copyTextureToTexture_"+e.id+"_"+t.id}),g=this.get(e).texture,_=this.get(t).texture;x.copyTextureToTexture({texture:g,mipLevel:n,origin:{x:c,y:d,z:h}},{texture:_,mipLevel:o,origin:{x:a,y:l,z:u}},[p,f,m]),this.device.queue.submit([x.finish()]),o===0&&t.generateMipmaps&&this.textureUtils.generateMipmaps(t)}copyFramebufferToTexture(e,t,s){const r=this.get(t);let n=null;t.renderTarget?e.isDepthTexture?n=this.get(t.depthTexture).texture:n=this.get(t.textures[0]).texture:e.isDepthTexture?n=this.textureUtils.getDepthBuffer(t.depth,t.stencil):n=this.context.getCurrentTexture();const o=this.get(e).texture;if(n.format!==o.format){console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.",n.format,o.format);return}let a;if(r.currentPass?(r.currentPass.end(),a=r.encoder):a=this.device.createCommandEncoder({label:"copyFramebufferToTexture_"+e.id}),a.copyTextureToTexture({texture:n,origin:[s.x,s.y,0]},{texture:o},[s.z,s.w]),r.currentPass){const{descriptor:l}=r;for(let u=0;u<l.colorAttachments.length;u++)l.colorAttachments[u].loadOp=Es.Load;if(t.depth&&(l.depthStencilAttachment.depthLoadOp=Es.Load),t.stencil&&(l.depthStencilAttachment.stencilLoadOp=Es.Load),r.currentPass=a.beginRenderPass(l),r.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},t.viewport&&this.updateViewport(t),t.scissor){const{x:u,y:c,width:d,height:h}=t.scissorValue;r.currentPass.setScissorRect(u,c,d,h)}}else this.device.queue.submit([a.finish()]);e.generateMipmaps&&this.textureUtils.generateMipmaps(e)}}class S9 extends E0{constructor(e,t,s,r,n,o){super(e,t,s,r,n,o),this.iesMap=null}copy(e,t){return super.copy(e,t),this.iesMap=e.iesMap,this}}class E9 extends E0{constructor(e,t,s,r,n,o){super(e,t,s,r,n,o),this.aspect=null}copy(e,t){return super.copy(e,t),this.aspect=e.aspect,this}}class A9 extends O${constructor(){super(),this.addMaterial(SW,"MeshPhongMaterial"),this.addMaterial(kO,"MeshStandardMaterial"),this.addMaterial(d8,"MeshPhysicalMaterial"),this.addMaterial(m8,"MeshToonMaterial"),this.addMaterial(wO,"MeshBasicMaterial"),this.addMaterial(TW,"MeshLambertMaterial"),this.addMaterial(fW,"MeshNormalMaterial"),this.addMaterial(_8,"MeshMatcapMaterial"),this.addMaterial(aW,"LineBasicMaterial"),this.addMaterial(uW,"LineDashedMaterial"),this.addMaterial(w8,"PointsMaterial"),this.addMaterial(BO,"SpriteMaterial"),this.addMaterial(v8,"ShadowMaterial"),this.addLight(_H,l4),this.addLight(rK,c4),this.addLight(nK,h4),this.addLight(jw,E0),this.addLight(uK,d4),this.addLight(cK,n4),this.addLight(dK,f4),this.addLight(oK,S9),this.addLight(lK,E9),this.addToneMapping(e$,CV),this.addToneMapping(t$,PV),this.addToneMapping(s$,NV),this.addToneMapping(i$,FV),this.addToneMapping(r$,RV),this.addToneMapping(n$,IV)}}class C9 extends NK{constructor(e={}){let t;e.forceWebGL?t=wN:(t=v9,e.getFallback=()=>(console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."),new wN(e)));const s=new t(e);super(s,e),this.library=new A9,this.isWebGPURenderer=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}}class P9 extends Yi{constructor(e=1,t=1){super(),this.image={width:e,height:t},this.magFilter=wr,this.minFilter=wr,this.isStorageTexture=!0}}/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */P.BRDF_GGX;P.BRDF_Lambert;P.BasicShadowFilter;P.Break;P.Continue;P.DFGApprox;P.D_GGX;P.Discard;P.EPSILON;P.F_Schlick;const PN=P.Fn;P.INFINITY;const N9=P.If;P.Switch;const _x=P.Loop;P.NodeShaderStage;P.NodeType;P.NodeUpdateType;P.NodeAccess;P.PCFShadowFilter;P.PCFSoftShadowFilter;P.PI;P.PI2;P.Return;P.Schlick_to_F0;P.ScriptableNodeResources;P.ShaderNode;P.TBNViewMatrix;P.VSMShadowFilter;P.V_GGX_SmithCorrelated;P.abs;P.acesFilmicToneMapping;P.acos;P.add;P.addNodeElement;P.agxToneMapping;P.all;P.alphaT;P.and;P.anisotropy;P.anisotropyB;P.anisotropyT;P.any;P.append;P.array;P.arrayBuffer;P.asin;P.assign;P.atan;P.atan2;P.atomicAdd;P.atomicAnd;P.atomicFunc;P.atomicMax;P.atomicMin;P.atomicOr;P.atomicStore;P.atomicSub;P.atomicXor;P.atomicLoad;P.attenuationColor;P.attenuationDistance;P.attribute;P.attributeArray;P.backgroundBlurriness;P.backgroundIntensity;P.backgroundRotation;P.batch;P.bentNormalView;P.billboarding;P.bitAnd;P.bitNot;P.bitOr;P.bitXor;P.bitangentGeometry;P.bitangentLocal;P.bitangentView;P.bitangentWorld;P.bitcast;P.blendBurn;P.blendColor;P.blendDodge;P.blendOverlay;P.blendScreen;P.blur;P.bool;P.buffer;P.bufferAttribute;P.bumpMap;P.burn;P.bvec2;P.bvec3;P.bvec4;P.bypass;P.cache;P.call;P.cameraFar;P.cameraIndex;P.cameraNear;P.cameraNormalMatrix;P.cameraPosition;P.cameraProjectionMatrix;P.cameraProjectionMatrixInverse;P.cameraViewMatrix;P.cameraWorldMatrix;P.cbrt;P.cdl;P.ceil;P.checker;P.cineonToneMapping;P.clamp;P.clearcoat;P.clearcoatRoughness;P.code;P.color;P.colorSpaceToWorking;P.colorToDirection;P.compute;P.computeSkinning;P.cond;P.Const;P.context;P.convert;P.convertColorSpace;P.convertToTexture;P.cos;P.cross;P.cubeTexture;P.dFdx;P.dFdy;P.dashSize;P.debug;P.decrement;P.decrementBefore;P.defaultBuildStages;P.defaultShaderStages;P.defined;P.degrees;P.deltaTime;P.densityFog;P.densityFogFactor;P.depth;P.depthPass;P.difference;P.diffuseColor;P.directPointLight;P.directionToColor;P.dispersion;P.distance;P.div;P.dodge;P.dot;P.drawIndex;P.dynamicBufferAttribute;P.element;P.emissive;P.equal;P.equals;P.equirectUV;P.exp;P.exp2;P.expression;P.faceDirection;P.faceForward;P.faceforward;const Oo=P.float;P.floor;P.fog;P.fract;P.frameGroup;P.frameId;P.frontFacing;P.fwidth;P.gain;P.gapSize;P.getConstNodeType;P.getCurrentStack;P.getDirection;P.getDistanceAttenuation;P.getGeometryRoughness;P.getNormalFromDepth;P.getParallaxCorrectNormal;P.getRoughness;P.getScreenPosition;P.getShIrradianceAt;P.getTextureIndex;P.getViewPosition;P.getShadowMaterial;P.getShadowRenderObjectFunction;P.glsl;P.glslFn;P.grayscale;P.greaterThan;P.greaterThanEqual;P.hash;P.highpModelNormalViewMatrix;P.highpModelViewMatrix;P.hue;P.increment;P.incrementBefore;P.instance;P.instanceIndex;P.instancedArray;P.instancedBufferAttribute;P.instancedDynamicBufferAttribute;P.instancedMesh;P.int;P.inverseSqrt;P.inversesqrt;P.invocationLocalIndex;P.invocationSubgroupIndex;P.ior;P.iridescence;P.iridescenceIOR;P.iridescenceThickness;P.ivec2;P.ivec3;P.ivec4;P.js;P.label;P.length;P.lengthSq;P.lessThan;P.lessThanEqual;P.lightPosition;P.lightShadowMatrix;P.lightTargetDirection;P.lightTargetPosition;P.lightViewPosition;P.lightingContext;P.lights;P.linearDepth;P.linearToneMapping;P.localId;const F9=P.globalId;P.log;P.log2;P.logarithmicDepthToViewZ;P.loop;P.luminance;P.mediumpModelViewMatrix;P.mat2;P.mat3;P.mat4;P.matcapUV;P.materialAO;P.materialAlphaTest;P.materialAnisotropy;P.materialAnisotropyVector;P.materialAttenuationColor;P.materialAttenuationDistance;P.materialClearcoat;P.materialClearcoatNormal;P.materialClearcoatRoughness;P.materialColor;P.materialDispersion;P.materialEmissive;P.materialIOR;P.materialIridescence;P.materialIridescenceIOR;P.materialIridescenceThickness;P.materialLightMap;P.materialLineDashOffset;P.materialLineDashSize;P.materialLineGapSize;P.materialLineScale;P.materialLineWidth;P.materialMetalness;P.materialNormal;P.materialOpacity;P.materialPointSize;P.materialReference;P.materialReflectivity;P.materialRefractionRatio;P.materialRotation;P.materialRoughness;P.materialSheen;P.materialSheenRoughness;P.materialShininess;P.materialSpecular;P.materialSpecularColor;P.materialSpecularIntensity;P.materialSpecularStrength;P.materialThickness;P.materialTransmission;P.max;P.maxMipLevel;P.metalness;P.min;P.mix;P.mixElement;P.mod;P.modInt;P.modelDirection;P.modelNormalMatrix;P.modelPosition;P.modelRadius;P.modelScale;P.modelViewMatrix;P.modelViewPosition;P.modelViewProjection;P.modelWorldMatrix;P.modelWorldMatrixInverse;P.morphReference;P.mrt;P.mul;P.mx_aastep;P.mx_cell_noise_float;P.mx_contrast;P.mx_fractal_noise_float;P.mx_fractal_noise_vec2;P.mx_fractal_noise_vec3;P.mx_fractal_noise_vec4;P.mx_hsvtorgb;P.mx_noise_float;P.mx_noise_vec3;P.mx_noise_vec4;P.mx_ramplr;P.mx_ramptb;P.mx_rgbtohsv;P.mx_safepower;P.mx_splitlr;P.mx_splittb;P.mx_srgb_texture_to_lin_rec709;P.mx_transform_uv;P.mx_worley_noise_float;P.mx_worley_noise_vec2;P.mx_worley_noise_vec3;P.negate;P.neutralToneMapping;P.nodeArray;P.nodeImmutable;P.nodeObject;P.nodeObjects;P.nodeProxy;P.normalFlat;P.normalGeometry;P.normalLocal;P.normalMap;P.normalView;P.normalViewGeometry;P.normalWorld;P.normalWorldGeometry;P.normalize;P.not;P.notEqual;P.numWorkgroups;P.objectDirection;P.objectGroup;P.objectPosition;P.objectRadius;P.objectScale;P.objectViewPosition;P.objectWorldMatrix;P.oneMinus;P.or;P.orthographicDepthToViewZ;P.oscSawtooth;P.oscSine;P.oscSquare;P.oscTriangle;P.output;P.outputStruct;P.overlay;P.overloadingFn;P.parabola;P.parallaxDirection;P.parallaxUV;P.parameter;P.pass;P.passTexture;P.pcurve;P.perspectiveDepthToViewZ;P.pmremTexture;P.pointUV;P.pointWidth;P.positionGeometry;P.positionLocal;P.positionPrevious;P.positionView;P.positionViewDirection;P.positionWorld;P.positionWorldDirection;P.posterize;P.pow;P.pow2;P.pow3;P.pow4;P.premultiplyAlpha;P.property;P.radians;const yx=P.rand;P.range;P.rangeFog;P.rangeFogFactor;P.reciprocal;P.lightProjectionUV;P.reference;P.referenceBuffer;P.reflect;P.reflectVector;P.reflectView;P.reflector;P.refract;P.refractVector;P.refractView;P.reinhardToneMapping;P.remainder;P.remap;P.remapClamp;P.renderGroup;P.renderOutput;P.rendererReference;P.rotate;P.rotateUV;P.roughness;P.round;P.rtt;P.sRGBTransferEOTF;P.sRGBTransferOETF;P.sample;P.sampler;P.samplerComparison;P.saturate;P.saturation;P.screen;P.screenCoordinate;P.screenSize;P.screenUV;P.scriptable;P.scriptableValue;P.select;P.setCurrentStack;P.shaderStages;P.shadow;P.pointShadow;P.shadowPositionWorld;P.sharedUniformGroup;P.shapeCircle;P.sheen;P.sheenRoughness;P.shiftLeft;P.shiftRight;P.shininess;P.sign;P.sin;P.sinc;P.skinning;P.smoothstep;P.smoothstepElement;P.specularColor;P.specularF90;P.spherizeUV;P.split;P.spritesheetUV;P.sqrt;P.stack;P.step;P.storage;P.storageBarrier;P.storageObject;P.storageTexture;P.string;P.struct;P.sub;P.subBuild;P.subgroupIndex;P.subgroupSize;P.tan;P.tangentGeometry;P.tangentLocal;P.tangentView;P.tangentWorld;P.temp;const R9=P.texture;P.texture3D;P.textureBarrier;P.textureBicubic;P.textureBicubicLevel;P.textureCubeUV;const I9=P.textureLoad;P.textureSize;const D9=P.textureStore;P.thickness;P.time;P.timerDelta;P.timerGlobal;P.timerLocal;P.toneMapping;P.toneMappingExposure;P.toonOutlinePass;P.transformDirection;P.transformNormal;P.transformNormalToView;P.transformedClearcoatNormalView;P.transformedNormalView;P.transformedNormalWorld;P.transmission;P.transpose;P.triNoise3D;P.triplanarTexture;P.triplanarTextures;P.trunc;P.tslFn;P.uint;const Ll=P.uniform;P.uniformCubeTexture;P.uniformArray;P.uniformGroup;P.uniformTexture;P.uniforms;P.unpremultiplyAlpha;P.userData;P.uv;const NN=P.uvec2;P.uvec3;P.uvec4;P.Var;P.varying;P.varyingProperty;const FN=P.vec2,Cb=P.vec3;P.vec4;P.vectorComponents;P.velocity;P.vertexColor;P.vertexIndex;P.vibrance;P.viewZToLogarithmicDepth;P.viewZToOrthographicDepth;P.viewZToPerspectiveDepth;P.viewport;P.viewportBottomLeft;P.viewportCoordinate;P.viewportDepthTexture;P.viewportLinearDepth;P.viewportMipTexture;P.viewportResolution;P.viewportSafeUV;P.viewportSharedTexture;P.viewportSize;P.viewportTexture;P.viewportTopLeft;P.viewportUV;P.wgsl;P.wgslFn;const k9=P.workgroupArray;P.workgroupBarrier;P.workgroupId;P.workingToColorSpace;P.xor;class L9{constructor(){Z(this,"camera");Z(this,"scene");Z(this,"bricks",[]);Z(this,"controls");Z(this,"noiseFactor",Ll(Oo(.1)));Z(this,"rand");Z(this,"freeze",!1);Z(this,"render_depth",!1);Z(this,"mesh",null);this.camera=new Ar(75,window.innerWidth/window.innerHeight,.001,1.5),this.camera.position.set(0,0,1),this.controls=new x4(this.camera,document.getElementById("canvas")),this.rand=Ll(Cb(0)),this.scene=new mh,this.scene.background=new gs("#fff");let e;{const t=new co({wireframe:!0}),s=1,r=1;e={mesh:new bn(new yc(s,r,1),t),width:s,height:r},e.mesh.position.x=0,e.mesh.position.y=0,e.mesh.position.z=-.5}}async initialize(){const s=new OffscreenCanvas(256,256),r=s.getContext("2d");r.fillStyle="black",r.fillRect(0,0,256,256);const n=new OffscreenCanvas(256,256),o=n.getContext("2d"),a={video:{width:720,height:720,facingMode:"user"}},l=await navigator.mediaDevices.getUserMedia(a),u=document.createElement("video");u.srcObject=l,u.play();const c=new YU(s),d=new yc(256,256);d.scale(-1.5/256,1.5/256,1.5/256);const h=new co({map:c,side:Da}),p=new bn(d,h);this.mesh=p,this.scene.add(p);async function f(){try{return(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{return!1}}const m=await sV("depth-estimation","onnx-community/depth-anything-v2-small",{dtype:await f()?"fp16":"fp32",device:"webgpu"}),x=async()=>{if(!this.freeze){o.drawImage(u,0,0,256,256);const{depth:g}=await m(n);r.drawImage(g.toCanvas(),0,0,256,256),c.needsUpdate=!0}requestAnimationFrame(x)};x()}onWindowResize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}async update(){this.mesh.position.set(this.render_depth?0:.125,0,0),this.controls.update(),this.rand.value.setX(Math.random()),this.rand.value.setY(Math.random()),this.rand.value.setZ(Math.random())}}class B9{constructor(e){Z(this,"camera");Z(this,"scene");Z(this,"computeNode");Z(this,"rand");Z(this,"minDisparity",Ll(.15));Z(this,"maxDisparity",Ll(.2));Z(this,"separation",Ll(.75));Z(this,"pattern_scale",Ll(6));const s=e.image.width/1,r=e.image.height/1;this.camera=new gm(0,1,1,0,.1,1e3),this.camera.position.set(0,0,1),this.scene=new mh;const n=new P9(s,r);n.minFilter=yi,n.magFilter=yi;const o=k9("float",s),a=PN(({uv:m})=>{const x=yx(m.add(this.rand.mul(1e4).xy)),g=yx(m.add(this.rand.mul(2e4).xy)),_=yx(m.add(this.rand.mul(3e4).xy));return Cb(x,g,_)}),l=Oo(s).mul(this.minDisparity).mul(this.separation),u=Oo(s).mul(this.maxDisparity).mul(this.separation),c=1,d=PN(()=>{const m=Oo(0).toVar("yOffset");_x(m.lessThan(c),()=>{const x=Oo(F9.x.mul(c).add(m)),g=Oo(0).mul(s),_=Oo(0).toVar("x");_x(_.lessThan(s),()=>{const S=FN(_.mul(1),x.mul(1)),w=Oo(I9(e,S).x.div(1)).mul(u.sub(l)),v=g.add(_);o.element(v).assign(0),N9(_.lessThan(l),()=>{const T=_.add(w).mod(l);o.element(v).assign(T)}).Else(()=>{const T=o.element(_.add(w).sub(l));o.element(v).assign(T)}),_.addAssign(1)}),_.assign(0),_x(_.lessThan(s),()=>{const S=NN(_,Oo(r).sub(x)),M=g.add(_),w=FN(o.element(M),x);D9(n,S,a({uv:NN(w.div(this.pattern_scale))})).toWriteOnly(),_.addAssign(1)}),m.addAssign(1)})});this.rand=Ll(Cb(0)),this.computeNode=d().compute(Math.ceil(r/c),[1]);const h=new wO({color:65280});h.colorNode=R9(n);const p=new yc(1,1),f=new bn(p,h);f.position.set(.5,.5,0),this.scene.add(f)}onWindowResize(){}update(){this.rand.value.setX(Math.random()),this.rand.value.setY(Math.random()),this.rand.value.setZ(Math.random())}}class O9{constructor(e){Z(this,"renderer");Z(this,"level");Z(this,"autostereogram");Z(this,"stats");Z(this,"renderTarget");Z(this,"render_depth",!1);Z(this,"show_fps",!1);Z(this,"freeze",!1);Z(this,"gui");Z(this,"noiseFactor",0);Z(this,"minDisparity",.15);Z(this,"maxDisparity",.2);Z(this,"separation",.75);Z(this,"pattern_scale",6);Z(this,"fadeTimeout",null);Z(this,"fadeAnimations",null);this.device=e,this.stats=new yV,this.stats.dom.hidden=!0,this.gui=new o0({}),this.gui.close(),this.gui.hide(),this.renderer=new C9({canvas:document.getElementById("canvas"),device:e,antialias:!0}),document.body.appendChild(this.renderer.domElement),document.body.appendChild(this.stats.dom),window.addEventListener("resize",()=>{this.onWindowResize_()},!1),this.level=new L9,this.renderTarget=new So(innerWidth,innerHeight),this.autostereogram=new B9(this.renderTarget.texture)}async initialize(){this.level.render_depth=this.render_depth,await this.level.initialize()}run(){this.onWindowResize_(),this.raf_(),this.gui.add(this,"render_depth"),this.gui.add(this,"show_fps"),this.gui.add(this,"freeze"),this.gui.add(this,"separation",.1,1.5,.01),this.gui.add(this,"pattern_scale",1,10,.1),this.gui.show(),this.setupFadeFunctionality()}onWindowResize_(){var e;(e=this.renderer)==null||e.setSize(window.innerWidth,window.innerHeight),this.level.onWindowResize(),this.autostereogram.onWindowResize()}raf_(){requestAnimationFrame(async()=>{this.stats.dom.hidden=!this.show_fps,this.stats.begin(),this.level.freeze=this.freeze,this.level.render_depth=this.render_depth,this.level.noiseFactor.value=this.noiseFactor,this.autostereogram.minDisparity.value=this.minDisparity,this.autostereogram.maxDisparity.value=this.maxDisparity,this.autostereogram.separation.value=this.separation,this.autostereogram.pattern_scale.value=this.pattern_scale,this.freeze||await this.level.update(),this.render_depth||this.renderer.setRenderTarget(this.renderTarget),await this.renderer.renderAsync(this.level.scene,this.level.camera),this.render_depth||(this.freeze||this.autostereogram.update(),await this.renderer.computeAsync(this.autostereogram.computeNode),this.renderer.setRenderTarget(null),await this.renderer.renderAsync(this.autostereogram.scene,this.autostereogram.camera)),this.stats.end(),this.raf_()})}setupFadeFunctionality(){const e=this.gui.domElement;e.addEventListener("mouseenter",()=>uo(this)),e.addEventListener("click",()=>uo(this)),e.addEventListener("input",()=>uo(this)),e.addEventListener("change",()=>uo(this)),e.addEventListener("touchstart",()=>uo(this)),e.addEventListener("touchend",()=>uo(this)),document.addEventListener("mousemove",()=>uo(this));const t=this.gui.show.bind(this.gui);this.gui.show=n=>{const o=t(n);return n!==!1&&(document.body.classList.remove("gui-faded"),document.body.classList.add("gui-visible"),Pb(this)),o};const s=this.gui.hide.bind(this.gui);this.gui.hide=()=>{const n=s();return this.fadeTimeout&&(clearTimeout(this.fadeTimeout),this.fadeTimeout=null),this.fadeAnimations&&(this.fadeAnimations.forEach(o=>o.cancel()),this.fadeAnimations=null),document.body.classList.remove("gui-faded","gui-visible"),n},new MutationObserver(n=>{n.forEach(o=>{o.type==="attributes"&&o.attributeName==="class"&&(o.target.classList.contains("expanded")?(this.fadeTimeout&&(clearTimeout(this.fadeTimeout),this.fadeTimeout=null),this.fadeAnimations&&(this.fadeAnimations.forEach(l=>l.cancel()),this.fadeAnimations=null),e.style.opacity="1",document.getElementById("viewing-tips-link").style.opacity="1",document.body.classList.remove("gui-faded"),document.body.classList.add("gui-visible")):Pb(this))})}).observe(e,{attributes:!0,attributeFilter:["class"]}),document.addEventListener("mousemove",n=>{const o=e.getBoundingClientRect(),a=50;n.clientX>=o.left-a&&n.clientX<=o.right+a&&n.clientY>=o.top-a&&n.clientY<=o.bottom+a&&uo(this)}),document.addEventListener("touchstart",()=>uo(this)),document.addEventListener("click",()=>uo(this))}}function Pb(i){if(!i.gui||!i.gui.domElement.classList.contains("closed"))return;i.fadeTimeout&&clearTimeout(i.fadeTimeout),i.fadeAnimations&&i.fadeAnimations.forEach(t=>t.cancel());const e=i.gui.domElement;e.classList.contains("expanded")||(e.style.opacity="1",document.getElementById("viewing-tips-link").style.opacity="1",i.fadeTimeout=setTimeout(()=>{$9(i)},3e3))}function $9(i){if(!i.gui)return;const e=i.gui.domElement;e.classList.contains("expanded")||(document.body.classList.remove("gui-visible"),document.body.classList.add("gui-faded"),i.fadeAnimations=[],[e,document.getElementById("viewing-tips-link")].forEach(t=>{i.fadeAnimations.push(t.animate([{opacity:"1"},{opacity:"0.1"}],{duration:2e3,easing:"ease-out",fill:"forwards"}))}))}function uo(i){i.gui&&(i.fadeTimeout&&(clearTimeout(i.fadeTimeout),i.fadeTimeout=null),i.fadeAnimations&&(i.fadeAnimations.forEach(e=>e.cancel()),i.fadeAnimations=null),document.body.classList.remove("gui-faded"),document.body.classList.add("gui-visible"),i.gui.domElement.style.opacity="1",Pb(i))}const j9=async()=>{if(!navigator.gpu)return;const e=await(await navigator.gpu.requestAdapter()).requestDevice();return new O9(e)};export{j9 as getApp};
